//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/persistence/package_provider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package persistence; import _cover_atomic_ "sync/atomic"

import (
	"io/ioutil"

	"github.com/hyperledger/fabric/common/chaincode"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/pkg/errors"
)

// StorePackageProvider is the interface needed to retrieve
// the code package from a ChaincodeInstallPackage
type StorePackageProvider interface {
	GetChaincodeInstallPath() string
	ListInstalledChaincodes() ([]chaincode.InstalledChaincode, error)
	Load(hash []byte) (codePackage []byte, name, version string, err error)
	RetrieveHash(name, version string) (hash []byte, err error)
}

// LegacyPackageProvider is the interface needed to retrieve
// the code package from a ChaincodeDeploymentSpec
type LegacyPackageProvider interface {
	GetChaincodeCodePackage(name, version string) (codePackage []byte, err error)
	ListInstalledChaincodes(dir string, de ccprovider.DirEnumerator, ce ccprovider.ChaincodeExtractor) ([]chaincode.InstalledChaincode, error)
}

// PackageParser provides an implementation of chaincode package parsing
type PackageParser interface {
	Parse(data []byte) (*ChaincodePackage, error)
}

// PackageProvider holds the necessary dependencies to obtain the code
// package bytes for a chaincode
type PackageProvider struct {
	Store    StorePackageProvider
	Parser   PackageParser
	LegacyPP LegacyPackageProvider
}

// GetChaincodeCodePackage gets the code package bytes for a chaincode given
// the name and version. It first searches through the persisted
// ChaincodeInstallPackages and then falls back to searching for
// ChaincodeDeploymentSpecs
func (p *PackageProvider) GetChaincodeCodePackage(name, version string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[0], 1);
	codePackage, err := p.getCodePackageFromStore(name, version)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[4], 1);
		return codePackage, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[1], 1);if _, ok := err.(*CodePackageNotFoundErr); !ok {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[5], 1);
		// return the error if the hash cannot be retrieved or the code package
		// fails to load from the persistence store
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[2], 1);codePackage, err = p.getCodePackageFromLegacyPP(name, version)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[6], 1);
		logger.Debug(err.Error())
		err = errors.Errorf("code package not found for chaincode with name '%s', version '%s'", name, version)
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[3], 1);return codePackage, nil
}

// GetCodePackageFromStore gets the code package bytes from the package
// provider's Store, which persists ChaincodeInstallPackages
func (p *PackageProvider) getCodePackageFromStore(name, version string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[7], 1);
	hash, err := p.Store.RetrieveHash(name, version)
	if _, ok := err.(*CodePackageNotFoundErr); ok {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[12], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[8], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[13], 1);
		return nil, errors.WithMessage(err, "error retrieving hash")
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[9], 1);fsBytes, _, _, err := p.Store.Load(hash)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[14], 1);
		return nil, errors.WithMessage(err, "error loading code package from ChaincodeInstallPackage")
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[10], 1);ccPackage, err := p.Parser.Parse(fsBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[15], 1);
		return nil, errors.WithMessage(err, "error parsing chaincode package")
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[11], 1);return ccPackage.CodePackage, nil
}

// GetCodePackageFromLegacyPP gets the code packages bytes from the
// legacy package provider, which persists ChaincodeDeploymentSpecs
func (p *PackageProvider) getCodePackageFromLegacyPP(name, version string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[16], 1);
	codePackage, err := p.LegacyPP.GetChaincodeCodePackage(name, version)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[18], 1);
		return nil, errors.Wrap(err, "error loading code package from ChaincodeDeploymentSpec")
	}
	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[17], 1);return codePackage, nil
}

// ListInstalledChaincodes returns metadata (name, version, and ID) for
// each chaincode installed on a peer
func (p *PackageProvider) ListInstalledChaincodes() ([]chaincode.InstalledChaincode, error) {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[19], 1);
	// first look through ChaincodeInstallPackages
	installedChaincodes, err := p.Store.ListInstalledChaincodes()

	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[23], 1);
		// log the error and continue
		logger.Debugf("error getting installed chaincodes from persistence store: %s", err)
	}

	// then look through CDS/SCDS
	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[20], 1);installedChaincodesLegacy, err := p.LegacyPP.ListInstalledChaincodes(p.Store.GetChaincodeInstallPath(), ioutil.ReadDir, ccprovider.LoadPackage)

	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[24], 1);
		// log the error and continue
		logger.Debugf("error getting installed chaincodes from ccprovider: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[21], 1);for _, cc := range installedChaincodesLegacy {_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[25], 1);
		installedChaincodes = append(installedChaincodes, cc)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346661366563343863376234.Count[22], 1);return installedChaincodes, nil
}

var GoCover_1_346661366563343863376234 = struct {
	Count     [26]uint32
	Pos       [3 * 26]uint32
	NumStmt   [26]uint16
} {
	Pos: [3 * 26]uint32{
		50, 52, 0x100059, // [0]
		55, 55, 0x310002, // [1]
		61, 62, 0x100002, // [2]
		67, 67, 0x190002, // [3]
		52, 54, 0x30010, // [4]
		55, 59, 0x30031, // [5]
		62, 66, 0x30010, // [6]
		72, 74, 0x300059, // [7]
		77, 77, 0x100002, // [8]
		81, 82, 0x100002, // [9]
		86, 87, 0x100002, // [10]
		91, 91, 0x230002, // [11]
		74, 76, 0x30030, // [12]
		77, 79, 0x30010, // [13]
		82, 84, 0x30010, // [14]
		87, 89, 0x30010, // [15]
		96, 98, 0x10005c, // [16]
		101, 101, 0x190002, // [17]
		98, 100, 0x30010, // [18]
		106, 110, 0x10005d, // [19]
		116, 118, 0x100002, // [20]
		123, 123, 0x2f0002, // [21]
		127, 127, 0x210002, // [22]
		110, 113, 0x30010, // [23]
		118, 121, 0x30010, // [24]
		123, 125, 0x3002f, // [25]
	},
	NumStmt: [26]uint16{
		2, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		3, // 6
		2, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
	},
}
var _ = _cover_atomic_.LoadUint32
