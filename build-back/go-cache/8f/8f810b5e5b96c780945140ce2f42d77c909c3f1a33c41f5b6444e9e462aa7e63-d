//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/pvtdatastorage/persistent_msgs_helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package pvtdatastorage; import _cover_atomic_ "sync/atomic"

func newExpiryData() *ExpiryData {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[0], 1);
	return &ExpiryData{Map: make(map[string]*Collections)}
}

func (e *ExpiryData) getOrCreateCollections(ns string) *Collections {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[1], 1);
	collections, ok := e.Map[ns]
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[3], 1);
		collections = &Collections{
			Map:            make(map[string]*TxNums),
			MissingDataMap: make(map[string]bool)}
		e.Map[ns] = collections
	} else{ _cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[4], 1);{
		// due to protobuf encoding/decoding, the previously
		// initialized map could be a nil now due to 0 length.
		// Hence, we need to reinitialize the map.
		if collections.Map == nil {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[6], 1);
			collections.Map = make(map[string]*TxNums)
		}
		_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[5], 1);if collections.MissingDataMap == nil {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[7], 1);
			collections.MissingDataMap = make(map[string]bool)
		}
	}}
	_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[2], 1);return collections
}

func (e *ExpiryData) addPresentData(ns, coll string, txNum uint64) {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[8], 1);
	collections := e.getOrCreateCollections(ns)

	txNums, ok := collections.Map[coll]
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[10], 1);
		txNums = &TxNums{}
		collections.Map[coll] = txNums
	}
	_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[9], 1);txNums.List = append(txNums.List, txNum)
}

func (e *ExpiryData) addMissingData(ns, coll string) {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[11], 1);
	collections := e.getOrCreateCollections(ns)
	collections.MissingDataMap[coll] = true
}

func newCollElgInfo(nsCollMap map[string][]string) *CollElgInfo {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[12], 1);
	m := &CollElgInfo{NsCollMap: map[string]*CollNames{}}
	for ns, colls := range nsCollMap {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[14], 1);
		collNames, ok := m.NsCollMap[ns]
		if !ok {_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[16], 1);
			collNames = &CollNames{}
			m.NsCollMap[ns] = collNames
		}
		_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[15], 1);collNames.Entries = colls
	}
	_cover_atomic_.AddUint32(&GoCover_3_653833333066373334656466.Count[13], 1);return m
}

var GoCover_3_653833333066373334656466 = struct {
	Count     [17]uint32
	Pos       [3 * 17]uint32
	NumStmt   [17]uint16
} {
	Pos: [3 * 17]uint32{
		9, 11, 0x20022, // [0]
		13, 15, 0x90045, // [1]
		31, 31, 0x140002, // [2]
		15, 20, 0x30009, // [3]
		20, 24, 0x1d0008, // [4]
		27, 27, 0x280003, // [5]
		24, 26, 0x4001d, // [6]
		27, 29, 0x40028, // [7]
		34, 38, 0x90044, // [8]
		42, 42, 0x2a0002, // [9]
		38, 41, 0x30009, // [10]
		45, 48, 0x20036, // [11]
		50, 52, 0x230041, // [12]
		60, 60, 0xa0002, // [13]
		52, 54, 0xa0023, // [14]
		58, 58, 0x1c0003, // [15]
		54, 57, 0x4000a, // [16]
	},
	NumStmt: [17]uint16{
		1, // 0
		2, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		2, // 10
		2, // 11
		2, // 12
		1, // 13
		2, // 14
		1, // 15
		2, // 16
	},
}
var _ = _cover_atomic_.LoadUint32
