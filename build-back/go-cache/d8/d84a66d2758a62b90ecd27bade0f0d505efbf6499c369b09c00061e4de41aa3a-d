//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/common/ordererclient.go:1
/*
Copyright IBM Corp. 2016-2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package common; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"fmt"

	"github.com/hyperledger/fabric/core/comm"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/pkg/errors"
)

// OrdererClient represents a client for communicating with an ordering
// service
type OrdererClient struct {
	commonClient
}

// NewOrdererClientFromEnv creates an instance of an OrdererClient from the
// global Viper instance
func NewOrdererClientFromEnv() (*OrdererClient, error) {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[0], 1);
	address, override, clientConfig, err := configFromEnv("orderer")
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[3], 1);
		return nil, errors.WithMessage(err, "failed to load config for OrdererClient")
	}
	_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[1], 1);gClient, err := comm.NewGRPCClient(clientConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[4], 1);
		return nil, errors.WithMessage(err, "failed to create OrdererClient from config")
	}
	_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[2], 1);oClient := &OrdererClient{
		commonClient: commonClient{
			GRPCClient: gClient,
			address:    address,
			sn:         override}}
	return oClient, nil
}

// Broadcast returns a broadcast client for the AtomicBroadcast service
func (oc *OrdererClient) Broadcast() (ab.AtomicBroadcast_BroadcastClient, error) {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[5], 1);
	conn, err := oc.commonClient.NewConnection(oc.address, oc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[7], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("orderer client failed to connect to %s", oc.address))
	}
	// TODO: check to see if we should actually handle error before returning
	_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[6], 1);return ab.NewAtomicBroadcastClient(conn).Broadcast(context.TODO())
}

// Deliver returns a deliver client for the AtomicBroadcast service
func (oc *OrdererClient) Deliver() (ab.AtomicBroadcast_DeliverClient, error) {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[8], 1);
	conn, err := oc.commonClient.NewConnection(oc.address, oc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[10], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("orderer client failed to connect to %s", oc.address))
	}
	// TODO: check to see if we should actually handle error before returning
	_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[9], 1);return ab.NewAtomicBroadcastClient(conn).Deliver(context.TODO())

}

// Certificate returns the TLS client certificate (if available)
func (oc *OrdererClient) Certificate() tls.Certificate {_cover_atomic_.AddUint32(&GoCover_5_393466303334653164333865.Count[11], 1);
	return oc.commonClient.Certificate()
}

var GoCover_5_393466303334653164333865 = struct {
	Count     [12]uint32
	Pos       [3 * 12]uint32
	NumStmt   [12]uint16
} {
	Pos: [3 * 12]uint32{
		26, 28, 0x100038, // [0]
		31, 32, 0x100002, // [1]
		35, 40, 0x150002, // [2]
		28, 30, 0x30010, // [3]
		32, 34, 0x30010, // [4]
		44, 46, 0x100052, // [5]
		50, 50, 0x440002, // [6]
		46, 48, 0x30010, // [7]
		54, 56, 0x10004e, // [8]
		60, 60, 0x420002, // [9]
		56, 58, 0x30010, // [10]
		65, 67, 0x20038, // [11]
	},
	NumStmt: [12]uint16{
		2, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		2, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
	},
}
var _ = _cover_atomic_.LoadUint32
