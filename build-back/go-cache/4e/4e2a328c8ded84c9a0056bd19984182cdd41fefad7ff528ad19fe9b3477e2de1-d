//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/client/signer.go:1
/*
Copyright IBM Corp All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package discovery; import _cover_atomic_ "sync/atomic"

import (
	"encoding/hex"
	"sync"

	"github.com/hyperledger/fabric/common/util"
)

// MemoizeSigner signs messages with the same signature
// if the message was signed recently
type MemoizeSigner struct {
	maxEntries uint
	sync.RWMutex
	memory map[string][]byte
	sign   Signer
}

// NewMemoizeSigner creates a new MemoizeSigner that signs
// message with the given sign function
func NewMemoizeSigner(signFunc Signer, maxEntries uint) *MemoizeSigner {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[0], 1);
	return &MemoizeSigner{
		maxEntries: maxEntries,
		memory:     make(map[string][]byte),
		sign:       signFunc,
	}
}

// Signer signs a message and returns the signature and nil,
// or nil and error on failure
func (ms *MemoizeSigner) Sign(msg []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[1], 1);
	sig, isInMemory := ms.lookup(msg)
	if isInMemory {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[4], 1);
		return sig, nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[2], 1);sig, err := ms.sign(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[5], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[3], 1);ms.memorize(msg, sig)
	return sig, nil
}

// lookup looks up the given message in memory and returns
// the signature, if the message is in memory
func (ms *MemoizeSigner) lookup(msg []byte) ([]byte, bool) {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[6], 1);
	ms.RLock()
	defer ms.RUnlock()
	sig, exists := ms.memory[msgDigest(msg)]
	return sig, exists
}

func (ms *MemoizeSigner) memorize(msg, signature []byte) {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[7], 1);
	if ms.maxEntries == 0 {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[10], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[8], 1);ms.RLock()
	shouldShrink := len(ms.memory) >= (int)(ms.maxEntries)
	ms.RUnlock()

	if shouldShrink {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[11], 1);
		ms.shrinkMemory()
	}
	_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[9], 1);ms.Lock()
	defer ms.Unlock()
	ms.memory[msgDigest(msg)] = signature

}

// evict evicts random messages from memory
// until its size is smaller than maxEntries
func (ms *MemoizeSigner) shrinkMemory() {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[12], 1);
	ms.Lock()
	defer ms.Unlock()
	for len(ms.memory) > (int)(ms.maxEntries) {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[13], 1);
		ms.evictFromMemory()
	}
}

// evictFromMemory evicts a random message from memory
func (ms *MemoizeSigner) evictFromMemory() {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[14], 1);
	for dig := range ms.memory {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[15], 1);
		delete(ms.memory, dig)
		return
	}
}

// msgDigest returns a digest of a given message
func msgDigest(msg []byte) string {_cover_atomic_.AddUint32(&GoCover_3_323533613534323836353731.Count[16], 1);
	return hex.EncodeToString(util.ComputeSHA256(msg))
}

var GoCover_3_323533613534323836353731 = struct {
	Count     [17]uint32
	Pos       [3 * 17]uint32
	NumStmt   [17]uint16
} {
	Pos: [3 * 17]uint32{
		27, 33, 0x20048, // [0]
		37, 39, 0x10003b, // [1]
		42, 43, 0x100002, // [2]
		46, 47, 0x110002, // [3]
		39, 41, 0x30010, // [4]
		43, 45, 0x30010, // [5]
		52, 57, 0x2003c, // [6]
		59, 60, 0x18003a, // [7]
		63, 67, 0x120002, // [8]
		70, 72, 0x270002, // [9]
		60, 62, 0x30018, // [10]
		67, 69, 0x30012, // [11]
		78, 81, 0x2c0029, // [12]
		81, 83, 0x3002c, // [13]
		87, 88, 0x1d002c, // [14]
		88, 91, 0x3001d, // [15]
		95, 97, 0x20023, // [16]
	},
	NumStmt: [17]uint16{
		1, // 0
		2, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		4, // 6
		1, // 7
		4, // 8
		3, // 9
		1, // 10
		1, // 11
		3, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
	},
}
var _ = _cover_atomic_.LoadUint32
