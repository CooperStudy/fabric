//line /home/cooper/go/src/github.com/hyperledger/fabric/core/endorser/endorser.go:1
/*
Copyright IBM Corp. 2016 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package endorser; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/validation"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/transientstore"
	putils "github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"go.uber.org/zap"
)

var endorserLogger = flogging.MustGetLogger("endorser")

// The Jira issue that documents Endorser flow along with its relationship to
// the lifecycle chaincode - https://jira.hyperledger.org/browse/FAB-181

type privateDataDistributor func(channel string, txID string, privateData *transientstore.TxPvtReadWriteSetWithConfigInfo, blkHt uint64) error

// Support contains functions that the endorser requires to execute its tasks
type Support interface {
	crypto.SignerSupport
	// IsSysCCAndNotInvokableExternal returns true if the supplied chaincode is
	// ia system chaincode and it NOT invokable
	IsSysCCAndNotInvokableExternal(name string) bool

	// GetTxSimulator returns the transaction simulator for the specified ledger
	// a client may obtain more than one such simulator; they are made unique
	// by way of the supplied txid
	GetTxSimulator(ledgername string, txid string) (ledger.TxSimulator, error)

	// GetHistoryQueryExecutor gives handle to a history query executor for the
	// specified ledger
	GetHistoryQueryExecutor(ledgername string) (ledger.HistoryQueryExecutor, error)

	// GetTransactionByID retrieves a transaction by id
	GetTransactionByID(chid, txID string) (*pb.ProcessedTransaction, error)

	// IsSysCC returns true if the name matches a system chaincode's
	// system chaincode names are system, chain wide
	IsSysCC(name string) bool

	// Execute - execute proposal, return original response of chaincode
	Execute(txParams *ccprovider.TransactionParams, cid, name, version, txid string, signedProp *pb.SignedProposal, prop *pb.Proposal, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)

	// ExecuteLegacyInit - executes a deployment proposal, return original response of chaincode
	ExecuteLegacyInit(txParams *ccprovider.TransactionParams, cid, name, version, txid string, signedProp *pb.SignedProposal, prop *pb.Proposal, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)

	// GetChaincodeDefinition returns ccprovider.ChaincodeDefinition for the chaincode with the supplied name
	GetChaincodeDefinition(chaincodeID string, txsim ledger.QueryExecutor) (ccprovider.ChaincodeDefinition, error)

	// CheckACL checks the ACL for the resource for the channel using the
	// SignedProposal from which an id can be extracted for testing against a policy
	CheckACL(signedProp *pb.SignedProposal, chdr *common.ChannelHeader, shdr *common.SignatureHeader, hdrext *pb.ChaincodeHeaderExtension) error

	// IsJavaCC returns true if the CDS package bytes describe a chaincode
	// that requires the java runtime environment to execute
	IsJavaCC(buf []byte) (bool, error)

	// CheckInstantiationPolicy returns an error if the instantiation in the supplied
	// ChaincodeDefinition differs from the instantiation policy stored on the ledger
	CheckInstantiationPolicy(name, version string, cd ccprovider.ChaincodeDefinition) error

	// GetChaincodeDeploymentSpecFS returns the deploymentspec for a chaincode from the fs
	GetChaincodeDeploymentSpecFS(cds *pb.ChaincodeDeploymentSpec) (*pb.ChaincodeDeploymentSpec, error)

	// GetApplicationConfig returns the configtxapplication.SharedConfig for the Channel
	// and whether the Application config exists
	GetApplicationConfig(cid string) (channelconfig.Application, bool)

	// NewQueryCreator creates a new QueryCreator
	NewQueryCreator(channel string) (QueryCreator, error)

	// EndorseWithPlugin endorses the response with a plugin
	EndorseWithPlugin(ctx Context) (*pb.ProposalResponse, error)

	// GetLedgerHeight returns ledger height for given channelID
	GetLedgerHeight(channelID string) (uint64, error)
}

// Endorser provides the Endorser service ProcessProposal
type Endorser struct {
	distributePrivateData privateDataDistributor
	s                     Support
	PlatformRegistry      *platforms.Registry
	PvtRWSetAssembler
}

// validateResult provides the result of endorseProposal verification
type validateResult struct {
	prop    *pb.Proposal
	hdrExt  *pb.ChaincodeHeaderExtension
	chainID string
	txid    string
	resp    *pb.ProposalResponse
}

// NewEndorserServer creates and returns a new Endorser server instance.
func NewEndorserServer(privDist privateDataDistributor, s Support, pr *platforms.Registry) *Endorser {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[0], 1);
	e := &Endorser{
		distributePrivateData: privDist,
		s:                     s,
		PlatformRegistry:      pr,
		PvtRWSetAssembler:     &rwSetAssembler{},
	}
	return e
}

// call specified chaincode (system or user)
func (e *Endorser) callChaincode(txParams *ccprovider.TransactionParams, version string, input *pb.ChaincodeInput, cid *pb.ChaincodeID) (*pb.Response, *pb.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[1], 1);
	endorserLogger.Infof("[%s][%s] Entry chaincode: %s", txParams.ChannelID, shorttxid(txParams.TxID), cid)
	defer func(start time.Time) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[6], 1);
		logger := endorserLogger.WithOptions(zap.AddCallerSkip(1))
		elapsedMilliseconds := time.Since(start).Round(time.Millisecond) / time.Millisecond
		logger.Infof("[%s][%s] Exit chaincode: %s (%dms)", txParams.ChannelID, shorttxid(txParams.TxID), cid, elapsedMilliseconds)
	}(time.Now())

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[2], 1);var err error
	var res *pb.Response
	var ccevent *pb.ChaincodeEvent

	// is this a system chaincode
	res, ccevent, err = e.s.Execute(txParams, txParams.ChannelID, cid.Name, version, txParams.TxID, txParams.SignedProp, txParams.Proposal, input)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[7], 1);
		return nil, nil, err
	}

	// per doc anything < 400 can be sent as TX.
	// fabric errors will always be >= 400 (ie, unambiguous errors )
	// "lscc" will respond with status 200 or 500 (ie, unambiguous OK or ERROR)
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[3], 1);if res.Status >= shim.ERRORTHRESHOLD {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[8], 1);
		return res, nil, nil
	}

	// ----- BEGIN -  SECTION THAT MAY NEED TO BE DONE IN LSCC ------
	// if this a call to deploy a chaincode, We need a mechanism
	// to pass TxSimulator into LSCC. Till that is worked out this
	// special code does the actual deploy, upgrade here so as to collect
	// all state under one TxSimulator
	//
	// NOTE that if there's an error all simulation, including the chaincode
	// table changes in lscc will be thrown away
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[4], 1);if cid.Name == "lscc" && len(input.Args) >= 3 && (string(input.Args[0]) == "deploy" || string(input.Args[0]) == "upgrade") {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[9], 1);
		userCDS, err := putils.GetChaincodeDeploymentSpec(input.Args[2], e.PlatformRegistry)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[13], 1);
			return nil, nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[10], 1);var cds *pb.ChaincodeDeploymentSpec
		cds, err = e.SanitizeUserCDS(userCDS)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[14], 1);
			return nil, nil, err
		}

		// this should not be a system chaincode
		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[11], 1);if e.s.IsSysCC(cds.ChaincodeSpec.ChaincodeId.Name) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[15], 1);
			return nil, nil, errors.Errorf("attempting to deploy a system chaincode %s/%s", cds.ChaincodeSpec.ChaincodeId.Name, txParams.ChannelID)
		}

		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[12], 1);_, _, err = e.s.ExecuteLegacyInit(txParams, txParams.ChannelID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txParams.TxID, txParams.SignedProp, txParams.Proposal, cds)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[16], 1);
			return nil, nil, err
		}
	}
	// ----- END -------

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[5], 1);return res, ccevent, err
}

func (e *Endorser) SanitizeUserCDS(userCDS *pb.ChaincodeDeploymentSpec) (*pb.ChaincodeDeploymentSpec, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[17], 1);
	fsCDS, err := e.s.GetChaincodeDeploymentSpecFS(userCDS)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[19], 1);
		return nil, errors.Wrapf(err, "cannot deploy a chaincode which is not installed")
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[18], 1);sanitizedCDS := proto.Clone(fsCDS).(*pb.ChaincodeDeploymentSpec)
	sanitizedCDS.CodePackage = nil
	sanitizedCDS.ChaincodeSpec.Input = userCDS.ChaincodeSpec.Input

	return sanitizedCDS, nil
}

// SimulateProposal simulates the proposal by calling the chaincode
func (e *Endorser) SimulateProposal(txParams *ccprovider.TransactionParams, cid *pb.ChaincodeID) (ccprovider.ChaincodeDefinition, *pb.Response, []byte, *pb.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[20], 1);
	endorserLogger.Debugf("[%s][%s] Entry chaincode: %s", txParams.ChannelID, shorttxid(txParams.TxID), cid)
	defer endorserLogger.Debugf("[%s][%s] Exit", txParams.ChannelID, shorttxid(txParams.TxID))
	// we do expect the payload to be a ChaincodeInvocationSpec
	// if we are supporting other payloads in future, this be glaringly point
	// as something that should change
	cis, err := putils.GetChaincodeInvocationSpec(txParams.Proposal)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[25], 1);
		return nil, nil, nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[21], 1);var cdLedger ccprovider.ChaincodeDefinition
	var version string

	if !e.s.IsSysCC(cid.Name) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[26], 1);
		cdLedger, err = e.s.GetChaincodeDefinition(cid.Name, txParams.TXSimulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[28], 1);
			return nil, nil, nil, nil, errors.WithMessage(err, fmt.Sprintf("make sure the chaincode %s has been successfully instantiated and try again", cid.Name))
		}
		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[27], 1);version = cdLedger.CCVersion()

		err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[29], 1);
			return nil, nil, nil, nil, err
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[30], 1);{
		version = util.GetSysCCVersion()
	}}

	// ---3. execute the proposal and get simulation results
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[22], 1);var simResult *ledger.TxSimulationResults
	var pubSimResBytes []byte
	var res *pb.Response
	var ccevent *pb.ChaincodeEvent
	res, ccevent, err = e.callChaincode(txParams, version, cis.ChaincodeSpec.Input, cid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[31], 1);
		endorserLogger.Errorf("[%s][%s] failed to invoke chaincode %s, error: %+v", txParams.ChannelID, shorttxid(txParams.TxID), cid, err)
		return nil, nil, nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[23], 1);if txParams.TXSimulator != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[32], 1);
		if simResult, err = txParams.TXSimulator.GetTxSimulationResults(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[35], 1);
			txParams.TXSimulator.Done()
			return nil, nil, nil, nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[33], 1);if simResult.PvtSimulationResults != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[36], 1);
			if cid.Name == "lscc" {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[40], 1);
				// TODO: remove once we can store collection configuration outside of LSCC
				txParams.TXSimulator.Done()
				return nil, nil, nil, nil, errors.New("Private data is forbidden to be used in instantiate")
			}
			_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[37], 1);pvtDataWithConfig, err := e.AssemblePvtRWSet(simResult.PvtSimulationResults, txParams.TXSimulator)
			// To read collection config need to read collection updates before
			// releasing the lock, hence txParams.TXSimulator.Done()  moved down here
			txParams.TXSimulator.Done()

			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[41], 1);
				return nil, nil, nil, nil, errors.WithMessage(err, "failed to obtain collections config")
			}
			_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[38], 1);endorsedAt, err := e.s.GetLedgerHeight(txParams.ChannelID)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[42], 1);
				return nil, nil, nil, nil, errors.WithMessage(err, fmt.Sprint("failed to obtain ledger height for channel", txParams.ChannelID))
			}
			// Add ledger height at which transaction was endorsed,
			// `endorsedAt` is obtained from the block storage and at times this could be 'endorsement Height + 1'.
			// However, since we use this height only to select the configuration (3rd parameter in distributePrivateData) and
			// manage transient store purge for orphaned private writesets (4th parameter in distributePrivateData), this works for now.
			// Ideally, ledger should add support in the simulator as a first class function `GetHeight()`.
			_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[39], 1);pvtDataWithConfig.EndorsedAt = endorsedAt
			if err := e.distributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[43], 1);
				return nil, nil, nil, nil, err
			}
		}

		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[34], 1);txParams.TXSimulator.Done()
		if pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[44], 1);
			return nil, nil, nil, nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[24], 1);return cdLedger, res, pubSimResBytes, ccevent, nil
}

// endorse the proposal by calling the ESCC
func (e *Endorser) endorseProposal(_ context.Context, chainID string, txid string, signedProp *pb.SignedProposal, proposal *pb.Proposal, response *pb.Response, simRes []byte, event *pb.ChaincodeEvent, visibility []byte, ccid *pb.ChaincodeID, txsim ledger.TxSimulator, cd ccprovider.ChaincodeDefinition) (*pb.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[45], 1);
	endorserLogger.Debugf("[%s][%s] Entry chaincode: %s", chainID, shorttxid(txid), ccid)
	defer endorserLogger.Debugf("[%s][%s] Exit", chainID, shorttxid(txid))

	isSysCC := cd == nil
	// 1) extract the name of the escc that is requested to endorse this chaincode
	var escc string
	// ie, "lscc" or system chaincodes
	if isSysCC {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[49], 1);
		escc = "escc"
	} else{ _cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[50], 1);{
		escc = cd.Endorsement()
	}}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[46], 1);endorserLogger.Debugf("[%s][%s] escc for chaincode %s is %s", chainID, shorttxid(txid), ccid, escc)

	// marshalling event bytes
	var err error
	var eventBytes []byte
	if event != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[51], 1);
		eventBytes, err = putils.GetBytesChaincodeEvent(event)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[52], 1);
			return nil, errors.Wrap(err, "failed to marshal event bytes")
		}
	}

	// set version of executing chaincode
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[47], 1);if isSysCC {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[53], 1);
		// if we want to allow mixed fabric levels we should
		// set syscc version to ""
		ccid.Version = util.GetSysCCVersion()
	} else{ _cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[54], 1);{
		ccid.Version = cd.CCVersion()
	}}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[48], 1);ctx := Context{
		PluginName:     escc,
		Channel:        chainID,
		SignedProposal: signedProp,
		ChaincodeID:    ccid,
		Event:          eventBytes,
		SimRes:         simRes,
		Response:       response,
		Visibility:     visibility,
		Proposal:       proposal,
		TxID:           txid,
	}
	return e.s.EndorseWithPlugin(ctx)
}

// preProcess checks the tx proposal headers, uniqueness and ACL
func (e *Endorser) preProcess(signedProp *pb.SignedProposal) (*validateResult, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[55], 1);
	vr := &validateResult{}
	// at first, we check whether the message is valid
	prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)

	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[61], 1);
		vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
		return vr, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[56], 1);chdr, err := putils.UnmarshalChannelHeader(hdr.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[62], 1);
		vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
		return vr, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[57], 1);shdr, err := putils.GetSignatureHeader(hdr.SignatureHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[63], 1);
		vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
		return vr, err
	}

	// block invocations to security-sensitive system chaincodes
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[58], 1);if e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[64], 1);
		endorserLogger.Errorf("Error: an attempt was made by %#v to invoke system chaincode %s", shdr.Creator, hdrExt.ChaincodeId.Name)
		err = errors.Errorf("chaincode %s cannot be invoked through a proposal", hdrExt.ChaincodeId.Name)
		vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
		return vr, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[59], 1);chainID := chdr.ChannelId
	txid := chdr.TxId
	endorserLogger.Debugf("[%s][%s] processing txid: %s", chainID, shorttxid(txid), txid)

	if chainID != "" {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[65], 1);
		// Here we handle uniqueness check and ACLs for proposals targeting a chain
		// Notice that ValidateProposalMessage has already verified that TxID is computed properly
		if _, err = e.s.GetTransactionByID(chainID, txid); err == nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[67], 1);
			err = errors.Errorf("duplicate transaction found [%s]. Creator [%x]", txid, shdr.Creator)
			vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
			return vr, err
		}

		// check ACL only for application chaincodes; ACLs
		// for system chaincodes are checked elsewhere
		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[66], 1);if !e.s.IsSysCC(hdrExt.ChaincodeId.Name) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[68], 1);
			// check that the proposal complies with the Channel's writers
			if err = e.s.CheckACL(signedProp, chdr, shdr, hdrExt); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[69], 1);
				vr.resp = &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}
				return vr, err
			}
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[70], 1);{
		// chainless proposals do not/cannot affect ledger and cannot be submitted as transactions
		// ignore uniqueness checks; also, chainless proposals are not validated using the policies
		// of the chain since by definition there is no chain; they are validated against the local
		// MSP of the peer instead by the call to ValidateProposalMessage above
	}}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[60], 1);vr.prop, vr.hdrExt, vr.chainID, vr.txid = prop, hdrExt, chainID, txid
	return vr, nil
}

// ProcessProposal process the Proposal
func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[71], 1);
	addr := util.ExtractRemoteAddress(ctx)
	endorserLogger.Debug("Entering: request from", addr)
	defer endorserLogger.Debug("Exit: request from", addr)

	// 0 -- check and validate
	vr, err := e.preProcess(signedProp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[77], 1);
		resp := vr.resp
		return resp, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[72], 1);prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid

	// obtaining once the tx simulator for this proposal. This will be nil
	// for chainless proposals
	// Also obtain a history query executor for history queries, since tx simulator does not cover history
	var txsim ledger.TxSimulator
	var historyQueryExecutor ledger.HistoryQueryExecutor
	if acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[78], 1);
		if txsim, err = e.s.GetTxSimulator(chainID, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[80], 1);
			return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
		}

		// txsim acquires a shared lock on the stateDB. As this would impact the block commits (i.e., commit
		// of valid write-sets to the stateDB), we must release the lock as early as possible.
		// Hence, this txsim object is closed in simulateProposal() as soon as the tx is simulated and
		// rwset is collected before gossip dissemination if required for privateData. For safety, we
		// add the following defer statement and is useful when an error occur. Note that calling
		// txsim.Done() more than once does not cause any issue. If the txsim is already
		// released, the following txsim.Done() simply returns.
		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[79], 1);defer txsim.Done()

		if historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[81], 1);
			return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[73], 1);txParams := &ccprovider.TransactionParams{
		ChannelID:            chainID,
		TxID:                 txid,
		SignedProp:           signedProp,
		Proposal:             prop,
		TXSimulator:          txsim,
		HistoryQueryExecutor: historyQueryExecutor,
	}
	// this could be a request to a chainless SysCC

	// TODO: if the proposal has an extension, it will be of type ChaincodeAction;
	//       if it's present it means that no simulation is to be performed because
	//       we're trying to emulate a submitting peer. On the other hand, we need
	//       to validate the supplied action before endorsing it

	// 1 -- simulate
	cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[82], 1);
		return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[74], 1);if res != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[83], 1);
		if res.Status >= shim.ERROR {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[84], 1);
			endorserLogger.Errorf("[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s", chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid)
			var cceventBytes []byte
			if ccevent != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[87], 1);
				cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[88], 1);
					return nil, errors.Wrap(err, "failed to marshal event bytes")
				}
			}
			_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[85], 1);pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[89], 1);
				return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
			}

			_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[86], 1);return pResp, nil
		}
	}

	// 2 -- endorse and get a marshalled ProposalResponse message
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[75], 1);var pResp *pb.ProposalResponse

	// TODO till we implement global ESCC, CSCC for system chaincodes
	// chainless proposals (such as CSCC) don't have to be endorsed
	if chainID == "" {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[90], 1);
		pResp = &pb.ProposalResponse{Response: res}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[91], 1);{
		//Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim
		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[93], 1);
			return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[92], 1);if pResp.Response.Status >= shim.ERRORTHRESHOLD {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[94], 1);
			endorserLogger.Debugf("[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s", chainID, shorttxid(txid), hdrExt.ChaincodeId, txid)
			return pResp, nil
		}
	}}

	// Set the proposal response payload - it
	// contains the "return value" from the
	// chaincode invocation
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[76], 1);pResp.Response = res

	return pResp, nil
}

// determine whether or not a transaction simulator should be
// obtained for a proposal.
func acquireTxSimulator(chainID string, ccid *pb.ChaincodeID) bool {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[95], 1);
	if chainID == "" {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[97], 1);
		return false
	}

	// ¯\_(ツ)_/¯ locking.
	// Don't get a simulator for the query and config system chaincode.
	// These don't need the simulator and its read lock results in deadlocks.
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[96], 1);switch ccid.Name {
	case "qscc", "cscc":_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[98], 1);
		return false
	default:_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[99], 1);
		return true
	}
}

// shorttxid replicates the chaincode package function to shorten txids.
// ~~TODO utilize a common shorttxid utility across packages.~~
// TODO use a formal type for transaction ID and make it a stringer
func shorttxid(txid string) string {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[100], 1);
	if len(txid) < 8 {_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[102], 1);
		return txid
	}
	_cover_atomic_.AddUint32(&GoCover_0_306432633236306362313365.Count[101], 1);return txid[0:8]
}

var GoCover_0_306432633236306362313365 = struct {
	Count     [103]uint32
	Pos       [3 * 103]uint32
	NumStmt   [103]uint16
} {
	Pos: [3 * 103]uint32{
		118, 126, 0x20066, // [0]
		129, 131, 0x1e00b3, // [1]
		137, 143, 0x100002, // [2]
		150, 150, 0x270002, // [3]
		162, 162, 0x7d0002, // [4]
		186, 186, 0x1a0002, // [5]
		131, 135, 0x3001e, // [6]
		143, 145, 0x30010, // [7]
		150, 152, 0x30027, // [8]
		162, 164, 0x11007d, // [9]
		168, 170, 0x110003, // [10]
		175, 175, 0x360003, // [11]
		179, 180, 0x110003, // [12]
		164, 166, 0x40011, // [13]
		170, 172, 0x40011, // [14]
		175, 177, 0x40036, // [15]
		180, 182, 0x40011, // [16]
		189, 191, 0x10006e, // [17]
		195, 199, 0x1a0002, // [18]
		191, 193, 0x30010, // [19]
		203, 210, 0x1000b4, // [20]
		214, 217, 0x1c0002, // [21]
		233, 238, 0x100002, // [22]
		243, 243, 0x210002, // [23]
		283, 283, 0x340002, // [24]
		210, 212, 0x30010, // [25]
		217, 219, 0x11001c, // [26]
		222, 225, 0x110003, // [27]
		219, 221, 0x40011, // [28]
		225, 227, 0x40011, // [29]
		228, 230, 0x30008, // [30]
		238, 241, 0x30010, // [31]
		243, 244, 0x510021, // [32]
		249, 249, 0x2c0003, // [33]
		278, 279, 0x4a0003, // [34]
		244, 247, 0x40051, // [35]
		249, 250, 0x1a002c, // [36]
		255, 260, 0x120004, // [37]
		263, 264, 0x120004, // [38]
		272, 273, 0x740004, // [39]
		250, 254, 0x5001a, // [40]
		260, 262, 0x50012, // [41]
		264, 266, 0x50012, // [42]
		273, 275, 0x50074, // [43]
		279, 281, 0x4004a, // [44]
		287, 295, 0xd014e, // [45]
		301, 306, 0x120002, // [46]
		314, 314, 0xd0002, // [47]
		322, 334, 0x230002, // [48]
		295, 297, 0x3000d, // [49]
		297, 299, 0x30008, // [50]
		306, 308, 0x110012, // [51]
		308, 310, 0x40011, // [52]
		314, 318, 0x3000d, // [53]
		318, 320, 0x30008, // [54]
		338, 343, 0x100057, // [55]
		348, 349, 0x100002, // [56]
		354, 355, 0x100002, // [57]
		361, 361, 0x410002, // [58]
		368, 372, 0x130002, // [59]
		397, 398, 0x100002, // [60]
		343, 346, 0x30010, // [61]
		349, 352, 0x30010, // [62]
		355, 358, 0x30010, // [63]
		361, 366, 0x30041, // [64]
		372, 375, 0x410013, // [65]
		383, 383, 0x2c0003, // [66]
		375, 379, 0x40041, // [67]
		383, 385, 0x46002c, // [68]
		385, 388, 0x50046, // [69]
		390, 395, 0x30009, // [70]
		402, 409, 0x100076, // [71]
		414, 421, 0x380002, // [72]
		440, 457, 0x100002, // [73]
		460, 460, 0x100002, // [74]
		480, 484, 0x130002, // [75]
		501, 503, 0x130002, // [76]
		409, 412, 0x30010, // [77]
		421, 422, 0x410038, // [78]
		433, 435, 0x530003, // [79]
		422, 424, 0x40041, // [80]
		435, 437, 0x40053, // [81]
		457, 459, 0x30010, // [82]
		460, 461, 0x1f0010, // [83]
		461, 464, 0x16001f, // [84]
		470, 471, 0x120004, // [85]
		475, 475, 0x150004, // [86]
		464, 466, 0x130016, // [87]
		466, 468, 0x60013, // [88]
		471, 473, 0x50012, // [89]
		484, 486, 0x30013, // [90]
		486, 489, 0x110008, // [91]
		492, 492, 0x330003, // [92]
		489, 491, 0x40011, // [93]
		492, 495, 0x40033, // [94]
		508, 509, 0x130044, // [95]
		516, 516, 0x130002, // [96]
		509, 511, 0x30013, // [97]
		517, 518, 0xf0016, // [98]
		519, 520, 0xe000a, // [99]
		527, 528, 0x130024, // [100]
		531, 531, 0x120002, // [101]
		528, 530, 0x30013, // [102]
	},
	NumStmt: [103]uint16{
		2, // 0
		2, // 1
		5, // 2
		1, // 3
		1, // 4
		1, // 5
		3, // 6
		1, // 7
		1, // 8
		2, // 9
		3, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		2, // 17
		4, // 18
		1, // 19
		4, // 20
		3, // 21
		6, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		3, // 27
		1, // 28
		1, // 29
		1, // 30
		2, // 31
		1, // 32
		1, // 33
		2, // 34
		2, // 35
		1, // 36
		3, // 37
		2, // 38
		2, // 39
		2, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		5, // 45
		4, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		3, // 55
		2, // 56
		2, // 57
		1, // 58
		4, // 59
		2, // 60
		2, // 61
		2, // 62
		2, // 63
		4, // 64
		1, // 65
		1, // 66
		3, // 67
		1, // 68
		2, // 69
		0, // 70
		5, // 71
		4, // 72
		3, // 73
		1, // 74
		2, // 75
		2, // 76
		2, // 77
		1, // 78
		2, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		3, // 84
		2, // 85
		1, // 86
		2, // 87
		1, // 88
		1, // 89
		1, // 90
		2, // 91
		1, // 92
		1, // 93
		2, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
	},
}
var _ = _cover_atomic_.LoadUint32
