//line /home/cooper/go/src/github.com/hyperledger/fabric/common/deliver/acl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package deliver; import _cover_atomic_ "sync/atomic"

import (
	"time"

	"github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

// ExpiresAtFunc is used to extract the time at which an identity expires.
type ExpiresAtFunc func(identityBytes []byte) time.Time

// ConfigSequencer provides the sequence number of the current config block.
type ConfigSequencer interface {
	Sequence() uint64
}

// NewSessionAC creates an instance of SessionAccessControl. This constructor will
// return an error if a signature header cannot be extracted from the envelope.
func NewSessionAC(chain ConfigSequencer, env *common.Envelope, policyChecker PolicyChecker, channelID string, expiresAt ExpiresAtFunc) (*SessionAccessControl, error) {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[0], 1);
	signedData, err := env.AsSignedData()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[2], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[1], 1);return &SessionAccessControl{
		envelope:       env,
		channelID:      channelID,
		sequencer:      chain,
		policyChecker:  policyChecker,
		sessionEndTime: expiresAt(signedData[0].Identity),
	}, nil
}

// SessionAccessControl holds access control related data for a common Envelope
// that is used to determine if a request is allowed for the identity
// associated with the request envelope.
type SessionAccessControl struct {
	sequencer          ConfigSequencer
	policyChecker      PolicyChecker
	channelID          string
	envelope           *common.Envelope
	lastConfigSequence uint64
	sessionEndTime     time.Time
	usedAtLeastOnce    bool
}

// Evaluate uses the PolicyChecker to determine if a request should be allowed.
// The decision is cached until the identity expires or the chain configuration
// changes.
func (ac *SessionAccessControl) Evaluate() error {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[3], 1);
	if !ac.sessionEndTime.IsZero() && time.Now().After(ac.sessionEndTime) {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[7], 1);
		return errors.Errorf("client identity expired %v before", time.Since(ac.sessionEndTime))
	}

	_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[4], 1);policyCheckNeeded := !ac.usedAtLeastOnce

	if currentConfigSequence := ac.sequencer.Sequence(); currentConfigSequence > ac.lastConfigSequence {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[8], 1);
		ac.lastConfigSequence = currentConfigSequence
		policyCheckNeeded = true
	}

	_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[5], 1);if !policyCheckNeeded {_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[9], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_313735643635643662363634.Count[6], 1);ac.usedAtLeastOnce = true
	return ac.policyChecker.CheckPolicy(ac.envelope, ac.channelID)
}

var GoCover_0_313735643635643662363634 = struct {
	Count     [10]uint32
	Pos       [3 * 10]uint32
	NumStmt   [10]uint16
} {
	Pos: [3 * 10]uint32{
		26, 28, 0x1000a7, // [0]
		32, 38, 0x80002, // [1]
		28, 30, 0x30010, // [2]
		57, 58, 0x480032, // [3]
		62, 64, 0x650002, // [4]
		69, 69, 0x180002, // [5]
		73, 74, 0x400002, // [6]
		58, 60, 0x30048, // [7]
		64, 67, 0x30065, // [8]
		69, 71, 0x30018, // [9]
	},
	NumStmt: [10]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		1, // 9
	},
}
var _ = _cover_atomic_.LoadUint32
