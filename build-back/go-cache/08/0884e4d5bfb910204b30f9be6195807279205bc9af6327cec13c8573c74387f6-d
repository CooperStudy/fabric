//line /home/cooper/go/src/github.com/hyperledger/fabric/core/comm/creds.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"errors"
	"net"

	"github.com/hyperledger/fabric/common/flogging"
	"google.golang.org/grpc/credentials"
)

var (
	ClientHandshakeNotImplError = errors.New("core/comm: Client handshakes" +
		"are not implemented with serverCreds")
	OverrrideHostnameNotSupportedError = errors.New(
		"core/comm: OverrideServerName is " +
			"not supported")
	MissingServerConfigError = errors.New(
		"core/comm: `serverConfig` cannot be nil")
	// alpnProtoStr are the specified application level protocols for gRPC.
	alpnProtoStr = []string{"h2"}
)

// NewServerTransportCredentials returns a new initialized
// grpc/credentials.TransportCredentials
func NewServerTransportCredentials(
	serverConfig *tls.Config,
	logger *flogging.FabricLogger) credentials.TransportCredentials {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[0], 1);

	// NOTE: unlike the default grpc/credentials implementation, we do not
	// clone the tls.Config which allows us to update it dynamically
	serverConfig.NextProtos = alpnProtoStr
	// override TLS version and ensure it is 1.2
	serverConfig.MinVersion = tls.VersionTLS12
	serverConfig.MaxVersion = tls.VersionTLS12
	return &serverCreds{
		serverConfig: serverConfig,
		logger:       logger}
}

// serverCreds is an implementation of grpc/credentials.TransportCredentials.
type serverCreds struct {
	serverConfig *tls.Config
	logger       *flogging.FabricLogger
}

// ClientHandShake is not implemented for `serverCreds`.
func (sc *serverCreds) ClientHandshake(context.Context,
	string, net.Conn) (net.Conn, credentials.AuthInfo, error) {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[1], 1);
	return nil, nil, ClientHandshakeNotImplError
}

// ServerHandshake does the authentication handshake for servers.
func (sc *serverCreds) ServerHandshake(rawConn net.Conn) (net.Conn, credentials.AuthInfo, error) {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[2], 1);
	conn := tls.Server(rawConn, sc.serverConfig)
	if err := conn.Handshake(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[4], 1);
		if sc.logger != nil {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[6], 1);
			sc.logger.With("remote address",
				conn.RemoteAddr().String()).Errorf("TLS handshake failed with error %s", err)
		}
		_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[5], 1);return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[3], 1);return conn, credentials.TLSInfo{State: conn.ConnectionState()}, nil
}

// Info provides the ProtocolInfo of this TransportCredentials.
func (sc *serverCreds) Info() credentials.ProtocolInfo {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[7], 1);
	return credentials.ProtocolInfo{
		SecurityProtocol: "tls",
		SecurityVersion:  "1.2",
	}
}

// Clone makes a copy of this TransportCredentials.
func (sc *serverCreds) Clone() credentials.TransportCredentials {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[8], 1);
	creds := NewServerTransportCredentials(sc.serverConfig, sc.logger)
	return creds
}

// OverrideServerName overrides the server name used to verify the hostname
// on the returned certificates from the server.
func (sc *serverCreds) OverrideServerName(string) error {_cover_atomic_.AddUint32(&GoCover_3_643230363037383562363632.Count[9], 1);
	return OverrrideHostnameNotSupportedError
}

var GoCover_3_643230363037383562363632 = struct {
	Count     [10]uint32
	Pos       [3 * 10]uint32
	NumStmt   [10]uint16
} {
	Pos: [3 * 10]uint32{
		35, 46, 0x20042, // [0]
		56, 58, 0x2003c, // [1]
		61, 63, 0x290062, // [2]
		70, 70, 0x460002, // [3]
		63, 64, 0x170029, // [4]
		68, 68, 0x170003, // [5]
		64, 67, 0x40017, // [6]
		74, 79, 0x20038, // [7]
		82, 85, 0x20041, // [8]
		89, 91, 0x20039, // [9]
	},
	NumStmt: [10]uint16{
		4, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
	},
}
var _ = _cover_atomic_.LoadUint32
