//line /home/cooper/go/src/github.com/hyperledger/fabric/common/policies/policy.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package policies; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

const (
	// Path separator is used to separate policy names in paths
	PathSeparator = "/"

	// ChannelPrefix is used in the path of standard channel policy managers
	ChannelPrefix = "Channel"

	// ApplicationPrefix is used in the path of standard application policy paths
	ApplicationPrefix = "Application"

	// OrdererPrefix is used in the path of standard orderer policy paths
	OrdererPrefix = "Orderer"

	// ChannelReaders is the label for the channel's readers policy (encompassing both orderer and application readers)
	ChannelReaders = PathSeparator + ChannelPrefix + PathSeparator + "Readers"

	// ChannelWriters is the label for the channel's writers policy (encompassing both orderer and application writers)
	ChannelWriters = PathSeparator + ChannelPrefix + PathSeparator + "Writers"

	// ChannelApplicationReaders is the label for the channel's application readers policy
	ChannelApplicationReaders = PathSeparator + ChannelPrefix + PathSeparator + ApplicationPrefix + PathSeparator + "Readers"

	// ChannelApplicationWriters is the label for the channel's application writers policy
	ChannelApplicationWriters = PathSeparator + ChannelPrefix + PathSeparator + ApplicationPrefix + PathSeparator + "Writers"

	// ChannelApplicationAdmins is the label for the channel's application admin policy
	ChannelApplicationAdmins = PathSeparator + ChannelPrefix + PathSeparator + ApplicationPrefix + PathSeparator + "Admins"

	// BlockValidation is the label for the policy which should validate the block signatures for the channel
	BlockValidation = PathSeparator + ChannelPrefix + PathSeparator + OrdererPrefix + PathSeparator + "BlockValidation"
)

var logger = flogging.MustGetLogger("policies")

// PrincipalSet is a collection of MSPPrincipals
type PrincipalSet []*msp.MSPPrincipal

// PrincipalSets aggregates PrincipalSets
type PrincipalSets []PrincipalSet

// ContainingOnly returns PrincipalSets that contain only principals of the given predicate
func (psSets PrincipalSets) ContainingOnly(f func(*msp.MSPPrincipal) bool) PrincipalSets {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[0], 1);
	var res PrincipalSets
	for _, set := range psSets {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[2], 1);
		if !set.ContainingOnly(f) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[4], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[3], 1);res = append(res, set)
	}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[1], 1);return res
}

// ContainingOnly returns whether the given PrincipalSet contains only Principals
// that satisfy the given predicate
func (ps PrincipalSet) ContainingOnly(f func(*msp.MSPPrincipal) bool) bool {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[5], 1);
	for _, principal := range ps {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[7], 1);
		if !f(principal) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[8], 1);
			return false
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[6], 1);return true
}

// UniqueSet returns a histogram that is induced by the PrincipalSet
func (ps PrincipalSet) UniqueSet() map[*msp.MSPPrincipal]int {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[9], 1);
	// Create a histogram that holds the MSPPrincipals and counts them
	histogram := make(map[struct {
		cls       int32
		principal string
	}]int)
	// Now, populate the histogram
	for _, principal := range ps {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[12], 1);
		key := struct {
			cls       int32
			principal string
		}{
			cls:       int32(principal.PrincipalClassification),
			principal: string(principal.Principal),
		}
		histogram[key]++
	}
	// Finally, convert to a histogram of MSPPrincipal pointers
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[10], 1);res := make(map[*msp.MSPPrincipal]int)
	for principal, count := range histogram {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[13], 1);
		res[&msp.MSPPrincipal{
			PrincipalClassification: msp.MSPPrincipal_Classification(principal.cls),
			Principal:               []byte(principal.principal),
		}] = count
	}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[11], 1);return res
}

// Policy is used to determine if a signature is valid
type Policy interface {
	// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy
	Evaluate(signatureSet []*cb.SignedData) error
}

// InquireablePolicy is a Policy that one can inquire
type InquireablePolicy interface {
	// SatisfiedBy returns a slice of PrincipalSets that each of them
	// satisfies the policy.
	SatisfiedBy() []PrincipalSet
}

// Manager is a read only subset of the policy ManagerImpl
type Manager interface {
	// GetPolicy returns a policy and true if it was the policy requested, or false if it is the default policy
	GetPolicy(id string) (Policy, bool)

	// Manager returns the sub-policy manager for a given path and whether it exists
	Manager(path []string) (Manager, bool)
}

// Provider provides the backing implementation of a policy
type Provider interface {
	// NewPolicy creates a new policy based on the policy bytes
	NewPolicy(data []byte) (Policy, proto.Message, error)
}

// ChannelPolicyManagerGetter is a support interface
// to get access to the policy manager of a given channel
type ChannelPolicyManagerGetter interface {
	// Returns the policy manager associated to the passed channel
	// and true if it was the manager requested, or false if it is the default manager
	Manager(channelID string) (Manager, bool)
}

// ManagerImpl is an implementation of Manager and configtx.ConfigHandler
// In general, it should only be referenced as an Impl for the configtx.ConfigManager
type ManagerImpl struct {
	path     string // The group level path
	policies map[string]Policy
	managers map[string]*ManagerImpl
}

// NewManagerImpl creates a new ManagerImpl with the given CryptoHelper
func NewManagerImpl(path string, providers map[int32]Provider, root *cb.ConfigGroup) (*ManagerImpl, error) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[14], 1);
	var err error
	_, ok := providers[int32(cb.Policy_IMPLICIT_META)]
	if ok {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[19], 1);
		logger.Panicf("ImplicitMetaPolicy type must be provider by the policy manager")
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[15], 1);managers := make(map[string]*ManagerImpl)

	for groupName, group := range root.Groups {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[20], 1);
		managers[groupName], err = NewManagerImpl(path+PathSeparator+groupName, providers, group)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[21], 1);
			return nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[16], 1);policies := make(map[string]Policy)
	for policyName, configPolicy := range root.Policies {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[22], 1);
		policy := configPolicy.Policy
		if policy == nil {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[25], 1);
			return nil, fmt.Errorf("policy %s at path %s was nil", policyName, path)
		}

		_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[23], 1);var cPolicy Policy

		if policy.Type == int32(cb.Policy_IMPLICIT_META) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[26], 1);
			imp, err := newImplicitMetaPolicy(policy.Value, managers)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[28], 1);
				return nil, errors.Wrapf(err, "implicit policy %s at path %s did not compile", policyName, path)
			}
			_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[27], 1);cPolicy = imp
		} else{ _cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[29], 1);{
			provider, ok := providers[int32(policy.Type)]
			if !ok {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[31], 1);
				return nil, fmt.Errorf("policy %s at path %s has unknown policy type: %v", policyName, path, policy.Type)
			}

			_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[30], 1);var err error
			cPolicy, _, err = provider.NewPolicy(policy.Value)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[32], 1);
				return nil, errors.Wrapf(err, "policy %s at path %s did not compile", policyName, path)
			}
		}}

		_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[24], 1);policies[policyName] = cPolicy

		logger.Debugf("Proposed new policy %s for %s", policyName, path)
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[17], 1);for groupName, manager := range managers {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[33], 1);
		for policyName, policy := range manager.policies {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[34], 1);
			policies[groupName+PathSeparator+policyName] = policy
		}
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[18], 1);return &ManagerImpl{
		path:     path,
		policies: policies,
		managers: managers,
	}, nil
}

type rejectPolicy string

func (rp rejectPolicy) Evaluate(signedData []*cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[35], 1);
	return fmt.Errorf("No such policy: '%s'", rp)
}

// Manager returns the sub-policy manager for a given path and whether it exists
func (pm *ManagerImpl) Manager(path []string) (Manager, bool) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[36], 1);
	logger.Debugf("Manager %s looking up path %v", pm.path, path)
	for manager := range pm.managers {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[40], 1);
		logger.Debugf("Manager %s has managers %s", pm.path, manager)
	}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[37], 1);if len(path) == 0 {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[41], 1);
		return pm, true
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[38], 1);m, ok := pm.managers[path[0]]
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[42], 1);
		return nil, false
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[39], 1);return m.Manager(path[1:])
}

type policyLogger struct {
	policy     Policy
	policyName string
}

func (pl *policyLogger) Evaluate(signatureSet []*cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[43], 1);
	if logger.IsEnabledFor(zapcore.DebugLevel) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[46], 1);
		logger.Debugf("== Evaluating %T Policy %s ==", pl.policy, pl.policyName)
		defer logger.Debugf("== Done Evaluating %T Policy %s", pl.policy, pl.policyName)
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[44], 1);err := pl.policy.Evaluate(signatureSet)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[47], 1);
		logger.Debugf("Signature set did not satisfy policy %s", pl.policyName)
	} else{ _cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[48], 1);{
		logger.Debugf("Signature set satisfies policy %s", pl.policyName)
	}}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[45], 1);return err
}

// GetPolicy returns a policy and true if it was the policy requested, or false if it is the default reject policy
func (pm *ManagerImpl) GetPolicy(id string) (Policy, bool) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[49], 1);
	if id == "" {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[53], 1);
		logger.Errorf("Returning dummy reject all policy because no policy ID supplied")
		return rejectPolicy(id), false
	}
	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[50], 1);var relpath string

	if strings.HasPrefix(id, PathSeparator) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[54], 1);
		if !strings.HasPrefix(id, PathSeparator+pm.path) {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[56], 1);
			logger.Debugf("Requested absolute policy %s from %s, returning rejectAll", id, pm.path)
			return rejectPolicy(id), false
		}
		// strip off the leading slash, the path, and the trailing slash
		_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[55], 1);relpath = id[1+len(pm.path)+1:]
	} else{ _cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[57], 1);{
		relpath = id
	}}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[51], 1);policy, ok := pm.policies[relpath]
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[58], 1);
		logger.Debugf("Returning dummy reject all policy because %s could not be found in %s/%s", id, pm.path, relpath)
		return rejectPolicy(relpath), false
	}

	_cover_atomic_.AddUint32(&GoCover_3_306461616464623964633937.Count[52], 1);return &policyLogger{
		policy:     policy,
		policyName: PathSeparator + pm.path + PathSeparator + relpath,
	}, true
}

var GoCover_3_306461616464623964633937 = struct {
	Count     [59]uint32
	Pos       [3 * 59]uint32
	NumStmt   [59]uint16
} {
	Pos: [3 * 59]uint32{
		62, 64, 0x1d005a, // [0]
		70, 70, 0xc0002, // [1]
		64, 65, 0x1d001d, // [2]
		68, 68, 0x190003, // [3]
		65, 66, 0xc001d, // [4]
		75, 76, 0x1f004c, // [5]
		81, 81, 0xd0002, // [6]
		76, 77, 0x14001f, // [7]
		77, 79, 0x40014, // [8]
		85, 92, 0x1f003e, // [9]
		103, 104, 0x2a0002, // [10]
		110, 110, 0xc0002, // [11]
		92, 101, 0x3001f, // [12]
		104, 109, 0x3002a, // [13]
		158, 161, 0x8006c, // [14]
		165, 167, 0x2c0002, // [15]
		174, 175, 0x360002, // [16]
		207, 207, 0x2b0002, // [17]
		213, 217, 0x80002, // [18]
		161, 163, 0x30008, // [19]
		167, 169, 0x11002c, // [20]
		169, 171, 0x40011, // [21]
		175, 177, 0x140036, // [22]
		181, 183, 0x340003, // [23]
		202, 204, 0x430003, // [24]
		177, 179, 0x40014, // [25]
		183, 185, 0x120034, // [26]
		188, 188, 0x110004, // [27]
		185, 187, 0x50012, // [28]
		189, 191, 0xb0009, // [29]
		195, 197, 0x120004, // [30]
		191, 193, 0x5000b, // [31]
		197, 199, 0x50012, // [32]
		207, 208, 0x34002b, // [33]
		208, 210, 0x40034, // [34]
		222, 224, 0x20044, // [35]
		227, 229, 0x23003f, // [36]
		232, 232, 0x140002, // [37]
		236, 237, 0x90002, // [38]
		241, 241, 0x1c0002, // [39]
		229, 231, 0x30023, // [40]
		232, 234, 0x30014, // [41]
		237, 239, 0x30009, // [42]
		249, 250, 0x2d0047, // [43]
		255, 256, 0x100002, // [44]
		261, 261, 0xc0002, // [45]
		250, 253, 0x3002d, // [46]
		256, 258, 0x30010, // [47]
		258, 260, 0x30008, // [48]
		265, 266, 0xe003c, // [49]
		270, 272, 0x2a0002, // [50]
		283, 284, 0x90002, // [51]
		289, 292, 0x90002, // [52]
		266, 269, 0x3000e, // [53]
		272, 273, 0x34002a, // [54]
		278, 278, 0x220003, // [55]
		273, 276, 0x40034, // [56]
		279, 281, 0x30008, // [57]
		284, 287, 0x30009, // [58]
	},
	NumStmt: [59]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		2, // 12
		1, // 13
		3, // 14
		2, // 15
		2, // 16
		1, // 17
		1, // 18
		1, // 19
		2, // 20
		1, // 21
		2, // 22
		2, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		2, // 29
		3, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		2, // 44
		1, // 45
		2, // 46
		1, // 47
		1, // 48
		1, // 49
		2, // 50
		2, // 51
		1, // 52
		2, // 53
		1, // 54
		1, // 55
		2, // 56
		1, // 57
		2, // 58
	},
}
var _ = _cover_atomic_.LoadUint32
