//line /home/cooper/go/src/github.com/hyperledger/fabric/common/flogging/fabenc/formatter.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fabenc; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"io"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"

	"go.uber.org/zap/zapcore"
)

// formatRegexp is broken into three groups:
//   1. the format verb
//   2. an optional colon that is ungrouped with '?:'
//   3. an optional, non-greedy format directive
//
// The grouping simplifies the verb proccessing during spec parsing.
var formatRegexp = regexp.MustCompile(`%{(color|id|level|message|module|shortfunc|time)(?::(.*?))?}`)

// ParseFormat parses a log format spec and returns a slice of formatters
// that should be iterated over to build a formatted log record.
//
// The op-loggng specifiers supported by this formatter are:
//   - %{color} - level specific SGR color escape or SGR reset
//   - %{id} - a unique log sequence number
//   - %{level} - the log level of the entry
//   - %{message} - the log message
//   - %{module} - the zap logger name
//   - %{shortfunc} - the name of the function creating the log record
//   - %{time} - the time the log entry was created
//
// Specifiers may include an optional format verb:
//   - color: reset|bold
//   - id: a fmt style numeric formatter without the leading %
//   - level: a fmt style string formatter without the leading %
//   - message: a fmt style string formatter without the leading %
//   - module: a fmt style string formatter without the leading %
//
func ParseFormat(spec string) ([]Formatter, error) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[0], 1);
	cursor := 0
	formatters := []Formatter{}

	// iterate over the regex groups and convert to formatters
	matches := formatRegexp.FindAllStringSubmatchIndex(spec, -1)
	for _, m := range matches {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[3], 1);
		start, end := m[0], m[1]
		verbStart, verbEnd := m[2], m[3]
		formatStart, formatEnd := m[4], m[5]

		if start > cursor {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[7], 1);
			formatters = append(formatters, StringFormatter{Value: spec[cursor:start]})
		}

		_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[4], 1);var format string
		if formatStart >= 0 {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[8], 1);
			format = spec[formatStart:formatEnd]
		}

		_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[5], 1);formatter, err := NewFormatter(spec[verbStart:verbEnd], format)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[9], 1);
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[6], 1);formatters = append(formatters, formatter)
		cursor = end
	}

	// handle any trailing suffix
	_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[1], 1);if cursor != len(spec) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[10], 1);
		formatters = append(formatters, StringFormatter{Value: spec[cursor:]})
	}

	_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[2], 1);return formatters, nil
}

// A MultiFormatter presents multiple formatters as a single Formatter. It can
// be used to change the set of formatters associated with an encoder at
// runtime.
type MultiFormatter struct {
	mutex      sync.RWMutex
	formatters []Formatter
}

// NewMultiFormatter creates a new MultiFormatter that delegates to the
// provided formatters. The formatters are used in the order they are
// presented.
func NewMultiFormatter(formatters ...Formatter) *MultiFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[11], 1);
	return &MultiFormatter{
		formatters: formatters,
	}
}

// Format iterates over its delegates to format a log record to the provided
// buffer.
func (m *MultiFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[12], 1);
	m.mutex.RLock()
	for i := range m.formatters {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[14], 1);
		m.formatters[i].Format(w, entry, fields)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[13], 1);m.mutex.RUnlock()
}

// SetFormatters replaces the delegate formatters.
func (m *MultiFormatter) SetFormatters(formatters []Formatter) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[15], 1);
	m.mutex.Lock()
	m.formatters = formatters
	m.mutex.Unlock()
}

// A StringFormatter formats a fixed string.
type StringFormatter struct{ Value string }

// Format writes the formatter's fixed string to provided writer.
func (s StringFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[16], 1);
	fmt.Fprintf(w, "%s", s.Value)
}

// NewFormatter creates the formatter for the provided verb. When a format is
// not provided, the default format for the verb is used.
func NewFormatter(verb, format string) (Formatter, error) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[17], 1);
	switch verb {
	case "color":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[18], 1);
		return newColorFormatter(format)
	case "id":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[19], 1);
		return newSequenceFormatter(format), nil
	case "level":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[20], 1);
		return newLevelFormatter(format), nil
	case "message":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[21], 1);
		return newMessageFormatter(format), nil
	case "module":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[22], 1);
		return newModuleFormatter(format), nil
	case "shortfunc":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[23], 1);
		return newShortFuncFormatter(format), nil
	case "time":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[24], 1);
		return newTimeFormatter(format), nil
	default:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[25], 1);
		return nil, fmt.Errorf("unknown verb: %s", verb)
	}
}

// A ColorFormatter formats an SGR color code.
type ColorFormatter struct {
	Bold  bool // set the bold attribute
	Reset bool // reset colors and attributes
}

func newColorFormatter(f string) (ColorFormatter, error) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[26], 1);
	switch f {
	case "bold":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[27], 1);
		return ColorFormatter{Bold: true}, nil
	case "reset":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[28], 1);
		return ColorFormatter{Reset: true}, nil
	case "":_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[29], 1);
		return ColorFormatter{}, nil
	default:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[30], 1);
		return ColorFormatter{}, fmt.Errorf("invalid color option: %s", f)
	}
}

// LevelColor returns the Color associated with a specific zap logging level.
func (c ColorFormatter) LevelColor(l zapcore.Level) Color {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[31], 1);
	switch l {
	case zapcore.DebugLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[32], 1);
		return ColorCyan
	case zapcore.InfoLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[33], 1);
		return ColorBlue
	case zapcore.WarnLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[34], 1);
		return ColorYellow
	case zapcore.ErrorLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[35], 1);
		return ColorRed
	case zapcore.DPanicLevel, zapcore.PanicLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[36], 1);
		return ColorMagenta
	case zapcore.FatalLevel:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[37], 1);
		return ColorMagenta
	default:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[38], 1);
		return ColorNone
	}
}

// Format writes the SGR color code to the provided writer.
func (c ColorFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[39], 1);
	switch {
	case c.Reset:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[40], 1);
		fmt.Fprintf(w, ResetColor())
	case c.Bold:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[41], 1);
		fmt.Fprintf(w, c.LevelColor(entry.Level).Bold())
	default:_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[42], 1);
		fmt.Fprintf(w, c.LevelColor(entry.Level).Normal())
	}
}

// LevelFormatter formats a log level.
type LevelFormatter struct{ FormatVerb string }

func newLevelFormatter(f string) LevelFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[43], 1);
	return LevelFormatter{FormatVerb: "%" + stringOrDefault(f, "s")}
}

// Format writes the logging level to the provided writer.
func (l LevelFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[44], 1);
	fmt.Fprintf(w, l.FormatVerb, entry.Level.CapitalString())
}

// MessageFormatter formats a log message.
type MessageFormatter struct{ FormatVerb string }

func newMessageFormatter(f string) MessageFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[45], 1);
	return MessageFormatter{FormatVerb: "%" + stringOrDefault(f, "s")}
}

// Format writes the log entry message to the provided writer.
func (m MessageFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[46], 1);
	fmt.Fprintf(w, m.FormatVerb, strings.TrimRight(entry.Message, "\n"))
}

// ModuleFormatter formats the zap logger name.
type ModuleFormatter struct{ FormatVerb string }

func newModuleFormatter(f string) ModuleFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[47], 1);
	return ModuleFormatter{FormatVerb: "%" + stringOrDefault(f, "s")}
}

// Format writes the zap logger name to the specified writer.
func (m ModuleFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[48], 1);
	fmt.Fprintf(w, m.FormatVerb, entry.LoggerName)
}

// sequence maintains the global sequence number shared by all SequeneFormatter
// instances.
var sequence uint64

// SetSequence explicitly sets the global sequence number.
func SetSequence(s uint64) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[49], 1); atomic.StoreUint64(&sequence, s) }

// SequenceFormatter formats a global sequence number.
type SequenceFormatter struct{ FormatVerb string }

func newSequenceFormatter(f string) SequenceFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[50], 1);
	return SequenceFormatter{FormatVerb: "%" + stringOrDefault(f, "d")}
}

// SequenceFormatter increments a global sequence number and writes it to the
// provided writer.
func (s SequenceFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[51], 1);
	fmt.Fprintf(w, s.FormatVerb, atomic.AddUint64(&sequence, 1))
}

// ShortFuncFormatter formats the name of the function creating the log record.
type ShortFuncFormatter struct{ FormatVerb string }

func newShortFuncFormatter(f string) ShortFuncFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[52], 1);
	return ShortFuncFormatter{FormatVerb: "%" + stringOrDefault(f, "s")}
}

// Format writes the calling function name to the provided writer. The name is obtained from
// the runtime and the package and line numbers are discarded.
func (s ShortFuncFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[53], 1);
	f := runtime.FuncForPC(entry.Caller.PC)
	if f == nil {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[55], 1);
		fmt.Fprintf(w, s.FormatVerb, "(unknown)")
		return
	}

	_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[54], 1);fname := f.Name()
	funcIdx := strings.LastIndex(fname, ".")
	fmt.Fprintf(w, s.FormatVerb, fname[funcIdx+1:])
}

// TimeFormatter formats the time from the zap log entry.
type TimeFormatter struct{ Layout string }

func newTimeFormatter(f string) TimeFormatter {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[56], 1);
	return TimeFormatter{Layout: stringOrDefault(f, "2006-01-02T15:04:05.999Z07:00")}
}

// Format writes the log record time stamp to the provided writer.
func (t TimeFormatter) Format(w io.Writer, entry zapcore.Entry, fields []zapcore.Field) {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[57], 1);
	fmt.Fprint(w, entry.Time.Format(t.Layout))
}

func stringOrDefault(str, dflt string) string {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[58], 1);
	if str != "" {_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[60], 1);
		return str
	}
	_cover_atomic_.AddUint32(&GoCover_2_363135623664303734363938.Count[59], 1);return dflt
}

var GoCover_2_363135623664303734363938 = struct {
	Count     [61]uint32
	Pos       [3 * 61]uint32
	NumStmt   [61]uint16
} {
	Pos: [3 * 61]uint32{
		48, 54, 0x1c0034, // [0]
		78, 78, 0x190002, // [1]
		82, 82, 0x180002, // [2]
		54, 59, 0x15001c, // [3]
		63, 64, 0x170003, // [4]
		68, 69, 0x110003, // [5]
		73, 74, 0xf0003, // [6]
		59, 61, 0x40015, // [7]
		64, 66, 0x40017, // [8]
		69, 71, 0x40011, // [9]
		78, 80, 0x30019, // [10]
		96, 100, 0x20041, // [11]
		104, 106, 0x1e005b, // [12]
		109, 109, 0x130002, // [13]
		106, 108, 0x3001e, // [14]
		113, 117, 0x20040, // [15]
		123, 125, 0x2005b, // [16]
		129, 130, 0xe003b, // [17]
		131, 132, 0x23000f, // [18]
		133, 134, 0x2b000c, // [19]
		135, 136, 0x28000f, // [20]
		137, 138, 0x2a0011, // [21]
		139, 140, 0x290010, // [22]
		141, 142, 0x2c0013, // [23]
		143, 144, 0x27000e, // [24]
		145, 146, 0x33000a, // [25]
		156, 157, 0xb003a, // [26]
		158, 159, 0x29000e, // [27]
		160, 161, 0x2a000f, // [28]
		162, 163, 0x1f000a, // [29]
		164, 165, 0x45000a, // [30]
		170, 171, 0xb003b, // [31]
		172, 173, 0x13001a, // [32]
		174, 175, 0x130019, // [33]
		176, 177, 0x150019, // [34]
		178, 179, 0x12001a, // [35]
		180, 181, 0x16002f, // [36]
		182, 183, 0x16001a, // [37]
		184, 185, 0x13000a, // [38]
		190, 191, 0x9005a, // [39]
		192, 193, 0x1f000f, // [40]
		194, 195, 0x33000e, // [41]
		196, 197, 0x35000a, // [42]
		204, 206, 0x20031, // [43]
		209, 211, 0x2005a, // [44]
		216, 218, 0x20035, // [45]
		221, 223, 0x2005c, // [46]
		228, 230, 0x20033, // [47]
		233, 235, 0x2005b, // [48]
		242, 242, 0x40001c, // [49]
		247, 249, 0x20037, // [50]
		253, 255, 0x2005d, // [51]
		260, 262, 0x20039, // [52]
		266, 268, 0xe005e, // [53]
		273, 275, 0x310002, // [54]
		268, 271, 0x3000e, // [55]
		281, 283, 0x2002f, // [56]
		286, 288, 0x20059, // [57]
		290, 291, 0xf002f, // [58]
		294, 294, 0xd0002, // [59]
		291, 293, 0x3000f, // [60]
	},
	NumStmt: [61]uint16{
		4, // 0
		1, // 1
		1, // 2
		4, // 3
		2, // 4
		2, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		3, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		2, // 53
		3, // 54
		2, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
	},
}
var _ = _cover_atomic_.LoadUint32
