//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/cceventmgmt/lsccstate_listener.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cceventmgmt; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
)

// KVLedgerLSCCStateListener listens for state changes for chaincode lifecycle
type KVLedgerLSCCStateListener struct {
	DeployedChaincodeInfoProvider ledger.DeployedChaincodeInfoProvider
}

// HandleStateUpdates uses 'DeployedChaincodeInfoProvider' to findout deployment of a chaincode
// and invokes `HandleChaincodeDeploy` function on chaincode event manager (which in turn is responsible for creation of statedb
// artifacts for the chaincode statedata)
func (listener *KVLedgerLSCCStateListener) HandleStateUpdates(trigger *ledger.StateUpdateTrigger) error {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[0], 1);
	channelName, kvWrites, postCommitQE, deployCCInfoProvider :=
		trigger.LedgerID, convertToKVWrites(trigger.StateUpdates), trigger.PostCommitQueryExecutor, listener.DeployedChaincodeInfoProvider

	logger.Debugf("Channel [%s]: Handling state updates in LSCC namespace - stateUpdates=%#v", channelName, kvWrites)
	updatedChaincodes, err := deployCCInfoProvider.UpdatedChaincodes(kvWrites)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[3], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[1], 1);chaincodeDefs := []*ChaincodeDefinition{}
	for _, updatedChaincode := range updatedChaincodes {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[4], 1);
		logger.Infof("Channel [%s]: Handling deploy or update of chaincode [%s]", channelName, updatedChaincode.Name)
		if updatedChaincode.Deleted {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[7], 1);
			// TODO handle delete case when delete is implemented in lifecycle
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[5], 1);deployedCCInfo, err := deployCCInfoProvider.ChaincodeInfo(updatedChaincode.Name, postCommitQE)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[8], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[6], 1);chaincodeDefs = append(chaincodeDefs, &ChaincodeDefinition{
			Name:              deployedCCInfo.Name,
			Hash:              deployedCCInfo.Hash,
			Version:           deployedCCInfo.Version,
			CollectionConfigs: deployedCCInfo.CollectionConfigPkg,
		})
	}
	_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[2], 1);return GetMgr().HandleChaincodeDeploy(channelName, chaincodeDefs)
}

// InterestedInNamespaces implements function from interface `ledger.StateListener`
func (listener *KVLedgerLSCCStateListener) InterestedInNamespaces() []string {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[9], 1);
	return listener.DeployedChaincodeInfoProvider.Namespaces()
}

// StateCommitDone implements function from interface `ledger.StateListener`
func (listener *KVLedgerLSCCStateListener) StateCommitDone(channelName string) {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[10], 1);
	GetMgr().ChaincodeDeployDone(channelName)
}

func convertToKVWrites(stateUpdates ledger.StateUpdates) map[string][]*kvrwset.KVWrite {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[11], 1);
	m := map[string][]*kvrwset.KVWrite{}
	for ns, updates := range stateUpdates {_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[13], 1);
		m[ns] = updates.([]*kvrwset.KVWrite)
	}
	_cover_atomic_.AddUint32(&GoCover_1_313036666535393137343839.Count[12], 1);return m
}

var GoCover_1_313036666535393137343839 = struct {
	Count     [14]uint32
	Pos       [3 * 14]uint32
	NumStmt   [14]uint16
} {
	Pos: [3 * 14]uint32{
		22, 28, 0x100069, // [0]
		31, 32, 0x350002, // [1]
		49, 49, 0x430002, // [2]
		28, 30, 0x30010, // [3]
		32, 34, 0x1f0035, // [4]
		38, 39, 0x110003, // [5]
		42, 47, 0x50003, // [6]
		34, 36, 0xc001f, // [7]
		39, 41, 0x40011, // [8]
		53, 55, 0x2004e, // [9]
		58, 60, 0x20050, // [10]
		62, 64, 0x280058, // [11]
		67, 67, 0xa0002, // [12]
		64, 66, 0x30028, // [13]
	},
	NumStmt: [14]uint16{
		4, // 0
		2, // 1
		1, // 2
		1, // 3
		2, // 4
		2, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
	},
}
var _ = _cover_atomic_.LoadUint32
