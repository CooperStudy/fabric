//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/confighistory/mgr.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package confighistory; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("confighistory")

const (
	collectionConfigNamespace = "lscc" // lscc namespace was introduced in version 1.2 and we continue to use this in order to be compatible with existing data
)

// Mgr should be registered as a state listener. The state listener builds the history and retriver helps in querying the history
type Mgr interface {
	ledger.StateListener
	GetRetriever(ledgerID string, ledgerInfoRetriever LedgerInfoRetriever) ledger.ConfigHistoryRetriever
	Close()
}

type mgr struct {
	ccInfoProvider ledger.DeployedChaincodeInfoProvider
	dbProvider     *dbProvider
}

// NewMgr constructs an instance that implements interface `Mgr`
func NewMgr(ccInfoProvider ledger.DeployedChaincodeInfoProvider) Mgr {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[0], 1);
	return newMgr(ccInfoProvider, dbPath())
}

func newMgr(ccInfoProvider ledger.DeployedChaincodeInfoProvider, dbPath string) Mgr {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[1], 1);
	return &mgr{ccInfoProvider, newDBProvider(dbPath)}
}

// InterestedInNamespaces implements function from the interface ledger.StateListener
func (m *mgr) InterestedInNamespaces() []string {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[2], 1);
	return m.ccInfoProvider.Namespaces()
}

// StateCommitDone implements function from the interface ledger.StateListener
func (m *mgr) StateCommitDone(ledgerID string) {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[3], 1);
	// Noop
}

// HandleStateUpdates implements function from the interface ledger.StateListener
// In this implementation, the latest collection config package is retrieved via
// ledger.DeployedChaincodeInfoProvider and is persisted as a separate entry in a separate db.
// The composite key for the entry is a tuple of <blockNum, namespace, key>
func (m *mgr) HandleStateUpdates(trigger *ledger.StateUpdateTrigger) error {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[4], 1);
	updatedCCs, err := m.ccInfoProvider.UpdatedChaincodes(convertToKVWrites(trigger.StateUpdates))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[10], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[5], 1);if len(updatedCCs) == 0 {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[11], 1);
		logger.Errorf("Config history manager is expected to recieve events only if at least one chaincode is updated stateUpdates = %#v",
			trigger.StateUpdates)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[6], 1);updatedCollConfigs := map[string]*common.CollectionConfigPackage{}
	for _, cc := range updatedCCs {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[12], 1);
		ccInfo, err := m.ccInfoProvider.ChaincodeInfo(cc.Name, trigger.PostCommitQueryExecutor)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[15], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[13], 1);if ccInfo.CollectionConfigPkg == nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[16], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[14], 1);updatedCollConfigs[ccInfo.Name] = ccInfo.CollectionConfigPkg
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[7], 1);if len(updatedCollConfigs) == 0 {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[17], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[8], 1);batch, err := prepareDBBatch(updatedCollConfigs, trigger.CommittingBlockNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[18], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[9], 1);dbHandle := m.dbProvider.getDB(trigger.LedgerID)
	return dbHandle.writeBatch(batch, true)
}

// GetRetriever returns an implementation of `ledger.ConfigHistoryRetriever` for the given ledger id.
func (m *mgr) GetRetriever(ledgerID string, ledgerInfoRetriever LedgerInfoRetriever) ledger.ConfigHistoryRetriever {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[19], 1);
	return &retriever{dbHandle: m.dbProvider.getDB(ledgerID), ledgerInfoRetriever: ledgerInfoRetriever}
}

// Close implements the function in the interface 'Mgr'
func (m *mgr) Close() {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[20], 1);
	m.dbProvider.Close()
}

type retriever struct {
	ledgerInfoRetriever LedgerInfoRetriever
	dbHandle            *db
}

// MostRecentCollectionConfigBelow implements function from the interface ledger.ConfigHistoryRetriever
func (r *retriever) MostRecentCollectionConfigBelow(blockNum uint64, chaincodeName string) (*ledger.CollectionConfigInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[21], 1);
	compositeKV, err := r.dbHandle.mostRecentEntryBelow(blockNum, collectionConfigNamespace, constructCollectionConfigKey(chaincodeName))
	if err != nil || compositeKV == nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[23], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[22], 1);return compositeKVToCollectionConfig(compositeKV)
}

// CollectionConfigAt implements function from the interface ledger.ConfigHistoryRetriever
func (r *retriever) CollectionConfigAt(blockNum uint64, chaincodeName string) (*ledger.CollectionConfigInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[24], 1);
	info, err := r.ledgerInfoRetriever.GetBlockchainInfo()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[28], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[25], 1);maxCommittedBlockNum := info.Height - 1
	if maxCommittedBlockNum < blockNum {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[29], 1);
		return nil, &ledger.ErrCollectionConfigNotYetAvailable{MaxBlockNumCommitted: maxCommittedBlockNum,
			Msg: fmt.Sprintf("The maximum block number committed [%d] is less than the requested block number [%d]", maxCommittedBlockNum, blockNum)}
	}

	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[26], 1);compositeKV, err := r.dbHandle.entryAt(blockNum, collectionConfigNamespace, constructCollectionConfigKey(chaincodeName))
	if err != nil || compositeKV == nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[30], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[27], 1);return compositeKVToCollectionConfig(compositeKV)
}

func prepareDBBatch(chaincodeCollConfigs map[string]*common.CollectionConfigPackage, committingBlockNum uint64) (*batch, error) {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[31], 1);
	batch := newBatch()
	for ccName, collConfig := range chaincodeCollConfigs {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[33], 1);
		key := constructCollectionConfigKey(ccName)
		var configBytes []byte
		var err error
		if configBytes, err = proto.Marshal(collConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[35], 1);
			return nil, errors.WithStack(err)
		}
		_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[34], 1);batch.add(collectionConfigNamespace, key, committingBlockNum, configBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[32], 1);return batch, nil
}

func compositeKVToCollectionConfig(compositeKV *compositeKV) (*ledger.CollectionConfigInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[36], 1);
	conf := &common.CollectionConfigPackage{}
	if err := proto.Unmarshal(compositeKV.value, conf); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[38], 1);
		return nil, errors.Wrap(err, "error unmarshalling compositeKV to collection config")
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[37], 1);return &ledger.CollectionConfigInfo{CollectionConfig: conf, CommittingBlockNum: compositeKV.blockNum}, nil
}

func constructCollectionConfigKey(chaincodeName string) string {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[39], 1);
	return chaincodeName + "~collection" // collection config key as in version 1.2 and we continue to use this in order to be compatible with existing data
}

func dbPath() string {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[40], 1);
	return ledgerconfig.GetConfigHistoryPath()
}

func convertToKVWrites(stateUpdates ledger.StateUpdates) map[string][]*kvrwset.KVWrite {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[41], 1);
	m := map[string][]*kvrwset.KVWrite{}
	for ns, updates := range stateUpdates {_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[43], 1);
		m[ns] = updates.([]*kvrwset.KVWrite)
	}
	_cover_atomic_.AddUint32(&GoCover_1_633363383730643239393737.Count[42], 1);return m
}

// LedgerInfoRetriever retrieves the relevant info from ledger
type LedgerInfoRetriever interface {
	GetBlockchainInfo() (*common.BlockchainInfo, error)
}

var GoCover_1_633363383730643239393737 = struct {
	Count     [44]uint32
	Pos       [3 * 44]uint32
	NumStmt   [44]uint16
} {
	Pos: [3 * 44]uint32{
		40, 42, 0x20046, // [0]
		44, 46, 0x20055, // [1]
		49, 51, 0x20031, // [2]
		54, 56, 0x20031, // [3]
		62, 64, 0x10004c, // [4]
		67, 67, 0x1a0002, // [5]
		72, 73, 0x200002, // [6]
		83, 83, 0x220002, // [7]
		86, 87, 0x100002, // [8]
		90, 91, 0x290002, // [9]
		64, 66, 0x30010, // [10]
		67, 71, 0x3001a, // [11]
		73, 75, 0x110020, // [12]
		78, 78, 0x280003, // [13]
		81, 81, 0x3f0003, // [14]
		75, 77, 0x40011, // [15]
		78, 79, 0xc0028, // [16]
		83, 85, 0x30022, // [17]
		87, 89, 0x30010, // [18]
		95, 97, 0x20074, // [19]
		100, 102, 0x20017, // [20]
		110, 112, 0x260082, // [21]
		115, 115, 0x330002, // [22]
		112, 114, 0x30026, // [23]
		119, 121, 0x100075, // [24]
		124, 125, 0x250002, // [25]
		130, 131, 0x260002, // [26]
		134, 134, 0x330002, // [27]
		121, 123, 0x30010, // [28]
		125, 128, 0x30025, // [29]
		131, 133, 0x30026, // [30]
		137, 139, 0x370081, // [31]
		148, 148, 0x130002, // [32]
		139, 143, 0x3f0037, // [33]
		146, 146, 0x4d0003, // [34]
		143, 145, 0x4003f, // [35]
		151, 153, 0x410064, // [36]
		156, 156, 0x6c0002, // [37]
		153, 155, 0x30041, // [38]
		159, 161, 0x20040, // [39]
		163, 165, 0x20016, // [40]
		167, 169, 0x280058, // [41]
		172, 172, 0xa0002, // [42]
		169, 171, 0x30028, // [43]
	},
	NumStmt: [44]uint16{
		1, // 0
		1, // 1
		1, // 2
		0, // 3
		2, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		2, // 9
		1, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		2, // 24
		2, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		2, // 31
		1, // 32
		4, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		1, // 43
	},
}
var _ = _cover_atomic_.LoadUint32
