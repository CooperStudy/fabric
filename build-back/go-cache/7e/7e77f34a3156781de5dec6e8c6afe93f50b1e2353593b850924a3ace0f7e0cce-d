//line /home/cooper/go/src/github.com/hyperledger/fabric/common/metrics/statsd/provider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package statsd; import _cover_atomic_ "sync/atomic"

import (
	"github.com/go-kit/kit/metrics/statsd"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/metrics/internal/namer"
)

const defaultFormat = "%{#fqname}"

type Provider struct {
	Statsd *statsd.Statsd
}

func (p *Provider) NewCounter(o metrics.CounterOpts) metrics.Counter {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[0], 1);
	if o.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[3], 1);
		o.StatsdFormat = defaultFormat
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[1], 1);counter := &Counter{
		statsdProvider: p.Statsd,
		namer:          namer.NewCounterNamer(o),
	}

	if len(o.LabelNames) == 0 {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[4], 1);
		counter.Counter = p.Statsd.NewCounter(counter.namer.Format(), 1)
	}

	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[2], 1);return counter
}

func (p *Provider) NewGauge(o metrics.GaugeOpts) metrics.Gauge {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[5], 1);
	if o.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[8], 1);
		o.StatsdFormat = defaultFormat
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[6], 1);gauge := &Gauge{
		statsdProvider: p.Statsd,
		namer:          namer.NewGaugeNamer(o),
	}

	if len(o.LabelNames) == 0 {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[9], 1);
		gauge.Gauge = p.Statsd.NewGauge(gauge.namer.Format())
	}

	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[7], 1);return gauge
}

func (p *Provider) NewHistogram(o metrics.HistogramOpts) metrics.Histogram {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[10], 1);
	if o.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[13], 1);
		o.StatsdFormat = defaultFormat
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[11], 1);histogram := &Histogram{
		statsdProvider: p.Statsd,
		namer:          namer.NewHistogramNamer(o),
	}

	if len(o.LabelNames) == 0 {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[14], 1);
		histogram.Timing = p.Statsd.NewTiming(histogram.namer.Format(), 1.0)
	}

	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[12], 1);return histogram
}

type Counter struct {
	Counter        *statsd.Counter
	namer          *namer.Namer
	statsdProvider *statsd.Statsd
}

func (c *Counter) Add(delta float64) {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[15], 1);
	if c.Counter == nil {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[17], 1);
		panic("label values must be provided by calling With")
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[16], 1);c.Counter.Add(delta)
}

func (c *Counter) With(labelValues ...string) metrics.Counter {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[18], 1);
	name := c.namer.Format(labelValues...)
	return &Counter{Counter: c.statsdProvider.NewCounter(name, 1)}
}

type Gauge struct {
	Gauge          *statsd.Gauge
	namer          *namer.Namer
	statsdProvider *statsd.Statsd
}

func (g *Gauge) Add(delta float64) {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[19], 1);
	if g.Gauge == nil {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[21], 1);
		panic("label values must be provided by calling With")
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[20], 1);g.Gauge.Add(delta)
}

func (g *Gauge) Set(value float64) {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[22], 1);
	if g.Gauge == nil {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[24], 1);
		panic("label values must be provided by calling With")
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[23], 1);g.Gauge.Set(value)
}

func (g *Gauge) With(labelValues ...string) metrics.Gauge {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[25], 1);
	name := g.namer.Format(labelValues...)
	return &Gauge{Gauge: g.statsdProvider.NewGauge(name)}
}

type Histogram struct {
	Timing         *statsd.Timing
	namer          *namer.Namer
	statsdProvider *statsd.Statsd
}

func (h *Histogram) With(labelValues ...string) metrics.Histogram {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[26], 1);
	name := h.namer.Format(labelValues...)
	return &Histogram{Timing: h.statsdProvider.NewTiming(name, 1)}
}

func (h *Histogram) Observe(value float64) {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[27], 1);
	if h.Timing == nil {_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[29], 1);
		panic("label values must be provided by calling With")
	}
	_cover_atomic_.AddUint32(&GoCover_0_306133643332643635623235.Count[28], 1);h.Timing.Observe(value)
}

var GoCover_0_306133643332643635623235 = struct {
	Count     [30]uint32
	Pos       [3 * 30]uint32
	NumStmt   [30]uint16
} {
	Pos: [3 * 30]uint32{
		21, 22, 0x1a0046, // [0]
		25, 30, 0x1c0002, // [1]
		34, 34, 0x100002, // [2]
		22, 24, 0x3001a, // [3]
		30, 32, 0x3001c, // [4]
		37, 38, 0x1a0040, // [5]
		41, 46, 0x1c0002, // [6]
		50, 50, 0xe0002, // [7]
		38, 40, 0x3001a, // [8]
		46, 48, 0x3001c, // [9]
		53, 54, 0x1a004c, // [10]
		57, 62, 0x1c0002, // [11]
		66, 66, 0x120002, // [12]
		54, 56, 0x3001a, // [13]
		62, 64, 0x3001c, // [14]
		75, 76, 0x160026, // [15]
		79, 79, 0x160002, // [16]
		76, 77, 0x390016, // [17]
		82, 85, 0x2003f, // [18]
		93, 94, 0x140024, // [19]
		97, 97, 0x140002, // [20]
		94, 95, 0x390014, // [21]
		100, 101, 0x140024, // [22]
		104, 104, 0x140002, // [23]
		101, 102, 0x390014, // [24]
		107, 110, 0x2003b, // [25]
		118, 121, 0x20043, // [26]
		123, 124, 0x15002c, // [27]
		127, 127, 0x190002, // [28]
		124, 125, 0x390015, // [29]
	},
	NumStmt: [30]uint16{
		1, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
	},
}
var _ = _cover_atomic_.LoadUint32
