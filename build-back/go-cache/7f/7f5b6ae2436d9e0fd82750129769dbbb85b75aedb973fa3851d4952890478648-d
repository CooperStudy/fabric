//line /home/cooper/go/src/github.com/hyperledger/fabric/common/tools/configtxgen/localconfig/config.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package localconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/common/viperutil"
	cf "github.com/hyperledger/fabric/core/config"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/orderer/etcdraft"
	"github.com/spf13/viper"
)

const (
	// Prefix identifies the prefix for the configtxgen-related ENV vars.
	Prefix string = "CONFIGTX"
)

var logger = flogging.MustGetLogger("common.tools.configtxgen.localconfig")
var configName = strings.ToLower(Prefix)

const (
	// TestChainID is the channel name used for testing purposes when one is
	// not given
	TestChainID = "testchainid"

	// SampleInsecureSoloProfile references the sample profile which does not
	// include any MSPs and uses solo for ordering.
	SampleInsecureSoloProfile = "SampleInsecureSolo"
	// SampleDevModeSoloProfile references the sample profile which requires
	// only basic membership for admin privileges and uses solo for ordering.
	SampleDevModeSoloProfile = "SampleDevModeSolo"
	// SampleSingleMSPSoloProfile references the sample profile which includes
	// only the sample MSP and uses solo for ordering.
	SampleSingleMSPSoloProfile = "SampleSingleMSPSolo"

	// SampleInsecureKafkaProfile references the sample profile which does not
	// include any MSPs and uses Kafka for ordering.
	SampleInsecureKafkaProfile = "SampleInsecureKafka"
	// SampleDevModeKafkaProfile references the sample profile which requires only
	// basic membership for admin privileges and uses Kafka for ordering.
	SampleDevModeKafkaProfile = "SampleDevModeKafka"
	// SampleSingleMSPKafkaProfile references the sample profile which includes
	// only the sample MSP and uses Kafka for ordering.
	SampleSingleMSPKafkaProfile = "SampleSingleMSPKafka"

	// SampleDevModeEtcdRaftProfile references the sample profile used for testing
	// the etcd/raft-based ordering service.
	SampleDevModeEtcdRaftProfile = "SampleDevModeEtcdRaft"

	// SampleSingleMSPChannelProfile references the sample profile which
	// includes only the sample MSP and is used to create a channel
	SampleSingleMSPChannelProfile = "SampleSingleMSPChannel"

	// SampleConsortiumName is the sample consortium from the
	// sample configtx.yaml
	SampleConsortiumName = "SampleConsortium"
	// SampleOrgName is the name of the sample org in the sample profiles
	SampleOrgName = "SampleOrg"

	// AdminRoleAdminPrincipal is set as AdminRole to cause the MSP role of
	// type Admin to be used as the admin principal default
	AdminRoleAdminPrincipal = "Role.ADMIN"
	// MemberRoleAdminPrincipal is set as AdminRole to cause the MSP role of
	// type Member to be used as the admin principal default
	MemberRoleAdminPrincipal = "Role.MEMBER"
)

// TopLevel consists of the structs used by the configtxgen tool.
type TopLevel struct {
	Profiles      map[string]*Profile        `yaml:"Profiles"`
	Organizations []*Organization            `yaml:"Organizations"`
	Channel       *Profile                   `yaml:"Channel"`
	Application   *Application               `yaml:"Application"`
	Orderer       *Orderer                   `yaml:"Orderer"`
	Capabilities  map[string]map[string]bool `yaml:"Capabilities"`
	Resources     *Resources                 `yaml:"Resources"`
}

// Profile encodes orderer/application configuration combinations for the
// configtxgen tool.
type Profile struct {
	Consortium   string                 `yaml:"Consortium"`
	Application  *Application           `yaml:"Application"`
	Orderer      *Orderer               `yaml:"Orderer"`
	Consortiums  map[string]*Consortium `yaml:"Consortiums"`
	Capabilities map[string]bool        `yaml:"Capabilities"`
	Policies     map[string]*Policy     `yaml:"Policies"`
}

// Policy encodes a channel config policy
type Policy struct {
	Type string `yaml:"Type"`
	Rule string `yaml:"Rule"`
}

// Consortium represents a group of organizations which may create channels
// with each other
type Consortium struct {
	Organizations []*Organization `yaml:"Organizations"`
}

// Application encodes the application-level configuration needed in config
// transactions.
type Application struct {
	Organizations []*Organization    `yaml:"Organizations"`
	Capabilities  map[string]bool    `yaml:"Capabilities"`
	Resources     *Resources         `yaml:"Resources"`
	Policies      map[string]*Policy `yaml:"Policies"`
	ACLs          map[string]string  `yaml:"ACLs"`
}

// Resources encodes the application-level resources configuration needed to
// seed the resource tree
type Resources struct {
	DefaultModPolicy string
}

// Organization encodes the organization-level configuration needed in
// config transactions.
type Organization struct {
	Name     string             `yaml:"Name"`
	ID       string             `yaml:"ID"`
	MSPDir   string             `yaml:"MSPDir"`
	MSPType  string             `yaml:"MSPType"`
	Policies map[string]*Policy `yaml:"Policies"`

	// Note: Viper deserialization does not seem to care for
	// embedding of types, so we use one organization struct
	// for both orderers and applications.
	AnchorPeers []*AnchorPeer `yaml:"AnchorPeers"`

	// AdminPrincipal is deprecated and may be removed in a future release
	// it was used for modifying the default policy generation, but policies
	// may now be specified explicitly so it is redundant and unnecessary
	AdminPrincipal string `yaml:"AdminPrincipal"`
}

// AnchorPeer encodes the necessary fields to identify an anchor peer.
type AnchorPeer struct {
	Host string `yaml:"Host"`
	Port int    `yaml:"Port"`
}

// Orderer contains configuration which is used for the
// bootstrapping of an orderer by the provisional bootstrapper.
type Orderer struct {
	OrdererType   string             `yaml:"OrdererType"`
	Addresses     []string           `yaml:"Addresses"`
	BatchTimeout  time.Duration      `yaml:"BatchTimeout"`
	BatchSize     BatchSize          `yaml:"BatchSize"`
	Kafka         Kafka              `yaml:"Kafka"`
	EtcdRaft      *etcdraft.Metadata `yaml:"EtcdRaft"`
	Organizations []*Organization    `yaml:"Organizations"`
	MaxChannels   uint64             `yaml:"MaxChannels"`
	Capabilities  map[string]bool    `yaml:"Capabilities"`
	Policies      map[string]*Policy `yaml:"Policies"`
}

// BatchSize contains configuration affecting the size of batches.
type BatchSize struct {
	MaxMessageCount   uint32 `yaml:"MaxMessageCount"`
	AbsoluteMaxBytes  uint32 `yaml:"AbsoluteMaxBytes"`
	PreferredMaxBytes uint32 `yaml:"PreferredMaxBytes"`
}

// Kafka contains configuration for the Kafka-based orderer.
type Kafka struct {
	Brokers []string `yaml:"Brokers"`
}

var genesisDefaults = TopLevel{
	Orderer: &Orderer{
		OrdererType:  "solo",
		Addresses:    []string{"127.0.0.1:7050"},
		BatchTimeout: 2 * time.Second,
		BatchSize: BatchSize{
			MaxMessageCount:   10,
			AbsoluteMaxBytes:  10 * 1024 * 1024,
			PreferredMaxBytes: 512 * 1024,
		},
		Kafka: Kafka{
			Brokers: []string{"127.0.0.1:9092"},
		},
		EtcdRaft: &etcdraft.Metadata{
			Options: &etcdraft.Options{
				TickInterval:    100,
				ElectionTick:    10,
				HeartbeatTick:   1,
				MaxInflightMsgs: 256,
				MaxSizePerMsg:   1048576,
			},
		},
	},
}

// LoadTopLevel simply loads the configtx.yaml file into the structs above and
// completes their initialization. Config paths may optionally be provided and
// will be used in place of the FABRIC_CFG_PATH env variable.
//
// Note, for environment overrides to work properly within a profile, Load
// should be used instead.
func LoadTopLevel(configPaths ...string) *TopLevel {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[0], 1);
	config := viper.New()
	if len(configPaths) > 0 {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[4], 1);
		for _, p := range configPaths {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[6], 1);
			config.AddConfigPath(p)
		}
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[5], 1);config.SetConfigName(configName)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[7], 1);{
		cf.InitViper(config, configName)
	}}

	// For environment variables
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[1], 1);config.SetEnvPrefix(Prefix)
	config.AutomaticEnv()

	replacer := strings.NewReplacer(".", "_")
	config.SetEnvKeyReplacer(replacer)

	err := config.ReadInConfig()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[8], 1);
		logger.Panic("Error reading configuration: ", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[2], 1);logger.Debugf("Using config file: %s", config.ConfigFileUsed())

	var uconf TopLevel
	err = viperutil.EnhancedExactUnmarshal(config, &uconf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[9], 1);
		logger.Panic("Error unmarshaling config into struct: ", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[3], 1);(&uconf).completeInitialization(filepath.Dir(config.ConfigFileUsed()))

	logger.Infof("Loaded configuration: %s", config.ConfigFileUsed())

	return &uconf
}

// Load returns the orderer/application config combination that corresponds to
// a given profile. Config paths may optionally be provided and will be used
// in place of the FABRIC_CFG_PATH env variable.
func Load(profile string, configPaths ...string) *Profile {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[10], 1);
	config := viper.New()
	if len(configPaths) > 0 {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[15], 1);
		for _, p := range configPaths {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[17], 1);
			config.AddConfigPath(p)
		}
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[16], 1);config.SetConfigName(configName)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[18], 1);{
		cf.InitViper(config, configName)
	}}

	// For environment variables
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[11], 1);config.SetEnvPrefix(Prefix)
	config.AutomaticEnv()

	// This replacer allows substitution within the particular profile without
	// having to fully qualify the name
	replacer := strings.NewReplacer(strings.ToUpper(fmt.Sprintf("profiles.%s.", profile)), "", ".", "_")
	config.SetEnvKeyReplacer(replacer)

	err := config.ReadInConfig()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[19], 1);
		logger.Panic("Error reading configuration: ", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[12], 1);logger.Debugf("Using config file: %s", config.ConfigFileUsed())

	var uconf TopLevel
	err = viperutil.EnhancedExactUnmarshal(config, &uconf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[20], 1);
		logger.Panic("Error unmarshaling config into struct: ", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[13], 1);result, ok := uconf.Profiles[profile]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[21], 1);
		logger.Panic("Could not find profile: ", profile)
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[14], 1);result.completeInitialization(filepath.Dir(config.ConfigFileUsed()))

	logger.Infof("Loaded configuration: %s", config.ConfigFileUsed())

	return result
}

func (t *TopLevel) completeInitialization(configDir string) {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[22], 1);
	for _, org := range t.Organizations {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[24], 1);
		org.completeInitialization(configDir)
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[23], 1);if t.Orderer != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[25], 1);
		t.Orderer.completeInitialization(configDir)
	}
}

func (p *Profile) completeInitialization(configDir string) {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[26], 1);
	if p.Application != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[29], 1);
		for _, org := range p.Application.Organizations {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[31], 1);
			org.completeInitialization(configDir)
		}
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[30], 1);if p.Application.Resources != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[32], 1);
			p.Application.Resources.completeInitialization()
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[27], 1);if p.Consortiums != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[33], 1);
		for _, consortium := range p.Consortiums {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[34], 1);
			for _, org := range consortium.Organizations {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[35], 1);
				org.completeInitialization(configDir)
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[28], 1);if p.Orderer != nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[36], 1);
		for _, org := range p.Orderer.Organizations {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[38], 1);
			org.completeInitialization(configDir)
		}
		// Some profiles will not define orderer parameters
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[37], 1);p.Orderer.completeInitialization(configDir)
	}
}

func (r *Resources) completeInitialization() {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[39], 1);
	for {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[40], 1);
		switch {
		case r.DefaultModPolicy == "":_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[41], 1);
			r.DefaultModPolicy = policies.ChannelApplicationAdmins
		default:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[42], 1);
			return
		}
	}
}

func (org *Organization) completeInitialization(configDir string) {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[43], 1);
	// set the MSP type; if none is specified we assume BCCSP
	if org.MSPType == "" {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[46], 1);
		org.MSPType = msp.ProviderTypeToString(msp.FABRIC)
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[44], 1);if org.AdminPrincipal == "" {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[47], 1);
		org.AdminPrincipal = AdminRoleAdminPrincipal
	}
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[45], 1);translatePaths(configDir, org)
}

func (ord *Orderer) completeInitialization(configDir string) {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[48], 1);
loop:
	for {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[50], 1);
		switch {
		case ord.OrdererType == "":_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[51], 1);
			logger.Infof("Orderer.OrdererType unset, setting to %v", genesisDefaults.Orderer.OrdererType)
			ord.OrdererType = genesisDefaults.Orderer.OrdererType
		case ord.Addresses == nil:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[52], 1);
			logger.Infof("Orderer.Addresses unset, setting to %s", genesisDefaults.Orderer.Addresses)
			ord.Addresses = genesisDefaults.Orderer.Addresses
		case ord.BatchTimeout == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[53], 1);
			logger.Infof("Orderer.BatchTimeout unset, setting to %s", genesisDefaults.Orderer.BatchTimeout)
			ord.BatchTimeout = genesisDefaults.Orderer.BatchTimeout
		case ord.BatchSize.MaxMessageCount == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[54], 1);
			logger.Infof("Orderer.BatchSize.MaxMessageCount unset, setting to %v", genesisDefaults.Orderer.BatchSize.MaxMessageCount)
			ord.BatchSize.MaxMessageCount = genesisDefaults.Orderer.BatchSize.MaxMessageCount
		case ord.BatchSize.AbsoluteMaxBytes == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[55], 1);
			logger.Infof("Orderer.BatchSize.AbsoluteMaxBytes unset, setting to %v", genesisDefaults.Orderer.BatchSize.AbsoluteMaxBytes)
			ord.BatchSize.AbsoluteMaxBytes = genesisDefaults.Orderer.BatchSize.AbsoluteMaxBytes
		case ord.BatchSize.PreferredMaxBytes == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[56], 1);
			logger.Infof("Orderer.BatchSize.PreferredMaxBytes unset, setting to %v", genesisDefaults.Orderer.BatchSize.PreferredMaxBytes)
			ord.BatchSize.PreferredMaxBytes = genesisDefaults.Orderer.BatchSize.PreferredMaxBytes
		default:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[57], 1);
			break loop
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[49], 1);logger.Infof("orderer type: %s", ord.OrdererType)
	// Additional, consensus type-dependent initialization goes here
	// Also using this to panic on unknown orderer type.
	switch ord.OrdererType {
	case "solo":_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[58], 1);
		// nothing to be done here
	case "kafka":_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[59], 1);
		if ord.Kafka.Brokers == nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[66], 1);
			logger.Infof("Orderer.Kafka unset, setting to %v", genesisDefaults.Orderer.Kafka.Brokers)
			ord.Kafka.Brokers = genesisDefaults.Orderer.Kafka.Brokers
		}
	case etcdraft.TypeKey:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[60], 1);
		if ord.EtcdRaft == nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[67], 1);
			logger.Panicf("%s raft configuration missing", etcdraft.TypeKey)
		}
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[61], 1);if ord.EtcdRaft.Options == nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[68], 1);
			logger.Infof("Orderer.EtcdRaft.Options unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options)
			ord.EtcdRaft.Options = genesisDefaults.Orderer.EtcdRaft.Options
		}
	_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[62], 1);second_loop:
		for {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[69], 1);
			switch {
			case ord.EtcdRaft.Options.TickInterval == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[70], 1);
				logger.Infof("Orderer.EtcdRaft.Options.TickInterval unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options.TickInterval)
				ord.EtcdRaft.Options.TickInterval = genesisDefaults.Orderer.EtcdRaft.Options.TickInterval

			case ord.EtcdRaft.Options.ElectionTick == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[71], 1);
				logger.Infof("Orderer.EtcdRaft.Options.ElectionTick unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options.ElectionTick)
				ord.EtcdRaft.Options.ElectionTick = genesisDefaults.Orderer.EtcdRaft.Options.ElectionTick

			case ord.EtcdRaft.Options.HeartbeatTick == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[72], 1);
				logger.Infof("Orderer.EtcdRaft.Options.HeartbeatTick unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options.HeartbeatTick)
				ord.EtcdRaft.Options.HeartbeatTick = genesisDefaults.Orderer.EtcdRaft.Options.HeartbeatTick

			case ord.EtcdRaft.Options.MaxInflightMsgs == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[73], 1);
				logger.Infof("Orderer.EtcdRaft.Options.MaxInflightMsgs unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options.MaxInflightMsgs)
				ord.EtcdRaft.Options.MaxInflightMsgs = genesisDefaults.Orderer.EtcdRaft.Options.MaxInflightMsgs

			case ord.EtcdRaft.Options.MaxSizePerMsg == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[74], 1);
				logger.Infof("Orderer.EtcdRaft.Options.MaxSizePerMsg unset, setting to %v", genesisDefaults.Orderer.EtcdRaft.Options.MaxSizePerMsg)
				ord.EtcdRaft.Options.MaxSizePerMsg = genesisDefaults.Orderer.EtcdRaft.Options.MaxSizePerMsg

			case len(ord.EtcdRaft.Consenters) == 0:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[75], 1);
				logger.Panicf("%s configuration did not specify any consenter", etcdraft.TypeKey)

			default:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[76], 1);
				break second_loop
			}
		}

		// validate the specified members for Options
		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[63], 1);if ord.EtcdRaft.Options.ElectionTick <= ord.EtcdRaft.Options.HeartbeatTick {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[77], 1);
			logger.Panicf("election tick must be greater than heartbeat tick")
		}

		_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[64], 1);for _, c := range ord.EtcdRaft.GetConsenters() {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[78], 1);
			if c.Host == "" {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[83], 1);
				logger.Panicf("consenter info in %s configuration did not specify host", etcdraft.TypeKey)
			}
			_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[79], 1);if c.Port == 0 {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[84], 1);
				logger.Panicf("consenter info in %s configuration did not specify port", etcdraft.TypeKey)
			}
			_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[80], 1);if c.ClientTlsCert == nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[85], 1);
				logger.Panicf("consenter info in %s configuration did not specify client TLS cert", etcdraft.TypeKey)
			}
			_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[81], 1);if c.ServerTlsCert == nil {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[86], 1);
				logger.Panicf("consenter info in %s configuration did not specify server TLS cert", etcdraft.TypeKey)
			}
			_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[82], 1);clientCertPath := string(c.GetClientTlsCert())
			cf.TranslatePathInPlace(configDir, &clientCertPath)
			c.ClientTlsCert = []byte(clientCertPath)
			serverCertPath := string(c.GetServerTlsCert())
			cf.TranslatePathInPlace(configDir, &serverCertPath)
			c.ServerTlsCert = []byte(serverCertPath)
		}
	default:_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[65], 1);
		logger.Panicf("unknown orderer type: %s", ord.OrdererType)
	}
}

func translatePaths(configDir string, org *Organization) {_cover_atomic_.AddUint32(&GoCover_0_393438663631623561366663.Count[87], 1);
	cf.TranslatePathInPlace(configDir, &org.MSPDir)
}

var GoCover_0_393438663631623561366663 = struct {
	Count     [88]uint32
	Pos       [3 * 88]uint32
	NumStmt   [88]uint16
} {
	Pos: [3 * 88]uint32{
		213, 215, 0x1a0034, // [0]
		225, 232, 0x100002, // [1]
		235, 239, 0x100002, // [2]
		243, 247, 0xf0002, // [3]
		215, 216, 0x21001a, // [4]
		219, 219, 0x230003, // [5]
		216, 218, 0x40021, // [6]
		220, 222, 0x30008, // [7]
		232, 234, 0x30010, // [8]
		239, 241, 0x30010, // [9]
		253, 255, 0x1a003b, // [10]
		265, 274, 0x100002, // [11]
		277, 281, 0x100002, // [12]
		285, 286, 0x90002, // [13]
		290, 294, 0xf0002, // [14]
		255, 256, 0x21001a, // [15]
		259, 259, 0x230003, // [16]
		256, 258, 0x40021, // [17]
		260, 262, 0x30008, // [18]
		274, 276, 0x30010, // [19]
		281, 283, 0x30010, // [20]
		286, 288, 0x30009, // [21]
		297, 298, 0x26003d, // [22]
		302, 302, 0x160002, // [23]
		298, 300, 0x30026, // [24]
		302, 304, 0x30016, // [25]
		307, 308, 0x1a003c, // [26]
		317, 317, 0x1a0002, // [27]
		325, 325, 0x160002, // [28]
		308, 309, 0x33001a, // [29]
		312, 312, 0x250003, // [30]
		309, 311, 0x40033, // [31]
		312, 314, 0x40025, // [32]
		317, 318, 0x2c001a, // [33]
		318, 319, 0x31002c, // [34]
		319, 321, 0x50031, // [35]
		325, 326, 0x2f0016, // [36]
		330, 330, 0x2e0003, // [37]
		326, 328, 0x4002f, // [38]
		334, 335, 0x6002e, // [39]
		335, 336, 0xa0006, // [40]
		337, 338, 0x3a0021, // [41]
		339, 340, 0xa000b, // [42]
		345, 347, 0x170043, // [43]
		351, 351, 0x1e0002, // [44]
		354, 354, 0x200002, // [45]
		347, 349, 0x30017, // [46]
		351, 353, 0x3001e, // [47]
		357, 359, 0x6003e, // [48]
		384, 387, 0x190002, // [49]
		359, 360, 0xa0006, // [50]
		361, 363, 0x39001e, // [51]
		364, 366, 0x35001d, // [52]
		367, 369, 0x3b001e, // [53]
		370, 372, 0x55002b, // [54]
		373, 375, 0x57002c, // [55]
		376, 378, 0x59002d, // [56]
		379, 380, 0xe000b, // [57]
		388, 388, 0xe000e, // [58]
		390, 391, 0x1f000f, // [59]
		395, 396, 0x1a0018, // [60]
		399, 399, 0x220003, // [61]
		403, 404, 0x70002, // [62]
		435, 435, 0x4e0003, // [63]
		439, 439, 0x320003, // [64]
		459, 460, 0x3d000a, // [65]
		391, 394, 0x4001f, // [66]
		396, 398, 0x4001a, // [67]
		399, 402, 0x40022, // [68]
		404, 405, 0xb0007, // [69]
		406, 408, 0x5e0030, // [70]
		410, 412, 0x5e0030, // [71]
		414, 416, 0x600031, // [72]
		418, 420, 0x640033, // [73]
		422, 424, 0x600031, // [74]
		426, 427, 0x56002b, // [75]
		429, 430, 0x16000c, // [76]
		435, 437, 0x4004e, // [77]
		439, 440, 0x140032, // [78]
		443, 443, 0x130004, // [79]
		446, 446, 0x1e0004, // [80]
		449, 449, 0x1e0004, // [81]
		452, 457, 0x2c0004, // [82]
		440, 442, 0x50014, // [83]
		443, 445, 0x50013, // [84]
		446, 448, 0x5001e, // [85]
		449, 451, 0x5001e, // [86]
		464, 466, 0x2003a, // [87]
	},
	NumStmt: [88]uint16{
		2, // 0
		6, // 1
		4, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		6, // 11
		4, // 12
		2, // 13
		3, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		1, // 50
		2, // 51
		2, // 52
		2, // 53
		2, // 54
		2, // 55
		2, // 56
		1, // 57
		0, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		2, // 66
		1, // 67
		2, // 68
		1, // 69
		2, // 70
		2, // 71
		2, // 72
		2, // 73
		2, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		6, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		1, // 87
	},
}
var _ = _cover_atomic_.LoadUint32
