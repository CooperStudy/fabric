//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/pvtdatastorage/kv_encoding.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package pvtdatastorage; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"math"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
	"github.com/pkg/errors"
	"github.com/willf/bitset"
)

var (
	pendingCommitKey               = []byte{0}
	lastCommittedBlkkey            = []byte{1}
	pvtDataKeyPrefix               = []byte{2}
	expiryKeyPrefix                = []byte{3}
	eligibleMissingDataKeyPrefix   = []byte{4}
	ineligibleMissingDataKeyPrefix = []byte{5}
	collElgKeyPrefix               = []byte{6}
	lastUpdatedOldBlocksKey        = []byte{7}

	nilByte    = byte(0)
	emptyValue = []byte{}
)

func getDataKeysForRangeScanByBlockNum(blockNum uint64) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[0], 1);
	startKey = append(pvtDataKeyPrefix, version.NewHeight(blockNum, 0).ToBytes()...)
	endKey = append(pvtDataKeyPrefix, version.NewHeight(blockNum+1, 0).ToBytes()...)
	return
}

func getExpiryKeysForRangeScan(minBlkNum, maxBlkNum uint64) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[1], 1);
	startKey = append(expiryKeyPrefix, version.NewHeight(minBlkNum, 0).ToBytes()...)
	endKey = append(expiryKeyPrefix, version.NewHeight(maxBlkNum+1, 0).ToBytes()...)
	return
}

func encodeLastCommittedBlockVal(blockNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[2], 1);
	return proto.EncodeVarint(blockNum)
}

func decodeLastCommittedBlockVal(blockNumBytes []byte) uint64 {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[3], 1);
	s, _ := proto.DecodeVarint(blockNumBytes)
	return s
}

func encodeDataKey(key *dataKey) []byte {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[4], 1);
	dataKeyBytes := append(pvtDataKeyPrefix, version.NewHeight(key.blkNum, key.txNum).ToBytes()...)
	dataKeyBytes = append(dataKeyBytes, []byte(key.ns)...)
	dataKeyBytes = append(dataKeyBytes, nilByte)
	return append(dataKeyBytes, []byte(key.coll)...)
}

func encodeDataValue(collData *rwset.CollectionPvtReadWriteSet) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[5], 1);
	return proto.Marshal(collData)
}

func encodeExpiryKey(expiryKey *expiryKey) []byte {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[6], 1);
	// reusing version encoding scheme here
	return append(expiryKeyPrefix, version.NewHeight(expiryKey.expiringBlk, expiryKey.committingBlk).ToBytes()...)
}

func encodeExpiryValue(expiryData *ExpiryData) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[7], 1);
	return proto.Marshal(expiryData)
}

func decodeExpiryKey(expiryKeyBytes []byte) *expiryKey {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[8], 1);
	height, _ := version.NewHeightFromBytes(expiryKeyBytes[1:])
	return &expiryKey{expiringBlk: height.BlockNum, committingBlk: height.TxNum}
}

func decodeExpiryValue(expiryValueBytes []byte) (*ExpiryData, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[9], 1);
	expiryData := &ExpiryData{}
	err := proto.Unmarshal(expiryValueBytes, expiryData)
	return expiryData, err
}

func decodeDatakey(datakeyBytes []byte) *dataKey {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[10], 1);
	v, n := version.NewHeightFromBytes(datakeyBytes[1:])
	blkNum := v.BlockNum
	tranNum := v.TxNum
	remainingBytes := datakeyBytes[n+1:]
	nilByteIndex := bytes.IndexByte(remainingBytes, nilByte)
	ns := string(remainingBytes[:nilByteIndex])
	coll := string(remainingBytes[nilByteIndex+1:])
	return &dataKey{nsCollBlk{ns, coll, blkNum}, tranNum}
}

func decodeDataValue(datavalueBytes []byte) (*rwset.CollectionPvtReadWriteSet, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[11], 1);
	collPvtdata := &rwset.CollectionPvtReadWriteSet{}
	err := proto.Unmarshal(datavalueBytes, collPvtdata)
	return collPvtdata, err
}

func encodeMissingDataKey(key *missingDataKey) []byte {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[12], 1);
	if key.isEligible {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[14], 1);
		keyBytes := append(eligibleMissingDataKeyPrefix, util.EncodeReverseOrderVarUint64(key.blkNum)...)
		keyBytes = append(keyBytes, []byte(key.ns)...)
		keyBytes = append(keyBytes, nilByte)
		return append(keyBytes, []byte(key.coll)...)
	}

	_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[13], 1);keyBytes := append(ineligibleMissingDataKeyPrefix, []byte(key.ns)...)
	keyBytes = append(keyBytes, nilByte)
	keyBytes = append(keyBytes, []byte(key.coll)...)
	keyBytes = append(keyBytes, nilByte)
	return append(keyBytes, []byte(util.EncodeReverseOrderVarUint64(key.blkNum))...)
}

func decodeMissingDataKey(keyBytes []byte) *missingDataKey {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[15], 1);
	key := &missingDataKey{nsCollBlk: nsCollBlk{}}
	if keyBytes[0] == eligibleMissingDataKeyPrefix[0] {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[17], 1);
		blkNum, numBytesConsumed := util.DecodeReverseOrderVarUint64(keyBytes[1:])

		splittedKey := bytes.Split(keyBytes[numBytesConsumed+1:], []byte{nilByte})
		key.ns = string(splittedKey[0])
		key.coll = string(splittedKey[1])
		key.blkNum = blkNum
		key.isEligible = true
		return key
	}

	_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[16], 1);splittedKey := bytes.SplitN(keyBytes[1:], []byte{nilByte}, 3) //encoded bytes for blknum may contain empty bytes
	key.ns = string(splittedKey[0])
	key.coll = string(splittedKey[1])
	key.blkNum, _ = util.DecodeReverseOrderVarUint64(splittedKey[2])
	key.isEligible = false
	return key
}

func encodeMissingDataValue(bitmap *bitset.BitSet) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[18], 1);
	return bitmap.MarshalBinary()
}

func decodeMissingDataValue(bitmapBytes []byte) (*bitset.BitSet, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[19], 1);
	bitmap := &bitset.BitSet{}
	if err := bitmap.UnmarshalBinary(bitmapBytes); err != nil {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[21], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[20], 1);return bitmap, nil
}

func encodeCollElgKey(blkNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[22], 1);
	return append(collElgKeyPrefix, util.EncodeReverseOrderVarUint64(blkNum)...)
}

func decodeCollElgKey(b []byte) uint64 {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[23], 1);
	blkNum, _ := util.DecodeReverseOrderVarUint64(b[1:])
	return blkNum
}

func encodeCollElgVal(m *CollElgInfo) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[24], 1);
	return proto.Marshal(m)
}

func decodeCollElgVal(b []byte) (*CollElgInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[25], 1);
	m := &CollElgInfo{}
	if err := proto.Unmarshal(b, m); err != nil {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[27], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[26], 1);return m, nil
}

func createRangeScanKeysForEligibleMissingDataEntries(blkNum uint64) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[28], 1);
	startKey = append(eligibleMissingDataKeyPrefix, util.EncodeReverseOrderVarUint64(blkNum)...)
	endKey = append(eligibleMissingDataKeyPrefix, util.EncodeReverseOrderVarUint64(0)...)

	return startKey, endKey
}

func createRangeScanKeysForIneligibleMissingData(maxBlkNum uint64, ns, coll string) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[29], 1);
	startKey = encodeMissingDataKey(
		&missingDataKey{
			nsCollBlk:  nsCollBlk{ns: ns, coll: coll, blkNum: maxBlkNum},
			isEligible: false,
		},
	)
	endKey = encodeMissingDataKey(
		&missingDataKey{
			nsCollBlk:  nsCollBlk{ns: ns, coll: coll, blkNum: 0},
			isEligible: false,
		},
	)
	return
}

func createRangeScanKeysForCollElg() (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[30], 1);
	return encodeCollElgKey(math.MaxUint64),
		encodeCollElgKey(0)
}

func datakeyRange(blockNum uint64) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[31], 1);
	startKey = append(pvtDataKeyPrefix, version.NewHeight(blockNum, 0).ToBytes()...)
	endKey = append(pvtDataKeyPrefix, version.NewHeight(blockNum, math.MaxUint64).ToBytes()...)
	return
}

func eligibleMissingdatakeyRange(blkNum uint64) (startKey, endKey []byte) {_cover_atomic_.AddUint32(&GoCover_1_653833333066373334656466.Count[32], 1);
	startKey = append(eligibleMissingDataKeyPrefix, util.EncodeReverseOrderVarUint64(blkNum)...)
	endKey = append(eligibleMissingDataKeyPrefix, util.EncodeReverseOrderVarUint64(blkNum-1)...)
	return
}

var GoCover_1_653833333066373334656466 = struct {
	Count     [33]uint32
	Pos       [3 * 33]uint32
	NumStmt   [33]uint16
} {
	Pos: [3 * 33]uint32{
		35, 39, 0x20053, // [0]
		41, 45, 0x20057, // [1]
		47, 49, 0x2003a, // [2]
		51, 54, 0x2003f, // [3]
		56, 61, 0x20029, // [4]
		63, 65, 0x20051, // [5]
		67, 70, 0x20033, // [6]
		72, 74, 0x20040, // [7]
		76, 79, 0x20038, // [8]
		81, 85, 0x20046, // [9]
		87, 96, 0x20032, // [10]
		98, 102, 0x20057, // [11]
		104, 105, 0x140037, // [12]
		112, 116, 0x520002, // [13]
		105, 110, 0x30014, // [14]
		119, 121, 0x34003c, // [15]
		132, 137, 0xc0002, // [16]
		121, 130, 0x30034, // [17]
		140, 142, 0x20044, // [18]
		144, 146, 0x3c0049, // [19]
		149, 149, 0x140002, // [20]
		146, 148, 0x3003c, // [21]
		152, 154, 0x2002d, // [22]
		156, 159, 0x20028, // [23]
		161, 163, 0x20037, // [24]
		165, 167, 0x2e0037, // [25]
		170, 170, 0xf0002, // [26]
		167, 169, 0x3002e, // [27]
		173, 178, 0x20060, // [28]
		180, 194, 0x2006f, // [29]
		196, 199, 0x20040, // [30]
		201, 205, 0x2003e, // [31]
		207, 211, 0x2004b, // [32]
	},
	NumStmt: [33]uint16{
		3, // 0
		3, // 1
		1, // 2
		2, // 3
		4, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		3, // 9
		8, // 10
		3, // 11
		1, // 12
		5, // 13
		4, // 14
		2, // 15
		6, // 16
		7, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		3, // 28
		3, // 29
		1, // 30
		3, // 31
		3, // 32
	},
}
var _ = _cover_atomic_.LoadUint32
