//line /home/cooper/go/src/github.com/hyperledger/fabric/core/committer/txvalidator/plugin_validator.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package txvalidator; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/common/cauthdsl"
	ledger2 "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/core/handlers/validation/api"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/capabilities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/identities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/state"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

// MapBasedPluginMapper maps plugin names to their corresponding factories
type MapBasedPluginMapper map[string]validation.PluginFactory

// PluginFactoryByName returns a plugin factory for the given plugin name, or nil if not found
func (m MapBasedPluginMapper) PluginFactoryByName(name PluginName) validation.PluginFactory {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[0], 1);
	return m[string(name)]
}

//go:generate mockery -dir . -name PluginMapper -case underscore -output mocks/
//go:generate mockery -dir ../../handlers/validation/api/ -name PluginFactory -case underscore -output mocks/
//go:generate mockery -dir ../../handlers/validation/api/ -name Plugin -case underscore -output mocks/

// PluginMapper maps plugin names to their corresponding factory instance.
// Returns nil if the name isn't associated to any plugin.
type PluginMapper interface {
	PluginFactoryByName(name PluginName) validation.PluginFactory
}

//go:generate mockery -dir . -name QueryExecutorCreator -case underscore -output mocks/

// QueryExecutorCreator creates new query executors
type QueryExecutorCreator interface {
	NewQueryExecutor() (ledger.QueryExecutor, error)
}

// Context defines information about a transaction
// that is being validated
type Context struct {
	Seq       int
	Envelope  []byte
	TxID      string
	Channel   string
	VSCCName  string
	Policy    []byte
	Namespace string
	Block     *common.Block
}

// String returns a string representation of this Context
func (c Context) String() string {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[1], 1);
	return fmt.Sprintf("Tx %s, seq %d out of %d in block %d for channel %s with validation plugin %s", c.TxID, c.Seq, len(c.Block.Data.Data), c.Block.Header.Number, c.Channel, c.VSCCName)
}

// PluginValidator values transactions with validation plugins
type PluginValidator struct {
	sync.Mutex
	pluginChannelMapping map[PluginName]*pluginsByChannel
	PluginMapper
	QueryExecutorCreator
	msp.IdentityDeserializer
	capabilities Capabilities
}

//go:generate mockery -dir ../../handlers/validation/api/capabilities/ -name Capabilities -case underscore -output mocks/
//go:generate mockery -dir ../../../msp/ -name IdentityDeserializer -case underscore -output mocks/

// NewPluginValidator creates a new PluginValidator
func NewPluginValidator(pm PluginMapper, qec QueryExecutorCreator, deserializer msp.IdentityDeserializer, capabilities Capabilities) *PluginValidator {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[2], 1);
	return &PluginValidator{
		capabilities:         capabilities,
		pluginChannelMapping: make(map[PluginName]*pluginsByChannel),
		PluginMapper:         pm,
		QueryExecutorCreator: qec,
		IdentityDeserializer: deserializer,
	}
}

func (pv *PluginValidator) ValidateWithPlugin(ctx *Context) error {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[3], 1);
	plugin, err := pv.getOrCreatePlugin(ctx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[6], 1);
		return &validation.ExecutionFailureError{
			Reason: fmt.Sprintf("plugin with name %s couldn't be used: %v", ctx.VSCCName, err),
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[4], 1);err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, 0, SerializedPolicy(ctx.Policy))
	validityStatus := "valid"
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[7], 1);
		validityStatus = fmt.Sprintf("invalid: %v", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[5], 1);logger.Debug("Transaction", ctx.TxID, "appears to be", validityStatus)
	return err
}

func (pv *PluginValidator) getOrCreatePlugin(ctx *Context) (validation.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[8], 1);
	pluginFactory := pv.PluginFactoryByName(PluginName(ctx.VSCCName))
	if pluginFactory == nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[10], 1);
		return nil, errors.Errorf("plugin with name %s wasn't found", ctx.VSCCName)
	}

	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[9], 1);pluginsByChannel := pv.getOrCreatePluginChannelMapping(PluginName(ctx.VSCCName), pluginFactory)
	return pluginsByChannel.createPluginIfAbsent(ctx.Channel)

}

func (pv *PluginValidator) getOrCreatePluginChannelMapping(plugin PluginName, pf validation.PluginFactory) *pluginsByChannel {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[11], 1);
	pv.Lock()
	defer pv.Unlock()
	endorserChannelMapping, exists := pv.pluginChannelMapping[PluginName(plugin)]
	if !exists {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[13], 1);
		endorserChannelMapping = &pluginsByChannel{
			pluginFactory:    pf,
			channels2Plugins: make(map[string]validation.Plugin),
			pv:               pv,
		}
		pv.pluginChannelMapping[PluginName(plugin)] = endorserChannelMapping
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[12], 1);return endorserChannelMapping
}

// PluginName defines the name of the plugin as it appears in the configuration
type PluginName string

type pluginsByChannel struct {
	sync.RWMutex
	pluginFactory    validation.PluginFactory
	channels2Plugins map[string]validation.Plugin
	pv               *PluginValidator
}

func (pbc *pluginsByChannel) createPluginIfAbsent(channel string) (validation.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[14], 1);
	pbc.RLock()
	plugin, exists := pbc.channels2Plugins[channel]
	pbc.RUnlock()
	if exists {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[18], 1);
		return plugin, nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[15], 1);pbc.Lock()
	defer pbc.Unlock()
	plugin, exists = pbc.channels2Plugins[channel]
	if exists {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[19], 1);
		return plugin, nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[16], 1);pluginInstance := pbc.pluginFactory.New()
	plugin, err := pbc.initPlugin(pluginInstance, channel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[20], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[17], 1);pbc.channels2Plugins[channel] = plugin
	return plugin, nil
}

func (pbc *pluginsByChannel) initPlugin(plugin validation.Plugin, channel string) (validation.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[21], 1);
	pe := &PolicyEvaluator{IdentityDeserializer: pbc.pv.IdentityDeserializer}
	sf := &StateFetcherImpl{QueryExecutorCreator: pbc.pv}
	if err := plugin.Init(pe, sf, pbc.pv.capabilities); err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[23], 1);
		return nil, errors.Wrap(err, "failed initializing plugin")
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[22], 1);return plugin, nil
}

type PolicyEvaluator struct {
	msp.IdentityDeserializer
}

// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy
func (id *PolicyEvaluator) Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[24], 1);
	pp := cauthdsl.NewPolicyProvider(id.IdentityDeserializer)
	policy, _, err := pp.NewPolicy(policyBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[26], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[25], 1);return policy.Evaluate(signatureSet)
}

// DeserializeIdentity unmarshals the given identity to msp.Identity
func (id *PolicyEvaluator) DeserializeIdentity(serializedIdentity []byte) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[27], 1);
	mspIdentity, err := id.IdentityDeserializer.DeserializeIdentity(serializedIdentity)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[29], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[28], 1);return &identity{Identity: mspIdentity}, nil
}

type identity struct {
	msp.Identity
}

func (i *identity) GetIdentityIdentifier() *IdentityIdentifier {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[30], 1);
	identifier := i.Identity.GetIdentifier()
	return &IdentityIdentifier{
		Id:    identifier.Id,
		Mspid: identifier.Mspid,
	}
}

type StateFetcherImpl struct {
	QueryExecutorCreator
}

func (sf *StateFetcherImpl) FetchState() (State, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[31], 1);
	qe, err := sf.NewQueryExecutor()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[33], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[32], 1);return &StateImpl{qe}, nil
}

type StateImpl struct {
	ledger.QueryExecutor
}

func (s *StateImpl) GetStateRangeScanIterator(namespace string, startKey string, endKey string) (ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[34], 1);
	it, err := s.QueryExecutor.GetStateRangeScanIterator(namespace, startKey, endKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[36], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[35], 1);return &ResultsIteratorImpl{ResultsIterator: it}, nil
}

type ResultsIteratorImpl struct {
	ledger2.ResultsIterator
}

func (it *ResultsIteratorImpl) Next() (QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[37], 1);
	return it.ResultsIterator.Next()
}

// SerializedPolicy defines a marshaled policy
type SerializedPolicy []byte

// Bytes returns te bytes of the SerializedPolicy
func (sp SerializedPolicy) Bytes() []byte {_cover_atomic_.AddUint32(&GoCover_0_653337613337663834376338.Count[38], 1);
	return sp
}

var GoCover_0_653337613337663834376338 = struct {
	Count     [39]uint32
	Pos       [3 * 39]uint32
	NumStmt   [39]uint16
} {
	Pos: [3 * 39]uint32{
		29, 31, 0x2005d, // [0]
		64, 66, 0x20022, // [1]
		82, 90, 0x20097, // [2]
		92, 94, 0x100043, // [3]
		99, 101, 0x100002, // [4]
		104, 105, 0xc0002, // [5]
		94, 98, 0x30010, // [6]
		101, 103, 0x30010, // [7]
		108, 110, 0x1a0057, // [8]
		114, 115, 0x3b0002, // [9]
		110, 112, 0x3001a, // [10]
		119, 123, 0xd007e, // [11]
		131, 131, 0x1f0002, // [12]
		123, 130, 0x3000d, // [13]
		144, 148, 0xc005e, // [14]
		152, 155, 0xc0002, // [15]
		159, 161, 0x100002, // [16]
		164, 165, 0x140002, // [17]
		148, 150, 0x3000c, // [18]
		155, 157, 0x3000c, // [19]
		161, 163, 0x30010, // [20]
		168, 171, 0x41006e, // [21]
		174, 174, 0x140002, // [22]
		171, 173, 0x30041, // [23]
		182, 185, 0x100062, // [24]
		188, 188, 0x260002, // [25]
		185, 187, 0x30010, // [26]
		192, 194, 0x10005d, // [27]
		197, 197, 0x2e0002, // [28]
		194, 196, 0x30010, // [29]
		204, 210, 0x20040, // [30]
		216, 218, 0x100039, // [31]
		221, 221, 0x1c0002, // [32]
		218, 220, 0x30010, // [33]
		228, 230, 0x10007a, // [34]
		233, 233, 0x370002, // [35]
		230, 232, 0x30010, // [36]
		240, 242, 0x2003c, // [37]
		248, 250, 0x2002b, // [38]
	},
	NumStmt: [39]uint16{
		1, // 0
		1, // 1
		1, // 2
		2, // 3
		3, // 4
		2, // 5
		1, // 6
		1, // 7
		2, // 8
		2, // 9
		1, // 10
		4, // 11
		1, // 12
		2, // 13
		4, // 14
		4, // 15
		3, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		3, // 21
		1, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		2, // 30
		2, // 31
		1, // 32
		1, // 33
		2, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
	},
}
var _ = _cover_atomic_.LoadUint32
