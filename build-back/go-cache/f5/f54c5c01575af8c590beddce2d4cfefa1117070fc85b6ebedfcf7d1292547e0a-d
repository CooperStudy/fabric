//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/orderer.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hyperledger/fabric/common/capabilities"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/pkg/errors"
)

const (
	// OrdererGroupKey is the group name for the orderer config
	OrdererGroupKey = "Orderer"
)

const (
	// ConsensusTypeKey is the cb.ConfigItem type key name for the ConsensusType message
	ConsensusTypeKey = "ConsensusType"

	// BatchSizeKey is the cb.ConfigItem type key name for the BatchSize message
	BatchSizeKey = "BatchSize"

	// BatchTimeoutKey is the cb.ConfigItem type key name for the BatchTimeout message
	BatchTimeoutKey = "BatchTimeout"

	// ChannelRestrictionsKey is the key name for the ChannelRestrictions message
	ChannelRestrictionsKey = "ChannelRestrictions"

	// KafkaBrokersKey is the cb.ConfigItem type key name for the KafkaBrokers message
	KafkaBrokersKey = "KafkaBrokers"
)

// OrdererProtos is used as the source of the OrdererConfig
type OrdererProtos struct {
	ConsensusType       *ab.ConsensusType
	BatchSize           *ab.BatchSize
	BatchTimeout        *ab.BatchTimeout
	KafkaBrokers        *ab.KafkaBrokers
	ChannelRestrictions *ab.ChannelRestrictions
	Capabilities        *cb.Capabilities
}

// OrdererConfig holds the orderer configuration information
type OrdererConfig struct {
	protos *OrdererProtos
	orgs   map[string]Org

	batchTimeout time.Duration
}

// NewOrdererConfig creates a new instance of the orderer config
func NewOrdererConfig(ordererGroup *cb.ConfigGroup, mspConfig *MSPConfigHandler) (*OrdererConfig, error) {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[0], 1);
	oc := &OrdererConfig{
		protos: &OrdererProtos{},
		orgs:   make(map[string]Org),
	}

	if err := DeserializeProtoValuesFromGroup(ordererGroup, oc.protos); err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[4], 1);
		return nil, errors.Wrap(err, "failed to deserialize values")
	}

	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[1], 1);if err := oc.Validate(); err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[5], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[2], 1);for orgName, orgGroup := range ordererGroup.Groups {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[6], 1);
		var err error
		if oc.orgs[orgName], err = NewOrganizationConfig(orgName, orgGroup, mspConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[7], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[3], 1);return oc, nil
}

// ConsensusType returns the configured consensus type
func (oc *OrdererConfig) ConsensusType() string {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[8], 1);
	return oc.protos.ConsensusType.Type
}

// ConsensusMetadata returns the metadata associated with the consensus type.
func (oc *OrdererConfig) ConsensusMetadata() []byte {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[9], 1);
	return oc.protos.ConsensusType.Metadata
}

// BatchSize returns the maximum number of messages to include in a block
func (oc *OrdererConfig) BatchSize() *ab.BatchSize {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[10], 1);
	return oc.protos.BatchSize
}

// BatchTimeout returns the amount of time to wait before creating a batch
func (oc *OrdererConfig) BatchTimeout() time.Duration {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[11], 1);
	return oc.batchTimeout
}

// KafkaBrokers returns the addresses (IP:port notation) of a set of "bootstrap"
// Kafka brokers, i.e. this is not necessarily the entire set of Kafka brokers
// used for ordering
func (oc *OrdererConfig) KafkaBrokers() []string {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[12], 1);
	return oc.protos.KafkaBrokers.Brokers
}

// MaxChannelsCount returns the maximum count of channels this orderer supports
func (oc *OrdererConfig) MaxChannelsCount() uint64 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[13], 1);
	return oc.protos.ChannelRestrictions.MaxCount
}

// Organizations returns a map of the orgs in the channel
func (oc *OrdererConfig) Organizations() map[string]Org {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[14], 1);
	return oc.orgs
}

// Capabilities returns the capabilities the ordering network has for this channel
func (oc *OrdererConfig) Capabilities() OrdererCapabilities {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[15], 1);
	return capabilities.NewOrdererProvider(oc.protos.Capabilities.Capabilities)
}

func (oc *OrdererConfig) Validate() error {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[16], 1);
	for _, validator := range []func() error{
		oc.validateBatchSize,
		oc.validateBatchTimeout,
		oc.validateKafkaBrokers,
	} {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[18], 1);
		if err := validator(); err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[19], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[17], 1);return nil
}

func (oc *OrdererConfig) validateBatchSize() error {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[20], 1);
	if oc.protos.BatchSize.MaxMessageCount == 0 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[25], 1);
		return fmt.Errorf("Attempted to set the batch size max message count to an invalid value: 0")
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[21], 1);if oc.protos.BatchSize.AbsoluteMaxBytes == 0 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[26], 1);
		return fmt.Errorf("Attempted to set the batch size absolute max bytes to an invalid value: 0")
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[22], 1);if oc.protos.BatchSize.PreferredMaxBytes == 0 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[27], 1);
		return fmt.Errorf("Attempted to set the batch size preferred max bytes to an invalid value: 0")
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[23], 1);if oc.protos.BatchSize.PreferredMaxBytes > oc.protos.BatchSize.AbsoluteMaxBytes {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[28], 1);
		return fmt.Errorf("Attempted to set the batch size preferred max bytes (%v) greater than the absolute max bytes (%v).", oc.protos.BatchSize.PreferredMaxBytes, oc.protos.BatchSize.AbsoluteMaxBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[24], 1);return nil
}

func (oc *OrdererConfig) validateBatchTimeout() error {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[29], 1);
	var err error
	oc.batchTimeout, err = time.ParseDuration(oc.protos.BatchTimeout.Timeout)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[32], 1);
		return fmt.Errorf("Attempted to set the batch timeout to a invalid value: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[30], 1);if oc.batchTimeout <= 0 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[33], 1);
		return fmt.Errorf("Attempted to set the batch timeout to a non-positive value: %s", oc.batchTimeout)
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[31], 1);return nil
}

func (oc *OrdererConfig) validateKafkaBrokers() error {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[34], 1);
	for _, broker := range oc.protos.KafkaBrokers.Brokers {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[36], 1);
		if !brokerEntrySeemsValid(broker) {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[37], 1);
			return fmt.Errorf("Invalid broker entry: %s", broker)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[35], 1);return nil
}

// This does just a barebones sanity check.
func brokerEntrySeemsValid(broker string) bool {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[38], 1);
	if !strings.Contains(broker, ":") {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[42], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[39], 1);parts := strings.Split(broker, ":")
	if len(parts) > 2 {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[43], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[40], 1);host := parts[0]
	port := parts[1]

	if _, err := strconv.ParseUint(port, 10, 16); err != nil {_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[44], 1);
		return false
	}

	// Valid hostnames may contain only the ASCII letters 'a' through 'z' (in a
	// case-insensitive manner), the digits '0' through '9', and the hyphen. IP
	// v4 addresses are  represented in dot-decimal notation, which consists of
	// four decimal numbers, each ranging from 0 to 255, separated by dots,
	// e.g., 172.16.254.1
	// The following regular expression:
	// 1. allows just a-z (case-insensitive), 0-9, and the dot and hyphen characters
	// 2. does not allow leading trailing dots or hyphens
	_cover_atomic_.AddUint32(&GoCover_11_373339383034363064316135.Count[41], 1);re, _ := regexp.Compile("^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9])$")
	matched := re.FindString(host)
	return len(matched) == len(host)
}

var GoCover_11_373339383034363064316135 = struct {
	Count     [45]uint32
	Pos       [3 * 45]uint32
	NumStmt   [45]uint16
} {
	Pos: [3 * 45]uint32{
		63, 69, 0x51006a, // [0]
		73, 73, 0x260002, // [1]
		77, 77, 0x350002, // [2]
		83, 83, 0x100002, // [3]
		69, 71, 0x30051, // [4]
		73, 75, 0x30026, // [5]
		77, 79, 0x5e0035, // [6]
		79, 81, 0x4005e, // [7]
		87, 89, 0x20031, // [8]
		92, 94, 0x20035, // [9]
		97, 99, 0x20034, // [10]
		102, 104, 0x20037, // [11]
		109, 111, 0x20032, // [12]
		114, 116, 0x20034, // [13]
		119, 121, 0x20039, // [14]
		124, 126, 0x2003d, // [15]
		128, 133, 0x4002b, // [16]
		139, 139, 0xc0002, // [17]
		133, 134, 0x250004, // [18]
		134, 136, 0x40025, // [19]
		142, 143, 0x2e0034, // [20]
		146, 146, 0x2f0002, // [21]
		149, 149, 0x300002, // [22]
		152, 152, 0x520002, // [23]
		155, 155, 0xc0002, // [24]
		143, 145, 0x3002e, // [25]
		146, 148, 0x3002f, // [26]
		149, 151, 0x30030, // [27]
		152, 154, 0x30052, // [28]
		158, 161, 0x100037, // [29]
		164, 164, 0x1a0002, // [30]
		167, 167, 0xc0002, // [31]
		161, 163, 0x30010, // [32]
		164, 166, 0x3001a, // [33]
		170, 171, 0x380037, // [34]
		176, 176, 0xc0002, // [35]
		171, 172, 0x250038, // [36]
		172, 174, 0x40025, // [37]
		180, 181, 0x240030, // [38]
		185, 186, 0x140002, // [39]
		190, 193, 0x3b0002, // [40]
		205, 207, 0x220002, // [41]
		181, 183, 0x30024, // [42]
		186, 188, 0x30014, // [43]
		193, 195, 0x3003b, // [44]
	},
	NumStmt: [45]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		3, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		2, // 39
		3, // 40
		3, // 41
		1, // 42
		1, // 43
		1, // 44
	},
}
var _ = _cover_atomic_.LoadUint32
