//line /home/cooper/go/src/github.com/hyperledger/fabric/core/scc/loadsysccs.go:1
/*
Copyright SecureKey Technologies Inc. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package scc; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"os"
	"plugin"
	"sync"

	"github.com/hyperledger/fabric/common/viperutil"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/pkg/errors"
)

const (
	sccFactoryMethod = "New"
)

// PluginConfig SCC plugin configuration
type PluginConfig struct {
	Enabled           bool   `mapstructure:"enabled" yaml:"enabled"`
	Name              string `mapstructure:"name" yaml:"name"`
	Path              string `mapstructure:"path" yaml:"path"`
	InvokableExternal bool   `mapstructure:"invokableExternal" yaml:"invokableExternal"`
	InvokableCC2CC    bool   `mapstructure:"invokableCC2CC" yaml:"invokableCC2CC"`
}

var once sync.Once
var sccPlugins []*SystemChaincode

// loadSysCCs reads system chaincode plugin configuration and loads them
func loadSysCCs(p *Provider) []*SystemChaincode {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[0], 1);
	once.Do(func() {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[2], 1);
		var config []*PluginConfig
		err := viperutil.EnhancedExactUnmarshalKey("chaincode.systemPlugins", &config)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[4], 1);
			panic(errors.WithMessage(err, "could not load YAML config"))
		}
		_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[3], 1);loadSysCCsWithConfig(config)
	})
	_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[1], 1);return sccPlugins
}

func loadSysCCsWithConfig(configs []*PluginConfig) {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[5], 1);
	for _, conf := range configs {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[6], 1);
		plugin := loadPlugin(conf.Path)
		chaincode := &SystemChaincode{
			Enabled:           conf.Enabled,
			Name:              conf.Name,
			Path:              conf.Path,
			Chaincode:         *plugin,
			InvokableExternal: conf.InvokableExternal,
			InvokableCC2CC:    conf.InvokableCC2CC,
		}
		sccPlugins = append(sccPlugins, chaincode)
		sysccLogger.Infof("Successfully loaded SCC %s from path %s", chaincode.Name, chaincode.Path)
	}
}

func loadPlugin(path string) *shim.Chaincode {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[7], 1);
	if _, err := os.Stat(path); err != nil {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[12], 1);
		panic(fmt.Errorf("Could not find plugin at path %s: %s", path, err))
	}

	_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[8], 1);p, err := plugin.Open(path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[13], 1);
		panic(fmt.Errorf("Error opening plugin at path %s: %s", path, err))
	}

	_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[9], 1);sccFactorySymbol, err := p.Lookup(sccFactoryMethod)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[14], 1);
		panic(fmt.Errorf(
			"Could not find symbol %s. Plugin must export this method", sccFactoryMethod))
	}

	_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[10], 1);sccFactory, ok := sccFactorySymbol.(func() shim.Chaincode)
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[15], 1);
		panic(fmt.Errorf("Function %s does not match expected definition func() shim.Chaincode",
			sccFactoryMethod))
	}

	_cover_atomic_.AddUint32(&GoCover_1_613163393733346361646563.Count[11], 1);scc := sccFactory()

	return &scc
}

var GoCover_1_613163393733346361646563 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		37, 38, 0x110031, // [0]
		46, 46, 0x130002, // [1]
		38, 41, 0x110011, // [2]
		44, 44, 0x1f0003, // [3]
		41, 42, 0x400011, // [4]
		49, 50, 0x1f0034, // [5]
		50, 62, 0x3001f, // [6]
		65, 66, 0x29002e, // [7]
		70, 71, 0x100002, // [8]
		75, 76, 0x100002, // [9]
		81, 82, 0x90002, // [10]
		87, 89, 0xd0002, // [11]
		66, 67, 0x470029, // [12]
		71, 72, 0x460010, // [13]
		76, 78, 0x520010, // [14]
		82, 84, 0x160009, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		1, // 1
		3, // 2
		1, // 3
		1, // 4
		1, // 5
		4, // 6
		1, // 7
		2, // 8
		2, // 9
		2, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
