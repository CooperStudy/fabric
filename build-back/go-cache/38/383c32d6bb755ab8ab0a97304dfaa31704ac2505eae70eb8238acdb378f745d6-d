//line /home/cooper/go/src/github.com/hyperledger/fabric/cmd/common/comm/config.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm; import _cover_atomic_ "sync/atomic"

import (
	"io/ioutil"
	"time"

	"github.com/hyperledger/fabric/common/crypto/tlsgen"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/pkg/errors"
)

type genTLSCertFunc func() (*tlsgen.CertKeyPair, error)

// Config defines configuration of a Client
type Config struct {
	CertPath       string
	KeyPath        string
	PeerCACertPath string
	Timeout        time.Duration
}

// ToSecureOptions converts this Config to SecureOptions.
// The given function generates a self signed client TLS certificate if
// the TLS certificate and key aren't present at the config
func (conf Config) ToSecureOptions(newSelfSignedTLSCert genTLSCertFunc) (*comm.SecureOptions, error) {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[0], 1);
	if conf.PeerCACertPath == "" {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[4], 1);
		return &comm.SecureOptions{}, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[1], 1);caBytes, err := loadFile(conf.PeerCACertPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[5], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[2], 1);var keyBytes, certBytes []byte
	// If TLS key and certificate aren't given, generate a self signed one on the fly
	if conf.KeyPath == "" && conf.CertPath == "" {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[6], 1);
		tlsCert, err := newSelfSignedTLSCert()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[8], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[7], 1);keyBytes, certBytes = tlsCert.Key, tlsCert.Cert
	} else{ _cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[9], 1);{
		keyBytes, err = loadFile(conf.KeyPath)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[11], 1);
			return nil, errors.WithStack(err)
		}
		_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[10], 1);certBytes, err = loadFile(conf.CertPath)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[12], 1);
			return nil, errors.WithStack(err)
		}
	}}
	_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[3], 1);return &comm.SecureOptions{
		Key:               keyBytes,
		Certificate:       certBytes,
		UseTLS:            true,
		ServerRootCAs:     [][]byte{caBytes},
		RequireClientCert: true,
	}, nil
}

func loadFile(path string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[13], 1);
	b, err := ioutil.ReadFile(path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[15], 1);
		return nil, errors.Errorf("Failed opening file %s: %v", path, err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_643331663539306330303863.Count[14], 1);return b, nil
}

var GoCover_1_643331663539306330303863 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		31, 32, 0x1f0066, // [0]
		35, 36, 0x100002, // [1]
		39, 41, 0x2f0002, // [2]
		57, 63, 0x80002, // [3]
		32, 34, 0x3001f, // [4]
		36, 38, 0x30010, // [5]
		41, 43, 0x11002f, // [6]
		46, 46, 0x320003, // [7]
		43, 45, 0x40011, // [8]
		47, 49, 0x110008, // [9]
		52, 53, 0x110003, // [10]
		49, 51, 0x40011, // [11]
		53, 55, 0x40011, // [12]
		66, 68, 0x10002c, // [13]
		71, 71, 0xf0002, // [14]
		68, 70, 0x30010, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
