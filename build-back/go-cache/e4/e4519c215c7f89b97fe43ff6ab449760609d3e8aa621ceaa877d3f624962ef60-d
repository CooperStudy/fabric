//line /home/cooper/go/src/github.com/hyperledger/fabric/token/server/accesscontrol.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package server; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/token"
	"github.com/pkg/errors"
)

//go:generate counterfeiter -o mock/acl_provider.go -fake-name ACLProvider . ACLProvider

type ACLProvider interface {
	// CheckACL checks access control for the resource for the given channel.
	// idinfo is an object such as []*common.SignedData from which
	// an id can be extracted for testing against a policy
	CheckACL(resName string, channelID string, idinfo interface{}) error
}

type ACLResources struct {
	IssueTokens    string
	TransferTokens string
	ListTokens     string
}

// PolicyBasedAccessControl implements token command access control functions.
type PolicyBasedAccessControl struct {
	ACLProvider  ACLProvider
	ACLResources *ACLResources
}

func (ac *PolicyBasedAccessControl) Check(sc *token.SignedCommand, c *token.Command) error {_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[0], 1);
	signedData := []*common.SignedData{{
		Identity:  c.Header.Creator,
		Data:      sc.Command,
		Signature: sc.Signature,
	}}

	switch t := c.GetPayload().(type) {

	case *token.Command_ImportRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[1], 1);
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.IssueTokens,
			c.Header.ChannelId,
			signedData,
		)
	case *token.Command_ListRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[2], 1);
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.ListTokens,
			c.Header.ChannelId,
			signedData,
		)
	case *token.Command_TransferRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[3], 1);
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.TransferTokens,
			c.Header.ChannelId,
			signedData,
		)
	case *token.Command_RedeemRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[4], 1);
		// Redeem has same policy as transfer
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.TransferTokens,
			c.Header.ChannelId,
			signedData,
		)

	case *token.Command_ApproveRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[5], 1);
		// Approve has the same policy as transfer
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.TransferTokens,
			c.Header.ChannelId,
			signedData,
		)

	case *token.Command_TransferFromRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[6], 1);
		// TransferFrom has the same policy as transfer
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.TransferTokens,
			c.Header.ChannelId,
			signedData,
		)

	case *token.Command_ExpectationRequest:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[7], 1);
		if c.GetExpectationRequest().GetExpectation() == nil {_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[11], 1);
			return errors.New("ExpectationRequest has nil Expectation")
		}
		_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[8], 1);plainExpectation := c.GetExpectationRequest().GetExpectation().GetPlainExpectation()
		if plainExpectation == nil {_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[12], 1);
			return errors.New("ExpectationRequest has nil PlainExpectation")
		}
		_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[9], 1);return ac.checkExpectation(plainExpectation, signedData, c)
	default:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[10], 1);
		return errors.Errorf("command type not recognized: %T", t)
	}
}

// checkExpectation checks either issue policy or transfer policy depending on the payload type in expectation
func (ac *PolicyBasedAccessControl) checkExpectation(plainExpectation *token.PlainExpectation, signedData []*common.SignedData, c *token.Command) error {_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[13], 1);
	switch t := plainExpectation.GetPayload().(type) {
	case *token.PlainExpectation_ImportExpectation:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[14], 1);
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.IssueTokens,
			c.Header.ChannelId,
			signedData,
		)
	case *token.PlainExpectation_TransferExpectation:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[15], 1);
		return ac.ACLProvider.CheckACL(
			ac.ACLResources.TransferTokens,
			c.Header.ChannelId,
			signedData,
		)
	default:_cover_atomic_.AddUint32(&GoCover_0_626466633561326138353830.Count[16], 1);
		return errors.Errorf("expectation payload type not recognized: %T", t)
	}
}

var GoCover_0_626466633561326138353830 = struct {
	Count     [17]uint32
	Pos       [3 * 17]uint32
	NumStmt   [17]uint16
} {
	Pos: [3 * 17]uint32{
		36, 43, 0x24005c, // [0]
		45, 50, 0x40024, // [1]
		51, 56, 0x40022, // [2]
		57, 62, 0x40026, // [3]
		63, 69, 0x40024, // [4]
		71, 77, 0x40025, // [5]
		79, 85, 0x4002a, // [6]
		87, 88, 0x380029, // [7]
		91, 92, 0x1e0003, // [8]
		95, 95, 0x3e0003, // [9]
		96, 97, 0x3d000a, // [10]
		88, 90, 0x40038, // [11]
		92, 94, 0x4001e, // [12]
		102, 103, 0x330099, // [13]
		104, 109, 0x40031, // [14]
		110, 115, 0x40033, // [15]
		116, 117, 0x49000a, // [16]
	},
	NumStmt: [17]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
	},
}
var _ = _cover_atomic_.LoadUint32
