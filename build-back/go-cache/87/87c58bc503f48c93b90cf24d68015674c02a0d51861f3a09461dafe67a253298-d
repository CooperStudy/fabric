//line /home/cooper/go/src/github.com/hyperledger/fabric/msp/cache/second_chance.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cache; import _cover_atomic_ "sync/atomic"

import (
	"sync"
	"sync/atomic"
)

// This package implements Second-Chance Algorithm, an approximate LRU algorithms.
// https://www.cs.jhu.edu/~yairamir/cs418/os6/tsld023.htm

// secondChanceCache holds key-value items with a limited size.
// When the number cached items exceeds the limit, victims are selected based on the
// Second-Chance Algorithm and get purged
type secondChanceCache struct {
	// manages mapping between keys and items
	table map[string]*cacheItem

	// holds a list of cached items.
	items []*cacheItem

	// indicates the next candidate of a victim in the items list
	position int

	// read lock for get, and write lock for add
	rwlock sync.RWMutex
}

type cacheItem struct {
	key   string
	value interface{}
	// set to 1 when get() is called. set to 0 when victim scan
	referenced int32
}

func newSecondChanceCache(cacheSize int) *secondChanceCache {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[0], 1);
	var cache secondChanceCache
	cache.position = 0
	cache.items = make([]*cacheItem, cacheSize)
	cache.table = make(map[string]*cacheItem)

	return &cache
}

func (cache *secondChanceCache) len() int {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[1], 1);
	cache.rwlock.RLock()
	defer cache.rwlock.RUnlock()

	return len(cache.table)
}

func (cache *secondChanceCache) get(key string) (interface{}, bool) {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[2], 1);
	cache.rwlock.RLock()
	defer cache.rwlock.RUnlock()

	item, ok := cache.table[key]
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[4], 1);
		return nil, false
	}

	// referenced bit is set to true to indicate that this item is recently accessed.
	_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[3], 1);atomic.StoreInt32(&item.referenced, 1)

	return item.value, true
}

func (cache *secondChanceCache) add(key string, value interface{}) {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[5], 1);
	cache.rwlock.Lock()
	defer cache.rwlock.Unlock()

	if old, ok := cache.table[key]; ok {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[8], 1);
		old.value = value
		atomic.StoreInt32(&old.referenced, 1)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[6], 1);var item cacheItem
	item.key = key
	item.value = value
	atomic.StoreInt32(&item.referenced, 1)

	size := len(cache.items)
	num := len(cache.table)
	if num < size {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[9], 1);
		// cache is not full, so just store the new item at the end of the list
		cache.table[key] = &item
		cache.items[num] = &item
		return
	}

	// starts victim scan since cache is full
	_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[7], 1);for {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[10], 1);
		// checks whether this item is recently accsessed or not
		victim := cache.items[cache.position]
		if atomic.LoadInt32(&victim.referenced) == 0 {_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[12], 1);
			// a victim is found. delete it, and store the new item here.
			delete(cache.table, victim.key)
			cache.table[key] = &item
			cache.items[cache.position] = &item
			cache.position = (cache.position + 1) % size
			return
		}

		// referenced bit is set to false so that this item will be get purged
		// unless it is accessed until a next victim scan
		_cover_atomic_.AddUint32(&GoCover_1_616432613863646637623432.Count[11], 1);atomic.StoreInt32(&victim.referenced, 0)
		cache.position = (cache.position + 1) % size
	}
}

var GoCover_1_616432613863646637623432 = struct {
	Count     [13]uint32
	Pos       [3 * 13]uint32
	NumStmt   [13]uint16
} {
	Pos: [3 * 13]uint32{
		41, 48, 0x2003d, // [0]
		50, 55, 0x2002b, // [1]
		57, 62, 0x90045, // [2]
		67, 69, 0x190002, // [3]
		62, 64, 0x30009, // [4]
		72, 76, 0x250044, // [5]
		82, 89, 0x100002, // [6]
		97, 97, 0x60002, // [7]
		76, 80, 0x30025, // [8]
		89, 94, 0x30010, // [9]
		97, 100, 0x300006, // [10]
		111, 112, 0x2f0003, // [11]
		100, 107, 0x40030, // [12]
	},
	NumStmt: [13]uint16{
		5, // 0
		3, // 1
		4, // 2
		2, // 3
		1, // 4
		3, // 5
		7, // 6
		1, // 7
		3, // 8
		3, // 9
		2, // 10
		2, // 11
		5, // 12
	},
}
var _ = _cover_atomic_.LoadUint32
