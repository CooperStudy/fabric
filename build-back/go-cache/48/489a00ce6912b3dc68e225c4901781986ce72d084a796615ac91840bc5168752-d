//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/localconfig/config.go:1
// Copyright IBM Corp. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package localconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/Shopify/sarama"
	bccsp "github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/viperutil"
	coreconfig "github.com/hyperledger/fabric/core/config"
	"github.com/spf13/viper"
)

// Prefix for environment variables.
const Prefix = "ORDERER"

var logger = flogging.MustGetLogger("localconfig")

// TopLevel directly corresponds to the orderer config YAML.
// Note, for non 1-1 mappings, you may append
// something like `mapstructure:"weirdFoRMat"` to
// modify the default mapping, see the "Unmarshal"
// section of https://github.com/spf13/viper for more info.
type TopLevel struct {
	General    General
	FileLedger FileLedger
	RAMLedger  RAMLedger
	Kafka      Kafka
	Debug      Debug
	Consensus  interface{}
	Operations Operations
	Metrics    Metrics
}

// General contains config which should be common among all orderer types.
type General struct {
	LedgerType     string
	ListenAddress  string
	ListenPort     uint16
	TLS            TLS
	Cluster        Cluster
	Keepalive      Keepalive
	GenesisMethod  string
	GenesisProfile string
	SystemChannel  string
	GenesisFile    string
	Profile        Profile
	LocalMSPDir    string
	LocalMSPID     string
	BCCSP          *bccsp.FactoryOpts
	Authentication Authentication
}

type Cluster struct {
	RootCAs                 []string
	ClientCertificate       string
	ClientPrivateKey        string
	DialTimeout             time.Duration
	RPCTimeout              time.Duration
	ReplicationBufferSize   int
	ReplicationPullTimeout  time.Duration
	ReplicationRetryTimeout time.Duration
}

// Keepalive contains configuration for gRPC servers.
type Keepalive struct {
	ServerMinInterval time.Duration
	ServerInterval    time.Duration
	ServerTimeout     time.Duration
}

// TLS contains configuration for TLS connections.
type TLS struct {
	Enabled            bool
	PrivateKey         string
	Certificate        string
	RootCAs            []string
	ClientAuthRequired bool
	ClientRootCAs      []string
}

// SASLPlain contains configuration for SASL/PLAIN authentication
type SASLPlain struct {
	Enabled  bool
	User     string
	Password string
}

// Authentication contains configuration parameters related to authenticating
// client messages.
type Authentication struct {
	TimeWindow time.Duration
}

// Profile contains configuration for Go pprof profiling.
type Profile struct {
	Enabled bool
	Address string
}

// FileLedger contains configuration for the file-based ledger.
type FileLedger struct {
	Location string
	Prefix   string
}

// RAMLedger contains configuration for the RAM ledger.
type RAMLedger struct {
	HistorySize uint
}

// Kafka contains configuration for the Kafka-based orderer.
type Kafka struct {
	Retry     Retry
	Verbose   bool
	Version   sarama.KafkaVersion // TODO Move this to global config
	TLS       TLS
	SASLPlain SASLPlain
	Topic     Topic
}

// Retry contains configuration related to retries and timeouts when the
// connection to the Kafka cluster cannot be established, or when Metadata
// requests needs to be repeated (because the cluster is in the middle of a
// leader election).
type Retry struct {
	ShortInterval   time.Duration
	ShortTotal      time.Duration
	LongInterval    time.Duration
	LongTotal       time.Duration
	NetworkTimeouts NetworkTimeouts
	Metadata        Metadata
	Producer        Producer
	Consumer        Consumer
}

// NetworkTimeouts contains the socket timeouts for network requests to the
// Kafka cluster.
type NetworkTimeouts struct {
	DialTimeout  time.Duration
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

// Metadata contains configuration for the metadata requests to the Kafka
// cluster.
type Metadata struct {
	RetryMax     int
	RetryBackoff time.Duration
}

// Producer contains configuration for the producer's retries when failing to
// post a message to a Kafka partition.
type Producer struct {
	RetryMax     int
	RetryBackoff time.Duration
}

// Consumer contains configuration for the consumer's retries when failing to
// read from a Kafa partition.
type Consumer struct {
	RetryBackoff time.Duration
}

// Topic contains the settings to use when creating Kafka topics
type Topic struct {
	ReplicationFactor int16
}

// Debug contains configuration for the orderer's debug parameters.
type Debug struct {
	BroadcastTraceDir string
	DeliverTraceDir   string
}

// Operations configures the operations endpont for the orderer.
type Operations struct {
	ListenAddress string
	TLS           TLS
}

// Operations confiures the metrics provider for the orderer.
type Metrics struct {
	Provider string
	Statsd   Statsd
}

// Statsd provides the configuration required to emit statsd metrics from the orderer.
type Statsd struct {
	Network       string
	Address       string
	WriteInterval time.Duration
	Prefix        string
}

// Defaults carries the default orderer configuration values.
var Defaults = TopLevel{
	General: General{
		LedgerType:     "file",
		ListenAddress:  "127.0.0.1",
		ListenPort:     7050,
		GenesisMethod:  "provisional",
		GenesisProfile: "SampleSingleMSPSolo",
		SystemChannel:  "test-system-channel-name",
		GenesisFile:    "genesisblock",
		Profile: Profile{
			Enabled: false,
			Address: "0.0.0.0:6060",
		},
		LocalMSPDir: "msp",
		LocalMSPID:  "SampleOrg",
		BCCSP:       bccsp.GetDefaultOpts(),
		Authentication: Authentication{
			TimeWindow: time.Duration(15 * time.Minute),
		},
	},
	RAMLedger: RAMLedger{
		HistorySize: 10000,
	},
	FileLedger: FileLedger{
		Location: "/var/hyperledger/production/orderer",
		Prefix:   "hyperledger-fabric-ordererledger",
	},
	Kafka: Kafka{
		Retry: Retry{
			ShortInterval: 1 * time.Minute,
			ShortTotal:    10 * time.Minute,
			LongInterval:  10 * time.Minute,
			LongTotal:     12 * time.Hour,
			NetworkTimeouts: NetworkTimeouts{
				DialTimeout:  30 * time.Second,
				ReadTimeout:  30 * time.Second,
				WriteTimeout: 30 * time.Second,
			},
			Metadata: Metadata{
				RetryBackoff: 250 * time.Millisecond,
				RetryMax:     3,
			},
			Producer: Producer{
				RetryBackoff: 100 * time.Millisecond,
				RetryMax:     3,
			},
			Consumer: Consumer{
				RetryBackoff: 2 * time.Second,
			},
		},
		Verbose: false,
		Version: sarama.V0_10_2_0,
		TLS: TLS{
			Enabled: false,
		},
		Topic: Topic{
			ReplicationFactor: 3,
		},
	},
	Debug: Debug{
		BroadcastTraceDir: "",
		DeliverTraceDir:   "",
	},
	Operations: Operations{
		ListenAddress: "127.0.0.1:0",
	},
	Metrics: Metrics{
		Provider: "disabled",
	},
}

// Load parses the orderer YAML file and environment, producing
// a struct suitable for config use, returning error on failure.
func Load() (*TopLevel, error) {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[0], 1);
	config := viper.New()
	coreconfig.InitViper(config, "orderer")
	config.SetEnvPrefix(Prefix)
	config.AutomaticEnv()
	replacer := strings.NewReplacer(".", "_")
	config.SetEnvKeyReplacer(replacer)

	if err := config.ReadInConfig(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[3], 1);
		return nil, fmt.Errorf("Error reading configuration: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[1], 1);var uconf TopLevel
	if err := viperutil.EnhancedExactUnmarshal(config, &uconf); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[4], 1);
		return nil, fmt.Errorf("Error unmarshaling config into struct: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[2], 1);uconf.completeInitialization(filepath.Dir(config.ConfigFileUsed()))
	return &uconf, nil
}

func (c *TopLevel) completeInitialization(configDir string) {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[5], 1);
	defer func() {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[7], 1);
		// Translate any paths for cluster TLS configuration if applicable
		if c.General.Cluster.ClientPrivateKey != "" {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[10], 1);
			coreconfig.TranslatePathInPlace(configDir, &c.General.Cluster.ClientPrivateKey)
		}
		_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[8], 1);if c.General.Cluster.ClientCertificate != "" {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[11], 1);
			coreconfig.TranslatePathInPlace(configDir, &c.General.Cluster.ClientCertificate)
		}
		_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[9], 1);c.General.Cluster.RootCAs = translateCAs(configDir, c.General.Cluster.RootCAs)
		// Translate any paths for general TLS configuration
		c.General.TLS.RootCAs = translateCAs(configDir, c.General.TLS.RootCAs)
		c.General.TLS.ClientRootCAs = translateCAs(configDir, c.General.TLS.ClientRootCAs)
		coreconfig.TranslatePathInPlace(configDir, &c.General.TLS.PrivateKey)
		coreconfig.TranslatePathInPlace(configDir, &c.General.TLS.Certificate)
		coreconfig.TranslatePathInPlace(configDir, &c.General.GenesisFile)
		coreconfig.TranslatePathInPlace(configDir, &c.General.LocalMSPDir)
	}()

	_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[6], 1);for {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[12], 1);
		switch {
		case c.General.LedgerType == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[13], 1);
			logger.Infof("General.LedgerType unset, setting to %s", Defaults.General.LedgerType)
			c.General.LedgerType = Defaults.General.LedgerType

		case c.General.ListenAddress == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[14], 1);
			logger.Infof("General.ListenAddress unset, setting to %s", Defaults.General.ListenAddress)
			c.General.ListenAddress = Defaults.General.ListenAddress
		case c.General.ListenPort == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[15], 1);
			logger.Infof("General.ListenPort unset, setting to %v", Defaults.General.ListenPort)
			c.General.ListenPort = Defaults.General.ListenPort

		case c.General.GenesisMethod == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[16], 1);
			c.General.GenesisMethod = Defaults.General.GenesisMethod
		case c.General.GenesisFile == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[17], 1);
			c.General.GenesisFile = Defaults.General.GenesisFile
		case c.General.GenesisProfile == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[18], 1);
			c.General.GenesisProfile = Defaults.General.GenesisProfile
		case c.General.SystemChannel == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[19], 1);
			c.General.SystemChannel = Defaults.General.SystemChannel

		case c.Kafka.TLS.Enabled && c.Kafka.TLS.Certificate == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[20], 1);
			logger.Panicf("General.Kafka.TLS.Certificate must be set if General.Kafka.TLS.Enabled is set to true.")
		case c.Kafka.TLS.Enabled && c.Kafka.TLS.PrivateKey == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[21], 1);
			logger.Panicf("General.Kafka.TLS.PrivateKey must be set if General.Kafka.TLS.Enabled is set to true.")
		case c.Kafka.TLS.Enabled && c.Kafka.TLS.RootCAs == nil:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[22], 1);
			logger.Panicf("General.Kafka.TLS.CertificatePool must be set if General.Kafka.TLS.Enabled is set to true.")

		case c.Kafka.SASLPlain.Enabled && c.Kafka.SASLPlain.User == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[23], 1);
			logger.Panic("General.Kafka.SASLPlain.User must be set if General.Kafka.SASLPlain.Enabled is set to true.")
		case c.Kafka.SASLPlain.Enabled && c.Kafka.SASLPlain.Password == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[24], 1);
			logger.Panic("General.Kafka.SASLPlain.Password must be set if General.Kafka.SASLPlain.Enabled is set to true.")

		case c.General.Profile.Enabled && c.General.Profile.Address == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[25], 1);
			logger.Infof("Profiling enabled and General.Profile.Address unset, setting to %s", Defaults.General.Profile.Address)
			c.General.Profile.Address = Defaults.General.Profile.Address

		case c.General.LocalMSPDir == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[26], 1);
			logger.Infof("General.LocalMSPDir unset, setting to %s", Defaults.General.LocalMSPDir)
			c.General.LocalMSPDir = Defaults.General.LocalMSPDir
		case c.General.LocalMSPID == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[27], 1);
			logger.Infof("General.LocalMSPID unset, setting to %s", Defaults.General.LocalMSPID)
			c.General.LocalMSPID = Defaults.General.LocalMSPID

		case c.General.Authentication.TimeWindow == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[28], 1);
			logger.Infof("General.Authentication.TimeWindow unset, setting to %s", Defaults.General.Authentication.TimeWindow)
			c.General.Authentication.TimeWindow = Defaults.General.Authentication.TimeWindow

		case c.FileLedger.Prefix == "":_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[29], 1);
			logger.Infof("FileLedger.Prefix unset, setting to %s", Defaults.FileLedger.Prefix)
			c.FileLedger.Prefix = Defaults.FileLedger.Prefix

		case c.Kafka.Retry.ShortInterval == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[30], 1);
			logger.Infof("Kafka.Retry.ShortInterval unset, setting to %v", Defaults.Kafka.Retry.ShortInterval)
			c.Kafka.Retry.ShortInterval = Defaults.Kafka.Retry.ShortInterval
		case c.Kafka.Retry.ShortTotal == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[31], 1);
			logger.Infof("Kafka.Retry.ShortTotal unset, setting to %v", Defaults.Kafka.Retry.ShortTotal)
			c.Kafka.Retry.ShortTotal = Defaults.Kafka.Retry.ShortTotal
		case c.Kafka.Retry.LongInterval == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[32], 1);
			logger.Infof("Kafka.Retry.LongInterval unset, setting to %v", Defaults.Kafka.Retry.LongInterval)
			c.Kafka.Retry.LongInterval = Defaults.Kafka.Retry.LongInterval
		case c.Kafka.Retry.LongTotal == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[33], 1);
			logger.Infof("Kafka.Retry.LongTotal unset, setting to %v", Defaults.Kafka.Retry.LongTotal)
			c.Kafka.Retry.LongTotal = Defaults.Kafka.Retry.LongTotal

		case c.Kafka.Retry.NetworkTimeouts.DialTimeout == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[34], 1);
			logger.Infof("Kafka.Retry.NetworkTimeouts.DialTimeout unset, setting to %v", Defaults.Kafka.Retry.NetworkTimeouts.DialTimeout)
			c.Kafka.Retry.NetworkTimeouts.DialTimeout = Defaults.Kafka.Retry.NetworkTimeouts.DialTimeout
		case c.Kafka.Retry.NetworkTimeouts.ReadTimeout == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[35], 1);
			logger.Infof("Kafka.Retry.NetworkTimeouts.ReadTimeout unset, setting to %v", Defaults.Kafka.Retry.NetworkTimeouts.ReadTimeout)
			c.Kafka.Retry.NetworkTimeouts.ReadTimeout = Defaults.Kafka.Retry.NetworkTimeouts.ReadTimeout
		case c.Kafka.Retry.NetworkTimeouts.WriteTimeout == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[36], 1);
			logger.Infof("Kafka.Retry.NetworkTimeouts.WriteTimeout unset, setting to %v", Defaults.Kafka.Retry.NetworkTimeouts.WriteTimeout)
			c.Kafka.Retry.NetworkTimeouts.WriteTimeout = Defaults.Kafka.Retry.NetworkTimeouts.WriteTimeout

		case c.Kafka.Retry.Metadata.RetryBackoff == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[37], 1);
			logger.Infof("Kafka.Retry.Metadata.RetryBackoff unset, setting to %v", Defaults.Kafka.Retry.Metadata.RetryBackoff)
			c.Kafka.Retry.Metadata.RetryBackoff = Defaults.Kafka.Retry.Metadata.RetryBackoff
		case c.Kafka.Retry.Metadata.RetryMax == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[38], 1);
			logger.Infof("Kafka.Retry.Metadata.RetryMax unset, setting to %v", Defaults.Kafka.Retry.Metadata.RetryMax)
			c.Kafka.Retry.Metadata.RetryMax = Defaults.Kafka.Retry.Metadata.RetryMax

		case c.Kafka.Retry.Producer.RetryBackoff == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[39], 1);
			logger.Infof("Kafka.Retry.Producer.RetryBackoff unset, setting to %v", Defaults.Kafka.Retry.Producer.RetryBackoff)
			c.Kafka.Retry.Producer.RetryBackoff = Defaults.Kafka.Retry.Producer.RetryBackoff
		case c.Kafka.Retry.Producer.RetryMax == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[40], 1);
			logger.Infof("Kafka.Retry.Producer.RetryMax unset, setting to %v", Defaults.Kafka.Retry.Producer.RetryMax)
			c.Kafka.Retry.Producer.RetryMax = Defaults.Kafka.Retry.Producer.RetryMax

		case c.Kafka.Retry.Consumer.RetryBackoff == 0:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[41], 1);
			logger.Infof("Kafka.Retry.Consumer.RetryBackoff unset, setting to %v", Defaults.Kafka.Retry.Consumer.RetryBackoff)
			c.Kafka.Retry.Consumer.RetryBackoff = Defaults.Kafka.Retry.Consumer.RetryBackoff

		case c.Kafka.Version == sarama.KafkaVersion{}:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[42], 1);
			logger.Infof("Kafka.Version unset, setting to %v", Defaults.Kafka.Version)
			c.Kafka.Version = Defaults.Kafka.Version

		default:_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[43], 1);
			return
		}
	}
}

func translateCAs(configDir string, certificateAuthorities []string) []string {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[44], 1);
	var results []string
	for _, ca := range certificateAuthorities {_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[46], 1);
		result := coreconfig.TranslatePath(configDir, ca)
		results = append(results, result)
	}
	_cover_atomic_.AddUint32(&GoCover_0_343435373361303039393231.Count[45], 1);return results
}

var GoCover_0_343435373361303039393231 = struct {
	Count     [47]uint32
	Pos       [3 * 47]uint32
	NumStmt   [47]uint16
} {
	Pos: [3 * 47]uint32{
		276, 284, 0x2e0020, // [0]
		288, 289, 0x490002, // [1]
		293, 294, 0x140002, // [2]
		284, 286, 0x3002e, // [3]
		289, 291, 0x30049, // [4]
		297, 298, 0xf003d, // [5]
		316, 316, 0x60002, // [6]
		298, 300, 0x2f000f, // [7]
		303, 303, 0x300003, // [8]
		306, 313, 0x450003, // [9]
		300, 302, 0x4002f, // [10]
		303, 305, 0x40030, // [11]
		316, 317, 0xa0006, // [12]
		318, 320, 0x360023, // [13]
		322, 324, 0x3c0026, // [14]
		325, 327, 0x360022, // [15]
		329, 330, 0x3c0026, // [16]
		331, 332, 0x380024, // [17]
		333, 334, 0x3e0027, // [18]
		335, 336, 0x3c0026, // [19]
		338, 339, 0x6b003d, // [20]
		340, 341, 0x6a003c, // [21]
		342, 343, 0x6f003a, // [22]
		345, 346, 0x6f0042, // [23]
		347, 348, 0x730046, // [24]
		350, 352, 0x400045, // [25]
		354, 356, 0x380024, // [26]
		357, 359, 0x360023, // [27]
		361, 363, 0x540031, // [28]
		365, 367, 0x340022, // [29]
		369, 371, 0x440029, // [30]
		372, 374, 0x3e0026, // [31]
		375, 377, 0x420028, // [32]
		378, 380, 0x3c0025, // [33]
		382, 384, 0x600037, // [34]
		385, 387, 0x600037, // [35]
		388, 390, 0x620038, // [36]
		392, 394, 0x540031, // [37]
		395, 397, 0x4c002d, // [38]
		399, 401, 0x540031, // [39]
		402, 404, 0x4c002d, // [40]
		406, 408, 0x540031, // [41]
		410, 412, 0x2c0031, // [42]
		414, 415, 0xa000b, // [43]
		420, 422, 0x2c004f, // [44]
		426, 426, 0x100002, // [45]
		422, 425, 0x3002c, // [46]
	},
	NumStmt: [47]uint16{
		7, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		7, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		2, // 26
		2, // 27
		2, // 28
		2, // 29
		2, // 30
		2, // 31
		2, // 32
		2, // 33
		2, // 34
		2, // 35
		2, // 36
		2, // 37
		2, // 38
		2, // 39
		2, // 40
		2, // 41
		2, // 42
		1, // 43
		2, // 44
		1, // 45
		2, // 46
	},
}
var _ = _cover_atomic_.LoadUint32
