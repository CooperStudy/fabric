//line /home/cooper/go/src/github.com/hyperledger/fabric/common/capabilities/orderer.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package capabilities; import _cover_atomic_ "sync/atomic"

import (
	cb "github.com/hyperledger/fabric/protos/common"
)

const (
	ordererTypeName = "Orderer"

	// OrdererV1_1 is the capabilties string for standard new non-backwards compatible fabric v1.1 orderer capabilities.
	OrdererV1_1 = "V1_1"
)

// OrdererProvider provides capabilities information for orderer level config.
type OrdererProvider struct {
	*registry
	v11BugFixes bool
}

// NewOrdererProvider creates an orderer capabilities provider.
func NewOrdererProvider(capabilities map[string]*cb.Capability) *OrdererProvider {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[0], 1);
	cp := &OrdererProvider{}
	cp.registry = newRegistry(cp, capabilities)
	_, cp.v11BugFixes = capabilities[OrdererV1_1]
	return cp
}

// Type returns a descriptive string for logging purposes.
func (cp *OrdererProvider) Type() string {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[1], 1);
	return ordererTypeName
}

// HasCapability returns true if the capability is supported by this binary.
func (cp *OrdererProvider) HasCapability(capability string) bool {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[2], 1);
	switch capability {
	// Add new capability names here
	case OrdererV1_1:_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[3], 1);
		return true
	default:_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[4], 1);
		return false
	}
}

// PredictableChannelTemplate specifies whether the v1.0 undesirable behavior of setting the /Channel
// group's mod_policy to "" and copying versions from the channel config should be fixed or not.
func (cp *OrdererProvider) PredictableChannelTemplate() bool {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[5], 1);
	return cp.v11BugFixes
}

// Resubmission specifies whether the v1.0 non-deterministic commitment of tx should be fixed by re-submitting
// the re-validated tx.
func (cp *OrdererProvider) Resubmission() bool {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[6], 1);
	return cp.v11BugFixes
}

// ExpirationCheck specifies whether the orderer checks for identity expiration checks
// when validating messages
func (cp *OrdererProvider) ExpirationCheck() bool {_cover_atomic_.AddUint32(&GoCover_3_333764323863383062363335.Count[7], 1);
	return cp.v11BugFixes
}

var GoCover_3_333764323863383062363335 = struct {
	Count     [8]uint32
	Pos       [3 * 8]uint32
	NumStmt   [8]uint16
} {
	Pos: [3 * 8]uint32{
		27, 32, 0x20052, // [0]
		35, 37, 0x2002a, // [1]
		40, 41, 0x140042, // [2]
		43, 44, 0xe0013, // [3]
		45, 46, 0xf000a, // [4]
		52, 54, 0x2003e, // [5]
		58, 60, 0x20030, // [6]
		64, 66, 0x20033, // [7]
	},
	NumStmt: [8]uint16{
		4, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
	},
}
var _ = _cover_atomic_.LoadUint32
