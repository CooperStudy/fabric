//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/utils/txutils.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package utils; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

// GetPayloads gets the underlying payload objects in a TransactionAction
func GetPayloads(txActions *peer.TransactionAction) (*peer.ChaincodeActionPayload, *peer.ChaincodeAction, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[0], 1);
	// TODO: pass in the tx type (in what follows we're assuming the
	// type is ENDORSER_TRANSACTION)
	ccPayload, err := GetChaincodeActionPayload(txActions.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[6], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[1], 1);if ccPayload.Action == nil || ccPayload.Action.ProposalResponsePayload == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[7], 1);
		return nil, nil, errors.New("no payload in ChaincodeActionPayload")
	}
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[2], 1);pRespPayload, err := GetProposalResponsePayload(ccPayload.Action.ProposalResponsePayload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[8], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[3], 1);if pRespPayload.Extension == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[9], 1);
		return nil, nil, errors.New("response payload is missing extension")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[4], 1);respPayload, err := GetChaincodeAction(pRespPayload.Extension)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[10], 1);
		return ccPayload, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[5], 1);return ccPayload, respPayload, nil
}

// GetEnvelopeFromBlock gets an envelope from a block's Data field.
func GetEnvelopeFromBlock(data []byte) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[11], 1);
	// Block always begins with an envelope
	var err error
	env := &common.Envelope{}
	if err = proto.Unmarshal(data, env); err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[13], 1);
		return nil, errors.Wrap(err, "error unmarshaling Envelope")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[12], 1);return env, nil
}

// CreateSignedEnvelope creates a signed envelope of the desired type, with
// marshaled dataMsg and signs it
func CreateSignedEnvelope(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[14], 1);
	return CreateSignedEnvelopeWithTLSBinding(txType, channelID, signer, dataMsg, msgVersion, epoch, nil)
}

// CreateSignedEnvelopeWithTLSBinding creates a signed envelope of the desired
// type, with marshaled dataMsg and signs it. It also includes a TLS cert hash
// into the channel header
func CreateSignedEnvelopeWithTLSBinding(txType common.HeaderType, channelID string, signer crypto.LocalSigner, dataMsg proto.Message, msgVersion int32, epoch uint64, tlsCertHash []byte) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[15], 1);
	payloadChannelHeader := MakeChannelHeader(txType, msgVersion, channelID, epoch)
	payloadChannelHeader.TlsCertHash = tlsCertHash
	var err error
	payloadSignatureHeader := &common.SignatureHeader{}

	if signer != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[19], 1);
		payloadSignatureHeader, err = signer.NewSignatureHeader()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[20], 1);
			return nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[16], 1);data, err := proto.Marshal(dataMsg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[21], 1);
		return nil, errors.Wrap(err, "error marshaling")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[17], 1);paylBytes := MarshalOrPanic(
		&common.Payload{
			Header: MakePayloadHeader(payloadChannelHeader, payloadSignatureHeader),
			Data:   data,
		},
	)

	var sig []byte
	if signer != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[22], 1);
		sig, err = signer.Sign(paylBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[23], 1);
			return nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[18], 1);env := &common.Envelope{
		Payload:   paylBytes,
		Signature: sig,
	}

	return env, nil
}

// CreateSignedTx assembles an Envelope message from proposal, endorsements,
// and a signer. This function should be called by a client when it has
// collected enough endorsements for a proposal to create a transaction and
// submit it to peers for ordering
func CreateSignedTx(proposal *peer.Proposal, signer msp.SigningIdentity, resps ...*peer.ProposalResponse) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[24], 1);
	if len(resps) == 0 {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[39], 1);
		return nil, errors.New("at least one proposal response is required")
	}

	// the original header
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[25], 1);hdr, err := GetHeader(proposal.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[40], 1);
		return nil, err
	}

	// the original payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[26], 1);pPayl, err := GetChaincodeProposalPayload(proposal.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[41], 1);
		return nil, err
	}

	// check that the signer is the same that is referenced in the header
	// TODO: maybe worth removing?
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[27], 1);signerBytes, err := signer.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[42], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[28], 1);shdr, err := GetSignatureHeader(hdr.SignatureHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[43], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[29], 1);if bytes.Compare(signerBytes, shdr.Creator) != 0 {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[44], 1);
		return nil, errors.New("signer must be the same as the one referenced in the header")
	}

	// get header extensions so we have the visibility field
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[30], 1);hdrExt, err := GetChaincodeHeaderExtension(hdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[45], 1);
		return nil, err
	}

	// ensure that all actions are bitwise equal and that they are successful
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[31], 1);var a1 []byte
	for n, r := range resps {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[46], 1);
		if n == 0 {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[48], 1);
			a1 = r.Payload
			if r.Response.Status < 200 || r.Response.Status >= 400 {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[50], 1);
				return nil, errors.Errorf("proposal response was not successful, error code %d, msg %s", r.Response.Status, r.Response.Message)
			}
			_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[49], 1);continue
		}

		_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[47], 1);if bytes.Compare(a1, r.Payload) != 0 {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[51], 1);
			return nil, errors.New("ProposalResponsePayloads do not match")
		}
	}

	// fill endorsements
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[32], 1);endorsements := make([]*peer.Endorsement, len(resps))
	for n, r := range resps {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[52], 1);
		endorsements[n] = r.Endorsement
	}

	// create ChaincodeEndorsedAction
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[33], 1);cea := &peer.ChaincodeEndorsedAction{ProposalResponsePayload: resps[0].Payload, Endorsements: endorsements}

	// obtain the bytes of the proposal payload that will go to the transaction
	propPayloadBytes, err := GetBytesProposalPayloadForTx(pPayl, hdrExt.PayloadVisibility)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[53], 1);
		return nil, err
	}

	// serialize the chaincode action payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[34], 1);cap := &peer.ChaincodeActionPayload{ChaincodeProposalPayload: propPayloadBytes, Action: cea}
	capBytes, err := GetBytesChaincodeActionPayload(cap)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[54], 1);
		return nil, err
	}

	// create a transaction
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[35], 1);taa := &peer.TransactionAction{Header: hdr.SignatureHeader, Payload: capBytes}
	taas := make([]*peer.TransactionAction, 1)
	taas[0] = taa
	tx := &peer.Transaction{Actions: taas}

	// serialize the tx
	txBytes, err := GetBytesTransaction(tx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[55], 1);
		return nil, err
	}

	// create the payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[36], 1);payl := &common.Payload{Header: hdr, Data: txBytes}
	paylBytes, err := GetBytesPayload(payl)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[56], 1);
		return nil, err
	}

	// sign the payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[37], 1);sig, err := signer.Sign(paylBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[57], 1);
		return nil, err
	}

	// here's the envelope
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[38], 1);return &common.Envelope{Payload: paylBytes, Signature: sig}, nil
}

// CreateProposalResponse creates a proposal response.
func CreateProposalResponse(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte, signingEndorser msp.SigningIdentity) (*peer.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[58], 1);
	hdr, err := GetHeader(hdrbytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[64], 1);
		return nil, err
	}

	// obtain the proposal hash given proposal header, payload and the
	// requested visibility
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[59], 1);pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[65], 1);
		return nil, errors.WithMessage(err, "error computing proposal hash")
	}

	// get the bytes of the proposal response payload - we need to sign them
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[60], 1);prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[66], 1);
		return nil, err
	}

	// serialize the signing identity
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[61], 1);endorser, err := signingEndorser.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[67], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error serializing signing identity for %s", signingEndorser.GetIdentifier()))
	}

	// sign the concatenation of the proposal response and the serialized
	// endorser identity with this endorser's key
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[62], 1);signature, err := signingEndorser.Sign(append(prpBytes, endorser...))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[68], 1);
		return nil, errors.WithMessage(err, "could not sign the proposal response payload")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[63], 1);resp := &peer.ProposalResponse{
		// Timestamp: TODO!
		Version: 1, // TODO: pick right version number
		Endorsement: &peer.Endorsement{
			Signature: signature,
			Endorser:  endorser,
		},
		Payload: prpBytes,
		Response: &peer.Response{
			Status:  200,
			Message: "OK",
		},
	}

	return resp, nil
}

// CreateProposalResponseFailure creates a proposal response for cases where
// endorsement proposal fails either due to a endorsement failure or a
// chaincode failure (chaincode response status >= shim.ERRORTHRESHOLD)
func CreateProposalResponseFailure(hdrbytes []byte, payl []byte, response *peer.Response, results []byte, events []byte, ccid *peer.ChaincodeID, visibility []byte) (*peer.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[69], 1);
	hdr, err := GetHeader(hdrbytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[73], 1);
		return nil, err
	}

	// obtain the proposal hash given proposal header, payload and the requested visibility
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[70], 1);pHashBytes, err := GetProposalHash1(hdr, payl, visibility)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[74], 1);
		return nil, errors.WithMessage(err, "error computing proposal hash")
	}

	// get the bytes of the proposal response payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[71], 1);prpBytes, err := GetBytesProposalResponsePayload(pHashBytes, response, results, events, ccid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[75], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[72], 1);resp := &peer.ProposalResponse{
		// Timestamp: TODO!
		Payload:  prpBytes,
		Response: response,
	}

	return resp, nil
}

// GetSignedProposal returns a signed proposal given a Proposal message and a
// signing identity
func GetSignedProposal(prop *peer.Proposal, signer msp.SigningIdentity) (*peer.SignedProposal, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[76], 1);
	// check for nil argument
	if prop == nil || signer == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[80], 1);
		return nil, errors.New("nil arguments")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[77], 1);propBytes, err := GetBytesProposal(prop)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[81], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[78], 1);signature, err := signer.Sign(propBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[82], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[79], 1);return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, nil
}

// MockSignedEndorserProposalOrPanic creates a SignedProposal with the
// passed arguments
func MockSignedEndorserProposalOrPanic(chainID string, cs *peer.ChaincodeSpec, creator, signature []byte) (*peer.SignedProposal, *peer.Proposal) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[83], 1);
	prop, _, err := CreateChaincodeProposal(
		common.HeaderType_ENDORSER_TRANSACTION,
		chainID,
		&peer.ChaincodeInvocationSpec{ChaincodeSpec: cs},
		creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[86], 1);
		panic(err)
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[84], 1);propBytes, err := GetBytesProposal(prop)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[87], 1);
		panic(err)
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[85], 1);return &peer.SignedProposal{ProposalBytes: propBytes, Signature: signature}, prop
}

func MockSignedEndorserProposal2OrPanic(chainID string, cs *peer.ChaincodeSpec, signer msp.SigningIdentity) (*peer.SignedProposal, *peer.Proposal) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[88], 1);
	serializedSigner, err := signer.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[92], 1);
		panic(err)
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[89], 1);prop, _, err := CreateChaincodeProposal(
		common.HeaderType_ENDORSER_TRANSACTION,
		chainID,
		&peer.ChaincodeInvocationSpec{ChaincodeSpec: &peer.ChaincodeSpec{}},
		serializedSigner)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[93], 1);
		panic(err)
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[90], 1);sProp, err := GetSignedProposal(prop, signer)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[94], 1);
		panic(err)
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[91], 1);return sProp, prop
}

// GetBytesProposalPayloadForTx takes a ChaincodeProposalPayload and returns
// its serialized version according to the visibility field
func GetBytesProposalPayloadForTx(payload *peer.ChaincodeProposalPayload, visibility []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[95], 1);
	// check for nil argument
	if payload == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[98], 1);
		return nil, errors.New("nil arguments")
	}

	// strip the transient bytes off the payload - this needs to be done no
	// matter the visibility mode
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[96], 1);cppNoTransient := &peer.ChaincodeProposalPayload{Input: payload.Input, TransientMap: nil}
	cppBytes, err := GetBytesChaincodeProposalPayload(cppNoTransient)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[99], 1);
		return nil, err
	}

	// currently the fabric only supports full visibility: this means that
	// there are no restrictions on which parts of the proposal payload will
	// be visible in the final transaction; this default approach requires
	// no additional instructions in the PayloadVisibility field; however
	// the fabric may be extended to encode more elaborate visibility
	// mechanisms that shall be encoded in this field (and handled
	// appropriately by the peer)

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[97], 1);return cppBytes, nil
}

// GetProposalHash2 gets the proposal hash - this version
// is called by the committer where the visibility policy
// has already been enforced and so we already get what
// we have to get in ccPropPayl
func GetProposalHash2(header *common.Header, ccPropPayl []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[100], 1);
	// check for nil argument
	if header == nil ||
		header.ChannelHeader == nil ||
		header.SignatureHeader == nil ||
		ccPropPayl == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[103], 1);
		return nil, errors.New("nil arguments")
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[101], 1);hash, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[104], 1);
		return nil, errors.WithMessage(err, "error instantiating hash function")
	}
	// hash the serialized Channel Header object
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[102], 1);hash.Write(header.ChannelHeader)
	// hash the serialized Signature Header object
	hash.Write(header.SignatureHeader)
	// hash the bytes of the chaincode proposal payload that we are given
	hash.Write(ccPropPayl)
	return hash.Sum(nil), nil
}

// GetProposalHash1 gets the proposal hash bytes after sanitizing the
// chaincode proposal payload according to the rules of visibility
func GetProposalHash1(header *common.Header, ccPropPayl []byte, visibility []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[105], 1);
	// check for nil argument
	if header == nil ||
		header.ChannelHeader == nil ||
		header.SignatureHeader == nil ||
		ccPropPayl == nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[110], 1);
		return nil, errors.New("nil arguments")
	}

	// unmarshal the chaincode proposal payload
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[106], 1);cpp, err := GetChaincodeProposalPayload(ccPropPayl)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[111], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[107], 1);ppBytes, err := GetBytesProposalPayloadForTx(cpp, visibility)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[112], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[108], 1);hash2, err := factory.GetDefault().GetHash(&bccsp.SHA256Opts{})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[113], 1);
		return nil, errors.WithMessage(err, "error instantiating hash function")
	}
	// hash the serialized Channel Header object
	_cover_atomic_.AddUint32(&GoCover_4_333834643165316261363934.Count[109], 1);hash2.Write(header.ChannelHeader)
	// hash the serialized Signature Header object
	hash2.Write(header.SignatureHeader)
	// hash of the part of the chaincode proposal payload that will go to the tx
	hash2.Write(ppBytes)
	return hash2.Sum(nil), nil
}

var GoCover_4_333834643165316261363934 = struct {
	Count     [114]uint32
	Pos       [3 * 114]uint32
	NumStmt   [114]uint16
} {
	Pos: [3 * 114]uint32{
		24, 28, 0x100072, // [0]
		32, 32, 0x500002, // [1]
		35, 36, 0x100002, // [2]
		40, 40, 0x230002, // [3]
		44, 45, 0x100002, // [4]
		48, 48, 0x240002, // [5]
		28, 30, 0x30010, // [6]
		32, 34, 0x30050, // [7]
		36, 38, 0x30010, // [8]
		40, 42, 0x30023, // [9]
		45, 47, 0x30010, // [10]
		52, 56, 0x320042, // [11]
		60, 60, 0x110002, // [12]
		56, 58, 0x30032, // [13]
		65, 67, 0x200b3, // [14]
		72, 78, 0x1300d5, // [15]
		85, 86, 0x100002, // [16]
		90, 98, 0x130002, // [17]
		105, 110, 0x110002, // [18]
		78, 80, 0x110013, // [19]
		80, 82, 0x40011, // [20]
		86, 88, 0x30010, // [21]
		98, 100, 0x110013, // [22]
		100, 102, 0x40011, // [23]
		117, 118, 0x150085, // [24]
		123, 124, 0x100002, // [25]
		129, 130, 0x100002, // [26]
		136, 137, 0x100002, // [27]
		141, 142, 0x100002, // [28]
		146, 146, 0x330002, // [29]
		151, 152, 0x100002, // [30]
		157, 158, 0x1a0002, // [31]
		173, 174, 0x1a0002, // [32]
		179, 183, 0x100002, // [33]
		188, 190, 0x100002, // [34]
		195, 202, 0x100002, // [35]
		207, 209, 0x100002, // [36]
		214, 215, 0x100002, // [37]
		220, 220, 0x420002, // [38]
		118, 120, 0x30015, // [39]
		124, 126, 0x30010, // [40]
		130, 132, 0x30010, // [41]
		137, 139, 0x30010, // [42]
		142, 144, 0x30010, // [43]
		146, 148, 0x30033, // [44]
		152, 154, 0x30010, // [45]
		158, 159, 0xd001a, // [46]
		167, 167, 0x280003, // [47]
		159, 161, 0x3b000d, // [48]
		164, 164, 0xc0004, // [49]
		161, 163, 0x5003b, // [50]
		167, 169, 0x40028, // [51]
		174, 176, 0x3001a, // [52]
		183, 185, 0x30010, // [53]
		190, 192, 0x30010, // [54]
		202, 204, 0x30010, // [55]
		209, 211, 0x30010, // [56]
		215, 217, 0x30010, // [57]
		224, 226, 0x1000e3, // [58]
		232, 233, 0x100002, // [59]
		238, 239, 0x100002, // [60]
		244, 245, 0x100002, // [61]
		251, 252, 0x100002, // [62]
		256, 270, 0x120002, // [63]
		226, 228, 0x30010, // [64]
		233, 235, 0x30010, // [65]
		239, 241, 0x30010, // [66]
		245, 247, 0x30010, // [67]
		252, 254, 0x30010, // [68]
		276, 278, 0x1000c5, // [69]
		283, 284, 0x100002, // [70]
		289, 290, 0x100002, // [71]
		294, 300, 0x120002, // [72]
		278, 280, 0x30010, // [73]
		284, 286, 0x30010, // [74]
		290, 292, 0x30010, // [75]
		305, 307, 0x220067, // [76]
		311, 312, 0x100002, // [77]
		316, 317, 0x100002, // [78]
		321, 321, 0x520002, // [79]
		307, 309, 0x30022, // [80]
		312, 314, 0x30010, // [81]
		317, 319, 0x30010, // [82]
		326, 332, 0x100092, // [83]
		336, 337, 0x100002, // [84]
		341, 341, 0x530002, // [85]
		332, 333, 0xd0010, // [86]
		337, 338, 0xd0010, // [87]
		344, 346, 0x100094, // [88]
		350, 355, 0x100002, // [89]
		359, 360, 0x100002, // [90]
		364, 364, 0x140002, // [91]
		346, 347, 0xd0010, // [92]
		355, 356, 0xd0010, // [93]
		360, 361, 0xd0010, // [94]
		369, 371, 0x14006e, // [95]
		377, 379, 0x100002, // [96]
		391, 391, 0x160002, // [97]
		371, 373, 0x30014, // [98]
		379, 381, 0x30010, // [99]
		398, 403, 0x150051, // [100]
		407, 408, 0x100002, // [101]
		412, 417, 0x1b0002, // [102]
		403, 405, 0x30015, // [103]
		408, 410, 0x30010, // [104]
		422, 427, 0x150064, // [105]
		432, 433, 0x100002, // [106]
		437, 438, 0x100002, // [107]
		442, 443, 0x100002, // [108]
		447, 452, 0x1c0002, // [109]
		427, 429, 0x30015, // [110]
		433, 435, 0x30010, // [111]
		438, 440, 0x30010, // [112]
		443, 445, 0x30010, // [113]
	},
	NumStmt: [114]uint16{
		2, // 0
		1, // 1
		2, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		3, // 11
		1, // 12
		1, // 13
		1, // 14
		5, // 15
		2, // 16
		3, // 17
		2, // 18
		2, // 19
		1, // 20
		1, // 21
		2, // 22
		1, // 23
		1, // 24
		2, // 25
		2, // 26
		2, // 27
		2, // 28
		1, // 29
		2, // 30
		2, // 31
		2, // 32
		3, // 33
		3, // 34
		6, // 35
		3, // 36
		2, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		2, // 58
		2, // 59
		2, // 60
		2, // 61
		2, // 62
		2, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		2, // 69
		2, // 70
		2, // 71
		2, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		2, // 77
		2, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		2, // 83
		2, // 84
		1, // 85
		1, // 86
		1, // 87
		2, // 88
		2, // 89
		2, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		3, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		2, // 101
		4, // 102
		1, // 103
		1, // 104
		1, // 105
		2, // 106
		2, // 107
		2, // 108
		4, // 109
		1, // 110
		1, // 111
		1, // 112
		1, // 113
	},
}
var _ = _cover_atomic_.LoadUint32
