//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/common/common.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package common; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/viperutil"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/core/config"
	"github.com/hyperledger/fabric/core/scc/cscc"
	"github.com/hyperledger/fabric/msp"
	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
	"github.com/hyperledger/fabric/peer/common/api"
	pcommon "github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	putils "github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// UndefinedParamValue defines what undefined parameters in the command line will initialise to
const UndefinedParamValue = ""
const CmdRoot = "core"

var mainLogger = flogging.MustGetLogger("main")
var logOutput = os.Stderr

var (
	defaultConnTimeout = 3 * time.Second
	// These function variables (xyzFnc) can be used to invoke corresponding xyz function
	// this will allow the invoking packages to mock these functions in their unit test cases

	// GetEndorserClientFnc is a function that returns a new endorser client connection
	// to the provided peer address using the TLS root cert file,
	// by default it is set to GetEndorserClient function
	GetEndorserClientFnc func(address, tlsRootCertFile string) (pb.EndorserClient, error)

	// GetPeerDeliverClientFnc is a function that returns a new deliver client connection
	// to the provided peer address using the TLS root cert file,
	// by default it is set to GetDeliverClient function
	GetPeerDeliverClientFnc func(address, tlsRootCertFile string) (api.PeerDeliverClient, error)

	// GetDeliverClientFnc is a function that returns a new deliver client connection
	// to the provided peer address using the TLS root cert file,
	// by default it is set to GetDeliverClient function
	GetDeliverClientFnc func(address, tlsRootCertFile string) (pb.Deliver_DeliverClient, error)

	// GetDefaultSignerFnc is a function that returns a default Signer(Default/PERR)
	// by default it is set to GetDefaultSigner function
	GetDefaultSignerFnc func() (msp.SigningIdentity, error)

	// GetBroadcastClientFnc returns an instance of the BroadcastClient interface
	// by default it is set to GetBroadcastClient function
	GetBroadcastClientFnc func() (BroadcastClient, error)

	// GetOrdererEndpointOfChainFnc returns orderer endpoints of given chain
	// by default it is set to GetOrdererEndpointOfChain function
	GetOrdererEndpointOfChainFnc func(chainID string, signer msp.SigningIdentity,
		endorserClient pb.EndorserClient) ([]string, error)

	// GetCertificateFnc is a function that returns the client TLS certificate
	GetCertificateFnc func() (tls.Certificate, error)
)

type commonClient struct {
	*comm.GRPCClient
	address string
	sn      string
}

func init() {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[0], 1);
	GetEndorserClientFnc = GetEndorserClient
	GetDefaultSignerFnc = GetDefaultSigner
	GetBroadcastClientFnc = GetBroadcastClient
	GetOrdererEndpointOfChainFnc = GetOrdererEndpointOfChain
	GetDeliverClientFnc = GetDeliverClient
	GetPeerDeliverClientFnc = GetPeerDeliverClient
	GetCertificateFnc = GetCertificate
}

// InitConfig initializes viper config
func InitConfig(cmdRoot string) error {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[1], 1);

	err := config.InitViper(nil, cmdRoot)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[4], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[2], 1);err = viper.ReadInConfig() // Find and read the config file
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[5], 1);            // Handle errors reading the config file
		// The version of Viper we use claims the config type isn't supported when in fact the file hasn't been found
		// Display a more helpful message to avoid confusing the user.
		if strings.Contains(fmt.Sprint(err), "Unsupported Config Type") {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[6], 1);
			return errors.New(fmt.Sprintf("Could not find config file. "+
				"Please make sure that FABRIC_CFG_PATH is set to a path "+
				"which contains %s.yaml", cmdRoot))
		} else{ _cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[7], 1);{
			return errors.WithMessage(err, fmt.Sprintf("error when reading %s config file", cmdRoot))
		}}
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[3], 1);return nil
}

// InitCrypto initializes crypto for this peer
func InitCrypto(mspMgrConfigDir, localMSPID, localMSPType string) error {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[8], 1);
	var err error
	// Check whether msp folder exists
	fi, err := os.Stat(mspMgrConfigDir)
	if os.IsNotExist(err) || !fi.IsDir() {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[13], 1);
		// No need to try to load MSP from folder which is not available
		return errors.Errorf("cannot init crypto, folder \"%s\" does not exist", mspMgrConfigDir)
	}
	// Check whether localMSPID exists
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[9], 1);if localMSPID == "" {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[14], 1);
		return errors.New("the local MSP must have an ID")
	}

	// Init the BCCSP
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[10], 1);SetBCCSPKeystorePath()
	var bccspConfig *factory.FactoryOpts
	err = viperutil.EnhancedExactUnmarshalKey("peer.BCCSP", &bccspConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[15], 1);
		return errors.WithMessage(err, "could not parse YAML config")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[11], 1);err = mspmgmt.LoadLocalMspWithType(mspMgrConfigDir, bccspConfig, localMSPID, localMSPType)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[16], 1);
		return errors.WithMessage(err, fmt.Sprintf("error when setting up MSP of type %s from directory %s", localMSPType, mspMgrConfigDir))
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[12], 1);return nil
}

// SetBCCSPKeystorePath sets the file keystore path for the SW BCCSP provider
// to an absolute path relative to the config file
func SetBCCSPKeystorePath() {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[17], 1);
	viper.Set("peer.BCCSP.SW.FileKeyStore.KeyStore",
		config.GetPath("peer.BCCSP.SW.FileKeyStore.KeyStore"))
}

// GetDefaultSigner return a default Signer(Default/PERR) for cli
func GetDefaultSigner() (msp.SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[18], 1);
	signer, err := mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[20], 1);
		return nil, errors.WithMessage(err, "error obtaining the default signing identity")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[19], 1);return signer, err
}

// GetOrdererEndpointOfChain returns orderer endpoints of given chain
func GetOrdererEndpointOfChain(chainID string, signer msp.SigningIdentity, endorserClient pb.EndorserClient) ([]string, error) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[21], 1);
	// query cscc for chain config block
	invocation := &pb.ChaincodeInvocationSpec{
		ChaincodeSpec: &pb.ChaincodeSpec{
			Type:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value["GOLANG"]),
			ChaincodeId: &pb.ChaincodeID{Name: "cscc"},
			Input:       &pb.ChaincodeInput{Args: [][]byte{[]byte(cscc.GetConfigBlock), []byte(chainID)}},
		},
	}

	creator, err := signer.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[31], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error serializing identity for %s", signer.GetIdentifier()))
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[22], 1);prop, _, err := putils.CreateProposalFromCIS(pcommon.HeaderType_CONFIG, "", invocation, creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[32], 1);
		return nil, errors.WithMessage(err, "error creating GetConfigBlock proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[23], 1);signedProp, err := putils.GetSignedProposal(prop, signer)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[33], 1);
		return nil, errors.WithMessage(err, "error creating signed GetConfigBlock proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[24], 1);proposalResp, err := endorserClient.ProcessProposal(context.Background(), signedProp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[34], 1);
		return nil, errors.WithMessage(err, "error endorsing GetConfigBlock")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[25], 1);if proposalResp == nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[35], 1);
		return nil, errors.WithMessage(err, "error nil proposal response")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[26], 1);if proposalResp.Response.Status != 0 && proposalResp.Response.Status != 200 {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[36], 1);
		return nil, errors.Errorf("error bad proposal response %d: %s", proposalResp.Response.Status, proposalResp.Response.Message)
	}

	// parse config block
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[27], 1);block, err := putils.GetBlockFromBlockBytes(proposalResp.Response.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[37], 1);
		return nil, errors.WithMessage(err, "error unmarshaling config block")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[28], 1);envelopeConfig, err := putils.ExtractEnvelope(block, 0)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[38], 1);
		return nil, errors.WithMessage(err, "error extracting config block envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[29], 1);bundle, err := channelconfig.NewBundleFromEnvelope(envelopeConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[39], 1);
		return nil, errors.WithMessage(err, "error loading config block")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[30], 1);return bundle.ChannelConfig().OrdererAddresses(), nil
}

// CheckLogLevel checks that a given log level string is valid
func CheckLogLevel(level string) error {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[40], 1);
	if !flogging.IsValidLevel(level) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[42], 1);
		return errors.Errorf("invalid log level provided - %s", level)
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[41], 1);return nil
}

func configFromEnv(prefix string) (address, override string, clientConfig comm.ClientConfig, err error) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[43], 1);
	address = viper.GetString(prefix + ".address")
	override = viper.GetString(prefix + ".tls.serverhostoverride")
	clientConfig = comm.ClientConfig{}
	connTimeout := viper.GetDuration(prefix + ".client.connTimeout")
	if connTimeout == time.Duration(0) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[47], 1);
		connTimeout = defaultConnTimeout
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[44], 1);clientConfig.Timeout = connTimeout
	secOpts := &comm.SecureOptions{
		UseTLS:            viper.GetBool(prefix + ".tls.enabled"),
		RequireClientCert: viper.GetBool(prefix + ".tls.clientAuthRequired")}
	if secOpts.UseTLS {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[48], 1);
		caPEM, res := ioutil.ReadFile(config.GetPath(prefix + ".tls.rootcert.file"))
		if res != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[50], 1);
			err = errors.WithMessage(res,
				fmt.Sprintf("unable to load %s.tls.rootcert.file", prefix))
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[49], 1);secOpts.ServerRootCAs = [][]byte{caPEM}
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[45], 1);if secOpts.RequireClientCert {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[51], 1);
		keyPEM, res := ioutil.ReadFile(config.GetPath(prefix + ".tls.clientKey.file"))
		if res != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[54], 1);
			err = errors.WithMessage(res,
				fmt.Sprintf("unable to load %s.tls.clientKey.file", prefix))
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[52], 1);secOpts.Key = keyPEM
		certPEM, res := ioutil.ReadFile(config.GetPath(prefix + ".tls.clientCert.file"))
		if res != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[55], 1);
			err = errors.WithMessage(res,
				fmt.Sprintf("unable to load %s.tls.clientCert.file", prefix))
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[53], 1);secOpts.Certificate = certPEM
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[46], 1);clientConfig.SecOpts = secOpts
	return
}

func InitCmd(cmd *cobra.Command, args []string) {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[56], 1);
	err := InitConfig(CmdRoot)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[62], 1); // Handle errors reading the config file
		mainLogger.Errorf("Fatal error when initializing %s config : %s", CmdRoot, err)
		os.Exit(1)
	}

	// read in the legacy logging level settings and, if set,
	// notify users of the FABRIC_LOGGING_SPEC env variable
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[57], 1);var loggingLevel string
	if viper.GetString("logging_level") != "" {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[63], 1);
		loggingLevel = viper.GetString("logging_level")
	} else{ _cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[64], 1);{
		loggingLevel = viper.GetString("logging.level")
	}}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[58], 1);if loggingLevel != "" {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[65], 1);
		mainLogger.Warning("CORE_LOGGING_LEVEL is no longer supported, please use the FABRIC_LOGGING_SPEC environment variable")
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[59], 1);loggingSpec := os.Getenv("FABRIC_LOGGING_SPEC")
	loggingFormat := os.Getenv("FABRIC_LOGGING_FORMAT")

	flogging.Init(flogging.Config{
		Format:  loggingFormat,
		Writer:  logOutput,
		LogSpec: loggingSpec,
	})

	// Init the MSP
	var mspMgrConfigDir = config.GetPath("peer.mspConfigPath")
	var mspID = viper.GetString("peer.localMspId")
	var mspType = viper.GetString("peer.localMspType")
	if mspType == "" {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[66], 1);
		mspType = msp.ProviderTypeToString(msp.FABRIC)
	}
	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[60], 1);err = InitCrypto(mspMgrConfigDir, mspID, mspType)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[67], 1); // Handle errors reading the config file
		mainLogger.Errorf("Cannot run peer because %s", err.Error())
		os.Exit(1)
	}

	_cover_atomic_.AddUint32(&GoCover_1_393466303334653164333865.Count[61], 1);runtime.GOMAXPROCS(viper.GetInt("peer.gomaxprocs"))
}

var GoCover_1_393466303334653164333865 = struct {
	Count     [68]uint32
	Pos       [3 * 68]uint32
	NumStmt   [68]uint16
} {
	Pos: [3 * 68]uint32{
		87, 95, 0x2000d, // [0]
		98, 101, 0x100027, // [1]
		105, 106, 0x100002, // [2]
		118, 118, 0xc0002, // [3]
		101, 103, 0x30010, // [4]
		106, 109, 0x430010, // [5]
		109, 113, 0x40043, // [6]
		113, 115, 0x40009, // [7]
		122, 126, 0x270049, // [8]
		131, 131, 0x160002, // [9]
		136, 139, 0x100002, // [10]
		143, 144, 0x100002, // [11]
		148, 148, 0xc0002, // [12]
		126, 129, 0x30027, // [13]
		131, 133, 0x30016, // [14]
		139, 141, 0x30010, // [15]
		144, 146, 0x30010, // [16]
		153, 156, 0x2001d, // [17]
		159, 161, 0x100036, // [18]
		165, 165, 0x140002, // [19]
		161, 163, 0x30010, // [20]
		169, 180, 0x100080, // [21]
		184, 185, 0x100002, // [22]
		189, 190, 0x100002, // [23]
		194, 195, 0x100002, // [24]
		199, 199, 0x190002, // [25]
		203, 203, 0x4e0002, // [26]
		208, 209, 0x100002, // [27]
		213, 214, 0x100002, // [28]
		217, 218, 0x100002, // [29]
		222, 222, 0x370002, // [30]
		180, 182, 0x30010, // [31]
		185, 187, 0x30010, // [32]
		190, 192, 0x30010, // [33]
		195, 197, 0x30010, // [34]
		199, 201, 0x30019, // [35]
		203, 205, 0x3004e, // [36]
		209, 211, 0x30010, // [37]
		214, 216, 0x30010, // [38]
		218, 220, 0x30010, // [39]
		226, 227, 0x230028, // [40]
		230, 230, 0xc0002, // [41]
		227, 229, 0x30023, // [42]
		233, 238, 0x250069, // [43]
		241, 245, 0x140002, // [44]
		254, 254, 0x1f0002, // [45]
		270, 271, 0x80002, // [46]
		238, 240, 0x30025, // [47]
		245, 247, 0x110014, // [48]
		252, 252, 0x2a0003, // [49]
		247, 251, 0x40011, // [50]
		254, 256, 0x11001f, // [51]
		261, 263, 0x110003, // [52]
		268, 268, 0x200003, // [53]
		256, 260, 0x40011, // [54]
		263, 267, 0x40011, // [55]
		274, 276, 0x100031, // [56]
		283, 284, 0x2c0002, // [57]
		289, 289, 0x180002, // [58]
		293, 306, 0x130002, // [59]
		309, 310, 0x100002, // [60]
		315, 315, 0x350002, // [61]
		276, 279, 0x30010, // [62]
		284, 286, 0x3002c, // [63]
		286, 288, 0x30008, // [64]
		289, 291, 0x30018, // [65]
		306, 308, 0x30013, // [66]
		310, 313, 0x30010, // [67]
	},
	NumStmt: [68]uint16{
		7, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		4, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		3, // 21
		2, // 22
		2, // 23
		2, // 24
		1, // 25
		1, // 26
		2, // 27
		2, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		5, // 43
		3, // 44
		1, // 45
		2, // 46
		1, // 47
		2, // 48
		1, // 49
		2, // 50
		2, // 51
		3, // 52
		1, // 53
		2, // 54
		2, // 55
		2, // 56
		2, // 57
		1, // 58
		7, // 59
		2, // 60
		1, // 61
		2, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		2, // 67
	},
}
var _ = _cover_atomic_.LoadUint32
