//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/shim/chaincode.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

// Package shim provides APIs for the chaincode to access its state
// variables, transaction context and call other chaincodes.
package shim; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/ptypes/timestamp"
	"github.com/hyperledger/fabric/bccsp/factory"
	commonledger "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/protos/ledger/queryresult"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	logging "github.com/op/go-logging"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
	"google.golang.org/grpc"
)

// Logger for the shim package.
var chaincodeLogger = logging.MustGetLogger("shim")
var logOutput = os.Stderr

var key string
var cert string

const (
	minUnicodeRuneValue   = 0            //U+0000
	maxUnicodeRuneValue   = utf8.MaxRune //U+10FFFF - maximum (and unallocated) code point
	compositeKeyNamespace = "\x00"
	emptyKeySubstitute    = "\x01"
)

// ChaincodeStub is an object passed to chaincode for shim side handling of
// APIs.
type ChaincodeStub struct {
	TxID                       string
	ChannelId                  string
	chaincodeEvent             *pb.ChaincodeEvent
	args                       [][]byte
	handler                    *Handler
	signedProposal             *pb.SignedProposal
	proposal                   *pb.Proposal
	validationParameterMetakey string

	// Additional fields extracted from the signedProposal
	creator   []byte
	transient map[string][]byte
	binding   []byte

	decorations map[string][]byte
}

// Peer address derived from command line or env var
var peerAddress string

//this separates the chaincode stream interface establishment
//so we can replace it with a mock peer stream
type peerStreamGetter func(name string) (PeerChaincodeStream, error)

//UTs to setup mock peer stream getter
var streamGetter peerStreamGetter

//the non-mock user CC stream establishment func
func userChaincodeStreamGetter(name string) (PeerChaincodeStream, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[0], 1);
	flag.StringVar(&peerAddress, "peer.address", "", "peer address")
	if viper.GetBool("peer.tls.enabled") {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[4], 1);
		keyPath := viper.GetString("tls.client.key.path")
		certPath := viper.GetString("tls.client.cert.path")

		data, err1 := ioutil.ReadFile(keyPath)
		if err1 != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[7], 1);
			err1 = errors.Wrap(err1, fmt.Sprintf("error trying to read file content %s", keyPath))
			chaincodeLogger.Errorf("%+v", err1)
			return nil, err1
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[5], 1);key = string(data)

		data, err1 = ioutil.ReadFile(certPath)
		if err1 != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[8], 1);
			err1 = errors.Wrap(err1, fmt.Sprintf("error trying to read file content %s", certPath))
			chaincodeLogger.Errorf("%+v", err1)
			return nil, err1
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[6], 1);cert = string(data)
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[1], 1);flag.Parse()

	chaincodeLogger.Debugf("Peer address: %s", getPeerAddress())

	// Establish connection with validating peer
	clientConn, err := newPeerClientConnection()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[9], 1);
		err = errors.Wrap(err, "error trying to connect to local peer")
		chaincodeLogger.Errorf("%+v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[2], 1);chaincodeLogger.Debugf("os.Args returns: %s", os.Args)

	chaincodeSupportClient := pb.NewChaincodeSupportClient(clientConn)

	// Establish stream with validating peer
	stream, err := chaincodeSupportClient.Register(context.Background())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[10], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error chatting with leader at address=%s", getPeerAddress()))
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[3], 1);return stream, nil
}

// chaincodes.
func Start(cc Chaincode) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[11], 1);
	// If Start() is called, we assume this is a standalone chaincode and set
	// up formatted logging.
	SetupChaincodeLogging()

	chaincodename := viper.GetString("chaincode.id.name")
	if chaincodename == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[16], 1);
		return errors.New("error chaincode id not provided")
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[12], 1);err := factory.InitFactories(factory.GetDefaultOpts())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[17], 1);
		return errors.WithMessage(err, "internal error, BCCSP could not be initialized with default options")
	}

	//mock stream not set up ... get real stream
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[13], 1);if streamGetter == nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[18], 1);
		streamGetter = userChaincodeStreamGetter
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[14], 1);stream, err := streamGetter(chaincodename)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[19], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[15], 1);err = chatWithPeer(chaincodename, stream, cc)

	return err
}

// IsEnabledForLogLevel checks to see if the chaincodeLogger is enabled for a specific logging level
// used primarily for testing
func IsEnabledForLogLevel(logLevel string) bool {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[20], 1);
	lvl, _ := logging.LogLevel(logLevel)
	return chaincodeLogger.IsEnabledFor(lvl)
}

var loggingSetup sync.Once

// SetupChaincodeLogging sets the chaincode logging format and the level
// to the values of CORE_CHAINCODE_LOGGING_FORMAT, CORE_CHAINCODE_LOGGING_LEVEL
// and CORE_CHAINCODE_LOGGING_SHIM set from core.yaml by chaincode_support.go
func SetupChaincodeLogging() {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[21], 1);
	loggingSetup.Do(setupChaincodeLogging)
}

func setupChaincodeLogging() {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[22], 1);
	// This is the default log config from 1.2
	const defaultLogFormat = "%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -> %{level:.4s} %{id:03x}%{color:reset} %{message}"
	const defaultLevel = logging.INFO

	viper.SetEnvPrefix("CORE")
	viper.AutomaticEnv()
	replacer := strings.NewReplacer(".", "_")
	viper.SetEnvKeyReplacer(replacer)

	// setup process-wide logging backend
	logFormat := viper.GetString("chaincode.logging.format")
	if logFormat == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[27], 1);
		logFormat = defaultLogFormat
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[23], 1);formatter := logging.MustStringFormatter(logFormat)
	backend := logging.NewLogBackend(os.Stderr, "", 0)
	backendFormatter := logging.NewBackendFormatter(backend, formatter)
	logging.SetBackend(backendFormatter).SetLevel(defaultLevel, "")

	// set default log level for all loggers
	chaincodeLogLevelString := viper.GetString("chaincode.logging.level")
	if chaincodeLogLevelString == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[28], 1);
		chaincodeLogger.Infof("Chaincode log level not provided; defaulting to: %s", defaultLevel.String())
		chaincodeLogLevelString = defaultLevel.String()
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[24], 1);_, err := LogLevel(chaincodeLogLevelString)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[29], 1);
		chaincodeLogger.Warningf("Error: '%s' for chaincode log level: %s; defaulting to %s", err, chaincodeLogLevelString, defaultLevel.String())
		chaincodeLogLevelString = defaultLevel.String()
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[25], 1);initFromSpec(chaincodeLogLevelString, defaultLevel)

	// override the log level for the shim logger - note: if this value is
	// blank or an invalid log level, then the above call to
	// `initFromSpec` already set the default log level so no action
	// is required here.
	shimLogLevelString := viper.GetString("chaincode.logging.shim")
	if shimLogLevelString != "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[30], 1);
		shimLogLevel, err := LogLevel(shimLogLevelString)
		if err == nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[31], 1);
			SetLoggingLevel(shimLogLevel)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[32], 1);{
			chaincodeLogger.Warningf("Error: %s for shim log level: %s", err, shimLogLevelString)
		}}
	}

	//now that logging is setup, print build level. This will help making sure
	//chaincode is matched with peer.
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[26], 1);buildLevel := viper.GetString("chaincode.buildlevel")
	chaincodeLogger.Infof("Chaincode (build level: %s) starting up ...", buildLevel)
}

// this has been moved from the 1.2 logging implementation
func initFromSpec(spec string, defaultLevel logging.Level) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[33], 1);
	levelAll := defaultLevel
	var err error

	fields := strings.Split(spec, ":")
	for _, field := range fields {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[35], 1);
		split := strings.Split(field, "=")
		switch len(split) {
		case 1:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[36], 1);
			if levelAll, err = logging.LogLevel(field); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[40], 1);
				chaincodeLogger.Warningf("Logging level '%s' not recognized, defaulting to '%s': %s", field, defaultLevel, err)
				levelAll = defaultLevel // need to reset cause original value was overwritten
			}
		case 2:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[37], 1);
			// <logger,<logger>...]=<level>
			levelSingle, err := logging.LogLevel(split[1])
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[41], 1);
				chaincodeLogger.Warningf("Invalid logging level in '%s' ignored", field)
				continue
			}

			_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[38], 1);if split[0] == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[42], 1);
				chaincodeLogger.Warningf("Invalid logging override specification '%s' ignored - no logger specified", field)
			} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[43], 1);{
				loggers := strings.Split(split[0], ",")
				for _, logger := range loggers {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[44], 1);
					chaincodeLogger.Debugf("Setting logging level for logger '%s' to '%s'", logger, levelSingle)
					logging.SetLevel(levelSingle, logger)
				}
			}}
		default:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[39], 1);
			chaincodeLogger.Warningf("Invalid logging override '%s' ignored - missing ':'?", field)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[34], 1);logging.SetLevel(levelAll, "") // set the logging level for all loggers
}

// StartInProc is an entry point for system chaincodes bootstrap. It is not an
// API for chaincodes.
func StartInProc(env []string, args []string, cc Chaincode, recv <-chan *pb.ChaincodeMessage, send chan<- *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[45], 1);
	chaincodeLogger.Debugf("in proc %v", args)

	var chaincodename string
	for _, v := range env {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[48], 1);
		if strings.Index(v, "CORE_CHAINCODE_ID_NAME=") == 0 {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[49], 1);
			p := strings.SplitAfter(v, "CORE_CHAINCODE_ID_NAME=")
			chaincodename = p[1]
			break
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[46], 1);if chaincodename == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[50], 1);
		return errors.New("error chaincode id not provided")
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[47], 1);stream := newInProcStream(recv, send)
	chaincodeLogger.Debugf("starting chat with peer using name=%s", chaincodename)
	err := chatWithPeer(chaincodename, stream, cc)
	return err
}

func getPeerAddress() string {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[51], 1);
	if peerAddress != "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[54], 1);
		return peerAddress
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[52], 1);if peerAddress = viper.GetString("peer.address"); peerAddress == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[55], 1);
		chaincodeLogger.Fatalf("peer.address not configured, can't connect to peer")
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[53], 1);return peerAddress
}

func newPeerClientConnection() (*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[56], 1);
	var peerAddress = getPeerAddress()
	// set the keepalive options to match static settings for chaincode server
	kaOpts := &comm.KeepaliveOptions{
		ClientInterval: time.Duration(1) * time.Minute,
		ClientTimeout:  time.Duration(20) * time.Second,
	}
	if viper.GetBool("peer.tls.enabled") {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[58], 1);
		return comm.NewClientConnectionWithAddress(peerAddress, true, true,
			comm.InitTLSForShim(key, cert), kaOpts)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[57], 1);return comm.NewClientConnectionWithAddress(peerAddress, true, false, nil, kaOpts)
}

func chatWithPeer(chaincodename string, stream PeerChaincodeStream, cc Chaincode) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[59], 1);
	// Create the shim handler responsible for all control logic
	handler := newChaincodeHandler(stream, cc)
	defer stream.CloseSend()

	// Send the ChaincodeID during register.
	chaincodeID := &pb.ChaincodeID{Name: chaincodename}
	payload, err := proto.Marshal(chaincodeID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[63], 1);
		return errors.Wrap(err, "error marshalling chaincodeID during chaincode registration")
	}

	// Register on the stream
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[60], 1);chaincodeLogger.Debugf("Registering.. sending %s", pb.ChaincodeMessage_REGISTER)
	if err = handler.serialSend(&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_REGISTER, Payload: payload}); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[64], 1);
		return errors.WithMessage(err, "error sending chaincode REGISTER")
	}

	// holds return values from gRPC Recv below
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[61], 1);type recvMsg struct {
		msg *pb.ChaincodeMessage
		err error
	}
	msgAvail := make(chan *recvMsg, 1)
	errc := make(chan error)

	receiveMessage := func() {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[65], 1);
		in, err := stream.Recv()
		msgAvail <- &recvMsg{in, err}
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[62], 1);go receiveMessage()
	for {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[66], 1);
		select {
		case rmsg := <-msgAvail:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[67], 1);
			switch {
			case rmsg.err == io.EOF:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[69], 1);
				err = errors.Wrapf(rmsg.err, "received EOF, ending chaincode stream")
				chaincodeLogger.Debugf("%+v", err)
				return err
			case rmsg.err != nil:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[70], 1);
				err := errors.Wrap(rmsg.err, "receive failed")
				chaincodeLogger.Errorf("Received error from server, ending chaincode stream: %+v", err)
				return err
			case rmsg.msg == nil:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[71], 1);
				err := errors.New("received nil message, ending chaincode stream")
				chaincodeLogger.Debugf("%+v", err)
				return err
			default:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[72], 1);
				chaincodeLogger.Debugf("[%s]Received message %s from peer", shorttxid(rmsg.msg.Txid), rmsg.msg.Type)
				err := handler.handleMessage(rmsg.msg, errc)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[74], 1);
					err = errors.WithMessage(err, "error handling message")
					return err
				}

				_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[73], 1);go receiveMessage()
			}

		case sendErr := <-errc:_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[68], 1);
			if sendErr != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[75], 1);
				err := errors.Wrap(sendErr, "error sending")
				return err
			}
		}
	}
}

// -- init stub ---
// ChaincodeInvocation functionality

func (stub *ChaincodeStub) init(handler *Handler, channelId string, txid string, input *pb.ChaincodeInput, signedProposal *pb.SignedProposal) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[76], 1);
	stub.TxID = txid
	stub.ChannelId = channelId
	stub.args = input.Args
	stub.handler = handler
	stub.signedProposal = signedProposal
	stub.decorations = input.Decorations
	stub.validationParameterMetakey = pb.MetaDataKeys_VALIDATION_PARAMETER.String()

	// TODO: sanity check: verify that every call to init with a nil
	// signedProposal is a legitimate one, meaning it is an internal call
	// to system chaincodes.
	if signedProposal != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[78], 1);
		var err error

		stub.proposal, err = utils.GetProposal(signedProposal.ProposalBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[81], 1);
			return errors.WithMessage(err, "failed extracting signedProposal from signed signedProposal")
		}

		// Extract creator, transient, binding...
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[79], 1);stub.creator, stub.transient, err = utils.GetChaincodeProposalContext(stub.proposal)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[82], 1);
			return errors.WithMessage(err, "failed extracting signedProposal fields")
		}

		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[80], 1);stub.binding, err = utils.ComputeProposalBinding(stub.proposal)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[83], 1);
			return errors.WithMessage(err, "failed computing binding from signedProposal")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[77], 1);return nil
}

// GetTxID returns the transaction ID for the proposal
func (stub *ChaincodeStub) GetTxID() string {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[84], 1);
	return stub.TxID
}

// GetChannelID returns the channel for the proposal
func (stub *ChaincodeStub) GetChannelID() string {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[85], 1);
	return stub.ChannelId
}

func (stub *ChaincodeStub) GetDecorations() map[string][]byte {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[86], 1);
	return stub.decorations
}

// ------------- Call Chaincode functions ---------------

// InvokeChaincode documentation can be found in interfaces.go
func (stub *ChaincodeStub) InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[87], 1);
	// Internally we handle chaincode name as a composite name
	if channel != "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[89], 1);
		chaincodeName = chaincodeName + "/" + channel
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[88], 1);return stub.handler.handleInvokeChaincode(chaincodeName, args, stub.ChannelId, stub.TxID)
}

// --------- State functions ----------

// GetState documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetState(key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[90], 1);
	// Access public data by setting the collection to empty string
	collection := ""
	return stub.handler.handleGetState(collection, key, stub.ChannelId, stub.TxID)
}

// SetStateValidationParameter documentation can be found in interfaces.go
func (stub *ChaincodeStub) SetStateValidationParameter(key string, ep []byte) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[91], 1);
	return stub.handler.handlePutStateMetadataEntry("", key, stub.validationParameterMetakey, ep, stub.ChannelId, stub.TxID)
}

// GetStateValidationParameter documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetStateValidationParameter(key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[92], 1);
	md, err := stub.handler.handleGetStateMetadata("", key, stub.ChannelId, stub.TxID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[95], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[93], 1);if ep, ok := md[stub.validationParameterMetakey]; ok {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[96], 1);
		return ep, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[94], 1);return nil, nil
}

// PutState documentation can be found in interfaces.go
func (stub *ChaincodeStub) PutState(key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[97], 1);
	if key == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[99], 1);
		return errors.New("key must not be an empty string")
	}
	// Access public data by setting the collection to empty string
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[98], 1);collection := ""
	return stub.handler.handlePutState(collection, key, value, stub.ChannelId, stub.TxID)
}

func (stub *ChaincodeStub) createStateQueryIterator(response *pb.QueryResponse) *StateQueryIterator {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[100], 1);
	return &StateQueryIterator{CommonIterator: &CommonIterator{
		handler:    stub.handler,
		channelId:  stub.ChannelId,
		txid:       stub.TxID,
		response:   response,
		currentLoc: 0}}
}

// GetQueryResult documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetQueryResult(query string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[101], 1);
	// Access public data by setting the collection to empty string
	collection := ""
	// ignore QueryResponseMetadata as it is not applicable for a rich query without pagination
	iterator, _, err := stub.handleGetQueryResult(collection, query, nil)

	return iterator, err
}

// DelState documentation can be found in interfaces.go
func (stub *ChaincodeStub) DelState(key string) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[102], 1);
	// Access public data by setting the collection to empty string
	collection := ""
	return stub.handler.handleDelState(collection, key, stub.ChannelId, stub.TxID)
}

//  ---------  private state functions  ---------

// GetPrivateData documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetPrivateData(collection string, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[103], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[105], 1);
		return nil, fmt.Errorf("collection must not be an empty string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[104], 1);return stub.handler.handleGetState(collection, key, stub.ChannelId, stub.TxID)
}

// PutPrivateData documentation can be found in interfaces.go
func (stub *ChaincodeStub) PutPrivateData(collection string, key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[106], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[109], 1);
		return fmt.Errorf("collection must not be an empty string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[107], 1);if key == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[110], 1);
		return fmt.Errorf("key must not be an empty string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[108], 1);return stub.handler.handlePutState(collection, key, value, stub.ChannelId, stub.TxID)
}

// DelPrivateData documentation can be found in interfaces.go
func (stub *ChaincodeStub) DelPrivateData(collection string, key string) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[111], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[113], 1);
		return fmt.Errorf("collection must not be an empty string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[112], 1);return stub.handler.handleDelState(collection, key, stub.ChannelId, stub.TxID)
}

// GetPrivateDataByRange documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetPrivateDataByRange(collection, startKey, endKey string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[114], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[118], 1);
		return nil, fmt.Errorf("collection must not be an empty string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[115], 1);if startKey == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[119], 1);
		startKey = emptyKeySubstitute
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[116], 1);if err := validateSimpleKeys(startKey, endKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[120], 1);
		return nil, err
	}
	// ignore QueryResponseMetadata as it is not applicable for a range query without pagination
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[117], 1);iterator, _, err := stub.handleGetStateByRange(collection, startKey, endKey, nil)

	return iterator, err
}

func (stub *ChaincodeStub) createRangeKeysForPartialCompositeKey(objectType string, attributes []string) (string, string, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[121], 1);
	partialCompositeKey, err := stub.CreateCompositeKey(objectType, attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[123], 1);
		return "", "", err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[122], 1);startKey := partialCompositeKey
	endKey := partialCompositeKey + string(maxUnicodeRuneValue)

	return startKey, endKey, nil
}

// GetPrivateDataByPartialCompositeKey documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetPrivateDataByPartialCompositeKey(collection, objectType string, attributes []string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[124], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[127], 1);
		return nil, fmt.Errorf("collection must not be an empty string")
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[125], 1);startKey, endKey, err := stub.createRangeKeysForPartialCompositeKey(objectType, attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[128], 1);
		return nil, err
	}
	// ignore QueryResponseMetadata as it is not applicable for a partial composite key query without pagination
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[126], 1);iterator, _, err := stub.handleGetStateByRange(collection, startKey, endKey, nil)

	return iterator, err
}

// GetPrivateDataQueryResult documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetPrivateDataQueryResult(collection, query string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[129], 1);
	if collection == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[131], 1);
		return nil, fmt.Errorf("collection must not be an empty string")
	}
	// ignore QueryResponseMetadata as it is not applicable for a range query without pagination
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[130], 1);iterator, _, err := stub.handleGetQueryResult(collection, query, nil)

	return iterator, err
}

// GetPrivateDataValidationParameter documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetPrivateDataValidationParameter(collection, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[132], 1);
	md, err := stub.handler.handleGetStateMetadata(collection, key, stub.ChannelId, stub.TxID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[135], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[133], 1);if ep, ok := md[stub.validationParameterMetakey]; ok {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[136], 1);
		return ep, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[134], 1);return nil, nil
}

// SetPrivateDataValidationParameter documentation can be found in interfaces.go
func (stub *ChaincodeStub) SetPrivateDataValidationParameter(collection, key string, ep []byte) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[137], 1);
	return stub.handler.handlePutStateMetadataEntry(collection, key, stub.validationParameterMetakey, ep, stub.ChannelId, stub.TxID)
}

// CommonIterator documentation can be found in interfaces.go
type CommonIterator struct {
	handler    *Handler
	channelId  string
	txid       string
	response   *pb.QueryResponse
	currentLoc int
}

// StateQueryIterator documentation can be found in interfaces.go
type StateQueryIterator struct {
	*CommonIterator
}

// HistoryQueryIterator documentation can be found in interfaces.go
type HistoryQueryIterator struct {
	*CommonIterator
}

type resultType uint8

const (
	STATE_QUERY_RESULT resultType = iota + 1
	HISTORY_QUERY_RESULT
)

func createQueryResponseMetadata(metadataBytes []byte) (*pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[138], 1);
	metadata := &pb.QueryResponseMetadata{}
	err := proto.Unmarshal(metadataBytes, metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[140], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[139], 1);return metadata, nil
}

func (stub *ChaincodeStub) handleGetStateByRange(collection, startKey, endKey string,
	metadata []byte) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[141], 1);

	response, err := stub.handler.handleGetStateByRange(collection, startKey, endKey, metadata, stub.ChannelId, stub.TxID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[144], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[142], 1);iterator := stub.createStateQueryIterator(response)
	responseMetadata, err := createQueryResponseMetadata(response.Metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[145], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[143], 1);return iterator, responseMetadata, nil
}

func (stub *ChaincodeStub) handleGetQueryResult(collection, query string,
	metadata []byte) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[146], 1);

	response, err := stub.handler.handleGetQueryResult(collection, query, metadata, stub.ChannelId, stub.TxID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[149], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[147], 1);iterator := stub.createStateQueryIterator(response)
	responseMetadata, err := createQueryResponseMetadata(response.Metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[150], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[148], 1);return iterator, responseMetadata, nil
}

// GetStateByRange documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[151], 1);
	if startKey == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[154], 1);
		startKey = emptyKeySubstitute
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[152], 1);if err := validateSimpleKeys(startKey, endKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[155], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[153], 1);collection := ""

	// ignore QueryResponseMetadata as it is not applicable for a range query without pagination
	iterator, _, err := stub.handleGetStateByRange(collection, startKey, endKey, nil)

	return iterator, err
}

// GetHistoryForKey documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetHistoryForKey(key string) (HistoryQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[156], 1);
	response, err := stub.handler.handleGetHistoryForKey(key, stub.ChannelId, stub.TxID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[158], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[157], 1);return &HistoryQueryIterator{CommonIterator: &CommonIterator{stub.handler, stub.ChannelId, stub.TxID, response, 0}}, nil
}

//CreateCompositeKey documentation can be found in interfaces.go
func (stub *ChaincodeStub) CreateCompositeKey(objectType string, attributes []string) (string, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[159], 1);
	return createCompositeKey(objectType, attributes)
}

//SplitCompositeKey documentation can be found in interfaces.go
func (stub *ChaincodeStub) SplitCompositeKey(compositeKey string) (string, []string, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[160], 1);
	return splitCompositeKey(compositeKey)
}

func createCompositeKey(objectType string, attributes []string) (string, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[161], 1);
	if err := validateCompositeKeyAttribute(objectType); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[164], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[162], 1);ck := compositeKeyNamespace + objectType + string(minUnicodeRuneValue)
	for _, att := range attributes {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[165], 1);
		if err := validateCompositeKeyAttribute(att); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[167], 1);
			return "", err
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[166], 1);ck += att + string(minUnicodeRuneValue)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[163], 1);return ck, nil
}

func splitCompositeKey(compositeKey string) (string, []string, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[168], 1);
	componentIndex := 1
	components := []string{}
	for i := 1; i < len(compositeKey); i++ {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[170], 1);
		if compositeKey[i] == minUnicodeRuneValue {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[171], 1);
			components = append(components, compositeKey[componentIndex:i])
			componentIndex = i + 1
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[169], 1);return components[0], components[1:], nil
}

func validateCompositeKeyAttribute(str string) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[172], 1);
	if !utf8.ValidString(str) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[175], 1);
		return errors.Errorf("not a valid utf8 string: [%x]", str)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[173], 1);for index, runeValue := range str {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[176], 1);
		if runeValue == minUnicodeRuneValue || runeValue == maxUnicodeRuneValue {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[177], 1);
			return errors.Errorf(`input contain unicode %#U starting at position [%d]. %#U and %#U are not allowed in the input attribute of a composite key`,
				runeValue, index, minUnicodeRuneValue, maxUnicodeRuneValue)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[174], 1);return nil
}

//To ensure that simple keys do not go into composite key namespace,
//we validate simplekey to check whether the key starts with 0x00 (which
//is the namespace for compositeKey). This helps in avoding simple/composite
//key collisions.
func validateSimpleKeys(simpleKeys ...string) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[178], 1);
	for _, key := range simpleKeys {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[180], 1);
		if len(key) > 0 && key[0] == compositeKeyNamespace[0] {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[181], 1);
			return errors.Errorf(`first character of the key [%s] contains a null character which is not allowed`, key)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[179], 1);return nil
}

//GetStateByPartialCompositeKey function can be invoked by a chaincode to query the
//state based on a given partial composite key. This function returns an
//iterator which can be used to iterate over all composite keys whose prefix
//matches the given partial composite key. This function should be used only for
//a partial composite key. For a full composite key, an iter with empty response
//would be returned.
func (stub *ChaincodeStub) GetStateByPartialCompositeKey(objectType string, attributes []string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[182], 1);
	collection := ""
	startKey, endKey, err := stub.createRangeKeysForPartialCompositeKey(objectType, attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[184], 1);
		return nil, err
	}
	// ignore QueryResponseMetadata as it is not applicable for a partial composite key query without pagination
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[183], 1);iterator, _, err := stub.handleGetStateByRange(collection, startKey, endKey, nil)

	return iterator, err
}

func createQueryMetadata(pageSize int32, bookmark string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[185], 1);
	// Construct the QueryMetadata with a page size and a bookmark needed for pagination
	metadata := &pb.QueryMetadata{PageSize: pageSize, Bookmark: bookmark}
	metadataBytes, err := proto.Marshal(metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[187], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[186], 1);return metadataBytes, nil
}

func (stub *ChaincodeStub) GetStateByRangeWithPagination(startKey, endKey string, pageSize int32,
	bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[188], 1);

	if startKey == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[192], 1);
		startKey = emptyKeySubstitute
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[189], 1);if err := validateSimpleKeys(startKey, endKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[193], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[190], 1);collection := ""

	metadata, err := createQueryMetadata(pageSize, bookmark)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[194], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[191], 1);return stub.handleGetStateByRange(collection, startKey, endKey, metadata)
}

func (stub *ChaincodeStub) GetStateByPartialCompositeKeyWithPagination(objectType string, keys []string,
	pageSize int32, bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[195], 1);

	collection := ""

	metadata, err := createQueryMetadata(pageSize, bookmark)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[198], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[196], 1);startKey, endKey, err := stub.createRangeKeysForPartialCompositeKey(objectType, keys)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[199], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[197], 1);return stub.handleGetStateByRange(collection, startKey, endKey, metadata)
}

func (stub *ChaincodeStub) GetQueryResultWithPagination(query string, pageSize int32,
	bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[200], 1);
	// Access public data by setting the collection to empty string
	collection := ""

	metadata, err := createQueryMetadata(pageSize, bookmark)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[202], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[201], 1);return stub.handleGetQueryResult(collection, query, metadata)
}

func (iter *StateQueryIterator) Next() (*queryresult.KV, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[203], 1);
	if result, err := iter.nextResult(STATE_QUERY_RESULT); err == nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[204], 1);
		return result.(*queryresult.KV), err
	} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[205], 1);{
		return nil, err
	}}
}

func (iter *HistoryQueryIterator) Next() (*queryresult.KeyModification, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[206], 1);
	if result, err := iter.nextResult(HISTORY_QUERY_RESULT); err == nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[207], 1);
		return result.(*queryresult.KeyModification), err
	} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[208], 1);{
		return nil, err
	}}
}

// HasNext documentation can be found in interfaces.go
func (iter *CommonIterator) HasNext() bool {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[209], 1);
	if iter.currentLoc < len(iter.response.Results) || iter.response.HasMore {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[211], 1);
		return true
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[210], 1);return false
}

// getResultsFromBytes deserializes QueryResult and return either a KV struct
// or KeyModification depending on the result type (i.e., state (range/execute)
// query, history query). Note that commonledger.QueryResult is an empty golang
// interface that can hold values of any type.
func (iter *CommonIterator) getResultFromBytes(queryResultBytes *pb.QueryResultBytes,
	rType resultType) (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[212], 1);

	if rType == STATE_QUERY_RESULT {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[214], 1);
		stateQueryResult := &queryresult.KV{}
		if err := proto.Unmarshal(queryResultBytes.ResultBytes, stateQueryResult); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[216], 1);
			return nil, errors.Wrap(err, "error unmarshaling result from bytes")
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[215], 1);return stateQueryResult, nil

	} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[217], 1);if rType == HISTORY_QUERY_RESULT {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[218], 1);
		historyQueryResult := &queryresult.KeyModification{}
		if err := proto.Unmarshal(queryResultBytes.ResultBytes, historyQueryResult); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[220], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[219], 1);return historyQueryResult, nil
	}}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[213], 1);return nil, errors.New("wrong result type")
}

func (iter *CommonIterator) fetchNextQueryResult() error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[221], 1);
	if response, err := iter.handler.handleQueryStateNext(iter.response.Id, iter.channelId, iter.txid); err == nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[222], 1);
		iter.currentLoc = 0
		iter.response = response
		return nil
	} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[223], 1);{
		return err
	}}
}

// nextResult returns the next QueryResult (i.e., either a KV struct or KeyModification)
// from the state or history query iterator. Note that commonledger.QueryResult is an
// empty golang interface that can hold values of any type.
func (iter *CommonIterator) nextResult(rType resultType) (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[224], 1);
	if iter.currentLoc < len(iter.response.Results) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[226], 1);
		// On valid access of an element from cached results
		queryResult, err := iter.getResultFromBytes(iter.response.Results[iter.currentLoc], rType)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[229], 1);
			chaincodeLogger.Errorf("Failed to decode query results: %+v", err)
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[227], 1);iter.currentLoc++

		if iter.currentLoc == len(iter.response.Results) && iter.response.HasMore {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[230], 1);
			// On access of last item, pre-fetch to update HasMore flag
			if err = iter.fetchNextQueryResult(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[231], 1);
				chaincodeLogger.Errorf("Failed to fetch next results: %+v", err)
				return nil, err
			}
		}

		_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[228], 1);return queryResult, err
	} else{ _cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[232], 1);if !iter.response.HasMore {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[233], 1);
		// On call to Next() without check of HasMore
		return nil, errors.New("no such key")
	}}

	// should not fall through here
	// case: no cached results but HasMore is true.
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[225], 1);return nil, errors.New("invalid iterator state")
}

// Close documentation can be found in interfaces.go
func (iter *CommonIterator) Close() error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[234], 1);
	_, err := iter.handler.handleQueryStateClose(iter.response.Id, iter.channelId, iter.txid)
	return err
}

// GetArgs documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetArgs() [][]byte {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[235], 1);
	return stub.args
}

// GetStringArgs documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetStringArgs() []string {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[236], 1);
	args := stub.GetArgs()
	strargs := make([]string, 0, len(args))
	for _, barg := range args {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[238], 1);
		strargs = append(strargs, string(barg))
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[237], 1);return strargs
}

// GetFunctionAndParameters documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetFunctionAndParameters() (function string, params []string) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[239], 1);
	allargs := stub.GetStringArgs()
	function = ""
	params = []string{}
	if len(allargs) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[241], 1);
		function = allargs[0]
		params = allargs[1:]
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[240], 1);return
}

// GetCreator documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetCreator() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[242], 1);
	return stub.creator, nil
}

// GetTransient documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetTransient() (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[243], 1);
	return stub.transient, nil
}

// GetBinding documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetBinding() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[244], 1);
	return stub.binding, nil
}

// GetSignedProposal documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetSignedProposal() (*pb.SignedProposal, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[245], 1);
	return stub.signedProposal, nil
}

// GetArgsSlice documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetArgsSlice() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[246], 1);
	args := stub.GetArgs()
	res := []byte{}
	for _, barg := range args {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[248], 1);
		res = append(res, barg...)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[247], 1);return res, nil
}

// GetTxTimestamp documentation can be found in interfaces.go
func (stub *ChaincodeStub) GetTxTimestamp() (*timestamp.Timestamp, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[249], 1);
	hdr, err := utils.GetHeader(stub.proposal.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[252], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[250], 1);chdr, err := utils.UnmarshalChannelHeader(hdr.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[253], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[251], 1);return chdr.GetTimestamp(), nil
}

// ------------- ChaincodeEvent API ----------------------

// SetEvent documentation can be found in interfaces.go
func (stub *ChaincodeStub) SetEvent(name string, payload []byte) error {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[254], 1);
	if name == "" {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[256], 1);
		return errors.New("event name can not be nil string")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[255], 1);stub.chaincodeEvent = &pb.ChaincodeEvent{EventName: name, Payload: payload}
	return nil
}

// ------------- Logging Control and Chaincode Loggers ---------------

// As independent programs, Go language chaincodes can use any logging
// methodology they choose, from simple fmt.Printf() to os.Stdout, to
// decorated logs created by the author's favorite logging package. The
// chaincode "shim" interface, however, is defined by the Hyperledger fabric
// and implements its own logging methodology. This methodology currently
// includes severity-based logging control and a standard way of decorating
// the logs.
//
// The facilities defined here allow a Go language chaincode to control the
// logging level of its shim, and to create its own logs formatted
// consistently with, and temporally interleaved with the shim logs without
// any knowledge of the underlying implementation of the shim, and without any
// other package requirements. The lack of package requirements is especially
// important because even if the chaincode happened to explicitly use the same
// logging package as the shim, unless the chaincode is physically included as
// part of the hyperledger fabric source code tree it could actually end up
// using a distinct binary instance of the logging package, with different
// formats and severity levels than the binary package used by the shim.
//
// Another approach that might have been taken, and could potentially be taken
// in the future, would be for the chaincode to supply a logging object for
// the shim to use, rather than the other way around as implemented
// here. There would be some complexities associated with that approach, so
// for the moment we have chosen the simpler implementation below. The shim
// provides one or more abstract logging objects for the chaincode to use via
// the NewLogger() API, and allows the chaincode to control the severity level
// of shim logs using the SetLoggingLevel() API.

// LoggingLevel is an enumerated type of severity levels that control
// chaincode logging.
type LoggingLevel logging.Level

// These constants comprise the LoggingLevel enumeration
const (
	LogDebug    = LoggingLevel(logging.DEBUG)
	LogInfo     = LoggingLevel(logging.INFO)
	LogNotice   = LoggingLevel(logging.NOTICE)
	LogWarning  = LoggingLevel(logging.WARNING)
	LogError    = LoggingLevel(logging.ERROR)
	LogCritical = LoggingLevel(logging.CRITICAL)
)

var shimLoggingLevel = LogInfo // Necessary for correct initialization; See Start()

// SetLoggingLevel allows a Go language chaincode to set the logging level of
// its shim.
func SetLoggingLevel(level LoggingLevel) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[257], 1);
	shimLoggingLevel = level
	logging.SetLevel(logging.Level(level), "shim")
}

// LogLevel converts a case-insensitive string chosen from CRITICAL, ERROR,
// WARNING, NOTICE, INFO or DEBUG into an element of the LoggingLevel
// type. In the event of errors the level returned is LogError.
func LogLevel(levelString string) (LoggingLevel, error) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[258], 1);
	l, err := logging.LogLevel(levelString)
	level := LoggingLevel(l)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[260], 1);
		level = LogError
	}
	_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[259], 1);return level, err
}

// ------------- Chaincode Loggers ---------------

// ChaincodeLogger is an abstraction of a logging object for use by
// chaincodes. These objects are created by the NewLogger API.
type ChaincodeLogger struct {
	logger *logging.Logger
}

// NewLogger allows a Go language chaincode to create one or more logging
// objects whose logs will be formatted consistently with, and temporally
// interleaved with the logs created by the shim interface. The logs created
// by this object can be distinguished from shim logs by the name provided,
// which will appear in the logs.
func NewLogger(name string) *ChaincodeLogger {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[261], 1);
	return &ChaincodeLogger{logging.MustGetLogger(name)}
}

// SetLevel sets the logging level for a chaincode logger. Note that currently
// the levels are actually controlled by the name given when the logger is
// created, so loggers should be given unique names other than "shim".
func (c *ChaincodeLogger) SetLevel(level LoggingLevel) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[262], 1);
	logging.SetLevel(logging.Level(level), c.logger.Module)
}

// IsEnabledFor returns true if the logger is enabled to creates logs at the
// given logging level.
func (c *ChaincodeLogger) IsEnabledFor(level LoggingLevel) bool {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[263], 1);
	return c.logger.IsEnabledFor(logging.Level(level))
}

// Debug logs will only appear if the ChaincodeLogger LoggingLevel is set to
// LogDebug.
func (c *ChaincodeLogger) Debug(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[264], 1);
	c.logger.Debug(args...)
}

// Info logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogInfo or LogDebug.
func (c *ChaincodeLogger) Info(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[265], 1);
	c.logger.Info(args...)
}

// Notice logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Notice(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[266], 1);
	c.logger.Notice(args...)
}

// Warning logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogWarning, LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Warning(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[267], 1);
	c.logger.Warning(args...)
}

// Error logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogError, LogWarning, LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Error(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[268], 1);
	c.logger.Error(args...)
}

// Critical logs always appear; They can not be disabled.
func (c *ChaincodeLogger) Critical(args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[269], 1);
	c.logger.Critical(args...)
}

// Debugf logs will only appear if the ChaincodeLogger LoggingLevel is set to
// LogDebug.
func (c *ChaincodeLogger) Debugf(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[270], 1);
	c.logger.Debugf(format, args...)
}

// Infof logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogInfo or LogDebug.
func (c *ChaincodeLogger) Infof(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[271], 1);
	c.logger.Infof(format, args...)
}

// Noticef logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Noticef(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[272], 1);
	c.logger.Noticef(format, args...)
}

// Warningf logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogWarning, LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Warningf(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[273], 1);
	c.logger.Warningf(format, args...)
}

// Errorf logs will appear if the ChaincodeLogger LoggingLevel is set to
// LogError, LogWarning, LogNotice, LogInfo or LogDebug.
func (c *ChaincodeLogger) Errorf(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[274], 1);
	c.logger.Errorf(format, args...)
}

// Criticalf logs always appear; They can not be disabled.
func (c *ChaincodeLogger) Criticalf(format string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_323061643534336238336134.Count[275], 1);
	c.logger.Criticalf(format, args...)
}

var GoCover_0_323061643534336238336134 = struct {
	Count     [276]uint32
	Pos       [3 * 276]uint32
	NumStmt   [276]uint16
} {
	Pos: [3 * 276]uint32{
		82, 84, 0x27004a, // [0]
		105, 111, 0x100002, // [1]
		117, 123, 0x100002, // [2]
		127, 127, 0x140002, // [3]
		84, 89, 0x120027, // [4]
		94, 97, 0x120003, // [5]
		102, 102, 0x160003, // [6]
		89, 93, 0x40012, // [7]
		97, 101, 0x40012, // [8]
		111, 115, 0x30010, // [9]
		123, 125, 0x30010, // [10]
		131, 137, 0x190020, // [11]
		141, 142, 0x100002, // [12]
		147, 147, 0x190002, // [13]
		151, 152, 0x100002, // [14]
		156, 158, 0xc0002, // [15]
		137, 139, 0x30019, // [16]
		142, 144, 0x30010, // [17]
		147, 149, 0x30019, // [18]
		152, 154, 0x30010, // [19]
		163, 166, 0x20031, // [20]
		173, 175, 0x2001e, // [21]
		177, 189, 0x15001e, // [22]
		193, 200, 0x230002, // [23]
		205, 206, 0x100002, // [24]
		211, 218, 0x1e0002, // [25]
		229, 230, 0x520002, // [26]
		189, 191, 0x30015, // [27]
		200, 203, 0x30023, // [28]
		206, 209, 0x30010, // [29]
		218, 220, 0x11001e, // [30]
		220, 222, 0x40011, // [31]
		222, 224, 0x40009, // [32]
		234, 239, 0x1f003c, // [33]
		269, 269, 0x200002, // [34]
		239, 241, 0x15001f, // [35]
		242, 243, 0x3b000a, // [36]
		247, 250, 0x12000a, // [37]
		255, 255, 0x160004, // [38]
		264, 265, 0x5b000b, // [39]
		243, 246, 0x5003b, // [40]
		250, 252, 0xd0012, // [41]
		255, 257, 0x50016, // [42]
		257, 259, 0x24000a, // [43]
		259, 262, 0x60024, // [44]
		274, 278, 0x180087, // [45]
		285, 285, 0x190002, // [46]
		289, 292, 0xc0002, // [47]
		278, 279, 0x370018, // [48]
		279, 282, 0x90037, // [49]
		285, 287, 0x30019, // [50]
		295, 296, 0x17001e, // [51]
		300, 300, 0x460002, // [52]
		304, 304, 0x140002, // [53]
		296, 298, 0x30017, // [54]
		300, 302, 0x30046, // [55]
		307, 314, 0x27003a, // [56]
		318, 318, 0x530002, // [57]
		314, 317, 0x30027, // [58]
		321, 329, 0x100059, // [59]
		334, 335, 0x760002, // [60]
		340, 347, 0x1b0002, // [61]
		352, 353, 0x60002, // [62]
		329, 331, 0x30010, // [63]
		335, 337, 0x30076, // [64]
		347, 350, 0x3001b, // [65]
		353, 354, 0xa0006, // [66]
		355, 356, 0xb001b, // [67]
		380, 381, 0x16001a, // [68]
		357, 360, 0xf001c, // [69]
		361, 364, 0xf0019, // [70]
		365, 368, 0xf0019, // [71]
		369, 372, 0x13000c, // [72]
		377, 377, 0x180005, // [73]
		372, 375, 0x60013, // [74]
		381, 384, 0x50016, // [75]
		392, 404, 0x1b0095, // [76]
		424, 424, 0xc0002, // [77]
		404, 408, 0x11001b, // [78]
		413, 414, 0x110003, // [79]
		418, 419, 0x110003, // [80]
		408, 410, 0x40011, // [81]
		414, 416, 0x40011, // [82]
		419, 421, 0x40011, // [83]
		428, 430, 0x2002d, // [84]
		433, 435, 0x20032, // [85]
		437, 439, 0x2003f, // [86]
		444, 446, 0x13006d, // [87]
		449, 449, 0x5b0002, // [88]
		446, 448, 0x30013, // [89]
		455, 459, 0x20041, // [90]
		462, 464, 0x20055, // [91]
		467, 469, 0x100054, // [92]
		472, 472, 0x370002, // [93]
		475, 475, 0x110002, // [94]
		469, 471, 0x30010, // [95]
		472, 474, 0x30037, // [96]
		479, 480, 0xf0045, // [97]
		484, 485, 0x570002, // [98]
		480, 482, 0x3000f, // [99]
		488, 495, 0x20065, // [100]
		498, 505, 0x2005e, // [101]
		508, 512, 0x20037, // [102]
		517, 518, 0x16005a, // [103]
		521, 521, 0x500002, // [104]
		518, 520, 0x30016, // [105]
		525, 526, 0x16005e, // [106]
		529, 529, 0xf0002, // [107]
		532, 532, 0x570002, // [108]
		526, 528, 0x30016, // [109]
		529, 531, 0x3000f, // [110]
		536, 537, 0x160050, // [111]
		540, 540, 0x500002, // [112]
		537, 539, 0x30016, // [113]
		544, 545, 0x16007c, // [114]
		548, 548, 0x140002, // [115]
		551, 551, 0x3d0002, // [116]
		555, 557, 0x160002, // [117]
		545, 547, 0x30016, // [118]
		548, 550, 0x30014, // [119]
		551, 553, 0x3003d, // [120]
		560, 562, 0x100082, // [121]
		565, 568, 0x1e0002, // [122]
		562, 564, 0x30010, // [123]
		572, 573, 0x160099, // [124]
		577, 578, 0x100002, // [125]
		582, 584, 0x160002, // [126]
		573, 575, 0x30016, // [127]
		578, 580, 0x30010, // [128]
		588, 589, 0x160075, // [129]
		593, 595, 0x160002, // [130]
		589, 591, 0x30016, // [131]
		599, 601, 0x100066, // [132]
		604, 604, 0x370002, // [133]
		607, 607, 0x110002, // [134]
		601, 603, 0x30010, // [135]
		604, 606, 0x30037, // [136]
		611, 613, 0x20067, // [137]
		641, 644, 0x10005b, // [138]
		648, 648, 0x160002, // [139]
		644, 646, 0x30010, // [140]
		652, 655, 0x100053, // [141]
		659, 661, 0x100002, // [142]
		665, 665, 0x280002, // [143]
		655, 657, 0x30010, // [144]
		661, 663, 0x30010, // [145]
		669, 672, 0x100053, // [146]
		676, 678, 0x100002, // [147]
		682, 682, 0x280002, // [148]
		672, 674, 0x30010, // [149]
		678, 680, 0x30010, // [150]
		686, 687, 0x14006a, // [151]
		690, 690, 0x3d0002, // [152]
		693, 698, 0x160002, // [153]
		687, 689, 0x30014, // [154]
		690, 692, 0x3003d, // [155]
		702, 704, 0x100060, // [156]
		707, 707, 0x7a0002, // [157]
		704, 706, 0x30010, // [158]
		711, 713, 0x20067, // [159]
		716, 718, 0x2005d, // [160]
		720, 721, 0x420051, // [161]
		724, 725, 0x210002, // [162]
		731, 731, 0x100002, // [163]
		721, 723, 0x30042, // [164]
		725, 726, 0x3c0021, // [165]
		729, 729, 0x2a0003, // [166]
		726, 728, 0x4003c, // [167]
		734, 737, 0x290047, // [168]
		743, 743, 0x2b0002, // [169]
		737, 738, 0x2d0029, // [170]
		738, 741, 0x4002d, // [171]
		746, 747, 0x1c0036, // [172]
		750, 750, 0x240002, // [173]
		756, 756, 0xc0002, // [174]
		747, 749, 0x3001c, // [175]
		750, 751, 0x4b0024, // [176]
		751, 754, 0x4004b, // [177]
		763, 764, 0x210035, // [178]
		769, 769, 0xc0002, // [179]
		764, 765, 0x390021, // [180]
		765, 767, 0x40039, // [181]
		778, 781, 0x100087, // [182]
		785, 787, 0x160002, // [183]
		781, 783, 0x30010, // [184]
		790, 794, 0x10004b, // [185]
		797, 797, 0x1b0002, // [186]
		794, 796, 0x30010, // [187]
		801, 803, 0x140053, // [188]
		806, 806, 0x3d0002, // [189]
		810, 813, 0x100002, // [190]
		817, 817, 0x4b0002, // [191]
		803, 805, 0x30014, // [192]
		806, 808, 0x3003d, // [193]
		813, 815, 0x30010, // [194]
		821, 826, 0x100063, // [195]
		830, 831, 0x100002, // [196]
		834, 834, 0x4b0002, // [197]
		826, 828, 0x30010, // [198]
		831, 833, 0x30010, // [199]
		838, 843, 0x100053, // [200]
		846, 846, 0x3f0002, // [201]
		843, 845, 0x30010, // [202]
		849, 850, 0x440041, // [203]
		850, 852, 0x30044, // [204]
		852, 854, 0x30008, // [205]
		857, 858, 0x460050, // [206]
		858, 860, 0x30046, // [207]
		860, 862, 0x30008, // [208]
		866, 867, 0x4b002c, // [209]
		870, 870, 0xe0002, // [210]
		867, 869, 0x3004b, // [211]
		878, 880, 0x210036, // [212]
		894, 894, 0x2d0002, // [213]
		880, 882, 0x590021, // [214]
		885, 885, 0x1f0003, // [215]
		882, 884, 0x40059, // [216]
		887, 887, 0x2a0008, // [217]
		887, 889, 0x5b002a, // [218]
		892, 892, 0x210003, // [219]
		889, 891, 0x4005b, // [220]
		897, 898, 0x71003a, // [221]
		898, 902, 0x30071, // [222]
		902, 904, 0x30008, // [223]
		910, 911, 0x32005c, // [224]
		936, 936, 0x320002, // [225]
		911, 914, 0x110032, // [226]
		918, 920, 0x4d0003, // [227]
		928, 928, 0x1a0003, // [228]
		914, 917, 0x40011, // [229]
		920, 922, 0x35004d, // [230]
		922, 925, 0x50035, // [231]
		929, 929, 0x230008, // [232]
		929, 932, 0x30023, // [233]
		940, 943, 0x2002b, // [234]
		946, 948, 0x2002f, // [235]
		951, 954, 0x1c0035, // [236]
		957, 957, 0x100002, // [237]
		954, 956, 0x3001c, // [238]
		961, 965, 0x17005a, // [239]
		969, 969, 0x80002, // [240]
		965, 968, 0x30017, // [241]
		973, 975, 0x20039, // [242]
		978, 980, 0x20046, // [243]
		983, 985, 0x20039, // [244]
		988, 990, 0x2004c, // [245]
		993, 996, 0x1c003b, // [246]
		999, 999, 0x110002, // [247]
		996, 998, 0x3001c, // [248]
		1003, 1005, 0x10004b, // [249]
		1008, 1009, 0x100002, // [250]
		1013, 1013, 0x210002, // [251]
		1005, 1007, 0x30010, // [252]
		1009, 1011, 0x30010, // [253]
		1019, 1020, 0x100048, // [254]
		1023, 1024, 0xc0002, // [255]
		1020, 1022, 0x30010, // [256]
		1075, 1078, 0x2002a, // [257]
		1083, 1086, 0x100039, // [258]
		1089, 1089, 0x130002, // [259]
		1086, 1088, 0x30010, // [260]
		1105, 1107, 0x2002e, // [261]
		1112, 1114, 0x20038, // [262]
		1118, 1120, 0x20041, // [263]
		1124, 1126, 0x20036, // [264]
		1130, 1132, 0x20035, // [265]
		1136, 1138, 0x20037, // [266]
		1142, 1144, 0x20038, // [267]
		1148, 1150, 0x20036, // [268]
		1153, 1155, 0x20039, // [269]
		1159, 1161, 0x20046, // [270]
		1165, 1167, 0x20045, // [271]
		1171, 1173, 0x20047, // [272]
		1177, 1179, 0x20048, // [273]
		1183, 1185, 0x20046, // [274]
		1188, 1190, 0x20049, // [275]
	},
	NumStmt: [276]uint16{
		2, // 0
		4, // 1
		4, // 2
		1, // 3
		4, // 4
		3, // 5
		1, // 6
		3, // 7
		3, // 8
		3, // 9
		1, // 10
		3, // 11
		2, // 12
		1, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		2, // 20
		1, // 21
		8, // 22
		6, // 23
		2, // 24
		3, // 25
		2, // 26
		1, // 27
		2, // 28
		2, // 29
		2, // 30
		1, // 31
		1, // 32
		4, // 33
		1, // 34
		2, // 35
		1, // 36
		2, // 37
		1, // 38
		1, // 39
		2, // 40
		2, // 41
		1, // 42
		2, // 43
		2, // 44
		3, // 45
		1, // 46
		4, // 47
		1, // 48
		3, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		3, // 56
		1, // 57
		1, // 58
		5, // 59
		2, // 60
		4, // 61
		2, // 62
		1, // 63
		1, // 64
		2, // 65
		1, // 66
		1, // 67
		1, // 68
		3, // 69
		3, // 70
		3, // 71
		3, // 72
		1, // 73
		2, // 74
		2, // 75
		8, // 76
		1, // 77
		3, // 78
		2, // 79
		2, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		2, // 90
		1, // 91
		2, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		2, // 98
		1, // 99
		1, // 100
		3, // 101
		2, // 102
		1, // 103
		1, // 104
		1, // 105
		1, // 106
		1, // 107
		1, // 108
		1, // 109
		1, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		2, // 117
		1, // 118
		1, // 119
		1, // 120
		2, // 121
		3, // 122
		1, // 123
		1, // 124
		2, // 125
		2, // 126
		1, // 127
		1, // 128
		1, // 129
		2, // 130
		1, // 131
		2, // 132
		1, // 133
		1, // 134
		1, // 135
		1, // 136
		1, // 137
		3, // 138
		1, // 139
		1, // 140
		2, // 141
		3, // 142
		1, // 143
		1, // 144
		1, // 145
		2, // 146
		3, // 147
		1, // 148
		1, // 149
		1, // 150
		1, // 151
		1, // 152
		3, // 153
		1, // 154
		1, // 155
		2, // 156
		1, // 157
		1, // 158
		1, // 159
		1, // 160
		1, // 161
		2, // 162
		1, // 163
		1, // 164
		1, // 165
		1, // 166
		1, // 167
		3, // 168
		1, // 169
		1, // 170
		2, // 171
		1, // 172
		1, // 173
		1, // 174
		1, // 175
		1, // 176
		1, // 177
		1, // 178
		1, // 179
		1, // 180
		1, // 181
		3, // 182
		2, // 183
		1, // 184
		3, // 185
		1, // 186
		1, // 187
		1, // 188
		1, // 189
		3, // 190
		1, // 191
		1, // 192
		1, // 193
		1, // 194
		3, // 195
		2, // 196
		1, // 197
		1, // 198
		1, // 199
		3, // 200
		1, // 201
		1, // 202
		1, // 203
		1, // 204
		1, // 205
		1, // 206
		1, // 207
		1, // 208
		1, // 209
		1, // 210
		1, // 211
		1, // 212
		1, // 213
		2, // 214
		1, // 215
		1, // 216
		1, // 217
		2, // 218
		1, // 219
		1, // 220
		1, // 221
		3, // 222
		1, // 223
		1, // 224
		1, // 225
		2, // 226
		2, // 227
		1, // 228
		2, // 229
		1, // 230
		2, // 231
		1, // 232
		1, // 233
		2, // 234
		1, // 235
		3, // 236
		1, // 237
		1, // 238
		4, // 239
		1, // 240
		2, // 241
		1, // 242
		1, // 243
		1, // 244
		1, // 245
		3, // 246
		1, // 247
		1, // 248
		2, // 249
		2, // 250
		1, // 251
		1, // 252
		1, // 253
		1, // 254
		2, // 255
		1, // 256
		2, // 257
		3, // 258
		1, // 259
		1, // 260
		1, // 261
		1, // 262
		1, // 263
		1, // 264
		1, // 265
		1, // 266
		1, // 267
		1, // 268
		1, // 269
		1, // 270
		1, // 271
		1, // 272
		1, // 273
		1, // 274
		1, // 275
	},
}
var _ = _cover_atomic_.LoadUint32
