//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/handler_registry.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"sync"

	"github.com/pkg/errors"
)

// HandlerRegistry maintains chaincode Handler instances.
type HandlerRegistry struct {
	allowUnsolicitedRegistration bool // from cs.userRunsCC

	mutex     sync.Mutex              // lock covering handlers and launching
	handlers  map[string]*Handler     // chaincode cname to associated handler
	launching map[string]*LaunchState // launching chaincodes to LaunchState
}

type LaunchState struct {
	mutex    sync.Mutex
	notified bool
	done     chan struct{}
	err      error
}

func NewLaunchState() *LaunchState {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[0], 1);
	return &LaunchState{
		done: make(chan struct{}),
	}
}

func (l *LaunchState) Done() <-chan struct{} {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[1], 1);
	return l.done
}

func (l *LaunchState) Err() error {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[2], 1);
	l.mutex.Lock()
	err := l.err
	l.mutex.Unlock()
	return err
}

func (l *LaunchState) Notify(err error) {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[3], 1);
	l.mutex.Lock()
	if !l.notified {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[5], 1);
		l.notified = true
		l.err = err
		close(l.done)
	}
	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[4], 1);l.mutex.Unlock()
}

// NewHandlerRegistry constructs a HandlerRegistry.
func NewHandlerRegistry(allowUnsolicitedRegistration bool) *HandlerRegistry {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[6], 1);
	return &HandlerRegistry{
		handlers:                     map[string]*Handler{},
		launching:                    map[string]*LaunchState{},
		allowUnsolicitedRegistration: allowUnsolicitedRegistration,
	}
}

// Launching indicates that chaincode is being launched. The LaunchState that
// is returned provides mechanisms to determine when the operation has
// completed and whether or not it failed. The bool indicates whether or not
// the chaincode has already been started.
func (r *HandlerRegistry) Launching(cname string) (*LaunchState, bool) {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[7], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()

	// launch happened or already happening
	if launchState, ok := r.launching[cname]; ok {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[10], 1);
		return launchState, true
	}

	// handler registered without going through launch
	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[8], 1);if _, ok := r.handlers[cname]; ok {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[11], 1);
		launchState := NewLaunchState()
		launchState.Notify(nil)
		return launchState, true
	}

	// first attempt to launch so the runtime needs to start
	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[9], 1);launchState := NewLaunchState()
	r.launching[cname] = launchState
	return launchState, false
}

// Ready indicates that the chaincode registration has completed and the
// READY response has been sent to the chaincode.
func (r *HandlerRegistry) Ready(cname string) {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[12], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()

	launchStatus := r.launching[cname]
	if launchStatus != nil {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[13], 1);
		launchStatus.Notify(nil)
	}
}

// Failed indicates that registration of a launched chaincode has failed.
func (r *HandlerRegistry) Failed(cname string, err error) {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[14], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()

	launchStatus := r.launching[cname]
	if launchStatus != nil {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[15], 1);
		launchStatus.Notify(err)
	}
}

// Handler retrieves the handler for a chaincode instance.
func (r *HandlerRegistry) Handler(cname string) *Handler {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[16], 1);
	r.mutex.Lock()
	h := r.handlers[cname]
	r.mutex.Unlock()
	return h
}

// Register adds a chaincode handler to the registry.
// An error will be returned if a handler is already registered for the
// chaincode. An error will also be returned if the chaincode has not already
// been "launched", and unsolicited registration is not allowed.
func (r *HandlerRegistry) Register(h *Handler) error {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[17], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()
	key := h.chaincodeID.Name

	if r.handlers[key] != nil {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[20], 1);
		chaincodeLogger.Debugf("duplicate registered handler(key:%s) return error", key)
		return errors.Errorf("duplicate chaincodeID: %s", h.chaincodeID.Name)
	}

	// This chaincode was not launched by the peer but is attempting
	// to register. Only allowed in development mode.
	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[18], 1);if r.launching[key] == nil && !r.allowUnsolicitedRegistration {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[21], 1);
		return errors.Errorf("peer will not accept external chaincode connection %v (except in dev mode)", h.chaincodeID.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[19], 1);r.handlers[key] = h

	chaincodeLogger.Debugf("registered handler complete for chaincode %s", key)
	return nil
}

// Deregister clears references to state associated specified chaincode.
// As part of the cleanup, it closes the handler so it can cleanup any state.
// If the registry does not contain the provided handler, an error is returned.
func (r *HandlerRegistry) Deregister(cname string) error {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[22], 1);
	chaincodeLogger.Debugf("deregister handler: %s", cname)

	r.mutex.Lock()
	handler := r.handlers[cname]
	delete(r.handlers, cname)
	delete(r.launching, cname)
	r.mutex.Unlock()

	if handler == nil {_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[24], 1);
		return errors.Errorf("could not find handler: %s", cname)
	}

	_cover_atomic_.AddUint32(&GoCover_6_323839383963343337363361.Count[23], 1);handler.Close()

	chaincodeLogger.Debugf("deregistered handler with key: %s", cname)
	return nil
}

var GoCover_6_323839383963343337363361 = struct {
	Count     [25]uint32
	Pos       [3 * 25]uint32
	NumStmt   [25]uint16
} {
	Pos: [3 * 25]uint32{
		31, 35, 0x20024, // [0]
		37, 39, 0x2002e, // [1]
		41, 46, 0x20023, // [2]
		48, 50, 0x110029, // [3]
		55, 55, 0x120002, // [4]
		50, 54, 0x30011, // [5]
		59, 65, 0x2004d, // [6]
		71, 76, 0x2f0048, // [7]
		81, 81, 0x240002, // [8]
		88, 90, 0x1b0002, // [9]
		76, 78, 0x3002f, // [10]
		81, 85, 0x30024, // [11]
		95, 100, 0x19002f, // [12]
		100, 102, 0x30019, // [13]
		106, 111, 0x19003b, // [14]
		111, 113, 0x30019, // [15]
		117, 122, 0x2003a, // [16]
		128, 133, 0x1c0036, // [17]
		140, 140, 0x400002, // [18]
		144, 147, 0xc0002, // [19]
		133, 136, 0x3001c, // [20]
		140, 142, 0x30040, // [21]
		153, 162, 0x14003a, // [22]
		166, 169, 0xc0002, // [23]
		162, 164, 0x30014, // [24]
	},
	NumStmt: [25]uint16{
		1, // 0
		1, // 1
		4, // 2
		2, // 3
		1, // 4
		3, // 5
		1, // 6
		3, // 7
		1, // 8
		3, // 9
		1, // 10
		3, // 11
		4, // 12
		1, // 13
		4, // 14
		1, // 15
		4, // 16
		4, // 17
		1, // 18
		3, // 19
		2, // 20
		1, // 21
		7, // 22
		3, // 23
		1, // 24
	},
}
var _ = _cover_atomic_.LoadUint32
