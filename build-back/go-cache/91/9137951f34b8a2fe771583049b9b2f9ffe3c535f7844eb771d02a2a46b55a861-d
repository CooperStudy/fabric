//line /home/cooper/go/src/github.com/hyperledger/fabric/core/handlers/validation/builtin/default_validation.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package builtin; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"reflect"

	commonerrors "github.com/hyperledger/fabric/common/errors"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/handlers/validation/api"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/capabilities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/identities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/policies"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/state"
	"github.com/hyperledger/fabric/core/handlers/validation/builtin/v12"
	"github.com/hyperledger/fabric/core/handlers/validation/builtin/v13"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("vscc")

type DefaultValidationFactory struct {
}

func (*DefaultValidationFactory) New() validation.Plugin {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[0], 1);
	return &DefaultValidation{}
}

type DefaultValidation struct {
	Capabilities    Capabilities
	TxValidatorV1_2 TransactionValidator
	TxValidatorV1_3 TransactionValidator
}

//go:generate mockery -dir . -name TransactionValidator -case underscore -output mocks/
type TransactionValidator interface {
	Validate(block *common.Block, namespace string, txPosition int, actionPosition int, policy []byte) commonerrors.TxValidationError
}

func (v *DefaultValidation) Validate(block *common.Block, namespace string, txPosition int, actionPosition int, contextData ...validation.ContextDatum) error {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[1], 1);
	if len(contextData) == 0 {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[8], 1);
		logger.Panicf("Expected to receive policy bytes in context data")
	}

	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[2], 1);serializedPolicy, isSerializedPolicy := contextData[0].(SerializedPolicy)
	if !isSerializedPolicy {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[9], 1);
		logger.Panicf("Expected to receive a serialized policy in the first context data")
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[3], 1);if block == nil || block.Data == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[10], 1);
		return errors.New("empty block")
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[4], 1);if txPosition >= len(block.Data.Data) {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[11], 1);
		return errors.Errorf("block has only %d transactions, but requested tx at position %d", len(block.Data.Data), txPosition)
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[5], 1);if block.Header == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[12], 1);
		return errors.Errorf("no block header")
	}

	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[6], 1);var err error
	switch {
	case v.Capabilities.V1_3Validation():_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[13], 1);
		err = v.TxValidatorV1_3.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())

	case v.Capabilities.V1_2Validation():_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[14], 1);
		fallthrough

	default:_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[15], 1);
		err = v.TxValidatorV1_2.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())
	}

	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[7], 1);logger.Debugf("block %d, namespace: %s, tx %d validation results is: %v", block.Header.Number, namespace, txPosition, err)
	return convertErrorTypeOrPanic(err)
}

func convertErrorTypeOrPanic(err error) error {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[16], 1);
	if err == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[20], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[17], 1);if err, isExecutionError := err.(*commonerrors.VSCCExecutionFailureError); isExecutionError {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[21], 1);
		return &validation.ExecutionFailureError{
			Reason: err.Error(),
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[18], 1);if err, isEndorsementError := err.(*commonerrors.VSCCEndorsementPolicyError); isEndorsementError {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[22], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[19], 1);logger.Panicf("Programming error: The error is %v, of type %v but expected to be either ExecutionFailureError or VSCCEndorsementPolicyError", err, reflect.TypeOf(err))
	return &validation.ExecutionFailureError{Reason: fmt.Sprintf("error of type %v returned from VSCC", reflect.TypeOf(err))}
}

func (v *DefaultValidation) Init(dependencies ...validation.Dependency) error {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[23], 1);
	var (
		d  IdentityDeserializer
		c  Capabilities
		sf StateFetcher
		pe PolicyEvaluator
	)
	for _, dep := range dependencies {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[29], 1);
		if deserializer, isIdentityDeserializer := dep.(IdentityDeserializer); isIdentityDeserializer {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[33], 1);
			d = deserializer
		}
		_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[30], 1);if capabilities, isCapabilities := dep.(Capabilities); isCapabilities {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[34], 1);
			c = capabilities
		}
		_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[31], 1);if stateFetcher, isStateFetcher := dep.(StateFetcher); isStateFetcher {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[35], 1);
			sf = stateFetcher
		}
		_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[32], 1);if policyEvaluator, isPolicyFetcher := dep.(PolicyEvaluator); isPolicyFetcher {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[36], 1);
			pe = policyEvaluator
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[24], 1);if sf == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[37], 1);
		return errors.New("stateFetcher not passed in init")
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[25], 1);if d == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[38], 1);
		return errors.New("identityDeserializer not passed in init")
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[26], 1);if c == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[39], 1);
		return errors.New("capabilities not passed in init")
	}
	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[27], 1);if pe == nil {_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[40], 1);
		return errors.New("policy fetcher not passed in init")
	}

	_cover_atomic_.AddUint32(&GoCover_0_356234613134613133313339.Count[28], 1);v.Capabilities = c
	v.TxValidatorV1_2 = v12.New(c, sf, d, pe)
	v.TxValidatorV1_3 = v13.New(c, sf, d, pe)

	return nil
}

var GoCover_0_356234613134613133313339 = struct {
	Count     [41]uint32
	Pos       [3 * 41]uint32
	NumStmt   [41]uint16
} {
	Pos: [3 * 41]uint32{
		31, 33, 0x2003a, // [0]
		46, 47, 0x1b009f, // [1]
		51, 52, 0x190002, // [2]
		55, 55, 0x270002, // [3]
		58, 58, 0x280002, // [4]
		61, 61, 0x190002, // [5]
		65, 66, 0x90002, // [6]
		77, 78, 0x250002, // [7]
		47, 49, 0x3001b, // [8]
		52, 54, 0x30019, // [9]
		55, 57, 0x30027, // [10]
		58, 60, 0x30028, // [11]
		61, 63, 0x30019, // [12]
		67, 68, 0x6b0027, // [13]
		70, 71, 0xe0027, // [14]
		73, 74, 0x6b000a, // [15]
		81, 82, 0x10002f, // [16]
		85, 85, 0x5e0002, // [17]
		90, 90, 0x630002, // [18]
		93, 94, 0x7b0002, // [19]
		82, 84, 0x30010, // [20]
		85, 89, 0x3005e, // [21]
		90, 92, 0x30063, // [22]
		97, 104, 0x23004f, // [23]
		118, 118, 0xf0002, // [24]
		121, 121, 0xe0002, // [25]
		124, 124, 0xe0002, // [26]
		127, 127, 0xf0002, // [27]
		131, 135, 0xc0002, // [28]
		104, 105, 0x610023, // [29]
		108, 108, 0x490003, // [30]
		111, 111, 0x490003, // [31]
		114, 114, 0x510003, // [32]
		105, 107, 0x40061, // [33]
		108, 110, 0x40049, // [34]
		111, 113, 0x40049, // [35]
		114, 116, 0x40051, // [36]
		118, 120, 0x3000f, // [37]
		121, 123, 0x3000e, // [38]
		124, 126, 0x3000e, // [39]
		127, 129, 0x3000f, // [40]
	},
	NumStmt: [41]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		4, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
	},
}
var _ = _cover_atomic_.LoadUint32
