//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/cluster/util.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cluster; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/hex"
	"encoding/pem"
	"reflect"
	"sync/atomic"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/configtx"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"google.golang.org/grpc"
)

// ConnByCertMap maps certificates represented as strings
// to gRPC connections
type ConnByCertMap map[string]*grpc.ClientConn

// Lookup looks up a certificate and returns the connection that was mapped
// to the certificate, and whether it was found or not
func (cbc ConnByCertMap) Lookup(cert []byte) (*grpc.ClientConn, bool) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[0], 1);
	conn, ok := cbc[string(cert)]
	return conn, ok
}

// Put associates the given connection to the certificate
func (cbc ConnByCertMap) Put(cert []byte, conn *grpc.ClientConn) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[1], 1);
	cbc[string(cert)] = conn
}

// Remove removes the connection that is associated to the given certificate
func (cbc ConnByCertMap) Remove(cert []byte) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[2], 1);
	delete(cbc, string(cert))
}

// MemberMapping defines NetworkMembers by their ID
type MemberMapping map[uint64]*Stub

// Put inserts the given stub to the MemberMapping
func (mp MemberMapping) Put(stub *Stub) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[3], 1);
	mp[stub.ID] = stub
}

// ByID retrieves the Stub with the given ID from the MemberMapping
func (mp MemberMapping) ByID(ID uint64) *Stub {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[4], 1);
	return mp[ID]
}

// LookupByClientCert retrieves a Stub with the given client certificate
func (mp MemberMapping) LookupByClientCert(cert []byte) *Stub {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[5], 1);
	for _, stub := range mp {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[7], 1);
		if bytes.Equal(stub.ClientTLSCert, cert) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[8], 1);
			return stub
		}
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[6], 1);return nil
}

// ServerCertificates returns a set of the server certificates
// represented as strings
func (mp MemberMapping) ServerCertificates() StringSet {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[9], 1);
	res := make(StringSet)
	for _, member := range mp {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[11], 1);
		res[string(member.ServerTLSCert)] = struct{}{}
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[10], 1);return res
}

// StringSet is a set of strings
type StringSet map[string]struct{}

// union adds the elements of the given set to the StringSet
func (ss StringSet) union(set StringSet) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[12], 1);
	for k := range set {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[13], 1);
		ss[k] = struct{}{}
	}
}

// subtract removes all elements in the given set from the StringSet
func (ss StringSet) subtract(set StringSet) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[14], 1);
	for k := range set {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[15], 1);
		delete(ss, k)
	}
}

// PredicateDialer creates gRPC connections
// that are only established if the given predicate
// is fulfilled
type PredicateDialer struct {
	Config atomic.Value
}

// NewTLSPinningDialer creates a new PredicateDialer
func NewTLSPinningDialer(config comm.ClientConfig) *PredicateDialer {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[16], 1);
	d := &PredicateDialer{}
	d.SetConfig(config)
	return d
}

// ClientConfig returns the comm.ClientConfig, or an error
// if they cannot be extracted.
func (dialer *PredicateDialer) ClientConfig() (comm.ClientConfig, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[17], 1);
	val := dialer.Config.Load()
	if val == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[21], 1);
		return comm.ClientConfig{}, errors.New("client config not initialized")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[18], 1);cc, isClientConfig := val.(comm.ClientConfig)
	if !isClientConfig {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[22], 1);
		err := errors.Errorf("value stored is %v, not comm.ClientConfig",
			reflect.TypeOf(val))
		return comm.ClientConfig{}, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[19], 1);if cc.SecOpts == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[23], 1);
		return comm.ClientConfig{}, errors.New("SecOpts is nil")
	}
	// Copy by value the secure options
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[20], 1);secOpts := *cc.SecOpts
	return comm.ClientConfig{
		AsyncConnect: cc.AsyncConnect,
		Timeout:      cc.Timeout,
		SecOpts:      &secOpts,
		KaOpts:       cc.KaOpts,
	}, nil
}

// SetConfig sets the configuration of the PredicateDialer
func (dialer *PredicateDialer) SetConfig(config comm.ClientConfig) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[24], 1);
	configCopy := comm.ClientConfig{
		AsyncConnect: config.AsyncConnect,
		Timeout:      config.Timeout,
		SecOpts:      &comm.SecureOptions{},
		KaOpts:       &comm.KeepaliveOptions{},
	}
	// Explicitly copy configuration
	if config.SecOpts != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[27], 1);
		*configCopy.SecOpts = *config.SecOpts
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[25], 1);if config.KaOpts != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[28], 1);
		*configCopy.KaOpts = *config.KaOpts
	} else{ _cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[29], 1);{
		configCopy.KaOpts = nil
	}}

	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[26], 1);dialer.Config.Store(configCopy)
}

// Dial creates a new gRPC connection that can only be established, if the remote node's
// certificate chain satisfy verifyFunc
func (dialer *PredicateDialer) Dial(address string, verifyFunc RemoteVerifier) (*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[30], 1);
	cfg := dialer.Config.Load().(comm.ClientConfig)
	cfg.SecOpts.VerifyCertificate = verifyFunc
	client, err := comm.NewGRPCClient(cfg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[32], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[31], 1);return client.NewConnection(address, "")
}

// DERtoPEM returns a PEM representation of the DER
// encoded certificate
func DERtoPEM(der []byte) string {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[33], 1);
	return string(pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: der,
	}))
}

// StandardDialer wraps a PredicateDialer
// to a standard cluster.Dialer that passes in a nil verify function
type StandardDialer struct {
	Dialer *PredicateDialer
}

// Dial dials to the given address
func (bdp *StandardDialer) Dial(address string) (*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[34], 1);
	return bdp.Dialer.Dial(address, nil)
}

//go:generate mockery -dir . -name BlockVerifier -case underscore -output ./mocks/

// BlockVerifier verifies block signatures.
type BlockVerifier interface {
	// VerifyBlockSignature verifies a signature of a block.
	// It has an optional argument of a configuration envelope
	// which would make the block verification to use validation rules
	// based on the given configuration in the ConfigEnvelope.
	// If the config envelope passed is nil, then the validation rules used
	// are the ones that were applied at commit of previous blocks.
	VerifyBlockSignature(sd []*common.SignedData, config *common.ConfigEnvelope) error
}

// BlockSequenceVerifier verifies that the given consecutive sequence
// of blocks is valid.
type BlockSequenceVerifier func([]*common.Block) error

// Dialer creates a gRPC connection to a remote address
type Dialer interface {
	Dial(address string) (*grpc.ClientConn, error)
}

// VerifyBlocks verifies the given consecutive sequence of blocks is valid,
// and returns nil if it's valid, else an error.
func VerifyBlocks(blockBuff []*common.Block, signatureVerifier BlockVerifier) error {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[35], 1);
	if len(blockBuff) == 0 {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[39], 1);
		return errors.New("buffer is empty")
	}
	// First, we verify that the block hash in every block is:
	// Equal to the hash in the header
	// Equal to the previous hash in the succeeding block
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[36], 1);for i := range blockBuff {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[40], 1);
		if err := VerifyBlockHash(i, blockBuff); err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[41], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[37], 1);var config *common.ConfigEnvelope
	// Verify all configuration blocks that are found inside the block batch,
	// with the configuration that was committed (nil) or with one that is picked up
	// during iteration over the block batch.
	for _, block := range blockBuff {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[42], 1);
		configFromBlock, err := ConfigFromBlock(block)
		if err == errNotAConfig {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[46], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[43], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[47], 1);
			return err
		}
		// The block is a configuration block, so verify it
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[44], 1);if err := VerifyBlockSignature(block, signatureVerifier, config); err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[48], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[45], 1);config = configFromBlock
	}

	// Verify the last block's signature
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[38], 1);lastBlock := blockBuff[len(blockBuff)-1]
	return VerifyBlockSignature(lastBlock, signatureVerifier, config)
}

var errNotAConfig = errors.New("not a config block")

// ConfigFromBlock returns a ConfigEnvelope if exists, or a *NotAConfigBlock error.
// It may also return some other error in case parsing failed.
func ConfigFromBlock(block *common.Block) (*common.ConfigEnvelope, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[49], 1);
	if block == nil || block.Data == nil || len(block.Data.Data) == 0 {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[57], 1);
		return nil, errors.New("empty block")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[50], 1);txn := block.Data.Data[0]
	env, err := utils.GetEnvelopeFromBlock(txn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[58], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[51], 1);payload, err := utils.GetPayload(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[59], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[52], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[60], 1);
		return nil, errors.New("nil header in payload")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[53], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[61], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[54], 1);if common.HeaderType(chdr.Type) != common.HeaderType_CONFIG {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[62], 1);
		return nil, errNotAConfig
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[55], 1);configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[63], 1);
		return nil, errors.Wrap(err, "invalid config envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[56], 1);return configEnvelope, nil
}

// VerifyBlockHash verifies the hash chain of the block with the given index
// among the blocks of the given block buffer.
func VerifyBlockHash(indexInBuffer int, blockBuff []*common.Block) error {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[64], 1);
	if len(blockBuff) <= indexInBuffer {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[69], 1);
		return errors.Errorf("index %d out of bounds (total %d blocks)", indexInBuffer, len(blockBuff))
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[65], 1);block := blockBuff[indexInBuffer]
	if block.Header == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[70], 1);
		return errors.New("missing block header")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[66], 1);seq := block.Header.Number
	dataHash := block.Data.Hash()
	// Verify data hash matches the hash in the header
	if !bytes.Equal(dataHash, block.Header.DataHash) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[71], 1);
		computedHash := hex.EncodeToString(dataHash)
		claimedHash := hex.EncodeToString(block.Header.DataHash)
		return errors.Errorf("computed hash of block (%d) (%s) doesn't match claimed hash (%s)",
			seq, computedHash, claimedHash)
	}
	// We have a previous block in the buffer, ensure current block's previous hash matches the previous one.
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[67], 1);if indexInBuffer > 0 {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[72], 1);
		prevBlock := blockBuff[indexInBuffer-1]
		currSeq := block.Header.Number
		if prevBlock.Header == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[75], 1);
			return errors.New("previous block header is nil")
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[73], 1);prevSeq := prevBlock.Header.Number
		if prevSeq+1 != currSeq {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[76], 1);
			return errors.Errorf("sequences %d and %d were received consecutively", prevSeq, currSeq)
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[74], 1);if !bytes.Equal(block.Header.PreviousHash, prevBlock.Header.Hash()) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[77], 1);
			claimedPrevHash := hex.EncodeToString(block.Header.PreviousHash)
			actualPrevHash := hex.EncodeToString(prevBlock.Header.Hash())
			return errors.Errorf("block %d's hash (%s) mismatches %d's prev block hash (%s)",
				currSeq, actualPrevHash, prevSeq, claimedPrevHash)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[68], 1);return nil
}

// SignatureSetFromBlock creates a signature set out of a block.
func SignatureSetFromBlock(block *common.Block) ([]*common.SignedData, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[78], 1);
	if block.Metadata == nil || len(block.Metadata.Metadata) <= int(common.BlockMetadataIndex_SIGNATURES) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[82], 1);
		return nil, errors.New("no metadata in block")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[79], 1);metadata, err := utils.GetMetadataFromBlock(block, common.BlockMetadataIndex_SIGNATURES)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[83], 1);
		return nil, errors.Errorf("failed unmarshaling medatata for signatures: %v", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[80], 1);var signatureSet []*common.SignedData
	for _, metadataSignature := range metadata.Signatures {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[84], 1);
		sigHdr, err := utils.GetSignatureHeader(metadataSignature.SignatureHeader)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[86], 1);
			return nil, errors.Errorf("failed unmarshaling signature header for block with id %d: %v",
				block.Header.Number, err)
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[85], 1);signatureSet = append(signatureSet,
			&common.SignedData{
				Identity: sigHdr.Creator,
				Data: util.ConcatenateBytes(metadata.Value,
					metadataSignature.SignatureHeader, block.Header.Bytes()),
				Signature: metadataSignature.Signature,
			},
		)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[81], 1);return signatureSet, nil
}

// VerifyBlockSignature verifies the signature on the block with the given BlockVerifier and the given config.
func VerifyBlockSignature(block *common.Block, verifier BlockVerifier, config *common.ConfigEnvelope) error {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[87], 1);
	signatureSet, err := SignatureSetFromBlock(block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[89], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[88], 1);return verifier.VerifyBlockSignature(signatureSet, config)
}

// EndpointConfig defines a configuration
// of endpoints of ordering service nodes
type EndpointConfig struct {
	TLSRootCAs [][]byte
	Endpoints  []string
}

// EndpointconfigFromConfigBlock retrieves TLS CA certificates and endpoints
// from a config block.
func EndpointconfigFromConfigBlock(block *common.Block) (*EndpointConfig, error) {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[90], 1);
	if block == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[97], 1);
		return nil, errors.New("nil block")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[91], 1);envelopeConfig, err := utils.ExtractEnvelope(block, 0)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[98], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[92], 1);var tlsCACerts [][]byte
	bundle, err := channelconfig.NewBundleFromEnvelope(envelopeConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[99], 1);
		return nil, errors.Wrap(err, "failed extracting bundle from envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[93], 1);msps, err := bundle.MSPManager().GetMSPs()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[100], 1);
		return nil, errors.Wrap(err, "failed obtaining MSPs from MSPManager")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[94], 1);ordererConfig, ok := bundle.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[101], 1);
		return nil, errors.New("failed obtaining orderer config from bundle")
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[95], 1);for _, org := range ordererConfig.Organizations() {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[102], 1);
		msp := msps[org.MSPID()]
		if msp == nil {_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[104], 1);
			return nil, errors.Errorf("no MSP found for MSP with ID of %s", org.MSPID())
		}
		_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[103], 1);tlsCACerts = append(tlsCACerts, msp.GetTLSRootCerts()...)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363733313532663932376566.Count[96], 1);return &EndpointConfig{
		Endpoints:  bundle.ChannelConfig().OrdererAddresses(),
		TLSRootCAs: tlsCACerts,
	}, nil
}

var GoCover_6_363733313532663932376566 = struct {
	Count     [105]uint32
	Pos       [3 * 105]uint32
	NumStmt   [105]uint16
} {
	Pos: [3 * 105]uint32{
		32, 35, 0x20047, // [0]
		38, 40, 0x20042, // [1]
		43, 45, 0x2002e, // [2]
		51, 53, 0x20029, // [3]
		56, 58, 0x2002f, // [4]
		61, 62, 0x1a003f, // [5]
		67, 67, 0xc0002, // [6]
		62, 63, 0x2c001a, // [7]
		63, 65, 0x4002c, // [8]
		72, 74, 0x1c0038, // [9]
		77, 77, 0xc0002, // [10]
		74, 76, 0x3001c, // [11]
		84, 85, 0x15002a, // [12]
		85, 87, 0x30015, // [13]
		91, 92, 0x15002d, // [14]
		92, 94, 0x30015, // [15]
		105, 109, 0x20045, // [16]
		113, 115, 0x10004a, // [17]
		118, 119, 0x150002, // [18]
		124, 124, 0x170002, // [19]
		128, 134, 0x80002, // [20]
		115, 117, 0x30010, // [21]
		119, 123, 0x30015, // [22]
		124, 126, 0x30017, // [23]
		138, 146, 0x1b0044, // [24]
		149, 149, 0x1a0002, // [25]
		155, 155, 0x210002, // [26]
		146, 148, 0x3001b, // [27]
		149, 151, 0x3001a, // [28]
		151, 153, 0x30008, // [29]
		160, 164, 0x10006a, // [30]
		167, 167, 0x2a0002, // [31]
		164, 166, 0x30010, // [32]
		172, 177, 0x20022, // [33]
		186, 188, 0x2004b, // [34]
		214, 215, 0x190055, // [35]
		221, 221, 0x1b0002, // [36]
		227, 231, 0x220002, // [37]
		247, 248, 0x430002, // [38]
		215, 217, 0x30019, // [39]
		221, 222, 0x37001b, // [40]
		222, 224, 0x40037, // [41]
		231, 233, 0x1b0022, // [42]
		236, 236, 0x110003, // [43]
		240, 240, 0x500003, // [44]
		243, 243, 0x1b0003, // [45]
		233, 234, 0xc001b, // [46]
		236, 238, 0x40011, // [47]
		240, 242, 0x40050, // [48]
		255, 256, 0x44004b, // [49]
		259, 261, 0x100002, // [50]
		264, 265, 0x100002, // [51]
		268, 268, 0x1b0002, // [52]
		271, 272, 0x100002, // [53]
		275, 275, 0x3e0002, // [54]
		278, 279, 0x100002, // [55]
		282, 282, 0x1c0002, // [56]
		256, 258, 0x30044, // [57]
		261, 263, 0x30010, // [58]
		265, 267, 0x30010, // [59]
		268, 270, 0x3001b, // [60]
		272, 274, 0x30010, // [61]
		275, 277, 0x3003e, // [62]
		279, 281, 0x30010, // [63]
		287, 288, 0x25004a, // [64]
		291, 292, 0x190002, // [65]
		295, 298, 0x330002, // [66]
		305, 305, 0x170002, // [67]
		322, 322, 0xc0002, // [68]
		288, 290, 0x30025, // [69]
		292, 294, 0x30019, // [70]
		298, 303, 0x30033, // [71]
		305, 308, 0x1e0017, // [72]
		311, 312, 0x1b0003, // [73]
		315, 315, 0x470003, // [74]
		308, 310, 0x4001e, // [75]
		312, 314, 0x4001b, // [76]
		315, 320, 0x40047, // [77]
		326, 327, 0x68004f, // [78]
		330, 331, 0x100002, // [79]
		335, 336, 0x380002, // [80]
		351, 351, 0x1a0002, // [81]
		327, 329, 0x30068, // [82]
		331, 333, 0x30010, // [83]
		336, 338, 0x110038, // [84]
		342, 349, 0x40003, // [85]
		338, 341, 0x40011, // [86]
		355, 357, 0x10006d, // [87]
		360, 360, 0x3c0002, // [88]
		357, 359, 0x30010, // [89]
		372, 373, 0x120052, // [90]
		376, 377, 0x100002, // [91]
		380, 382, 0x100002, // [92]
		385, 386, 0x100002, // [93]
		389, 390, 0x90002, // [94]
		393, 393, 0x340002, // [95]
		400, 403, 0x80002, // [96]
		373, 375, 0x30012, // [97]
		377, 379, 0x30010, // [98]
		382, 384, 0x30010, // [99]
		386, 388, 0x30010, // [100]
		390, 392, 0x30009, // [101]
		393, 395, 0x110034, // [102]
		398, 398, 0x3c0003, // [103]
		395, 397, 0x40011, // [104]
	},
	NumStmt: [105]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		2, // 17
		2, // 18
		1, // 19
		2, // 20
		1, // 21
		2, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		4, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		2, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		2, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		3, // 50
		2, // 51
		1, // 52
		2, // 53
		1, // 54
		2, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		2, // 65
		3, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		3, // 71
		3, // 72
		2, // 73
		1, // 74
		1, // 75
		1, // 76
		3, // 77
		1, // 78
		2, // 79
		2, // 80
		1, // 81
		1, // 82
		1, // 83
		2, // 84
		1, // 85
		1, // 86
		2, // 87
		1, // 88
		1, // 89
		1, // 90
		2, // 91
		3, // 92
		2, // 93
		2, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		2, // 102
		1, // 103
		1, // 104
	},
}
var _ = _cover_atomic_.LoadUint32
