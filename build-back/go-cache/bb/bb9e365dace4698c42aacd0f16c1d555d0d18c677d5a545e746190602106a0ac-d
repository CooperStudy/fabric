//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/util/uint64_encoding.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package util; import _cover_atomic_ "sync/atomic"

import (
	"encoding/binary"
	"math"

	"github.com/golang/protobuf/proto"
)

// EncodeReverseOrderVarUint64 returns a byte-representation for a uint64 number such that
// the number is first subtracted from MaxUint64 and then all the leading 0xff bytes
// are trimmed and replaced by the number of such trimmed bytes. This helps in reducing the size.
// In the byte order comparison this encoding ensures that EncodeReverseOrderVarUint64(A) > EncodeReverseOrderVarUint64(B),
// If B > A
func EncodeReverseOrderVarUint64(number uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[0], 1);
	bytes := make([]byte, 8)
	binary.BigEndian.PutUint64(bytes, math.MaxUint64-number)
	numFFBytes := 0
	for _, b := range bytes {_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[2], 1);
		if b != 0xff {_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[4], 1);
			break
		}
		_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[3], 1);numFFBytes++
	}
	_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[1], 1);size := 8 - numFFBytes
	encodedBytes := make([]byte, size+1)
	encodedBytes[0] = proto.EncodeVarint(uint64(numFFBytes))[0]
	copy(encodedBytes[1:], bytes[numFFBytes:])
	return encodedBytes
}

// DecodeReverseOrderVarUint64 decodes the number from the bytes obtained from function 'EncodeReverseOrderVarUint64'.
// Also, returns the number of bytes that are consumed in the process
func DecodeReverseOrderVarUint64(bytes []byte) (uint64, int) {_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[5], 1);
	s, _ := proto.DecodeVarint(bytes)
	numFFBytes := int(s)
	decodedBytes := make([]byte, 8)
	realBytesNum := 8 - numFFBytes
	copy(decodedBytes[numFFBytes:], bytes[1:realBytesNum+1])
	numBytesConsumed := realBytesNum + 1
	for i := 0; i < numFFBytes; i++ {_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[7], 1);
		decodedBytes[i] = 0xff
	}
	_cover_atomic_.AddUint32(&GoCover_1_376463623436383239386665.Count[6], 1);return (math.MaxUint64 - binary.BigEndian.Uint64(decodedBytes)), numBytesConsumed
}

var GoCover_1_376463623436383239386665 = struct {
	Count     [8]uint32
	Pos       [3 * 8]uint32
	NumStmt   [8]uint16
} {
	Pos: [3 * 8]uint32{
		21, 25, 0x1a0038, // [0]
		31, 35, 0x150002, // [1]
		25, 26, 0x10001a, // [2]
		29, 29, 0xf0003, // [3]
		26, 27, 0x90010, // [4]
		40, 47, 0x22003e, // [5]
		50, 50, 0x530002, // [6]
		47, 49, 0x30022, // [7]
	},
	NumStmt: [8]uint16{
		4, // 0
		5, // 1
		1, // 2
		1, // 3
		1, // 4
		7, // 5
		1, // 6
		1, // 7
	},
}
var _ = _cover_atomic_.LoadUint32
