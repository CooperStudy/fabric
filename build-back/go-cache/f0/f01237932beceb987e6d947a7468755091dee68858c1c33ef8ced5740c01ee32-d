//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate/common_storage_db.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package privacyenabledstate; import _cover_atomic_ "sync/atomic"

import (
	"encoding/base64"
	"strings"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
	"github.com/hyperledger/fabric/core/ledger/kvledger/bookkeeping"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecouchdb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/stateleveldb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("privacyenabledstate")

const (
	nsJoiner       = "$$"
	pvtDataPrefix  = "p"
	hashDataPrefix = "h"
)

// CommonStorageDBProvider implements interface DBProvider
type CommonStorageDBProvider struct {
	statedb.VersionedDBProvider
	bookkeepingProvider bookkeeping.Provider
}

// NewCommonStorageDBProvider constructs an instance of DBProvider
func NewCommonStorageDBProvider(bookkeeperProvider bookkeeping.Provider, metricsProvider metrics.Provider) (DBProvider, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[0], 1);
	var vdbProvider statedb.VersionedDBProvider
	var err error
	if ledgerconfig.IsCouchDBEnabled() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[2], 1);
		if vdbProvider, err = statecouchdb.NewVersionedDBProvider(metricsProvider); err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[3], 1);
			return nil, err
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[4], 1);{
		vdbProvider = stateleveldb.NewVersionedDBProvider()
	}}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[1], 1);return &CommonStorageDBProvider{vdbProvider, bookkeeperProvider}, nil
}

// GetDBHandle implements function from interface DBProvider
func (p *CommonStorageDBProvider) GetDBHandle(id string) (DB, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[5], 1);
	vdb, err := p.VersionedDBProvider.GetDBHandle(id)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[7], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[6], 1);bookkeeper := p.bookkeepingProvider.GetDBHandle(id, bookkeeping.MetadataPresenceIndicator)
	metadataHint := newMetadataHint(bookkeeper)
	return NewCommonStorageDB(vdb, id, metadataHint)
}

// Close implements function from interface DBProvider
func (p *CommonStorageDBProvider) Close() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[8], 1);
	p.VersionedDBProvider.Close()
}

// CommonStorageDB implements interface DB. This implementation uses a single database to maintain
// both the public and private data
type CommonStorageDB struct {
	statedb.VersionedDB
	metadataHint *metadataHint
}

// NewCommonStorageDB wraps a VersionedDB instance. The public data is managed directly by the wrapped versionedDB.
// For managing the hashed data and private data, this implementation creates separate namespaces in the wrapped db
func NewCommonStorageDB(vdb statedb.VersionedDB, ledgerid string, metadataHint *metadataHint) (DB, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[9], 1);
	return &CommonStorageDB{vdb, metadataHint}, nil
}

// IsBulkOptimizable implements corresponding function in interface DB
func (s *CommonStorageDB) IsBulkOptimizable() bool {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[10], 1);
	_, ok := s.VersionedDB.(statedb.BulkOptimizable)
	return ok
}

// LoadCommittedVersionsOfPubAndHashedKeys implements corresponding function in interface DB
func (s *CommonStorageDB) LoadCommittedVersionsOfPubAndHashedKeys(pubKeys []*statedb.CompositeKey,
	hashedKeys []*HashedCompositeKey) error {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[11], 1);

	bulkOptimizable, ok := s.VersionedDB.(statedb.BulkOptimizable)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[15], 1);
		return nil
	}
	// Here, hashedKeys are merged into pubKeys to get a combined set of keys for combined loading
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[12], 1);for _, key := range hashedKeys {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[16], 1);
		ns := deriveHashedDataNs(key.Namespace, key.CollectionName)
		// No need to check for duplicates as hashedKeys are in separate namespace
		var keyHashStr string
		if !s.BytesKeySupported() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[18], 1);
			keyHashStr = base64.StdEncoding.EncodeToString([]byte(key.KeyHash))
		} else{ _cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[19], 1);{
			keyHashStr = key.KeyHash
		}}
		_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[17], 1);pubKeys = append(pubKeys, &statedb.CompositeKey{
			Namespace: ns,
			Key:       keyHashStr,
		})
	}

	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[13], 1);err := bulkOptimizable.LoadCommittedVersions(pubKeys)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[20], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[14], 1);return nil
}

// ClearCachedVersions implements corresponding function in interface DB
func (s *CommonStorageDB) ClearCachedVersions() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[21], 1);
	bulkOptimizable, ok := s.VersionedDB.(statedb.BulkOptimizable)
	if ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[22], 1);
		bulkOptimizable.ClearCachedVersions()
	}
}

// GetChaincodeEventListener implements corresponding function in interface DB
func (s *CommonStorageDB) GetChaincodeEventListener() cceventmgmt.ChaincodeLifecycleEventListener {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[23], 1);
	_, ok := s.VersionedDB.(statedb.IndexCapable)
	if ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[25], 1);
		return s
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[24], 1);return nil
}

// GetPrivateData implements corresponding function in interface DB
func (s *CommonStorageDB) GetPrivateData(namespace, collection, key string) (*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[26], 1);
	return s.GetState(derivePvtDataNs(namespace, collection), key)
}

// GetValueHash implements corresponding function in interface DB
func (s *CommonStorageDB) GetValueHash(namespace, collection string, keyHash []byte) (*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[27], 1);
	keyHashStr := string(keyHash)
	if !s.BytesKeySupported() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[29], 1);
		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[28], 1);return s.GetState(deriveHashedDataNs(namespace, collection), keyHashStr)
}

// GetKeyHashVersion implements corresponding function in interface DB
func (s *CommonStorageDB) GetKeyHashVersion(namespace, collection string, keyHash []byte) (*version.Height, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[30], 1);
	keyHashStr := string(keyHash)
	if !s.BytesKeySupported() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[32], 1);
		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[31], 1);return s.GetVersion(deriveHashedDataNs(namespace, collection), keyHashStr)
}

// GetCachedKeyHashVersion retrieves the keyhash version from cache
func (s *CommonStorageDB) GetCachedKeyHashVersion(namespace, collection string, keyHash []byte) (*version.Height, bool) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[33], 1);
	bulkOptimizable, ok := s.VersionedDB.(statedb.BulkOptimizable)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[36], 1);
		return nil, false
	}

	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[34], 1);keyHashStr := string(keyHash)
	if !s.BytesKeySupported() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[37], 1);
		keyHashStr = base64.StdEncoding.EncodeToString(keyHash)
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[35], 1);return bulkOptimizable.GetCachedVersion(deriveHashedDataNs(namespace, collection), keyHashStr)
}

// GetPrivateDataMultipleKeys implements corresponding function in interface DB
func (s *CommonStorageDB) GetPrivateDataMultipleKeys(namespace, collection string, keys []string) ([]*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[38], 1);
	return s.GetStateMultipleKeys(derivePvtDataNs(namespace, collection), keys)
}

// GetPrivateDataRangeScanIterator implements corresponding function in interface DB
func (s *CommonStorageDB) GetPrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[39], 1);
	return s.GetStateRangeScanIterator(derivePvtDataNs(namespace, collection), startKey, endKey)
}

// ExecuteQueryOnPrivateData implements corresponding function in interface DB
func (s CommonStorageDB) ExecuteQueryOnPrivateData(namespace, collection, query string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[40], 1);
	return s.ExecuteQuery(derivePvtDataNs(namespace, collection), query)
}

// ApplyUpdates overrides the function in statedb.VersionedDB and throws appropriate error message
// Otherwise, somewhere in the code, usage of this function could lead to updating only public data.
func (s *CommonStorageDB) ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) error {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[41], 1);
	return errors.New("this function should not be invoked on this type. Please invoke function ApplyPrivacyAwareUpdates")
}

// ApplyPrivacyAwareUpdates implements corresponding function in interface DB
func (s *CommonStorageDB) ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[42], 1);
	// combinedUpdates includes both updates to public db and private db, which are partitioned by a separate namespace
	combinedUpdates := updates.PubUpdates
	addPvtUpdates(combinedUpdates, updates.PvtUpdates)
	addHashedUpdates(combinedUpdates, updates.HashUpdates, !s.BytesKeySupported())
	s.metadataHint.setMetadataUsedFlag(updates)
	return s.VersionedDB.ApplyUpdates(combinedUpdates.UpdateBatch, height)
}

// GetStateMetadata implements corresponding function in interface DB. This implementation provides
// an optimization such that it keeps track if a namespaces has never stored metadata for any of
// its items, the value 'nil' is returned without going to the db. This is intented to be invoked
// in the validation and commit path. This saves the chaincodes from paying unnecessary performance
// penality if they do not use features that leverage metadata (such as key-level endorsement),
func (s *CommonStorageDB) GetStateMetadata(namespace, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[43], 1);
	if !s.metadataHint.metadataEverUsedFor(namespace) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[46], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[44], 1);vv, err := s.GetState(namespace, key)
	if err != nil || vv == nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[47], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[45], 1);return vv.Metadata, nil
}

// GetPrivateDataMetadataByHash implements corresponding function in interface DB. For additional details, see
// decription of the similar function 'GetStateMetadata'
func (s *CommonStorageDB) GetPrivateDataMetadataByHash(namespace, collection string, keyHash []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[48], 1);
	if !s.metadataHint.metadataEverUsedFor(namespace) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[51], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[49], 1);vv, err := s.GetValueHash(namespace, collection, keyHash)
	if err != nil || vv == nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[52], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[50], 1);return vv.Metadata, nil
}

// HandleChaincodeDeploy initializes database artifacts for the database associated with the namespace
// This function delibrately suppresses the errors that occur during the creation of the indexes on couchdb.
// This is because, in the present code, we do not differentiate between the errors because of couchdb interaction
// and the errors because of bad index files - the later being unfixable by the admin. Note that the error suppression
// is acceptable since peer can continue in the committing role without the indexes. However, executing chaincode queries
// may be affected, until a new chaincode with fixed indexes is installed and instantiated
func (s *CommonStorageDB) HandleChaincodeDeploy(chaincodeDefinition *cceventmgmt.ChaincodeDefinition, dbArtifactsTar []byte) error {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[53], 1);
	//Check to see if the interface for IndexCapable is implemented
	indexCapable, ok := s.VersionedDB.(statedb.IndexCapable)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[59], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[54], 1);if chaincodeDefinition == nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[60], 1);
		return errors.New("chaincode definition not found while creating couchdb index")
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[55], 1);dbArtifacts, err := ccprovider.ExtractFileEntries(dbArtifactsTar, indexCapable.GetDBType())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[61], 1);
		logger.Errorf("Index creation: error extracting db artifacts from tar for chaincode [%s]: %s", chaincodeDefinition.Name, err)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[56], 1);collectionConfigMap, err := extractCollectionNames(chaincodeDefinition)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[62], 1);
		logger.Errorf("Error while retrieving collection config for chaincode=[%s]: %s",
			chaincodeDefinition.Name, err)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[57], 1);for directoryPath, archiveDirectoryEntries := range dbArtifacts {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[63], 1);
		// split the directory name
		directoryPathArray := strings.Split(directoryPath, "/")
		// process the indexes for the chain
		if directoryPathArray[3] == "indexes" {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[65], 1);
			err := indexCapable.ProcessIndexesForChaincodeDeploy(chaincodeDefinition.Name, archiveDirectoryEntries)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[67], 1);
				logger.Errorf("Error processing index for chaincode [%s]: %s", chaincodeDefinition.Name, err)
			}
			_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[66], 1);continue
		}
		// check for the indexes directory for the collection
		_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[64], 1);if directoryPathArray[3] == "collections" && directoryPathArray[5] == "indexes" {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[68], 1);
			collectionName := directoryPathArray[4]
			_, ok := collectionConfigMap[collectionName]
			if !ok {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[69], 1);
				logger.Errorf("Error processing index for chaincode [%s]: cannot create an index for an undefined collection=[%s]", chaincodeDefinition.Name, collectionName)
			} else{ _cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[70], 1);{
				err := indexCapable.ProcessIndexesForChaincodeDeploy(derivePvtDataNs(chaincodeDefinition.Name, collectionName),
					archiveDirectoryEntries)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[71], 1);
					logger.Errorf("Error processing collection index for chaincode [%s]: %s", chaincodeDefinition.Name, err)
				}
			}}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[58], 1);return nil
}

// ChaincodeDeployDone is a noop for couchdb state impl
func (s *CommonStorageDB) ChaincodeDeployDone(succeeded bool) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[72], 1);
	// NOOP
}

func derivePvtDataNs(namespace, collection string) string {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[73], 1);
	return namespace + nsJoiner + pvtDataPrefix + collection
}

func deriveHashedDataNs(namespace, collection string) string {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[74], 1);
	return namespace + nsJoiner + hashDataPrefix + collection
}

func addPvtUpdates(pubUpdateBatch *PubUpdateBatch, pvtUpdateBatch *PvtUpdateBatch) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[75], 1);
	for ns, nsBatch := range pvtUpdateBatch.UpdateMap {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[76], 1);
		for _, coll := range nsBatch.GetCollectionNames() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[77], 1);
			for key, vv := range nsBatch.GetUpdates(coll) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[78], 1);
				pubUpdateBatch.Update(derivePvtDataNs(ns, coll), key, vv)
			}
		}
	}
}

func addHashedUpdates(pubUpdateBatch *PubUpdateBatch, hashedUpdateBatch *HashedUpdateBatch, base64Key bool) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[79], 1);
	for ns, nsBatch := range hashedUpdateBatch.UpdateMap {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[80], 1);
		for _, coll := range nsBatch.GetCollectionNames() {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[81], 1);
			for key, vv := range nsBatch.GetUpdates(coll) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[82], 1);
				if base64Key {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[84], 1);
					key = base64.StdEncoding.EncodeToString([]byte(key))
				}
				_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[83], 1);pubUpdateBatch.Update(deriveHashedDataNs(ns, coll), key, vv)
			}
		}
	}
}

func extractCollectionNames(chaincodeDefinition *cceventmgmt.ChaincodeDefinition) (map[string]bool, error) {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[85], 1);
	collectionConfigs := chaincodeDefinition.CollectionConfigs
	collectionConfigsMap := make(map[string]bool)
	if collectionConfigs != nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[87], 1);
		for _, config := range collectionConfigs.Config {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[88], 1);
			sConfig := config.GetStaticCollectionConfig()
			if sConfig == nil {_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[90], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[89], 1);collectionConfigsMap[sConfig.Name] = true
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_626362383230316436633863.Count[86], 1);return collectionConfigsMap, nil
}

var GoCover_0_626362383230316436633863 = struct {
	Count     [91]uint32
	Pos       [3 * 91]uint32
	NumStmt   [91]uint16
} {
	Pos: [3 * 91]uint32{
		41, 44, 0x250080, // [0]
		51, 51, 0x470002, // [1]
		44, 45, 0x5a0025, // [2]
		45, 47, 0x4005a, // [3]
		48, 50, 0x30008, // [4]
		55, 57, 0x100046, // [5]
		60, 62, 0x320002, // [6]
		57, 59, 0x30010, // [7]
		66, 68, 0x2002b, // [8]
		79, 81, 0x2006b, // [9]
		84, 87, 0x20034, // [10]
		91, 94, 0x9002a, // [11]
		98, 98, 0x210002, // [12]
		113, 114, 0x100002, // [13]
		118, 118, 0xc0002, // [14]
		94, 96, 0x30009, // [15]
		98, 102, 0x1d0021, // [16]
		107, 110, 0x50003, // [17]
		102, 104, 0x4001d, // [18]
		104, 106, 0x40009, // [19]
		114, 116, 0x30010, // [20]
		122, 124, 0x80031, // [21]
		124, 126, 0x30008, // [22]
		130, 132, 0x80063, // [23]
		135, 135, 0xc0002, // [24]
		132, 134, 0x30008, // [25]
		139, 141, 0x2006e, // [26]
		144, 146, 0x1c0077, // [27]
		149, 149, 0x4a0002, // [28]
		146, 148, 0x3001c, // [29]
		153, 155, 0x1c0074, // [30]
		158, 158, 0x4c0002, // [31]
		155, 157, 0x3001c, // [32]
		162, 164, 0x90079, // [33]
		168, 169, 0x1c0002, // [34]
		172, 172, 0x600002, // [35]
		164, 166, 0x30009, // [36]
		169, 171, 0x3001c, // [37]
		176, 178, 0x20086, // [38]
		181, 183, 0x2008c, // [39]
		186, 188, 0x2007a, // [40]
		192, 194, 0x20062, // [41]
		197, 204, 0x20068, // [42]
		211, 212, 0x340053, // [43]
		215, 216, 0x1d0002, // [44]
		219, 219, 0x190002, // [45]
		212, 214, 0x30034, // [46]
		216, 218, 0x3001d, // [47]
		224, 225, 0x340076, // [48]
		228, 229, 0x1d0002, // [49]
		232, 232, 0x190002, // [50]
		225, 227, 0x30034, // [51]
		229, 231, 0x3001d, // [52]
		241, 244, 0x90084, // [53]
		247, 247, 0x200002, // [54]
		250, 251, 0x100002, // [55]
		256, 257, 0x100002, // [56]
		263, 263, 0x420002, // [57]
		289, 289, 0xc0002, // [58]
		244, 246, 0x30009, // [59]
		247, 249, 0x30020, // [60]
		251, 254, 0x30010, // [61]
		257, 261, 0x30010, // [62]
		263, 267, 0x290042, // [63]
		275, 275, 0x530003, // [64]
		267, 269, 0x120029, // [65]
		272, 272, 0xc0004, // [66]
		269, 271, 0x50012, // [67]
		275, 278, 0xb0053, // [68]
		278, 280, 0x5000b, // [69]
		280, 283, 0x13000a, // [70]
		283, 285, 0x60013, // [71]
		293, 295, 0x20040, // [72]
		297, 299, 0x2003b, // [73]
		301, 303, 0x2003e, // [74]
		305, 306, 0x340054, // [75]
		306, 307, 0x350034, // [76]
		307, 308, 0x320035, // [77]
		308, 310, 0x50032, // [78]
		315, 316, 0x37006d, // [79]
		316, 317, 0x350037, // [80]
		317, 318, 0x320035, // [81]
		318, 319, 0x120032, // [82]
		322, 322, 0x410005, // [83]
		319, 321, 0x60012, // [84]
		328, 331, 0x1e006c, // [85]
		340, 340, 0x220002, // [86]
		331, 332, 0x33001e, // [87]
		332, 334, 0x160033, // [88]
		337, 337, 0x2d0004, // [89]
		334, 335, 0xd0016, // [90]
	},
	NumStmt: [91]uint16{
		3, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		3, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		2, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		2, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		2, // 33
		2, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		5, // 42
		1, // 43
		2, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		1, // 50
		1, // 51
		1, // 52
		2, // 53
		1, // 54
		2, // 55
		2, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		2, // 61
		2, // 62
		2, // 63
		1, // 64
		2, // 65
		1, // 66
		1, // 67
		3, // 68
		1, // 69
		2, // 70
		1, // 71
		0, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		3, // 85
		1, // 86
		1, // 87
		2, // 88
		1, // 89
		1, // 90
	},
}
var _ = _cover_atomic_.LoadUint32
