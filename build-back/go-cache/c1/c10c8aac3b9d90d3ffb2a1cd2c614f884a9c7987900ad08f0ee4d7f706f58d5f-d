//line /home/cooper/go/src/github.com/hyperledger/fabric/msp/identities.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msp; import _cover_atomic_ "sync/atomic"

import (
	"crypto"
	"crypto/rand"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

var mspIdentityLogger = flogging.MustGetLogger("msp.identity")

type identity struct {
	// id contains the identifier (MSPID and identity identifier) for this instance
	id *IdentityIdentifier

	// cert contains the x.509 certificate that signs the public key of this instance
	cert *x509.Certificate

	// this is the public key of this instance
	pk bccsp.Key

	// reference to the MSP that "owns" this identity
	msp *bccspmsp
}

func newIdentity(cert *x509.Certificate, pk bccsp.Key, msp *bccspmsp) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[0], 1);
	if mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[5], 1);
		mspIdentityLogger.Debugf("Creating identity instance for cert %s", certToPEM(cert))
	}

	// Sanitize first the certificate
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[1], 1);cert, err := msp.sanitizeCert(cert)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[6], 1);
		return nil, err
	}

	// Compute identity identifier

	// Use the hash of the identity's certificate as id in the IdentityIdentifier
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[2], 1);hashOpt, err := bccsp.GetHashOpt(msp.cryptoConfig.IdentityIdentifierHashFunction)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[7], 1);
		return nil, errors.WithMessage(err, "failed getting hash function options")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[3], 1);digest, err := msp.bccsp.Hash(cert.Raw, hashOpt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[8], 1);
		return nil, errors.WithMessage(err, "failed hashing raw certificate to compute the id of the IdentityIdentifier")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[4], 1);id := &IdentityIdentifier{
		Mspid: msp.name,
		Id:    hex.EncodeToString(digest)}

	return &identity{id: id, cert: cert, pk: pk, msp: msp}, nil
}

// ExpiresAt returns the time at which the Identity expires.
func (id *identity) ExpiresAt() time.Time {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[9], 1);
	return id.cert.NotAfter
}

// SatisfiesPrincipal returns null if this instance matches the supplied principal or an error otherwise
func (id *identity) SatisfiesPrincipal(principal *msp.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[10], 1);
	return id.msp.SatisfiesPrincipal(id, principal)
}

// GetIdentifier returns the identifier (MSPID/IDID) for this instance
func (id *identity) GetIdentifier() *IdentityIdentifier {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[11], 1);
	return id.id
}

// GetMSPIdentifier returns the MSP identifier for this instance
func (id *identity) GetMSPIdentifier() string {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[12], 1);
	return id.id.Mspid
}

// Validate returns nil if this instance is a valid identity or an error otherwise
func (id *identity) Validate() error {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[13], 1);
	return id.msp.Validate(id)
}

// GetOrganizationalUnits returns the OU for this instance
func (id *identity) GetOrganizationalUnits() []*OUIdentifier {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[14], 1);
	if id.cert == nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[18], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[15], 1);cid, err := id.msp.getCertificationChainIdentifier(id)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[19], 1);
		mspIdentityLogger.Errorf("Failed getting certification chain identifier for [%v]: [%+v]", id, err)

		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[16], 1);res := []*OUIdentifier{}
	for _, unit := range id.cert.Subject.OrganizationalUnit {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[20], 1);
		res = append(res, &OUIdentifier{
			OrganizationalUnitIdentifier: unit,
			CertifiersIdentifier:         cid,
		})
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[17], 1);return res
}

// Anonymous returns true if this identity provides anonymity
func (id *identity) Anonymous() bool {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[21], 1);
	return false
}

// NewSerializedIdentity returns a serialized identity
// having as content the passed mspID and x509 certificate in PEM format.
// This method does not check the validity of certificate nor
// any consistency of the mspID with it.
func NewSerializedIdentity(mspID string, certPEM []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[22], 1);
	// We serialize identities by prepending the MSPID
	// and appending the x509 cert in PEM format
	sId := &msp.SerializedIdentity{Mspid: mspID, IdBytes: certPEM}
	raw, err := proto.Marshal(sId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[24], 1);
		return nil, errors.Wrapf(err, "failed serializing identity [%s][%X]", mspID, certPEM)
	}
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[23], 1);return raw, nil
}

// Verify checks against a signature and a message
// to determine whether this identity produced the
// signature; it returns nil if so or an error otherwise
func (id *identity) Verify(msg []byte, sig []byte) error {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[25], 1);
	// mspIdentityLogger.Infof("Verifying signature")

	// Compute Hash
	hashOpt, err := id.getHashOpt(id.msp.cryptoConfig.SignatureHashFamily)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[30], 1);
		return errors.WithMessage(err, "failed getting hash function options")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[26], 1);digest, err := id.msp.bccsp.Hash(msg, hashOpt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[31], 1);
		return errors.WithMessage(err, "failed computing digest")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[27], 1);if mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[32], 1);
		mspIdentityLogger.Debugf("Verify: digest = %s", hex.Dump(digest))
		mspIdentityLogger.Debugf("Verify: sig = %s", hex.Dump(sig))
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[28], 1);valid, err := id.msp.bccsp.Verify(id.pk, sig, digest, nil)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[33], 1);
		return errors.WithMessage(err, "could not determine the validity of the signature")
	} else{ _cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[34], 1);if !valid {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[35], 1);
		return errors.New("The signature is invalid")
	}}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[29], 1);return nil
}

// Serialize returns a byte array representation of this identity
func (id *identity) Serialize() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[36], 1);
	// mspIdentityLogger.Infof("Serializing identity %s", id.id)

	pb := &pem.Block{Bytes: id.cert.Raw, Type: "CERTIFICATE"}
	pemBytes := pem.EncodeToMemory(pb)
	if pemBytes == nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[39], 1);
		return nil, errors.New("encoding of identity failed")
	}

	// We serialize identities by prepending the MSPID and appending the ASN.1 DER content of the cert
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[37], 1);sId := &msp.SerializedIdentity{Mspid: id.id.Mspid, IdBytes: pemBytes}
	idBytes, err := proto.Marshal(sId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[40], 1);
		return nil, errors.Wrapf(err, "could not marshal a SerializedIdentity structure for identity %s", id.id)
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[38], 1);return idBytes, nil
}

func (id *identity) getHashOpt(hashFamily string) (bccsp.HashOpts, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[41], 1);
	switch hashFamily {
	case bccsp.SHA2:_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[43], 1);
		return bccsp.GetHashOpt(bccsp.SHA256)
	case bccsp.SHA3:_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[44], 1);
		return bccsp.GetHashOpt(bccsp.SHA3_256)
	}
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[42], 1);return nil, errors.Errorf("hash familiy not recognized [%s]", hashFamily)
}

type signingidentity struct {
	// we embed everything from a base identity
	identity

	// signer corresponds to the object that can produce signatures from this identity
	signer crypto.Signer
}

func newSigningIdentity(cert *x509.Certificate, pk bccsp.Key, signer crypto.Signer, msp *bccspmsp) (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[45], 1);
	//mspIdentityLogger.Infof("Creating signing identity instance for ID %s", id)
	mspId, err := newIdentity(cert, pk, msp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[47], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[46], 1);return &signingidentity{identity: *mspId.(*identity), signer: signer}, nil
}

// Sign produces a signature over msg, signed by this instance
func (id *signingidentity) Sign(msg []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[48], 1);
	//mspIdentityLogger.Infof("Signing message")

	// Compute Hash
	hashOpt, err := id.getHashOpt(id.msp.cryptoConfig.SignatureHashFamily)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[52], 1);
		return nil, errors.WithMessage(err, "failed getting hash function options")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[49], 1);digest, err := id.msp.bccsp.Hash(msg, hashOpt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[53], 1);
		return nil, errors.WithMessage(err, "failed computing digest")
	}

	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[50], 1);if len(msg) < 32 {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[54], 1);
		mspIdentityLogger.Debugf("Sign: plaintext: %X \n", msg)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[55], 1);{
		mspIdentityLogger.Debugf("Sign: plaintext: %X...%X \n", msg[0:16], msg[len(msg)-16:])
	}}
	_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[51], 1);mspIdentityLogger.Debugf("Sign: digest: %X \n", digest)

	// Sign
	return id.signer.Sign(rand.Reader, digest, nil)
}

// GetPublicVersion returns the public version of this identity,
// namely, the one that is only able to verify messages and not sign them
func (id *signingidentity) GetPublicVersion() Identity {_cover_atomic_.AddUint32(&GoCover_5_636433306662306231613333.Count[56], 1);
	return &id.identity
}

var GoCover_5_636433306662306231613333 = struct {
	Count     [57]uint32
	Pos       [3 * 57]uint32
	NumStmt   [57]uint16
} {
	Pos: [3 * 57]uint32{
		41, 42, 0x380059, // [0]
		47, 48, 0x100002, // [1]
		55, 56, 0x100002, // [2]
		60, 61, 0x100002, // [3]
		65, 69, 0x3d0002, // [4]
		42, 44, 0x30038, // [5]
		48, 50, 0x30010, // [6]
		56, 58, 0x30010, // [7]
		61, 63, 0x30010, // [8]
		73, 75, 0x2002b, // [9]
		78, 80, 0x2004b, // [10]
		83, 85, 0x20039, // [11]
		88, 90, 0x2002f, // [12]
		93, 95, 0x20026, // [13]
		98, 99, 0x14003e, // [14]
		103, 104, 0x100002, // [15]
		110, 111, 0x3a0002, // [16]
		118, 118, 0xc0002, // [17]
		99, 101, 0x30014, // [18]
		104, 108, 0x30010, // [19]
		111, 116, 0x3003a, // [20]
		122, 124, 0x20026, // [21]
		130, 135, 0x10004a, // [22]
		138, 138, 0x110002, // [23]
		135, 137, 0x30010, // [24]
		144, 149, 0x10003a, // [25]
		153, 154, 0x100002, // [26]
		158, 158, 0x380002, // [27]
		163, 164, 0x100002, // [28]
		170, 170, 0xc0002, // [29]
		149, 151, 0x30010, // [30]
		154, 156, 0x30010, // [31]
		158, 161, 0x30038, // [32]
		164, 166, 0x30010, // [33]
		166, 166, 0x130008, // [34]
		166, 168, 0x30013, // [35]
		174, 179, 0x150031, // [36]
		184, 186, 0x100002, // [37]
		190, 190, 0x150002, // [38]
		179, 181, 0x30015, // [39]
		186, 188, 0x30010, // [40]
		193, 194, 0x14004b, // [41]
		200, 200, 0x4b0002, // [42]
		195, 196, 0x280012, // [43]
		197, 198, 0x2a0012, // [44]
		211, 214, 0x10007d, // [45]
		217, 217, 0x4c0002, // [46]
		214, 216, 0x30010, // [47]
		221, 226, 0x10003d, // [48]
		230, 231, 0x100002, // [49]
		235, 235, 0x130002, // [50]
		240, 243, 0x310002, // [51]
		226, 228, 0x30010, // [52]
		231, 233, 0x30010, // [53]
		235, 237, 0x30013, // [54]
		237, 239, 0x30008, // [55]
		248, 250, 0x20038, // [56]
	},
	NumStmt: [57]uint16{
		1, // 0
		2, // 1
		2, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		2, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		3, // 22
		1, // 23
		1, // 24
		2, // 25
		2, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		3, // 36
		3, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		2, // 45
		1, // 46
		1, // 47
		2, // 48
		2, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
	},
}
var _ = _cover_atomic_.LoadUint32
