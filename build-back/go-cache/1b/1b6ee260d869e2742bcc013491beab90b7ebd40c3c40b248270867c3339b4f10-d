//line /home/cooper/go/src/github.com/hyperledger/fabric/common/tools/configtxgen/encoder/encoder.go:1
/*
Copyright IBM Corp. 2016 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package encoder; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/cauthdsl"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/genesis"
	"github.com/hyperledger/fabric/common/policies"
	genesisconfig "github.com/hyperledger/fabric/common/tools/configtxgen/localconfig"
	"github.com/hyperledger/fabric/common/tools/configtxlator/update"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/msp"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/orderer/etcdraft"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

const (
	ordererAdminsPolicyName = "/Channel/Orderer/Admins"

	msgVersion = int32(0)
	epoch      = 0
)

var logger = flogging.MustGetLogger("common.tools.configtxgen.encoder")

const (
	// ConsensusTypeSolo identifies the solo consensus implementation.
	ConsensusTypeSolo = "solo"
	// ConsensusTypeKafka identifies the Kafka-based consensus implementation.
	ConsensusTypeKafka = "kafka"

	// BlockValidationPolicyKey TODO
	BlockValidationPolicyKey = "BlockValidation"

	// OrdererAdminsPolicy is the absolute path to the orderer admins policy
	OrdererAdminsPolicy = "/Channel/Orderer/Admins"

	// SignaturePolicyType is the 'Type' string for signature policies
	SignaturePolicyType = "Signature"

	// ImplicitMetaPolicyType is the 'Type' string for implicit meta policies
	ImplicitMetaPolicyType = "ImplicitMeta"
)

func addValue(cg *cb.ConfigGroup, value channelconfig.ConfigValue, modPolicy string) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[0], 1);
	cg.Values[value.Key()] = &cb.ConfigValue{
		Value:     utils.MarshalOrPanic(value.Value()),
		ModPolicy: modPolicy,
	}
}

func addPolicy(cg *cb.ConfigGroup, policy policies.ConfigPolicy, modPolicy string) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[1], 1);
	cg.Policies[policy.Key()] = &cb.ConfigPolicy{
		Policy:    policy.Value(),
		ModPolicy: modPolicy,
	}
}

func addPolicies(cg *cb.ConfigGroup, policyMap map[string]*genesisconfig.Policy, modPolicy string) error {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[2], 1);
	for policyName, policy := range policyMap {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[4], 1);
		switch policy.Type {
		case ImplicitMetaPolicyType:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[5], 1);
			imp, err := policies.ImplicitMetaFromString(policy.Rule)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[10], 1);
				return errors.Wrapf(err, "invalid implicit meta policy rule '%s'", policy.Rule)
			}
			_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[6], 1);cg.Policies[policyName] = &cb.ConfigPolicy{
				ModPolicy: modPolicy,
				Policy: &cb.Policy{
					Type:  int32(cb.Policy_IMPLICIT_META),
					Value: utils.MarshalOrPanic(imp),
				},
			}
		case SignaturePolicyType:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[7], 1);
			sp, err := cauthdsl.FromString(policy.Rule)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[11], 1);
				return errors.Wrapf(err, "invalid signature policy rule '%s'", policy.Rule)
			}
			_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[8], 1);cg.Policies[policyName] = &cb.ConfigPolicy{
				ModPolicy: modPolicy,
				Policy: &cb.Policy{
					Type:  int32(cb.Policy_SIGNATURE),
					Value: utils.MarshalOrPanic(sp),
				},
			}
		default:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[9], 1);
			return errors.Errorf("unknown policy type: %s", policy.Type)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[3], 1);return nil
}

// addImplicitMetaPolicyDefaults adds the Readers/Writers/Admins policies, with Any/Any/Majority rules respectively.
func addImplicitMetaPolicyDefaults(cg *cb.ConfigGroup) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[12], 1);
	addPolicy(cg, policies.ImplicitMetaMajorityPolicy(channelconfig.AdminsPolicyKey), channelconfig.AdminsPolicyKey)
	addPolicy(cg, policies.ImplicitMetaAnyPolicy(channelconfig.ReadersPolicyKey), channelconfig.AdminsPolicyKey)
	addPolicy(cg, policies.ImplicitMetaAnyPolicy(channelconfig.WritersPolicyKey), channelconfig.AdminsPolicyKey)
}

// addSignaturePolicyDefaults adds the Readers/Writers/Admins policies as signature policies requiring one signature from the given mspID.
// If devMode is set to true, the Admins policy will accept arbitrary user certs for admin functions, otherwise it requires the cert satisfies
// the admin role principal.
func addSignaturePolicyDefaults(cg *cb.ConfigGroup, mspID string, devMode bool) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[13], 1);
	if devMode {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[15], 1);
		logger.Warningf("Specifying AdminPrincipal is deprecated and will be removed in a future release, override the admin principal with explicit policies.")
		addPolicy(cg, policies.SignaturePolicy(channelconfig.AdminsPolicyKey, cauthdsl.SignedByMspMember(mspID)), channelconfig.AdminsPolicyKey)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[16], 1);{
		addPolicy(cg, policies.SignaturePolicy(channelconfig.AdminsPolicyKey, cauthdsl.SignedByMspAdmin(mspID)), channelconfig.AdminsPolicyKey)
	}}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[14], 1);addPolicy(cg, policies.SignaturePolicy(channelconfig.ReadersPolicyKey, cauthdsl.SignedByMspMember(mspID)), channelconfig.AdminsPolicyKey)
	addPolicy(cg, policies.SignaturePolicy(channelconfig.WritersPolicyKey, cauthdsl.SignedByMspMember(mspID)), channelconfig.AdminsPolicyKey)
}

// NewChannelGroup defines the root of the channel configuration.  It defines basic operating principles like the hashing
// algorithm used for the blocks, as well as the location of the ordering service.  It will recursively call into the
// NewOrdererGroup, NewConsortiumsGroup, and NewApplicationGroup depending on whether these sub-elements are set in the
// configuration.  All mod_policy values are set to "Admins" for this group, with the exception of the OrdererAddresses
// value which is set to "/Channel/Orderer/Admins".
func NewChannelGroup(conf *genesisconfig.Profile) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[17], 1);
	if conf.Orderer == nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[25], 1);
		return nil, errors.New("missing orderer config section")
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[18], 1);channelGroup := cb.NewConfigGroup()
	if len(conf.Policies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[26], 1);
		logger.Warningf("Default policy emission is deprecated, please include policy specifications for the channel group in configtx.yaml")
		addImplicitMetaPolicyDefaults(channelGroup)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[27], 1);{
		if err := addPolicies(channelGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[28], 1);
			return nil, errors.Wrapf(err, "error adding policies to channel group")
		}
	}}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[19], 1);addValue(channelGroup, channelconfig.HashingAlgorithmValue(), channelconfig.AdminsPolicyKey)
	addValue(channelGroup, channelconfig.BlockDataHashingStructureValue(), channelconfig.AdminsPolicyKey)
	addValue(channelGroup, channelconfig.OrdererAddressesValue(conf.Orderer.Addresses), ordererAdminsPolicyName)

	if conf.Consortium != "" {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[29], 1);
		addValue(channelGroup, channelconfig.ConsortiumValue(conf.Consortium), channelconfig.AdminsPolicyKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[20], 1);if len(conf.Capabilities) > 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[30], 1);
		addValue(channelGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[21], 1);var err error
	channelGroup.Groups[channelconfig.OrdererGroupKey], err = NewOrdererGroup(conf.Orderer)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[31], 1);
		return nil, errors.Wrap(err, "could not create orderer group")
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[22], 1);if conf.Application != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[32], 1);
		channelGroup.Groups[channelconfig.ApplicationGroupKey], err = NewApplicationGroup(conf.Application)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[33], 1);
			return nil, errors.Wrap(err, "could not create application group")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[23], 1);if conf.Consortiums != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[34], 1);
		channelGroup.Groups[channelconfig.ConsortiumsGroupKey], err = NewConsortiumsGroup(conf.Consortiums)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[35], 1);
			return nil, errors.Wrap(err, "could not create consortiums group")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[24], 1);channelGroup.ModPolicy = channelconfig.AdminsPolicyKey
	return channelGroup, nil
}

// NewOrdererGroup returns the orderer component of the channel configuration.  It defines parameters of the ordering service
// about how large blocks should be, how frequently they should be emitted, etc. as well as the organizations of the ordering network.
// It sets the mod_policy of all elements to "Admins".  This group is always present in any channel configuration.
func NewOrdererGroup(conf *genesisconfig.Orderer) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[36], 1);
	ordererGroup := cb.NewConfigGroup()
	if len(conf.Policies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[41], 1);
		logger.Warningf("Default policy emission is deprecated, please include policy specifications for the orderer group in configtx.yaml")
		addImplicitMetaPolicyDefaults(ordererGroup)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[42], 1);{
		if err := addPolicies(ordererGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[43], 1);
			return nil, errors.Wrapf(err, "error adding policies to orderer group")
		}
	}}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[37], 1);ordererGroup.Policies[BlockValidationPolicyKey] = &cb.ConfigPolicy{
		Policy:    policies.ImplicitMetaAnyPolicy(channelconfig.WritersPolicyKey).Value(),
		ModPolicy: channelconfig.AdminsPolicyKey,
	}
	addValue(ordererGroup, channelconfig.BatchSizeValue(
		conf.BatchSize.MaxMessageCount,
		conf.BatchSize.AbsoluteMaxBytes,
		conf.BatchSize.PreferredMaxBytes,
	), channelconfig.AdminsPolicyKey)
	addValue(ordererGroup, channelconfig.BatchTimeoutValue(conf.BatchTimeout.String()), channelconfig.AdminsPolicyKey)
	addValue(ordererGroup, channelconfig.ChannelRestrictionsValue(conf.MaxChannels), channelconfig.AdminsPolicyKey)

	if len(conf.Capabilities) > 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[44], 1);
		addValue(ordererGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[38], 1);var consensusMetadata []byte
	var err error

	switch conf.OrdererType {
	case ConsensusTypeSolo:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[45], 1);
	case ConsensusTypeKafka:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[46], 1);
		addValue(ordererGroup, channelconfig.KafkaBrokersValue(conf.Kafka.Brokers), channelconfig.AdminsPolicyKey)
	case etcdraft.TypeKey:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[47], 1);
		if consensusMetadata, err = etcdraft.Marshal(conf.EtcdRaft); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[49], 1);
			return nil, errors.Errorf("cannot marshal metadata for orderer type %s: %s", etcdraft.TypeKey, err)
		}
	default:_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[48], 1);
		return nil, errors.Errorf("unknown orderer type: %s", conf.OrdererType)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[39], 1);addValue(ordererGroup, channelconfig.ConsensusTypeValue(conf.OrdererType, consensusMetadata), channelconfig.AdminsPolicyKey)

	for _, org := range conf.Organizations {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[50], 1);
		var err error
		ordererGroup.Groups[org.Name], err = NewOrdererOrgGroup(org)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[51], 1);
			return nil, errors.Wrap(err, "failed to create orderer org")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[40], 1);ordererGroup.ModPolicy = channelconfig.AdminsPolicyKey
	return ordererGroup, nil
}

// NewOrdererOrgGroup returns an orderer org component of the channel configuration.  It defines the crypto material for the
// organization (its MSP).  It sets the mod_policy of all elements to "Admins".
func NewOrdererOrgGroup(conf *genesisconfig.Organization) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[52], 1);
	mspConfig, err := msp.GetVerifyingMspConfig(conf.MSPDir, conf.ID, conf.MSPType)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[55], 1);
		return nil, errors.Wrapf(err, "1 - Error loading MSP configuration for org: %s", conf.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[53], 1);ordererOrgGroup := cb.NewConfigGroup()
	if len(conf.Policies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[56], 1);
		logger.Warningf("Default policy emission is deprecated, please include policy specifications for the orderer org group %s in configtx.yaml", conf.Name)
		addSignaturePolicyDefaults(ordererOrgGroup, conf.ID, conf.AdminPrincipal != genesisconfig.AdminRoleAdminPrincipal)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[57], 1);{
		if err := addPolicies(ordererOrgGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[58], 1);
			return nil, errors.Wrapf(err, "error adding policies to orderer org group '%s'", conf.Name)
		}
	}}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[54], 1);addValue(ordererOrgGroup, channelconfig.MSPValue(mspConfig), channelconfig.AdminsPolicyKey)

	ordererOrgGroup.ModPolicy = channelconfig.AdminsPolicyKey
	return ordererOrgGroup, nil
}

// NewApplicationGroup returns the application component of the channel configuration.  It defines the organizations which are involved
// in application logic like chaincodes, and how these members may interact with the orderer.  It sets the mod_policy of all elements to "Admins".
func NewApplicationGroup(conf *genesisconfig.Application) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[59], 1);
	applicationGroup := cb.NewConfigGroup()
	if len(conf.Policies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[64], 1);
		logger.Warningf("Default policy emission is deprecated, please include policy specifications for the application group in configtx.yaml")
		addImplicitMetaPolicyDefaults(applicationGroup)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[65], 1);{
		if err := addPolicies(applicationGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[66], 1);
			return nil, errors.Wrapf(err, "error adding policies to application group")
		}
	}}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[60], 1);if len(conf.ACLs) > 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[67], 1);
		addValue(applicationGroup, channelconfig.ACLValues(conf.ACLs), channelconfig.AdminsPolicyKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[61], 1);if len(conf.Capabilities) > 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[68], 1);
		addValue(applicationGroup, channelconfig.CapabilitiesValue(conf.Capabilities), channelconfig.AdminsPolicyKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[62], 1);for _, org := range conf.Organizations {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[69], 1);
		var err error
		applicationGroup.Groups[org.Name], err = NewApplicationOrgGroup(org)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[70], 1);
			return nil, errors.Wrap(err, "failed to create application org")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[63], 1);applicationGroup.ModPolicy = channelconfig.AdminsPolicyKey
	return applicationGroup, nil
}

// NewApplicationOrgGroup returns an application org component of the channel configuration.  It defines the crypto material for the organization
// (its MSP) as well as its anchor peers for use by the gossip network.  It sets the mod_policy of all elements to "Admins".
func NewApplicationOrgGroup(conf *genesisconfig.Organization) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[71], 1);
	mspConfig, err := msp.GetVerifyingMspConfig(conf.MSPDir, conf.ID, conf.MSPType)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[75], 1);
		return nil, errors.Wrapf(err, "1 - Error loading MSP configuration for org %s", conf.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[72], 1);applicationOrgGroup := cb.NewConfigGroup()
	if len(conf.Policies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[76], 1);
		logger.Warningf("Default policy emission is deprecated, please include policy specifications for the application org group %s in configtx.yaml", conf.Name)
		addSignaturePolicyDefaults(applicationOrgGroup, conf.ID, conf.AdminPrincipal != genesisconfig.AdminRoleAdminPrincipal)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[77], 1);{
		if err := addPolicies(applicationOrgGroup, conf.Policies, channelconfig.AdminsPolicyKey); err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[78], 1);
			return nil, errors.Wrapf(err, "error adding policies to application org group %s", conf.Name)
		}
	}}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[73], 1);addValue(applicationOrgGroup, channelconfig.MSPValue(mspConfig), channelconfig.AdminsPolicyKey)

	var anchorProtos []*pb.AnchorPeer
	for _, anchorPeer := range conf.AnchorPeers {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[79], 1);
		anchorProtos = append(anchorProtos, &pb.AnchorPeer{
			Host: anchorPeer.Host,
			Port: int32(anchorPeer.Port),
		})
	}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[74], 1);addValue(applicationOrgGroup, channelconfig.AnchorPeersValue(anchorProtos), channelconfig.AdminsPolicyKey)

	applicationOrgGroup.ModPolicy = channelconfig.AdminsPolicyKey
	return applicationOrgGroup, nil
}

// NewConsortiumsGroup returns the consortiums component of the channel configuration.  This element is only defined for the ordering system channel.
// It sets the mod_policy for all elements to "/Channel/Orderer/Admins".
func NewConsortiumsGroup(conf map[string]*genesisconfig.Consortium) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[80], 1);
	consortiumsGroup := cb.NewConfigGroup()
	// This policy is not referenced anywhere, it is only used as part of the implicit meta policy rule at the channel level, so this setting
	// effectively degrades control of the ordering system channel to the ordering admins
	addPolicy(consortiumsGroup, policies.SignaturePolicy(channelconfig.AdminsPolicyKey, cauthdsl.AcceptAllPolicy), ordererAdminsPolicyName)

	for consortiumName, consortium := range conf {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[82], 1);
		var err error
		consortiumsGroup.Groups[consortiumName], err = NewConsortiumGroup(consortium)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[83], 1);
			return nil, errors.Wrapf(err, "failed to create consortium %s", consortiumName)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[81], 1);consortiumsGroup.ModPolicy = ordererAdminsPolicyName
	return consortiumsGroup, nil
}

// NewConsortiums returns a consortiums component of the channel configuration.  Each consortium defines the organizations which may be involved in channel
// creation, as well as the channel creation policy the orderer checks at channel creation time to authorize the action.  It sets the mod_policy of all
// elements to "/Channel/Orderer/Admins".
func NewConsortiumGroup(conf *genesisconfig.Consortium) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[84], 1);
	consortiumGroup := cb.NewConfigGroup()

	for _, org := range conf.Organizations {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[86], 1);
		var err error
		// Note, NewOrdererOrgGroup is correct here, as the structure is identical
		consortiumGroup.Groups[org.Name], err = NewOrdererOrgGroup(org)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[87], 1);
			return nil, errors.Wrap(err, "failed to create consortium org")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[85], 1);addValue(consortiumGroup, channelconfig.ChannelCreationPolicyValue(policies.ImplicitMetaAnyPolicy(channelconfig.AdminsPolicyKey).Value()), ordererAdminsPolicyName)

	consortiumGroup.ModPolicy = ordererAdminsPolicyName
	return consortiumGroup, nil
}

// NewChannelCreateConfigUpdate generates a ConfigUpdate which can be sent to the orderer to create a new channel.  Optionally, the channel group of the
// ordering system channel may be passed in, and the resulting ConfigUpdate will extract the appropriate versions from this file.
func NewChannelCreateConfigUpdate(channelID string, conf *genesisconfig.Profile) (*cb.ConfigUpdate, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[88], 1);
	if conf.Application == nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[93], 1);
		return nil, errors.New("cannot define a new channel with no Application section")
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[89], 1);if conf.Consortium == "" {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[94], 1);
		return nil, errors.New("cannot define a new channel with no Consortium value")
	}

	// Parse only the application section, and encapsulate it inside a channel group
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[90], 1);ag, err := NewApplicationGroup(conf.Application)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[95], 1);
		return nil, errors.Wrapf(err, "could not turn channel application profile into application group")
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[91], 1);var template, newChannelGroup *cb.ConfigGroup

	newChannelGroup = &cb.ConfigGroup{
		Groups: map[string]*cb.ConfigGroup{
			channelconfig.ApplicationGroupKey: ag,
		},
	}

	// Assume the orgs have not been modified
	template = proto.Clone(newChannelGroup).(*cb.ConfigGroup)
	template.Groups[channelconfig.ApplicationGroupKey].Values = nil
	template.Groups[channelconfig.ApplicationGroupKey].Policies = nil

	updt, err := update.Compute(&cb.Config{ChannelGroup: template}, &cb.Config{ChannelGroup: newChannelGroup})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[96], 1);
		return nil, errors.Wrapf(err, "could not compute update")
	}

	// Add the consortium name to create the channel for into the write set as required.
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[92], 1);updt.ChannelId = channelID
	updt.ReadSet.Values[channelconfig.ConsortiumKey] = &cb.ConfigValue{Version: 0}
	updt.WriteSet.Values[channelconfig.ConsortiumKey] = &cb.ConfigValue{
		Version: 0,
		Value: utils.MarshalOrPanic(&cb.Consortium{
			Name: conf.Consortium,
		}),
	}

	return updt, nil
}

// MakeChannelCreationTransaction is a handy utility function for creating transactions for channel creation
func MakeChannelCreationTransaction(channelID string, signer crypto.LocalSigner, conf *genesisconfig.Profile) (*cb.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[97], 1);
	newChannelConfigUpdate, err := NewChannelCreateConfigUpdate(channelID, conf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[100], 1);
		return nil, errors.Wrap(err, "config update generation failure")
	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[98], 1);newConfigUpdateEnv := &cb.ConfigUpdateEnvelope{
		ConfigUpdate: utils.MarshalOrPanic(newChannelConfigUpdate),
	}

	if signer != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[101], 1);
		sigHeader, err := signer.NewSignatureHeader()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[103], 1);
			return nil, errors.Wrap(err, "creating signature header failed")
		}

		_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[102], 1);newConfigUpdateEnv.Signatures = []*cb.ConfigSignature{{
			SignatureHeader: utils.MarshalOrPanic(sigHeader),
		}}

		newConfigUpdateEnv.Signatures[0].Signature, err = signer.Sign(util.ConcatenateBytes(newConfigUpdateEnv.Signatures[0].SignatureHeader, newConfigUpdateEnv.ConfigUpdate))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[104], 1);
			return nil, errors.Wrap(err, "signature failure over config update")
		}

	}

	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[99], 1);return utils.CreateSignedEnvelope(cb.HeaderType_CONFIG_UPDATE, channelID, signer, newConfigUpdateEnv, msgVersion, epoch)
}

// Bootstrapper is a wrapper around NewChannelConfigGroup which can produce genesis blocks
type Bootstrapper struct {
	channelGroup *cb.ConfigGroup
}

// New creates a new Bootstrapper for generating genesis blocks
func New(config *genesisconfig.Profile) *Bootstrapper {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[105], 1);
	channelGroup, err := NewChannelGroup(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[107], 1);
		logger.Panicf("Error creating channel group: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[106], 1);return &Bootstrapper{
		channelGroup: channelGroup,
	}
}

// GenesisBlock produces a genesis block for the default test chain id
func (bs *Bootstrapper) GenesisBlock() *cb.Block {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[108], 1);
	block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(genesisconfig.TestChainID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[110], 1);
		logger.Panicf("Error creating genesis block from channel group: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[109], 1);return block
}

// GenesisBlockForChannel produces a genesis block for a given channel ID
func (bs *Bootstrapper) GenesisBlockForChannel(channelID string) *cb.Block {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[111], 1);
	block, err := genesis.NewFactoryImpl(bs.channelGroup).Block(channelID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[113], 1);
		logger.Panicf("Error creating genesis block from channel group: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_376666666338326438346433.Count[112], 1);return block
}

var GoCover_0_376666666338326438346433 = struct {
	Count     [114]uint32
	Pos       [3 * 114]uint32
	NumStmt   [114]uint16
} {
	Pos: [3 * 114]uint32{
		56, 61, 0x20056, // [0]
		63, 68, 0x20054, // [1]
		70, 71, 0x2c006a, // [2]
		101, 101, 0xc0002, // [3]
		71, 72, 0x16002c, // [4]
		73, 75, 0x12001f, // [5]
		78, 84, 0x50004, // [6]
		85, 87, 0x12001c, // [7]
		90, 96, 0x50004, // [8]
		97, 98, 0x40000b, // [9]
		75, 77, 0x50012, // [10]
		87, 89, 0x50012, // [11]
		105, 109, 0x20038, // [12]
		114, 115, 0xd0051, // [13]
		121, 122, 0x8b0002, // [14]
		115, 118, 0x3000d, // [15]
		118, 120, 0x30008, // [16]
		130, 131, 0x19004c, // [17]
		135, 136, 0x1d0002, // [18]
		145, 149, 0x1b0002, // [19]
		153, 153, 0x200002, // [20]
		157, 159, 0x100002, // [21]
		163, 163, 0x1d0002, // [22]
		170, 170, 0x1d0002, // [23]
		177, 178, 0x1a0002, // [24]
		131, 133, 0x30019, // [25]
		136, 139, 0x3001d, // [26]
		139, 140, 0x610008, // [27]
		140, 142, 0x40061, // [28]
		149, 151, 0x3001b, // [29]
		153, 155, 0x30020, // [30]
		159, 161, 0x30010, // [31]
		163, 165, 0x11001d, // [32]
		165, 167, 0x40011, // [33]
		170, 172, 0x11001d, // [34]
		172, 174, 0x40011, // [35]
		184, 186, 0x1d004c, // [36]
		194, 206, 0x200002, // [37]
		210, 213, 0x1a0002, // [38]
		225, 227, 0x290002, // [39]
		235, 236, 0x1a0002, // [40]
		186, 189, 0x3001d, // [41]
		189, 190, 0x610008, // [42]
		190, 192, 0x40061, // [43]
		206, 208, 0x30020, // [44]
		214, 214, 0x190019, // [45]
		215, 216, 0x6d001a, // [46]
		217, 218, 0x4b0018, // [47]
		221, 222, 0x4a000a, // [48]
		218, 220, 0x4004b, // [49]
		227, 230, 0x110029, // [50]
		230, 232, 0x40011, // [51]
		241, 243, 0x100054, // [52]
		247, 248, 0x1d0002, // [53]
		257, 260, 0x1d0002, // [54]
		243, 245, 0x30010, // [55]
		248, 251, 0x3001d, // [56]
		251, 252, 0x640008, // [57]
		252, 254, 0x40064, // [58]
		265, 267, 0x1d0054, // [59]
		276, 276, 0x180002, // [60]
		280, 280, 0x200002, // [61]
		284, 284, 0x290002, // [62]
		292, 293, 0x1e0002, // [63]
		267, 270, 0x3001d, // [64]
		270, 271, 0x650008, // [65]
		271, 273, 0x40065, // [66]
		276, 278, 0x30018, // [67]
		280, 282, 0x30020, // [68]
		284, 287, 0x110029, // [69]
		287, 289, 0x40011, // [70]
		298, 300, 0x100058, // [71]
		304, 305, 0x1d0002, // [72]
		313, 316, 0x2e0002, // [73]
		322, 325, 0x210002, // [74]
		300, 302, 0x30010, // [75]
		305, 308, 0x3001d, // [76]
		308, 309, 0x680008, // [77]
		309, 311, 0x40068, // [78]
		316, 321, 0x3002e, // [79]
		330, 336, 0x2f005e, // [80]
		344, 345, 0x1e0002, // [81]
		336, 339, 0x11002f, // [82]
		339, 341, 0x40011, // [83]
		351, 354, 0x290052, // [84]
		363, 366, 0x1d0002, // [85]
		354, 358, 0x110029, // [86]
		358, 360, 0x40011, // [87]
		371, 372, 0x1d006c, // [88]
		376, 376, 0x1b0002, // [89]
		381, 382, 0x100002, // [90]
		386, 400, 0x100002, // [91]
		405, 414, 0x120002, // [92]
		372, 374, 0x3001d, // [93]
		376, 378, 0x3001b, // [94]
		382, 384, 0x30010, // [95]
		400, 402, 0x30010, // [96]
		418, 420, 0x100085, // [97]
		424, 428, 0x130002, // [98]
		445, 445, 0x7a0002, // [99]
		420, 422, 0x30010, // [100]
		428, 430, 0x110013, // [101]
		434, 439, 0x110003, // [102]
		430, 432, 0x40011, // [103]
		439, 441, 0x40011, // [104]
		454, 456, 0x100037, // [105]
		459, 461, 0x30002, // [106]
		456, 458, 0x30010, // [107]
		465, 467, 0x100032, // [108]
		470, 470, 0xe0002, // [109]
		467, 469, 0x30010, // [110]
		474, 476, 0x10004c, // [111]
		479, 479, 0xe0002, // [112]
		476, 478, 0x30010, // [113]
	},
	NumStmt: [114]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		3, // 12
		1, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		2, // 18
		4, // 19
		1, // 20
		3, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		2, // 32
		1, // 33
		2, // 34
		1, // 35
		2, // 36
		5, // 37
		3, // 38
		2, // 39
		2, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		0, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		3, // 50
		1, // 51
		2, // 52
		2, // 53
		3, // 54
		1, // 55
		2, // 56
		1, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		1, // 62
		2, // 63
		2, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		3, // 69
		1, // 70
		2, // 71
		2, // 72
		3, // 73
		3, // 74
		1, // 75
		2, // 76
		1, // 77
		1, // 78
		1, // 79
		3, // 80
		2, // 81
		3, // 82
		1, // 83
		2, // 84
		3, // 85
		3, // 86
		1, // 87
		1, // 88
		1, // 89
		2, // 90
		7, // 91
		4, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		2, // 97
		2, // 98
		1, // 99
		1, // 100
		2, // 101
		3, // 102
		1, // 103
		1, // 104
		2, // 105
		1, // 106
		1, // 107
		2, // 108
		1, // 109
		1, // 110
		2, // 111
		1, // 112
		1, // 113
	},
}
var _ = _cover_atomic_.LoadUint32
