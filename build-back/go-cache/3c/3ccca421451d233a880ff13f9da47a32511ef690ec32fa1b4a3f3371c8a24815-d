//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/cluster/deliver.go:1
/*
Copyright IBM Corp. 2018 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cluster; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"math"
	"math/rand"
	"reflect"
	"sync"
	"time"

	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/orderer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"google.golang.org/grpc"
)

// BlockPuller pulls blocks from remote ordering nodes.
// Its operations are not thread safe.
type BlockPuller struct {
	// Configuration
	MaxTotalBufferBytes int
	Signer              crypto.LocalSigner
	TLSCert             []byte
	Channel             string
	FetchTimeout        time.Duration
	RetryTimeout        time.Duration
	Logger              *flogging.FabricLogger
	Dialer              Dialer
	VerifyBlockSequence BlockSequenceVerifier
	Endpoints           []string
	// Internal state
	stream       *ImpatientStream
	blockBuff    []*common.Block
	latestSeq    uint64
	endpoint     string
	conn         *grpc.ClientConn
	cancelStream func()
}

// Clone returns a copy of this BlockPuller initialized
// for the given channel
func (p *BlockPuller) Clone() *BlockPuller {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[0], 1);
	// Clone by value
	copy := *p
	// Reset internal state
	copy.stream = nil
	copy.blockBuff = nil
	copy.latestSeq = 0
	copy.endpoint = ""
	copy.conn = nil
	copy.cancelStream = nil
	return &copy
}

// Close makes the BlockPuller close the connection and stream
// with the remote endpoint.
func (p *BlockPuller) Close() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[1], 1);
	if p.cancelStream != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[4], 1);
		p.cancelStream()
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[2], 1);p.cancelStream = nil

	if p.conn != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[5], 1);
		p.conn.Close()
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[3], 1);p.conn = nil
	p.endpoint = ""
	p.latestSeq = 0
}

// PullBlock blocks until a block with the given sequence is fetched
// from some remote ordering node.
func (p *BlockPuller) PullBlock(seq uint64) *common.Block {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[6], 1);
	for {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[7], 1);
		block := p.tryFetchBlock(seq)
		if block != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[8], 1);
			return block
		}
	}
}

// HeightsByEndpoints returns the block heights by endpoints of orderers
func (p *BlockPuller) HeightsByEndpoints() map[string]uint64 {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[9], 1);
	res := make(map[string]uint64)
	for endpoint, endpointInfo := range p.probeEndpoints(1).byEndpoints() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[11], 1);
		endpointInfo.conn.Close()
		res[endpoint] = endpointInfo.lastBlockSeq + 1
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[10], 1);p.Logger.Info("Returning the heights of OSNs mapped by endpoints", res)
	return res
}

func (p *BlockPuller) tryFetchBlock(seq uint64) *common.Block {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[12], 1);
	var reConnected bool
	for p.isDisconnected() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[17], 1);
		reConnected = true
		p.connectToSomeEndpoint(seq)
		if p.isDisconnected() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[18], 1);
			time.Sleep(p.RetryTimeout)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[13], 1);block := p.popBlock(seq)
	if block != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[19], 1);
		return block
	}
	// Else, buffer is empty. So we need to pull blocks
	// to re-fill it.
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[14], 1);if err := p.pullBlocks(seq, reConnected); err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[20], 1);
		p.Logger.Errorf("Failed pulling blocks: %v", err)
		// Something went wrong, disconnect. and return nil
		p.Close()
		// If we have a block in the buffer, return it.
		if len(p.blockBuff) > 0 {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[22], 1);
			return p.blockBuff[0]
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[21], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[15], 1);if err := p.VerifyBlockSequence(p.blockBuff); err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[23], 1);
		p.Close()
		p.Logger.Errorf("Failed verifying received blocks: %v", err)
		return nil
	}

	// At this point, the buffer is full, so shift it and return the first block.
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[16], 1);return p.popBlock(seq)
}

func (p *BlockPuller) setCancelStreamFunc(f func()) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[24], 1);
	p.cancelStream = f
}

func (p *BlockPuller) pullBlocks(seq uint64, reConnected bool) error {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[25], 1);
	env, err := p.seekNextEnvelope(seq)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[29], 1);
		p.Logger.Errorf("Failed creating seek envelope: %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[26], 1);stream, err := p.obtainStream(reConnected, env, seq)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[30], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[27], 1);var totalSize int
	p.blockBuff = nil
	nextExpectedSequence := seq
	for totalSize < p.MaxTotalBufferBytes && nextExpectedSequence <= p.latestSeq {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[31], 1);
		resp, err := stream.Recv()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[35], 1);
			p.Logger.Errorf("Failed receiving next block from %s: %v", p.endpoint, err)
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[32], 1);block, err := extractBlockFromResponse(resp)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[36], 1);
			p.Logger.Errorf("Received a bad block from %s: %v", p.endpoint, err)
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[33], 1);seq := block.Header.Number
		if seq != nextExpectedSequence {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[37], 1);
			p.Logger.Errorf("Expected to receive sequence %d but got %d instead", nextExpectedSequence, seq)
			return errors.Errorf("got unexpected sequence from %s - (%d) instead of (%d)", p.endpoint, seq, nextExpectedSequence)
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[34], 1);size := blockSize(block)
		totalSize += size
		p.blockBuff = append(p.blockBuff, block)
		nextExpectedSequence++
		p.Logger.Infof("Got block %d of size %dKB from %s", seq, size/1024, p.endpoint)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[28], 1);return nil
}

func (p *BlockPuller) obtainStream(reConnected bool, env *common.Envelope, seq uint64) (*ImpatientStream, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[38], 1);
	var stream *ImpatientStream
	var err error
	if reConnected {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[40], 1);
		p.Logger.Infof("Sending request for block %d to %s", seq, p.endpoint)
		stream, err = p.requestBlocks(p.endpoint, NewImpatientStream(p.conn, p.FetchTimeout), env)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[42], 1);
			return nil, err
		}
		// Stream established successfully.
		// In next iterations of this function, reuse it.
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[41], 1);p.stream = stream
	} else{ _cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[43], 1);{
		// Reuse previous stream
		stream = p.stream
	}}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[39], 1);p.setCancelStreamFunc(stream.cancelFunc)
	return stream, nil
}

// popBlock pops a block from the in-memory buffer and returns it,
// or returns nil if the buffer is empty or the block doesn't match
// the given wanted sequence.
func (p *BlockPuller) popBlock(seq uint64) *common.Block {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[44], 1);
	if len(p.blockBuff) == 0 {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[47], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[45], 1);block, rest := p.blockBuff[0], p.blockBuff[1:]
	p.blockBuff = rest
	// If the requested block sequence is the wrong one, discard the buffer
	// to start fetching blocks all over again.
	if seq != block.Header.Number {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[48], 1);
		p.blockBuff = nil
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[46], 1);return block
}

func (p *BlockPuller) isDisconnected() bool {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[49], 1);
	return p.conn == nil
}

// connectToSomeEndpoint makes the BlockPuller connect to some endpoint that has
// the given minimum block sequence.
func (p *BlockPuller) connectToSomeEndpoint(minRequestedSequence uint64) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[50], 1);
	// Probe all endpoints in parallel, searching an endpoint with a given minimum block sequence
	// and then sort them by their endpoints to a map.
	endpointsInfo := p.probeEndpoints(minRequestedSequence).byEndpoints()
	if len(endpointsInfo) == 0 {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[53], 1);
		p.Logger.Warningf("Could not connect to any endpoint of %v", p.Endpoints)
		return
	}

	// Choose a random endpoint out of the available endpoints
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[51], 1);chosenEndpoint := randomEndpoint(endpointsInfo)
	// Disconnect all connections but this endpoint
	for endpoint, endpointInfo := range endpointsInfo {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[54], 1);
		if endpoint == chosenEndpoint {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[56], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[55], 1);endpointInfo.conn.Close()
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[52], 1);p.conn = endpointsInfo[chosenEndpoint].conn
	p.endpoint = chosenEndpoint
	p.latestSeq = endpointsInfo[chosenEndpoint].lastBlockSeq

	p.Logger.Infof("Connected to %s with last block seq of %d", p.endpoint, p.latestSeq)
}

// probeEndpoints reaches to all endpoints known and returns the latest block sequences
// of the endpoints, as well as gRPC connections to them.
func (p *BlockPuller) probeEndpoints(minRequestedSequence uint64) *endpointInfoBucket {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[57], 1);
	endpointsInfo := make(chan *endpointInfo, len(p.Endpoints))

	var wg sync.WaitGroup
	wg.Add(len(p.Endpoints))

	for _, endpoint := range p.Endpoints {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[59], 1);
		go func(endpoint string) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[60], 1);
			defer wg.Done()
			endpointInfo, err := p.probeEndpoint(endpoint, minRequestedSequence)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[62], 1);
				return
			}
			_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[61], 1);endpointsInfo <- endpointInfo
		}(endpoint)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[58], 1);wg.Wait()

	close(endpointsInfo)
	return &endpointInfoBucket{
		bucket: endpointsInfo,
		logger: p.Logger,
	}
}

// probeEndpoint returns a gRPC connection and the latest block sequence of an endpoint with the given
// requires minimum sequence, or error if something goes wrong.
func (p *BlockPuller) probeEndpoint(endpoint string, minRequestedSequence uint64) (*endpointInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[63], 1);
	conn, err := p.Dialer.Dial(endpoint)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[66], 1);
		p.Logger.Warningf("Failed connecting to %s: %v", endpoint, err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[64], 1);lastBlockSeq, err := p.fetchLastBlockSeq(minRequestedSequence, endpoint, conn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[67], 1);
		conn.Close()
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[65], 1);return &endpointInfo{conn: conn, lastBlockSeq: lastBlockSeq, endpoint: endpoint}, nil
}

// randomEndpoint returns a random endpoint of the given endpointInfo
func randomEndpoint(endpointsToHeight map[string]*endpointInfo) string {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[68], 1);
	var candidates []string
	for endpoint := range endpointsToHeight {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[70], 1);
		candidates = append(candidates, endpoint)
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[69], 1);rand.Seed(time.Now().UnixNano())
	return candidates[rand.Intn(len(candidates))]
}

// fetchLastBlockSeq returns the last block sequence of an endpoint with the given gRPC connection.
func (p *BlockPuller) fetchLastBlockSeq(minRequestedSequence uint64, endpoint string, conn *grpc.ClientConn) (uint64, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[71], 1);
	env, err := p.seekLastEnvelope()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[77], 1);
		p.Logger.Errorf("Failed creating seek envelope for %s: %v", endpoint, err)
		return 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[72], 1);stream, err := p.requestBlocks(endpoint, NewImpatientStream(conn, p.FetchTimeout), env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[78], 1);
		return 0, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[73], 1);defer stream.abort()

	resp, err := stream.Recv()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[79], 1);
		p.Logger.Errorf("Failed receiving the latest block from %s: %v", endpoint, err)
		return 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[74], 1);block, err := extractBlockFromResponse(resp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[80], 1);
		p.Logger.Errorf("Received a bad block from %s: %v", endpoint, err)
		return 0, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[75], 1);stream.CloseSend()

	seq := block.Header.Number
	if seq < minRequestedSequence {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[81], 1);
		err := errors.Errorf("minimum requested sequence is %d but %s is at sequence %d", minRequestedSequence, endpoint, seq)
		p.Logger.Infof("Skipping pulling from %s: %v", endpoint, err)
		return 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[76], 1);p.Logger.Infof("%s is at block sequence of %d", endpoint, seq)
	return block.Header.Number, nil
}

// requestBlocks starts requesting blocks from the given endpoint, using the given ImpatientStreamCreator by sending
// the given envelope.
// It returns a stream that is used to pull blocks, or error if something goes wrong.
func (p *BlockPuller) requestBlocks(endpoint string, newStream ImpatientStreamCreator, env *common.Envelope) (*ImpatientStream, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[82], 1);
	stream, err := newStream()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[85], 1);
		p.Logger.Warningf("Failed establishing deliver stream with %s", endpoint)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[83], 1);if err := stream.Send(env); err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[86], 1);
		p.Logger.Errorf("Failed sending seek envelope to %s: %v", endpoint, err)
		stream.abort()
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[84], 1);return stream, nil
}

func extractBlockFromResponse(resp *orderer.DeliverResponse) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[87], 1);
	switch t := resp.Type.(type) {
	case *orderer.DeliverResponse_Block:_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[88], 1);
		block := t.Block
		if block == nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[94], 1);
			return nil, errors.New("block is nil")
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[89], 1);if block.Data == nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[95], 1);
			return nil, errors.New("block data is nil")
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[90], 1);if block.Header == nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[96], 1);
			return nil, errors.New("block header is nil")
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[91], 1);if block.Metadata == nil || len(block.Metadata.Metadata) == 0 {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[97], 1);
			return nil, errors.New("block metadata is empty")
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[92], 1);return block, nil
	default:_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[93], 1);
		return nil, errors.Errorf("response is of type %v, but expected a block", reflect.TypeOf(resp.Type))
	}
}

func (p *BlockPuller) seekLastEnvelope() (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[98], 1);
	return utils.CreateSignedEnvelopeWithTLSBinding(
		common.HeaderType_DELIVER_SEEK_INFO,
		p.Channel,
		p.Signer,
		last(),
		int32(0),
		uint64(0),
		util.ComputeSHA256(p.TLSCert),
	)
}

func (p *BlockPuller) seekNextEnvelope(startSeq uint64) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[99], 1);
	return utils.CreateSignedEnvelopeWithTLSBinding(
		common.HeaderType_DELIVER_SEEK_INFO,
		p.Channel,
		p.Signer,
		nextSeekInfo(startSeq),
		int32(0),
		uint64(0),
		util.ComputeSHA256(p.TLSCert),
	)
}

func last() *orderer.SeekInfo {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[100], 1);
	return &orderer.SeekInfo{
		Start:    &orderer.SeekPosition{Type: &orderer.SeekPosition_Newest{Newest: &orderer.SeekNewest{}}},
		Stop:     &orderer.SeekPosition{Type: &orderer.SeekPosition_Specified{Specified: &orderer.SeekSpecified{Number: math.MaxUint64}}},
		Behavior: orderer.SeekInfo_BLOCK_UNTIL_READY,
	}
}

func nextSeekInfo(startSeq uint64) *orderer.SeekInfo {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[101], 1);
	return &orderer.SeekInfo{
		Start:    &orderer.SeekPosition{Type: &orderer.SeekPosition_Specified{Specified: &orderer.SeekSpecified{Number: startSeq}}},
		Stop:     &orderer.SeekPosition{Type: &orderer.SeekPosition_Specified{Specified: &orderer.SeekSpecified{Number: math.MaxUint64}}},
		Behavior: orderer.SeekInfo_BLOCK_UNTIL_READY,
	}
}

func blockSize(block *common.Block) int {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[102], 1);
	return len(utils.MarshalOrPanic(block))
}

type endpointInfo struct {
	endpoint     string
	conn         *grpc.ClientConn
	lastBlockSeq uint64
}

type endpointInfoBucket struct {
	bucket <-chan *endpointInfo
	logger *flogging.FabricLogger
}

func (eib endpointInfoBucket) byEndpoints() map[string]*endpointInfo {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[103], 1);
	infoByEndpoints := make(map[string]*endpointInfo)
	for endpointInfo := range eib.bucket {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[105], 1);
		if _, exists := infoByEndpoints[endpointInfo.endpoint]; exists {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[107], 1);
			eib.logger.Warningf("Duplicate endpoint found(%s), skipping it", endpointInfo.endpoint)
			endpointInfo.conn.Close()
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[106], 1);infoByEndpoints[endpointInfo.endpoint] = endpointInfo
	}
	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[104], 1);return infoByEndpoints
}

// ImpatientStreamCreator creates an ImpatientStream
type ImpatientStreamCreator func() (*ImpatientStream, error)

// ImpatientStream aborts the stream if it waits for too long for a message.
type ImpatientStream struct {
	waitTimeout time.Duration
	orderer.AtomicBroadcast_DeliverClient
	cancelFunc func()
}

func (stream *ImpatientStream) abort() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[108], 1);
	stream.cancelFunc()
}

// Recv blocks until a response is received from the stream or the
// timeout expires.
func (stream *ImpatientStream) Recv() (*orderer.DeliverResponse, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[109], 1);
	// Initialize a timeout to cancel the stream when it expires
	timeout := time.NewTimer(stream.waitTimeout)
	defer timeout.Stop()

	responseChan := make(chan errorAndResponse, 1)

	// receive waitGroup ensures the goroutine below exits before
	// this function exits.
	var receive sync.WaitGroup
	receive.Add(1)
	defer receive.Wait()

	go func() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[111], 1);
		defer receive.Done()
		resp, err := stream.AtomicBroadcast_DeliverClient.Recv()
		responseChan <- errorAndResponse{err: err, resp: resp}
	}()

	_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[110], 1);select {
	case <-timeout.C:_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[112], 1);
		stream.cancelFunc()
		return nil, errors.Errorf("didn't receive a response within %v", stream.waitTimeout)
	case respAndErr := <-responseChan:_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[113], 1);
		return respAndErr.resp, respAndErr.err
	}
}

// NewImpatientStream returns a ImpatientStreamCreator that creates impatientStreams.
func NewImpatientStream(conn *grpc.ClientConn, waitTimeout time.Duration) ImpatientStreamCreator {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[114], 1);
	return func() (*ImpatientStream, error) {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[115], 1);
		abc := orderer.NewAtomicBroadcastClient(conn)
		ctx, cancel := context.WithCancel(context.Background())

		stream, err := abc.Deliver(ctx)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[117], 1);
			cancel()
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[116], 1);once := &sync.Once{}
		return &ImpatientStream{
			waitTimeout: waitTimeout,
			// The stream might be canceled while Close() is being called, but also
			// while a timeout expires, so ensure it's only called once.
			cancelFunc: func() {_cover_atomic_.AddUint32(&GoCover_2_363733313532663932376566.Count[118], 1);
				once.Do(cancel)
			},
			AtomicBroadcast_DeliverClient: stream,
		}, nil
	}
}

type errorAndResponse struct {
	err  error
	resp *orderer.DeliverResponse
}

var GoCover_2_363733313532663932376566 = struct {
	Count     [119]uint32
	Pos       [3 * 119]uint32
	NumStmt   [119]uint16
} {
	Pos: [3 * 119]uint32{
		52, 63, 0x2002c, // [0]
		67, 68, 0x1b001f, // [1]
		71, 73, 0x130002, // [2]
		76, 78, 0x110002, // [3]
		68, 70, 0x3001b, // [4]
		73, 75, 0x30013, // [5]
		83, 84, 0x6003b, // [6]
		84, 86, 0x130006, // [7]
		86, 88, 0x40013, // [8]
		93, 95, 0x48003e, // [9]
		99, 100, 0xc0002, // [10]
		95, 98, 0x30048, // [11]
		103, 105, 0x19003f, // [12]
		113, 114, 0x120002, // [13]
		119, 119, 0x370002, // [14]
		130, 130, 0x3b0002, // [15]
		137, 137, 0x180002, // [16]
		105, 108, 0x190019, // [17]
		108, 110, 0x40019, // [18]
		114, 116, 0x30012, // [19]
		119, 124, 0x1b0037, // [20]
		127, 127, 0xd0003, // [21]
		124, 126, 0x4001b, // [22]
		130, 134, 0x3003b, // [23]
		140, 142, 0x20035, // [24]
		144, 146, 0x100046, // [25]
		151, 152, 0x100002, // [26]
		156, 159, 0x4f0002, // [27]
		182, 182, 0xc0002, // [28]
		146, 149, 0x30010, // [29]
		152, 154, 0x30010, // [30]
		159, 161, 0x11004f, // [31]
		166, 167, 0x110003, // [32]
		171, 172, 0x220003, // [33]
		176, 180, 0x520003, // [34]
		161, 164, 0x40011, // [35]
		167, 170, 0x40011, // [36]
		172, 175, 0x40022, // [37]
		185, 188, 0x110072, // [38]
		202, 203, 0x140002, // [39]
		188, 191, 0x110011, // [40]
		196, 196, 0x140003, // [41]
		191, 193, 0x40011, // [42]
		197, 200, 0x30008, // [43]
		209, 210, 0x1b003a, // [44]
		213, 217, 0x200002, // [45]
		221, 221, 0xe0002, // [46]
		210, 212, 0x3001b, // [47]
		217, 220, 0x30020, // [48]
		224, 226, 0x2002d, // [49]
		230, 234, 0x1d004a, // [50]
		240, 242, 0x340002, // [51]
		249, 253, 0x560002, // [52]
		234, 237, 0x3001d, // [53]
		242, 243, 0x210034, // [54]
		246, 246, 0x1c0003, // [55]
		243, 244, 0xc0021, // [56]
		258, 264, 0x270057, // [57]
		274, 280, 0x30002, // [58]
		264, 265, 0x1c0027, // [59]
		265, 268, 0x12001c, // [60]
		271, 271, 0x210004, // [61]
		268, 270, 0x50012, // [62]
		285, 287, 0x10006a, // [63]
		292, 293, 0x100002, // [64]
		298, 298, 0x570002, // [65]
		287, 290, 0x30010, // [66]
		293, 296, 0x30010, // [67]
		302, 304, 0x2a0048, // [68]
		308, 309, 0x2f0002, // [69]
		304, 306, 0x3002a, // [70]
		313, 315, 0x10007e, // [71]
		320, 321, 0x100002, // [72]
		324, 327, 0x100002, // [73]
		332, 333, 0x100002, // [74]
		337, 340, 0x200002, // [75]
		346, 347, 0x210002, // [76]
		315, 318, 0x30010, // [77]
		321, 323, 0x30010, // [78]
		327, 330, 0x30010, // [79]
		333, 336, 0x30010, // [80]
		340, 344, 0x30020, // [81]
		353, 355, 0x100088, // [82]
		360, 360, 0x290002, // [83]
		365, 365, 0x140002, // [84]
		355, 358, 0x30010, // [85]
		360, 364, 0x30029, // [86]
		368, 369, 0x1f0055, // [87]
		370, 372, 0x130026, // [88]
		375, 375, 0x180003, // [89]
		378, 378, 0x1a0003, // [90]
		381, 381, 0x410003, // [91]
		384, 384, 0x140003, // [92]
		385, 386, 0x67000a, // [93]
		372, 374, 0x40013, // [94]
		375, 377, 0x40018, // [95]
		378, 380, 0x4001a, // [96]
		381, 383, 0x40041, // [97]
		390, 400, 0x20044, // [98]
		402, 412, 0x20053, // [99]
		414, 420, 0x2001f, // [100]
		422, 428, 0x20036, // [101]
		430, 432, 0x20029, // [102]
		445, 447, 0x270046, // [103]
		455, 455, 0x180002, // [104]
		447, 448, 0x420027, // [105]
		453, 453, 0x380003, // [106]
		448, 451, 0xc0042, // [107]
		468, 470, 0x20028, // [108]
		474, 487, 0xc0049, // [109]
		493, 493, 0x90002, // [110]
		487, 491, 0x3000c, // [111]
		494, 496, 0x570013, // [112]
		497, 498, 0x290024, // [113]
		503, 504, 0x2a0062, // [114]
		504, 509, 0x11002a, // [115]
		514, 519, 0x170003, // [116]
		509, 512, 0x40011, // [117]
		519, 521, 0x50017, // [118]
	},
	NumStmt: [119]uint16{
		8, // 0
		1, // 1
		2, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		2, // 9
		2, // 10
		2, // 11
		2, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		3, // 17
		1, // 18
		1, // 19
		3, // 20
		1, // 21
		1, // 22
		3, // 23
		1, // 24
		2, // 25
		2, // 26
		4, // 27
		1, // 28
		2, // 29
		1, // 30
		2, // 31
		2, // 32
		2, // 33
		5, // 34
		2, // 35
		2, // 36
		2, // 37
		3, // 38
		2, // 39
		3, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		3, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		2, // 50
		2, // 51
		4, // 52
		2, // 53
		1, // 54
		1, // 55
		1, // 56
		4, // 57
		3, // 58
		1, // 59
		3, // 60
		1, // 61
		1, // 62
		2, // 63
		2, // 64
		1, // 65
		2, // 66
		2, // 67
		2, // 68
		2, // 69
		1, // 70
		2, // 71
		2, // 72
		3, // 73
		2, // 74
		3, // 75
		2, // 76
		2, // 77
		1, // 78
		2, // 79
		2, // 80
		3, // 81
		2, // 82
		1, // 83
		1, // 84
		2, // 85
		3, // 86
		1, // 87
		2, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
		2, // 103
		1, // 104
		1, // 105
		1, // 106
		3, // 107
		1, // 108
		7, // 109
		1, // 110
		3, // 111
		2, // 112
		1, // 113
		1, // 114
		4, // 115
		2, // 116
		2, // 117
		1, // 118
	},
}
var _ = _cover_atomic_.LoadUint32
