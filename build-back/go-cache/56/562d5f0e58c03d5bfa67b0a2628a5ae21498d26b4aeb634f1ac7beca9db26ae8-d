//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/kv_ledger.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package kvledger; import _cover_atomic_ "sync/atomic"

import (
	"sync"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	commonledger "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
	"github.com/hyperledger/fabric/core/ledger/confighistory"
	"github.com/hyperledger/fabric/core/ledger/kvledger/bookkeeping"
	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/ledgerstorage"
	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("kvledger")

// KVLedger provides an implementation of `ledger.PeerLedger`.
// This implementation provides a key-value based data model
type kvLedger struct {
	ledgerID               string
	blockStore             *ledgerstorage.Store
	txtmgmt                txmgr.TxMgr
	historyDB              historydb.HistoryDB
	configHistoryRetriever ledger.ConfigHistoryRetriever
	blockAPIsRWLock        *sync.RWMutex
	stats                  *ledgerStats
}

// NewKVLedger constructs new `KVLedger`
func newKVLedger(
	ledgerID string,
	blockStore *ledgerstorage.Store,
	versionedDB privacyenabledstate.DB,
	historyDB historydb.HistoryDB,
	configHistoryMgr confighistory.Mgr,
	stateListeners []ledger.StateListener,
	bookkeeperProvider bookkeeping.Provider,
	ccInfoProvider ledger.DeployedChaincodeInfoProvider,
	stats *ledgerStats,
) (*kvLedger, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[0], 1);
	logger.Debugf("Creating KVLedger ledgerID=%s: ", ledgerID)
	// Create a kvLedger for this chain/ledger, which encasulates the underlying
	// id store, blockstore, txmgr (state database), history database
	l := &kvLedger{ledgerID: ledgerID, blockStore: blockStore, historyDB: historyDB, blockAPIsRWLock: &sync.RWMutex{}}

	// TODO Move the function `GetChaincodeEventListener` to ledger interface and
	// this functionality of regiserting for events to ledgermgmt package so that this
	// is reused across other future ledger implementations
	ccEventListener := versionedDB.GetChaincodeEventListener()
	logger.Debugf("Register state db for chaincode lifecycle events: %t", ccEventListener != nil)
	if ccEventListener != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[5], 1);
		cceventmgmt.GetMgr().Register(ledgerID, ccEventListener)
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[1], 1);btlPolicy := pvtdatapolicy.ConstructBTLPolicy(&collectionInfoRetriever{l, ccInfoProvider})
	if err := l.initTxMgr(versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[6], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[2], 1);l.initBlockStore(btlPolicy)
	//Recover both state DB and history DB if they are out of sync with block storage
	if err := l.recoverDBs(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[7], 1);
		panic(errors.WithMessage(err, "error during state DB recovery"))
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[3], 1);l.configHistoryRetriever = configHistoryMgr.GetRetriever(ledgerID, l)

	info, err := l.GetBlockchainInfo()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[8], 1);
		return nil, err
	}
	// initialize stat with the current height
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[4], 1);stats.updateBlockchainHeight(info.Height)
	l.stats = stats
	return l, nil
}

func (l *kvLedger) initTxMgr(versionedDB privacyenabledstate.DB, stateListeners []ledger.StateListener,
	btlPolicy pvtdatapolicy.BTLPolicy, bookkeeperProvider bookkeeping.Provider, ccInfoProvider ledger.DeployedChaincodeInfoProvider) error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[9], 1);
	var err error
	l.txtmgmt, err = lockbasedtxmgr.NewLockBasedTxMgr(l.ledgerID, versionedDB, stateListeners, btlPolicy, bookkeeperProvider, ccInfoProvider)
	return err
}

func (l *kvLedger) initBlockStore(btlPolicy pvtdatapolicy.BTLPolicy) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[10], 1);
	l.blockStore.Init(btlPolicy)
}

//Recover the state database and history database (if exist)
//by recommitting last valid blocks
func (l *kvLedger) recoverDBs() error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[11], 1);
	logger.Debugf("Entering recoverDB()")
	if err := l.syncStateAndHistoryDBWithBlockstore(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[14], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[12], 1);if err := l.syncStateDBWithPvtdatastore(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[15], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[13], 1);return nil
}

func (l *kvLedger) syncStateAndHistoryDBWithBlockstore() error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[16], 1);
	//If there is no block in blockstorage, nothing to recover.
	info, _ := l.blockStore.GetBlockchainInfo()
	if info.Height == 0 {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[23], 1);
		logger.Debug("Block storage is empty.")
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[17], 1);lastAvailableBlockNum := info.Height - 1
	recoverables := []recoverable{l.txtmgmt, l.historyDB}
	recoverers := []*recoverer{}
	for _, recoverable := range recoverables {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[24], 1);
		recoverFlag, firstBlockNum, err := recoverable.ShouldRecover(lastAvailableBlockNum)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[26], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[25], 1);if recoverFlag {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[27], 1);
			recoverers = append(recoverers, &recoverer{firstBlockNum, recoverable})
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[18], 1);if len(recoverers) == 0 {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[28], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[19], 1);if len(recoverers) == 1 {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[29], 1);
		return l.recommitLostBlocks(recoverers[0].firstBlockNum, lastAvailableBlockNum, recoverers[0].recoverable)
	}

	// both dbs need to be recovered
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[20], 1);if recoverers[0].firstBlockNum > recoverers[1].firstBlockNum {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[30], 1);
		// swap (put the lagger db at 0 index)
		recoverers[0], recoverers[1] = recoverers[1], recoverers[0]
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[21], 1);if recoverers[0].firstBlockNum != recoverers[1].firstBlockNum {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[31], 1);
		// bring the lagger db equal to the other db
		if err := l.recommitLostBlocks(recoverers[0].firstBlockNum, recoverers[1].firstBlockNum-1,
			recoverers[0].recoverable); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[32], 1);
			return err
		}
	}
	// get both the db upto block storage
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[22], 1);return l.recommitLostBlocks(recoverers[1].firstBlockNum, lastAvailableBlockNum,
		recoverers[0].recoverable, recoverers[1].recoverable)
}

func (l *kvLedger) syncStateDBWithPvtdatastore() error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[33], 1);
	// TODO: So far, the design philosophy was that the scope of block storage is
	// limited to storing and retrieving blocks data with certain guarantees and statedb is
	// for the state management. The higher layer, 'kvledger', coordinates the acts between
	// the two. However, with maintaining the state of the consumption of blocks (i.e,
	// lastUpdatedOldBlockList for pvtstore reconciliation) within private data block storage
	// breaks that assumption. The knowledge of what blocks have been consumed for the purpose
	// of state update should not lie with the source (i.e., pvtdatastorage). A potential fix
	// is mentioned in FAB-12731
	blocksPvtData, err := l.blockStore.GetLastUpdatedOldBlocksPvtData()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[37], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[34], 1);if err := l.txtmgmt.RemoveStaleAndCommitPvtDataOfOldBlocks(blocksPvtData); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[38], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[35], 1);if err := l.blockStore.ResetLastUpdatedOldBlocksList(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[39], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[36], 1);return nil
}

//recommitLostBlocks retrieves blocks in specified range and commit the write set to either
//state DB or history DB or both
func (l *kvLedger) recommitLostBlocks(firstBlockNum uint64, lastBlockNum uint64, recoverables ...recoverable) error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[40], 1);
	logger.Infof("Recommitting lost blocks - firstBlockNum=%d, lastBlockNum=%d, recoverables=%#v", firstBlockNum, lastBlockNum, recoverables)
	var err error
	var blockAndPvtdata *ledger.BlockAndPvtData
	for blockNumber := firstBlockNum; blockNumber <= lastBlockNum; blockNumber++ {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[42], 1);
		if blockAndPvtdata, err = l.GetPvtDataAndBlockByNum(blockNumber, nil); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[44], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[43], 1);for _, r := range recoverables {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[45], 1);
			if err := r.CommitLostBlock(blockAndPvtdata); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[46], 1);
				return err
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[41], 1);logger.Infof("Recommitted lost blocks - firstBlockNum=%d, lastBlockNum=%d, recoverables=%#v", firstBlockNum, lastBlockNum, recoverables)
	return nil
}

// GetTransactionByID retrieves a transaction by id
func (l *kvLedger) GetTransactionByID(txID string) (*peer.ProcessedTransaction, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[47], 1);
	tranEnv, err := l.blockStore.RetrieveTxByID(txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[50], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[48], 1);txVResult, err := l.blockStore.RetrieveTxValidationCodeByTxID(txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[51], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[49], 1);processedTran := &peer.ProcessedTransaction{TransactionEnvelope: tranEnv, ValidationCode: int32(txVResult)}
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return processedTran, nil
}

// GetBlockchainInfo returns basic info about blockchain
func (l *kvLedger) GetBlockchainInfo() (*common.BlockchainInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[52], 1);
	bcInfo, err := l.blockStore.GetBlockchainInfo()
	l.blockAPIsRWLock.RLock()
	defer l.blockAPIsRWLock.RUnlock()
	return bcInfo, err
}

// GetBlockByNumber returns block at a given height
// blockNumber of  math.MaxUint64 will return last block
func (l *kvLedger) GetBlockByNumber(blockNumber uint64) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[53], 1);
	block, err := l.blockStore.RetrieveBlockByNumber(blockNumber)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return block, err
}

// GetBlocksIterator returns an iterator that starts from `startBlockNumber`(inclusive).
// The iterator is a blocking iterator i.e., it blocks till the next block gets available in the ledger
// ResultsIterator contains type BlockHolder
func (l *kvLedger) GetBlocksIterator(startBlockNumber uint64) (commonledger.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[54], 1);
	blkItr, err := l.blockStore.RetrieveBlocks(startBlockNumber)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[56], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[55], 1);return &blocksItr{l.blockAPIsRWLock, blkItr}, nil
}

// GetBlockByHash returns a block given it's hash
func (l *kvLedger) GetBlockByHash(blockHash []byte) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[57], 1);
	block, err := l.blockStore.RetrieveBlockByHash(blockHash)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return block, err
}

// GetBlockByTxID returns a block which contains a transaction
func (l *kvLedger) GetBlockByTxID(txID string) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[58], 1);
	block, err := l.blockStore.RetrieveBlockByTxID(txID)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return block, err
}

func (l *kvLedger) GetTxValidationCodeByTxID(txID string) (peer.TxValidationCode, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[59], 1);
	txValidationCode, err := l.blockStore.RetrieveTxValidationCodeByTxID(txID)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return txValidationCode, err
}

//Prune prunes the blocks/transactions that satisfy the given policy
func (l *kvLedger) Prune(policy commonledger.PrunePolicy) error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[60], 1);
	return errors.New("not yet implemented")
}

// NewTxSimulator returns new `ledger.TxSimulator`
func (l *kvLedger) NewTxSimulator(txid string) (ledger.TxSimulator, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[61], 1);
	return l.txtmgmt.NewTxSimulator(txid)
}

// NewQueryExecutor gives handle to a query executor.
// A client can obtain more than one 'QueryExecutor's for parallel execution.
// Any synchronization should be performed at the implementation level if required
func (l *kvLedger) NewQueryExecutor() (ledger.QueryExecutor, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[62], 1);
	return l.txtmgmt.NewQueryExecutor(util.GenerateUUID())
}

// NewHistoryQueryExecutor gives handle to a history query executor.
// A client can obtain more than one 'HistoryQueryExecutor's for parallel execution.
// Any synchronization should be performed at the implementation level if required
// Pass the ledger blockstore so that historical values can be looked up from the chain
func (l *kvLedger) NewHistoryQueryExecutor() (ledger.HistoryQueryExecutor, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[63], 1);
	return l.historyDB.NewHistoryQueryExecutor(l.blockStore)
}

// CommitWithPvtData commits the block and the corresponding pvt data in an atomic operation
func (l *kvLedger) CommitWithPvtData(pvtdataAndBlock *ledger.BlockAndPvtData) error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[64], 1);
	var err error
	block := pvtdataAndBlock.Block
	blockNo := pvtdataAndBlock.Block.Header.Number

	startBlockProcessing := time.Now()
	logger.Debugf("[%s] Validating state for block [%d]", l.ledgerID, blockNo)
	txstatsInfo, err := l.txtmgmt.ValidateAndPrepare(pvtdataAndBlock, true)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[69], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[65], 1);elapsedBlockProcessing := time.Since(startBlockProcessing)

	startCommitBlockStorage := time.Now()
	logger.Debugf("[%s] Committing block [%d] to storage", l.ledgerID, blockNo)
	l.blockAPIsRWLock.Lock()
	defer l.blockAPIsRWLock.Unlock()
	if err = l.blockStore.CommitWithPvtData(pvtdataAndBlock); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[70], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[66], 1);elapsedCommitBlockStorage := time.Since(startCommitBlockStorage)

	startCommitState := time.Now()
	logger.Debugf("[%s] Committing block [%d] transactions to state database", l.ledgerID, blockNo)
	if err = l.txtmgmt.Commit(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[71], 1);
		panic(errors.WithMessage(err, "error during commit to txmgr"))
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[67], 1);elapsedCommitState := time.Since(startCommitState)

	// History database could be written in parallel with state and/or async as a future optimization,
	// although it has not been a bottleneck...no need to clutter the log with elapsed duration.
	if ledgerconfig.IsHistoryDBEnabled() {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[72], 1);
		logger.Debugf("[%s] Committing block [%d] transactions to history database", l.ledgerID, blockNo)
		if err := l.historyDB.Commit(block); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[73], 1);
			panic(errors.WithMessage(err, "Error during commit to history db"))
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[68], 1);elapsedCommitWithPvtData := time.Since(startBlockProcessing)

	logger.Infof("[%s] Committed block [%d] with %d transaction(s) in %dms (state_validation=%dms block_commit=%dms state_commit=%dms)",
		l.ledgerID, block.Header.Number, len(block.Data.Data),
		elapsedCommitWithPvtData/time.Millisecond,
		elapsedBlockProcessing/time.Millisecond,
		elapsedCommitBlockStorage/time.Millisecond,
		elapsedCommitState/time.Millisecond,
	)
	l.updateBlockStats(blockNo,
		elapsedBlockProcessing,
		elapsedCommitBlockStorage,
		elapsedCommitState,
		txstatsInfo,
	)
	return nil
}

func (l *kvLedger) updateBlockStats(
	blockNum uint64,
	blockProcessingTime time.Duration,
	blockstorageCommitTime time.Duration,
	statedbCommitTime time.Duration,
	txstatsInfo []*txmgr.TxStatInfo,
) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[74], 1);
	l.stats.updateBlockchainHeight(blockNum + 1)
	l.stats.updateBlockProcessingTime(blockProcessingTime)
	l.stats.updateBlockstorageCommitTime(blockstorageCommitTime)
	l.stats.updateStatedbCommitTime(statedbCommitTime)
	l.stats.updateTransactionsStats(txstatsInfo)
}

// GetMissingPvtDataInfoForMostRecentBlocks returns the missing private data information for the
// most recent `maxBlock` blocks which miss at least a private data of a eligible collection.
func (l *kvLedger) GetMissingPvtDataInfoForMostRecentBlocks(maxBlock int) (ledger.MissingPvtDataInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[75], 1);
	return l.blockStore.GetMissingPvtDataInfoForMostRecentBlocks(maxBlock)
}

// GetPvtDataAndBlockByNum returns the block and the corresponding pvt data.
// The pvt data is filtered by the list of 'collections' supplied
func (l *kvLedger) GetPvtDataAndBlockByNum(blockNum uint64, filter ledger.PvtNsCollFilter) (*ledger.BlockAndPvtData, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[76], 1);
	blockAndPvtdata, err := l.blockStore.GetPvtDataAndBlockByNum(blockNum, filter)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return blockAndPvtdata, err
}

// GetPvtDataByNum returns only the pvt data  corresponding to the given block number
// The pvt data is filtered by the list of 'collections' supplied
func (l *kvLedger) GetPvtDataByNum(blockNum uint64, filter ledger.PvtNsCollFilter) ([]*ledger.TxPvtData, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[77], 1);
	pvtdata, err := l.blockStore.GetPvtDataByNum(blockNum, filter)
	l.blockAPIsRWLock.RLock()
	l.blockAPIsRWLock.RUnlock()
	return pvtdata, err
}

// Purge removes private read-writes set generated by endorsers at block height lesser than
// a given maxBlockNumToRetain. In other words, Purge only retains private read-write sets
// that were generated at block height of maxBlockNumToRetain or higher.
func (l *kvLedger) PurgePrivateData(maxBlockNumToRetain uint64) error {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[78], 1);
	return errors.New("not yet implemented")
}

// PrivateDataMinBlockNum returns the lowest retained endorsement block height
func (l *kvLedger) PrivateDataMinBlockNum() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[79], 1);
	return 0, errors.New("not yet implemented")
}

func (l *kvLedger) GetConfigHistoryRetriever() (ledger.ConfigHistoryRetriever, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[80], 1);
	return l.configHistoryRetriever, nil
}

func (l *kvLedger) CommitPvtDataOfOldBlocks(pvtData []*ledger.BlockPvtData) ([]*ledger.PvtdataHashMismatch, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[81], 1);
	logger.Debugf("[%s:] Comparing pvtData of [%d] old blocks against the hashes in transaction's rwset to find valid and invalid data",
		l.ledgerID, len(pvtData))
	validPvtData, hashMismatches, err := ConstructValidAndInvalidPvtData(pvtData, l.blockStore)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[86], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[82], 1);logger.Debugf("[%s:] Committing pvtData of [%d] old blocks to the pvtdatastore", l.ledgerID, len(pvtData))
	err = l.blockStore.CommitPvtDataOfOldBlocks(validPvtData)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[87], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[83], 1);logger.Debugf("[%s:] Committing pvtData of [%d] old blocks to the stateDB", l.ledgerID, len(pvtData))
	err = l.txtmgmt.RemoveStaleAndCommitPvtDataOfOldBlocks(validPvtData)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[88], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[84], 1);logger.Debugf("[%s:] Clearing the bookkeeping information from pvtdatastore", l.ledgerID)
	if err := l.blockStore.ResetLastUpdatedOldBlocksList(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[89], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[85], 1);return hashMismatches, nil
}

func (l *kvLedger) GetMissingPvtDataTracker() (ledger.MissingPvtDataTracker, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[90], 1);
	return l, nil
}

// Close closes `KVLedger`
func (l *kvLedger) Close() {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[91], 1);
	l.blockStore.Shutdown()
	l.txtmgmt.Shutdown()
}

type blocksItr struct {
	blockAPIsRWLock *sync.RWMutex
	blocksItr       commonledger.ResultsIterator
}

func (itr *blocksItr) Next() (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[92], 1);
	block, err := itr.blocksItr.Next()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[94], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[93], 1);itr.blockAPIsRWLock.RLock()
	itr.blockAPIsRWLock.RUnlock()
	return block, nil
}

func (itr *blocksItr) Close() {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[95], 1);
	itr.blocksItr.Close()
}

type collectionInfoRetriever struct {
	ledger       ledger.PeerLedger
	infoProvider ledger.DeployedChaincodeInfoProvider
}

func (r *collectionInfoRetriever) CollectionInfo(chaincodeName, collectionName string) (*common.StaticCollectionConfig, error) {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[96], 1);
	qe, err := r.ledger.NewQueryExecutor()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[98], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_653063666537353930343531.Count[97], 1);defer qe.Done()
	return r.infoProvider.CollectionInfo(chaincodeName, collectionName, qe)
}

var GoCover_2_653063666537353930343531 = struct {
	Count     [99]uint32
	Pos       [3 * 99]uint32
	NumStmt   [99]uint16
} {
	Pos: [3 * 99]uint32{
		57, 68, 0x1c0016, // [0]
		71, 72, 0x700002, // [1]
		75, 77, 0x270002, // [2]
		80, 83, 0x100002, // [3]
		87, 89, 0xf0002, // [4]
		68, 70, 0x3001c, // [5]
		72, 74, 0x30070, // [6]
		77, 78, 0x430027, // [7]
		83, 85, 0x30010, // [8]
		93, 97, 0x20089, // [9]
		99, 101, 0x20046, // [10]
		105, 107, 0x400027, // [11]
		110, 110, 0x380002, // [12]
		113, 113, 0xc0002, // [13]
		107, 109, 0x30040, // [14]
		110, 112, 0x30038, // [15]
		116, 119, 0x160040, // [16]
		123, 126, 0x2b0002, // [17]
		135, 135, 0x1a0002, // [18]
		138, 138, 0x1a0002, // [19]
		143, 143, 0x3f0002, // [20]
		147, 147, 0x400002, // [21]
		155, 156, 0x380002, // [22]
		119, 122, 0x30016, // [23]
		126, 128, 0x11002b, // [24]
		131, 131, 0x120003, // [25]
		128, 130, 0x40011, // [26]
		131, 133, 0x40012, // [27]
		135, 137, 0x3001a, // [28]
		138, 140, 0x3001a, // [29]
		143, 146, 0x3003f, // [30]
		147, 150, 0x2b0040, // [31]
		150, 152, 0x4002b, // [32]
		159, 169, 0x100038, // [33]
		172, 172, 0x580002, // [34]
		175, 175, 0x450002, // [35]
		179, 179, 0xc0002, // [36]
		169, 171, 0x30010, // [37]
		172, 174, 0x30058, // [38]
		175, 177, 0x30045, // [39]
		184, 188, 0x4f0075, // [40]
		198, 199, 0xc0002, // [41]
		188, 189, 0x55004f, // [42]
		192, 192, 0x220003, // [43]
		189, 191, 0x40055, // [44]
		192, 193, 0x3d0022, // [45]
		193, 195, 0x5003d, // [46]
		203, 205, 0x100058, // [47]
		208, 209, 0x100002, // [48]
		212, 215, 0x1b0002, // [49]
		205, 207, 0x30010, // [50]
		209, 211, 0x30010, // [51]
		219, 224, 0x20048, // [52]
		228, 233, 0x20050, // [53]
		238, 240, 0x100065, // [54]
		243, 243, 0x330002, // [55]
		240, 242, 0x30010, // [56]
		247, 252, 0x2004c, // [57]
		255, 260, 0x20047, // [58]
		262, 267, 0x2005a, // [59]
		270, 272, 0x20041, // [60]
		275, 277, 0x2004c, // [61]
		282, 284, 0x20045, // [62]
		290, 292, 0x20053, // [63]
		295, 303, 0x100055, // [64]
		306, 312, 0x470002, // [65]
		315, 319, 0x2a0002, // [66]
		322, 326, 0x270002, // [67]
		333, 348, 0xc0002, // [68]
		303, 305, 0x30010, // [69]
		312, 314, 0x30047, // [70]
		319, 320, 0x41002a, // [71]
		326, 328, 0x330027, // [72]
		328, 329, 0x470033, // [73]
		357, 363, 0x20003, // [74]
		367, 369, 0x2006e, // [75]
		373, 378, 0x2007d, // [76]
		382, 387, 0x20071, // [77]
		392, 394, 0x20047, // [78]
		397, 399, 0x2003d, // [79]
		401, 403, 0x20057, // [80]
		405, 409, 0x100074, // [81]
		413, 415, 0x100002, // [82]
		419, 421, 0x100002, // [83]
		425, 426, 0x450002, // [84]
		430, 430, 0x1c0002, // [85]
		409, 411, 0x30010, // [86]
		415, 417, 0x30010, // [87]
		421, 423, 0x30010, // [88]
		426, 428, 0x30045, // [89]
		433, 435, 0x20055, // [90]
		438, 441, 0x2001c, // [91]
		448, 450, 0x100040, // [92]
		453, 455, 0x130002, // [93]
		450, 452, 0x30010, // [94]
		458, 460, 0x2001f, // [95]
		467, 469, 0x100080, // [96]
		472, 473, 0x490002, // [97]
		469, 471, 0x30010, // [98]
	},
	NumStmt: [99]uint16{
		5, // 0
		2, // 1
		2, // 2
		3, // 3
		3, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		3, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
		4, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		2, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		4, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		2, // 47
		2, // 48
		4, // 49
		1, // 50
		1, // 51
		4, // 52
		4, // 53
		2, // 54
		1, // 55
		1, // 56
		4, // 57
		4, // 58
		4, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		7, // 64
		6, // 65
		4, // 66
		2, // 67
		4, // 68
		1, // 69
		1, // 70
		1, // 71
		2, // 72
		1, // 73
		5, // 74
		1, // 75
		4, // 76
		4, // 77
		1, // 78
		1, // 79
		1, // 80
		3, // 81
		3, // 82
		3, // 83
		2, // 84
		1, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		1, // 90
		2, // 91
		2, // 92
		3, // 93
		1, // 94
		1, // 95
		2, // 96
		2, // 97
		1, // 98
	},
}
var _ = _cover_atomic_.LoadUint32
