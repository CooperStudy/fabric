//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/orderer/etcdraft/configuration.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package etcdraft; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"io/ioutil"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/protos/orderer"
)

// TypeKey is the string with which this consensus implementation is identified across Fabric.
const TypeKey = "etcdraft"

func init() {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[0], 1);
	orderer.ConsensusTypeMetadataMap[TypeKey] = ConsensusTypeMetadataFactory{}
}

// ConsensusTypeMetadataFactory allows this implementation's proto messages to register
// their type with the orderer's proto messages. This is needed for protolator to work.
type ConsensusTypeMetadataFactory struct{}

// NewMessage implements the Orderer.ConsensusTypeMetadataFactory interface.
func (dogf ConsensusTypeMetadataFactory) NewMessage() proto.Message {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[1], 1);
	return &Metadata{}
}

// Marshal serializes this implementation's proto messages. It is called by the encoder package
// during the creation of the Orderer ConfigGroup.
func Marshal(md *Metadata) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[2], 1);
	for _, c := range md.Consenters {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[4], 1);
		// Expect the user to set the config value for client/server certs to the
		// path where they are persisted locally, then load these files to memory.
		clientCert, err := ioutil.ReadFile(string(c.GetClientTlsCert()))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[7], 1);
			return nil, fmt.Errorf("cannot load client cert for consenter %s:%d: %s", c.GetHost(), c.GetPort(), err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[5], 1);c.ClientTlsCert = clientCert

		serverCert, err := ioutil.ReadFile(string(c.GetServerTlsCert()))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[8], 1);
			return nil, fmt.Errorf("cannot load server cert for consenter %s:%d: %s", c.GetHost(), c.GetPort(), err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[6], 1);c.ServerTlsCert = serverCert
	}
	_cover_atomic_.AddUint32(&GoCover_0_373934343933643063623932.Count[3], 1);return proto.Marshal(md)
}

var GoCover_0_373934343933643063623932 = struct {
	Count     [9]uint32
	Pos       [3 * 9]uint32
	NumStmt   [9]uint16
} {
	Pos: [3 * 9]uint32{
		20, 22, 0x2000d, // [0]
		29, 31, 0x20045, // [1]
		35, 36, 0x22002c, // [2]
		51, 51, 0x1a0002, // [3]
		36, 40, 0x110022, // [4]
		43, 46, 0x110003, // [5]
		49, 49, 0x1f0003, // [6]
		40, 42, 0x40011, // [7]
		46, 48, 0x40011, // [8]
	},
	NumStmt: [9]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		3, // 5
		1, // 6
		1, // 7
		1, // 8
	},
}
var _ = _cover_atomic_.LoadUint32
