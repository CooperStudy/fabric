//line /home/cooper/go/src/github.com/hyperledger/fabric/common/tools/cryptogen/ca/generator.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package ca; import _cover_atomic_ "sync/atomic"

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"io/ioutil"
	"math/big"
	"net"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/hyperledger/fabric/bccsp/utils"
	"github.com/hyperledger/fabric/common/tools/cryptogen/csp"
)

type CA struct {
	Name               string
	Country            string
	Province           string
	Locality           string
	OrganizationalUnit string
	StreetAddress      string
	PostalCode         string
	//SignKey  *ecdsa.PrivateKey
	Signer   crypto.Signer
	SignCert *x509.Certificate
}

// NewCA creates an instance of CA and saves the signing key pair in
// baseDir/name
func NewCA(baseDir, org, name, country, province, locality, orgUnit, streetAddress, postalCode string) (*CA, error) {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[0], 1);

	var response error
	var ca *CA

	err := os.MkdirAll(baseDir, 0755)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[2], 1);
		priv, signer, err := csp.GeneratePrivateKey(baseDir)
		response = err
		if err == nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[3], 1);
			// get public signing certificate
			ecPubKey, err := csp.GetECPublicKey(priv)
			response = err
			if err == nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[4], 1);
				template := x509Template()
				//this is a CA
				template.IsCA = true
				template.KeyUsage |= x509.KeyUsageDigitalSignature |
					x509.KeyUsageKeyEncipherment | x509.KeyUsageCertSign |
					x509.KeyUsageCRLSign
				template.ExtKeyUsage = []x509.ExtKeyUsage{
					x509.ExtKeyUsageClientAuth,
					x509.ExtKeyUsageServerAuth,
				}

				//set the organization for the subject
				subject := subjectTemplateAdditional(country, province, locality, orgUnit, streetAddress, postalCode)
				subject.Organization = []string{org}
				subject.CommonName = name

				template.Subject = subject
				template.SubjectKeyId = priv.SKI()

				x509Cert, err := genCertificateECDSA(baseDir, name, &template, &template,
					ecPubKey, signer)
				response = err
				if err == nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[5], 1);
					ca = &CA{
						Name:               name,
						Signer:             signer,
						SignCert:           x509Cert,
						Country:            country,
						Province:           province,
						Locality:           locality,
						OrganizationalUnit: orgUnit,
						StreetAddress:      streetAddress,
						PostalCode:         postalCode,
					}
				}
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[1], 1);return ca, response
}

// SignCertificate creates a signed certificate based on a built-in template
// and saves it in baseDir/name
func (ca *CA) SignCertificate(baseDir, name string, ous, sans []string, pub *ecdsa.PublicKey,
	ku x509.KeyUsage, eku []x509.ExtKeyUsage) (*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[6], 1);

	template := x509Template()
	template.KeyUsage = ku
	template.ExtKeyUsage = eku

	//set the organization for the subject
	subject := subjectTemplateAdditional(ca.Country, ca.Province, ca.Locality, ca.OrganizationalUnit, ca.StreetAddress, ca.PostalCode)
	subject.CommonName = name

	subject.OrganizationalUnit = append(subject.OrganizationalUnit, ous...)

	template.Subject = subject
	for _, san := range sans {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[9], 1);
		// try to parse as an IP address first
		ip := net.ParseIP(san)
		if ip != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[10], 1);
			template.IPAddresses = append(template.IPAddresses, ip)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[11], 1);{
			template.DNSNames = append(template.DNSNames, san)
		}}
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[7], 1);cert, err := genCertificateECDSA(baseDir, name, &template, ca.SignCert,
		pub, ca.Signer)

	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[12], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[8], 1);return cert, nil
}

// default template for X509 subject
func subjectTemplate() pkix.Name {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[13], 1);
	return pkix.Name{
		Country:  []string{"US"},
		Locality: []string{"San Francisco"},
		Province: []string{"California"},
	}
}

// Additional for X509 subject
func subjectTemplateAdditional(country, province, locality, orgUnit, streetAddress, postalCode string) pkix.Name {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[14], 1);
	name := subjectTemplate()
	if len(country) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[21], 1);
		name.Country = []string{country}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[15], 1);if len(province) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[22], 1);
		name.Province = []string{province}
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[16], 1);if len(locality) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[23], 1);
		name.Locality = []string{locality}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[17], 1);if len(orgUnit) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[24], 1);
		name.OrganizationalUnit = []string{orgUnit}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[18], 1);if len(streetAddress) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[25], 1);
		name.StreetAddress = []string{streetAddress}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[19], 1);if len(postalCode) >= 1 {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[26], 1);
		name.PostalCode = []string{postalCode}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[20], 1);return name
}

// default template for X509 certificates
func x509Template() x509.Certificate {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[27], 1);

	// generate a serial number
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, _ := rand.Int(rand.Reader, serialNumberLimit)

	// set expiry to around 10 years
	expiry := 3650 * 24 * time.Hour
	// round minute and backdate 5 minutes
	notBefore := time.Now().Round(time.Minute).Add(-5 * time.Minute).UTC()

	//basic template to use
	x509 := x509.Certificate{
		SerialNumber:          serialNumber,
		NotBefore:             notBefore,
		NotAfter:              notBefore.Add(expiry).UTC(),
		BasicConstraintsValid: true,
	}
	return x509

}

// generate a signed X509 certificate using ECDSA
func genCertificateECDSA(baseDir, name string, template, parent *x509.Certificate, pub *ecdsa.PublicKey,
	priv interface{}) (*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[28], 1);

	//create the x509 public cert
	certBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[33], 1);
		return nil, err
	}

	//write cert out to file
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[29], 1);fileName := filepath.Join(baseDir, name+"-cert.pem")
	certFile, err := os.Create(fileName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[34], 1);
		return nil, err
	}
	//pem encode the cert
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[30], 1);err = pem.Encode(certFile, &pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
	certFile.Close()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[35], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[31], 1);x509Cert, err := x509.ParseCertificate(certBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[36], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[32], 1);return x509Cert, nil
}

// LoadCertificateECDSA load a ecdsa cert from a file in cert path
func LoadCertificateECDSA(certPath string) (*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[37], 1);
	var cert *x509.Certificate
	var err error

	walkFunc := func(path string, info os.FileInfo, err error) error {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[40], 1);
		if strings.HasSuffix(path, ".pem") {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[42], 1);
			rawCert, err := ioutil.ReadFile(path)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[44], 1);
				return err
			}
			_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[43], 1);block, _ := pem.Decode(rawCert)
			cert, err = utils.DERToX509Certificate(block.Bytes)
		}
		_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[41], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[38], 1);err = filepath.Walk(certPath, walkFunc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[45], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_613031396266663037383364.Count[39], 1);return cert, err
}

var GoCover_0_613031396266663037383364 = struct {
	Count     [46]uint32
	Pos       [3 * 46]uint32
	NumStmt   [46]uint16
} {
	Pos: [3 * 46]uint32{
		42, 48, 0x100075, // [0]
		94, 94, 0x150002, // [1]
		48, 51, 0x110010, // [2]
		51, 55, 0x120011, // [3]
		55, 78, 0x130012, // [4]
		78, 90, 0x60013, // [5]
		100, 113, 0x1b0047, // [6]
		123, 126, 0x100002, // [7]
		130, 130, 0x120002, // [8]
		113, 116, 0x10001b, // [9]
		116, 118, 0x40010, // [10]
		118, 120, 0x40009, // [11]
		126, 128, 0x30010, // [12]
		134, 140, 0x20022, // [13]
		143, 145, 0x170072, // [14]
		148, 148, 0x180002, // [15]
		152, 152, 0x180002, // [16]
		155, 155, 0x170002, // [17]
		158, 158, 0x1d0002, // [18]
		161, 161, 0x1a0002, // [19]
		164, 164, 0xd0002, // [20]
		145, 147, 0x30017, // [21]
		148, 150, 0x30018, // [22]
		152, 154, 0x30018, // [23]
		155, 157, 0x30017, // [24]
		158, 160, 0x3001d, // [25]
		161, 163, 0x3001a, // [26]
		168, 188, 0x20026, // [27]
		192, 196, 0x10002f, // [28]
		201, 203, 0x100002, // [29]
		207, 209, 0x100002, // [30]
		213, 214, 0x100002, // [31]
		217, 217, 0x160002, // [32]
		196, 198, 0x30010, // [33]
		203, 205, 0x30010, // [34]
		209, 211, 0x30010, // [35]
		214, 216, 0x30010, // [36]
		221, 225, 0x430047, // [37]
		237, 238, 0x100002, // [38]
		242, 242, 0x120002, // [39]
		225, 226, 0x260043, // [40]
		234, 234, 0xd0003, // [41]
		226, 228, 0x120026, // [42]
		231, 232, 0x370004, // [43]
		228, 230, 0x50012, // [44]
		238, 240, 0x30010, // [45]
	},
	NumStmt: [46]uint16{
		4, // 0
		1, // 1
		3, // 2
		3, // 3
		12, // 4
		1, // 5
		8, // 6
		2, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		6, // 27
		2, // 28
		3, // 29
		3, // 30
		2, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		3, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		2, // 42
		2, // 43
		1, // 44
		1, // 45
	},
}
var _ = _cover_atomic_.LoadUint32
