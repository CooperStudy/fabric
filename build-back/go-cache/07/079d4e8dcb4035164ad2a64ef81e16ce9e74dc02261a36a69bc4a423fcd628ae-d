//line /home/cooper/go/src/github.com/hyperledger/fabric/core/common/privdata/simplecollection.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package privdata; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	m "github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
)

// SimpleCollection implements a collection with static properties
// and a public member set
type SimpleCollection struct {
	name         string
	accessPolicy policies.Policy
	memberOrgs   []string
	conf         common.StaticCollectionConfig
}

type SimpleCollectionPersistenceConfigs struct {
	blockToLive uint64
}

// CollectionID returns the collection's ID
func (sc *SimpleCollection) CollectionID() string {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[0], 1);
	return sc.name
}

// MemberOrgs returns the MSP IDs that are part of this collection
func (sc *SimpleCollection) MemberOrgs() []string {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[1], 1);
	return sc.memberOrgs
}

// RequiredPeerCount returns the minimum number of peers
// required to send private data to
func (sc *SimpleCollection) RequiredPeerCount() int {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[2], 1);
	return int(sc.conf.RequiredPeerCount)
}

func (sc *SimpleCollection) MaximumPeerCount() int {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[3], 1);
	return int(sc.conf.MaximumPeerCount)
}

// AccessFilter returns the member filter function that evaluates signed data
// against the member access policy of this collection
func (sc *SimpleCollection) AccessFilter() Filter {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[4], 1);
	return func(sd common.SignedData) bool {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[5], 1);
		if err := sc.accessPolicy.Evaluate([]*common.SignedData{&sd}); err != nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[7], 1);
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[6], 1);return true
	}
}

func (sc *SimpleCollection) IsMemberOnlyRead() bool {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[8], 1);
	return sc.conf.MemberOnlyRead
}

// Setup configures a simple collection object based on a given
// StaticCollectionConfig proto that has all the necessary information
func (sc *SimpleCollection) Setup(collectionConfig *common.StaticCollectionConfig, deserializer msp.IdentityDeserializer) error {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[9], 1);
	if collectionConfig == nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[15], 1);
		return errors.New("Nil config passed to collection setup")
	}
	_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[10], 1);sc.conf = *collectionConfig
	sc.name = collectionConfig.GetName()

	// get the access signature policy envelope
	collectionPolicyConfig := collectionConfig.GetMemberOrgsPolicy()
	if collectionPolicyConfig == nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[16], 1);
		return errors.New("Collection config policy is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[11], 1);accessPolicyEnvelope := collectionPolicyConfig.GetSignaturePolicy()
	if accessPolicyEnvelope == nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[17], 1);
		return errors.New("Collection config access policy is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[12], 1);err := sc.setupAccessPolicy(collectionPolicyConfig, deserializer)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[18], 1);
		return err
	}

	// get member org MSP IDs from the envelope
	_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[13], 1);for _, principal := range accessPolicyEnvelope.Identities {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[19], 1);
		switch principal.PrincipalClassification {
		case m.MSPPrincipal_ROLE:_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[20], 1);
			// Principal contains the msp role
			mspRole := &m.MSPRole{}
			err := proto.Unmarshal(principal.Principal, mspRole)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[27], 1);
				return errors.Wrap(err, "Could not unmarshal MSPRole from principal")
			}
			_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[21], 1);sc.memberOrgs = append(sc.memberOrgs, mspRole.MspIdentifier)
		case m.MSPPrincipal_IDENTITY:_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[22], 1);
			principalId, err := deserializer.DeserializeIdentity(principal.Principal)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[28], 1);
				return errors.Wrap(err, "Invalid identity principal, not a certificate")
			}
			_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[23], 1);sc.memberOrgs = append(sc.memberOrgs, principalId.GetMSPIdentifier())
		case m.MSPPrincipal_ORGANIZATION_UNIT:_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[24], 1);
			OU := &m.OrganizationUnit{}
			err := proto.Unmarshal(principal.Principal, OU)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[29], 1);
				return errors.Wrap(err, "Could not unmarshal OrganizationUnit from principal")
			}
			_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[25], 1);sc.memberOrgs = append(sc.memberOrgs, OU.MspIdentifier)
		default:_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[26], 1);
			return errors.New(fmt.Sprintf("Invalid principal type %d", int32(principal.PrincipalClassification)))
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[14], 1);return nil
}

// Setup configures a simple collection object based on a given
// StaticCollectionConfig proto that has all the necessary information
func (sc *SimpleCollection) setupAccessPolicy(collectionPolicyConfig *common.CollectionPolicyConfig, deserializer msp.IdentityDeserializer) error {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[30], 1);
	var err error
	sc.accessPolicy, err = getPolicy(collectionPolicyConfig, deserializer)
	return err
}

// BlockToLive return collection's block to live configuration
func (s *SimpleCollectionPersistenceConfigs) BlockToLive() uint64 {_cover_atomic_.AddUint32(&GoCover_2_666632313434393663303335.Count[31], 1);
	return s.blockToLive
}

var GoCover_2_666632313434393663303335 = struct {
	Count     [32]uint32
	Pos       [3 * 32]uint32
	NumStmt   [32]uint16
} {
	Pos: [3 * 32]uint32{
		34, 36, 0x20033, // [0]
		39, 41, 0x20033, // [1]
		45, 47, 0x20035, // [2]
		49, 51, 0x20034, // [3]
		55, 56, 0x290033, // [4]
		56, 57, 0x4d0029, // [5]
		60, 60, 0xe0003, // [6]
		57, 59, 0x4004d, // [7]
		64, 66, 0x20035, // [8]
		70, 71, 0x1d0081, // [9]
		74, 79, 0x230002, // [10]
		82, 83, 0x210002, // [11]
		87, 88, 0x100002, // [12]
		93, 93, 0x3c0002, // [13]
		121, 121, 0xc0002, // [14]
		71, 73, 0x3001d, // [15]
		79, 81, 0x30023, // [16]
		83, 85, 0x30021, // [17]
		88, 90, 0x30010, // [18]
		93, 94, 0x2c003c, // [19]
		95, 99, 0x12001c, // [20]
		102, 102, 0x400004, // [21]
		103, 105, 0x120020, // [22]
		108, 108, 0x490004, // [23]
		109, 112, 0x120029, // [24]
		115, 115, 0x3b0004, // [25]
		116, 117, 0x69000b, // [26]
		99, 101, 0x50012, // [27]
		105, 107, 0x50012, // [28]
		112, 114, 0x50012, // [29]
		126, 130, 0x20093, // [30]
		133, 135, 0x20043, // [31]
	},
	NumStmt: [32]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		4, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		3, // 20
		1, // 21
		2, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		3, // 30
		1, // 31
	},
}
var _ = _cover_atomic_.LoadUint32
