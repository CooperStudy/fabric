//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/support/chaincode/support.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/chaincode"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/common/policies/inquire"
	common2 "github.com/hyperledger/fabric/protos/common"
)

var logger = flogging.MustGetLogger("discovery.DiscoverySupport")

type MetadataRetriever interface {
	Metadata(channel string, cc string, loadCollections bool) *chaincode.Metadata
}

// DiscoverySupport implements support that is used for service discovery
// that is related to chaincode
type DiscoverySupport struct {
	ci MetadataRetriever
}

// NewDiscoverySupport creates a new DiscoverySupport
func NewDiscoverySupport(ci MetadataRetriever) *DiscoverySupport {_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[0], 1);
	s := &DiscoverySupport{
		ci: ci,
	}
	return s
}

func (s *DiscoverySupport) PolicyByChaincode(channel string, cc string) policies.InquireablePolicy {_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[1], 1);
	chaincodeData := s.ci.Metadata(channel, cc, false)
	if chaincodeData == nil {_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[5], 1);
		logger.Info("Chaincode", cc, "wasn't found")
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[2], 1);pol := &common2.SignaturePolicyEnvelope{}
	if err := proto.Unmarshal(chaincodeData.Policy, pol); err != nil {_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[6], 1);
		logger.Warning("Failed unmarshaling policy for chaincode", cc, ":", err)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[3], 1);if len(pol.Identities) == 0 || pol.Rule == nil {_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[7], 1);
		logger.Warningf("Invalid policy, either Identities(%v) or Rule(%v) are empty:", pol.Identities, pol.Rule)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_616539363232326239636636.Count[4], 1);return inquire.NewInquireableSignaturePolicy(pol)
}

var GoCover_0_616539363232326239636636 = struct {
	Count     [8]uint32
	Pos       [3 * 8]uint32
	NumStmt   [8]uint16
} {
	Pos: [3 * 8]uint32{
		31, 36, 0x20042, // [0]
		38, 40, 0x1a0064, // [1]
		44, 45, 0x430002, // [2]
		49, 49, 0x310002, // [3]
		53, 53, 0x330002, // [4]
		40, 43, 0x3001a, // [5]
		45, 48, 0x30043, // [6]
		49, 52, 0x30031, // [7]
	},
	NumStmt: [8]uint16{
		2, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		2, // 5
		2, // 6
		2, // 7
	},
}
var _ = _cover_atomic_.LoadUint32
