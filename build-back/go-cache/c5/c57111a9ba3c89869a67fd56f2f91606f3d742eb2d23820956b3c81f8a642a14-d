//line /home/cooper/go/src/github.com/hyperledger/fabric/common/flogging/floggingtest/logger.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package floggingtest; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"regexp"
	"strings"
	"sync"
	"testing"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/flogging/fabenc"
	"github.com/onsi/gomega/gbytes"
	"go.uber.org/zap"
	"go.uber.org/zap/buffer"
	"go.uber.org/zap/zapcore"
)

// DefaultFormat is a log encoding format that is mostly compatible with the default
// log format but excludes colorization and time.
const DefaultFormat = "[%{module}] %{shortfunc} -> %{level:.4s} %{id:04x} %{message}"

type Recorder struct {
	mutex    sync.RWMutex
	entries  []string
	messages []string
	buffer   *gbytes.Buffer
}

func newRecorder() *Recorder {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[0], 1);
	return &Recorder{
		buffer:   gbytes.NewBuffer(),
		entries:  []string{},
		messages: []string{},
	}
}

func (r *Recorder) addEntry(e zapcore.Entry, line *buffer.Buffer) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[1], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()

	r.buffer.Write(line.Bytes())
	r.entries = append(r.entries, strings.TrimRight(line.String(), "\n"))
	r.messages = append(r.messages, e.Message)
}

func (r *Recorder) Reset() {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[2], 1);
	r.mutex.Lock()
	defer r.mutex.Unlock()
	r.buffer = gbytes.NewBuffer()
	r.entries = []string{}
	r.messages = []string{}
}

func (r *Recorder) Buffer() *gbytes.Buffer {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[3], 1);
	r.mutex.RLock()
	defer r.mutex.RUnlock()
	return r.buffer
}

func (r *Recorder) Entries() []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[4], 1);
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	entries := make([]string, len(r.entries), cap(r.entries))
	for i, v := range r.entries {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[6], 1);
		entries[i] = v
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[5], 1);return entries
}

func (r *Recorder) EntriesContaining(sub string) []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[7], 1);
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	matches := []string{}
	for _, entry := range r.entries {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[9], 1);
		if strings.Contains(entry, sub) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[10], 1);
			matches = append(matches, entry)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[8], 1);return matches
}

func (r *Recorder) EntriesMatching(regex string) []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[11], 1);
	re := regexp.MustCompile(regex)
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	matches := []string{}
	for _, entry := range r.entries {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[13], 1);
		if re.MatchString(entry) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[14], 1);
			matches = append(matches, entry)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[12], 1);return matches
}

func (r *Recorder) Messages() []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[15], 1);
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	messages := make([]string, len(r.messages), cap(r.messages))
	for i, v := range r.messages {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[17], 1);
		messages[i] = v
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[16], 1);return messages
}

func (r *Recorder) MessagesContaining(sub string) []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[18], 1);
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	matches := []string{}
	for _, msg := range r.messages {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[20], 1);
		if strings.Contains(msg, sub) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[21], 1);
			matches = append(matches, msg)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[19], 1);return matches
}

func (r *Recorder) MessagesMatching(regex string) []string {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[22], 1);
	re := regexp.MustCompile(regex)
	r.mutex.RLock()
	defer r.mutex.RUnlock()

	matches := []string{}
	for _, msg := range r.messages {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[24], 1);
		if re.MatchString(msg) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[25], 1);
			matches = append(matches, msg)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[23], 1);return matches
}

type RecordingCore struct {
	zapcore.LevelEnabler
	encoder  zapcore.Encoder
	recorder *Recorder
	fields   []zapcore.Field
	writer   zapcore.WriteSyncer
}

func (r *RecordingCore) Write(e zapcore.Entry, fields []zapcore.Field) error {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[26], 1);
	buf, err := r.encoder.EncodeEntry(e, fields)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[28], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[27], 1);r.writer.Write(buf.Bytes())
	r.recorder.addEntry(e, buf)

	buf.Free()

	return nil
}

func (r *RecordingCore) Check(e zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[29], 1);
	if r.Enabled(e.Level) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[32], 1);
		ce = ce.AddCore(e, r)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[30], 1);if ce != nil && e.Level == zapcore.FatalLevel {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[33], 1);
		panic(e.Message)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[31], 1);return ce
}

func (r *RecordingCore) With(fields []zapcore.Field) zapcore.Core {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[34], 1);
	clone := &RecordingCore{
		LevelEnabler: r.LevelEnabler,
		encoder:      r.encoder.Clone(),
		recorder:     r.recorder,
		writer:       r.writer,
	}

	for _, f := range fields {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[36], 1);
		f.AddTo(clone.encoder)
	}

	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[35], 1);return clone
}

func (r *RecordingCore) Sync() error {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[37], 1);
	return r.writer.Sync()
}

type TestingWriter struct{ testing.TB }

func (t *TestingWriter) Write(buf []byte) (int, error) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[38], 1);
	t.Logf("%s", bytes.TrimRight(buf, "\n"))
	return len(buf), nil
}

func (t *TestingWriter) Sync() error {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[39], 1); return nil }

type Option func(r *RecordingCore, l *zap.Logger) *zap.Logger

func Named(loggerName string) Option {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[40], 1);
	return func(r *RecordingCore, l *zap.Logger) *zap.Logger {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[41], 1);
		return l.Named(loggerName)
	}
}

func AtLevel(level zapcore.Level) Option {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[42], 1);
	return func(r *RecordingCore, l *zap.Logger) *zap.Logger {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[43], 1);
		r.LevelEnabler = zap.LevelEnablerFunc(func(l zapcore.Level) bool {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[45], 1);
			return level.Enabled(l)
		})
		_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[44], 1);return l
	}
}

func NewTestLogger(tb testing.TB, options ...Option) (*flogging.FabricLogger, *Recorder) {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[46], 1);
	enabler := zap.LevelEnablerFunc(func(l zapcore.Level) bool {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[51], 1);
		return zapcore.DebugLevel.Enabled(l)
	})

	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[47], 1);formatters, err := fabenc.ParseFormat(DefaultFormat)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[52], 1);
		tb.Fatalf("failed to parse format %s: %s", DefaultFormat, err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[48], 1);encoder := fabenc.NewFormatEncoder(formatters...)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[53], 1);
		tb.Fatalf("failed to create format encoder: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[49], 1);recorder := newRecorder()
	recordingCore := &RecordingCore{
		LevelEnabler: enabler,
		encoder:      encoder,
		recorder:     recorder,
		writer:       &TestingWriter{TB: tb},
	}

	zl := zap.New(recordingCore)
	for _, o := range options {_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[54], 1);
		zl = o(recordingCore, zl)
	}

	_cover_atomic_.AddUint32(&GoCover_0_623739346539303636313236.Count[50], 1);return flogging.NewFabricLogger(zl, zap.AddCaller()), recorder
}

var GoCover_0_623739346539303636313236 = struct {
	Count     [55]uint32
	Pos       [3 * 55]uint32
	NumStmt   [55]uint16
} {
	Pos: [3 * 55]uint32{
		35, 41, 0x2001e, // [0]
		43, 50, 0x20043, // [1]
		52, 58, 0x2001c, // [2]
		60, 64, 0x2002c, // [3]
		66, 71, 0x1e0027, // [4]
		74, 74, 0x100002, // [5]
		71, 73, 0x3001e, // [6]
		77, 82, 0x22003b, // [7]
		87, 87, 0x100002, // [8]
		82, 83, 0x230022, // [9]
		83, 85, 0x40023, // [10]
		90, 96, 0x22003b, // [11]
		101, 101, 0x100002, // [12]
		96, 97, 0x1c0022, // [13]
		97, 99, 0x4001c, // [14]
		104, 109, 0x1f0028, // [15]
		112, 112, 0x110002, // [16]
		109, 111, 0x3001f, // [17]
		115, 120, 0x21003c, // [18]
		125, 125, 0x100002, // [19]
		120, 121, 0x210021, // [20]
		121, 123, 0x40021, // [21]
		128, 134, 0x21003c, // [22]
		139, 139, 0x100002, // [23]
		134, 135, 0x1a0021, // [24]
		135, 137, 0x4001a, // [25]
		150, 152, 0x10004e, // [26]
		156, 161, 0xc0002, // [27]
		152, 154, 0x30010, // [28]
		164, 165, 0x180060, // [29]
		168, 168, 0x300002, // [30]
		171, 171, 0xb0002, // [31]
		165, 167, 0x30018, // [32]
		168, 169, 0x130030, // [33]
		174, 182, 0x1b0043, // [34]
		186, 186, 0xe0002, // [35]
		182, 184, 0x3001b, // [36]
		189, 191, 0x20026, // [37]
		195, 198, 0x20038, // [38]
		200, 200, 0x340026, // [39]
		204, 205, 0x3b0026, // [40]
		205, 207, 0x3003b, // [41]
		210, 211, 0x3b002a, // [42]
		211, 212, 0x44003b, // [43]
		215, 215, 0xb0003, // [44]
		212, 214, 0x40044, // [45]
		219, 220, 0x3d005a, // [46]
		224, 225, 0x100002, // [47]
		228, 229, 0x100002, // [48]
		233, 242, 0x1c0002, // [49]
		246, 246, 0x400002, // [50]
		220, 222, 0x3003d, // [51]
		225, 227, 0x30010, // [52]
		229, 231, 0x30010, // [53]
		242, 244, 0x3001c, // [54]
	},
	NumStmt: [55]uint16{
		1, // 0
		5, // 1
		5, // 2
		3, // 3
		4, // 4
		1, // 5
		1, // 6
		4, // 7
		1, // 8
		1, // 9
		1, // 10
		5, // 11
		1, // 12
		1, // 13
		1, // 14
		4, // 15
		1, // 16
		1, // 17
		4, // 18
		1, // 19
		1, // 20
		1, // 21
		5, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		4, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		2, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		2, // 47
		2, // 48
		4, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
	},
}
var _ = _cover_atomic_.LoadUint32
