//line /home/cooper/go/src/github.com/hyperledger/fabric/core/peer/configtx_processor.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package peer; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/customtx"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
)

const (
	channelConfigKey = "resourcesconfigtx.CHANNEL_CONFIG_KEY"
	peerNamespace    = ""
)

// txProcessor implements the interface 'github.com/hyperledger/fabric/core/ledger/customtx/Processor'
type configtxProcessor struct {
}

// newTxProcessor constructs a new instance of txProcessor
func newConfigTxProcessor() customtx.Processor {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[0], 1);
	return &configtxProcessor{}
}

// GenerateSimulationResults implements function in the interface 'github.com/hyperledger/fabric/core/ledger/customtx/Processor'
// This implemantation processes following two types of transactions.
// CONFIG  - simply stores the config in the statedb. Additionally, stores the resource config seed if the transaction is from the genesis block.
// PEER_RESOURCE_UPDATE - In a normal course, this validates the transaction against the current resource bundle,
// computes the full configuration, and stores the full configuration if the transaction is found valid.
// However, if 'initializingLedger' is true (i.e., either the ledger is being created from the genesis block
// or the ledger is synching the state with the blockchain, during start up), the full config is computed using
// the most recent configs from statedb
func (tp *configtxProcessor) GenerateSimulationResults(txEnv *common.Envelope, simulator ledger.TxSimulator, initializingLedger bool) error {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[1], 1);
	payload := utils.UnmarshalPayloadOrPanic(txEnv.Payload)
	channelHdr := utils.UnmarshalChannelHeaderOrPanic(payload.Header.ChannelHeader)
	txType := common.HeaderType(channelHdr.GetType())

	switch txType {
	case common.HeaderType_CONFIG:_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[2], 1);
		peerLogger.Debugf("Processing CONFIG")
		return processChannelConfigTx(txEnv, simulator)

	default:_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[3], 1);
		return fmt.Errorf("tx type [%s] is not expected", txType)
	}
}

func processChannelConfigTx(txEnv *common.Envelope, simulator ledger.TxSimulator) error {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[4], 1);
	configEnvelope := &common.ConfigEnvelope{}
	if _, err := utils.UnmarshalEnvelopeOfType(txEnv, common.HeaderType_CONFIG, configEnvelope); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[8], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[5], 1);channelConfig := configEnvelope.Config

	if err := persistConf(simulator, channelConfigKey, channelConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[9], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[6], 1);peerLogger.Debugf("channelConfig=%s", channelConfig)
	if channelConfig == nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[10], 1);
		return fmt.Errorf("Channel config found nil")
	}

	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[7], 1);return nil
}

func persistConf(simulator ledger.TxSimulator, key string, config *common.Config) error {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[11], 1);
	serializedConfig, err := serialize(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[13], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[12], 1);return simulator.SetState(peerNamespace, key, serializedConfig)
}

func retrievePersistedConf(queryExecuter ledger.QueryExecutor, key string) (*common.Config, error) {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[14], 1);
	serializedConfig, err := queryExecuter.GetState(peerNamespace, key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[17], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[15], 1);if serializedConfig == nil {_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[18], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323265356137393664323638.Count[16], 1);return deserialize(serializedConfig)
}

var GoCover_1_323265356137393664323638 = struct {
	Count     [19]uint32
	Pos       [3 * 19]uint32
	NumStmt   [19]uint16
} {
	Pos: [3 * 19]uint32{
		28, 30, 0x20030, // [0]
		40, 45, 0x10008d, // [1]
		46, 48, 0x320020, // [2]
		50, 51, 0x3c000a, // [3]
		55, 57, 0x6a0059, // [4]
		60, 62, 0x500002, // [5]
		66, 67, 0x1a0002, // [6]
		71, 71, 0xc0002, // [7]
		57, 59, 0x3006a, // [8]
		62, 64, 0x30050, // [9]
		67, 69, 0x3001a, // [10]
		74, 76, 0x100059, // [11]
		79, 79, 0x410002, // [12]
		76, 78, 0x30010, // [13]
		82, 84, 0x100064, // [14]
		87, 87, 0x1d0002, // [15]
		90, 90, 0x260002, // [16]
		84, 86, 0x30010, // [17]
		87, 89, 0x3001d, // [18]
	},
	NumStmt: [19]uint16{
		1, // 0
		4, // 1
		2, // 2
		1, // 3
		2, // 4
		2, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
	},
}
var _ = _cover_atomic_.LoadUint32
