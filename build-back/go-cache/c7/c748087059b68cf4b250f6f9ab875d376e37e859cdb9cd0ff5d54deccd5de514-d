//line /home/cooper/go/src/github.com/hyperledger/fabric/core/aclmgmt/resourceprovider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package aclmgmt; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
)

//--------- errors ---------

//PolicyNotFound cache for resource
type PolicyNotFound string

func (e PolicyNotFound) Error() string {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[0], 1);
	return fmt.Sprintf("policy %s not found", string(e))
}

//InvalidIdInfo
type InvalidIdInfo string

func (e InvalidIdInfo) Error() string {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[1], 1);
	return fmt.Sprintf("Invalid id for policy [%s]", string(e))
}

//---------- policyEvaluator ------

//policyEvalutor interface provides the interfaces for policy evaluation
type policyEvaluator interface {
	PolicyRefForAPI(resName string) string
	Evaluate(polName string, id []*common.SignedData) error
}

//policyEvaluatorImpl implements policyEvaluator
type policyEvaluatorImpl struct {
	bundle channelconfig.Resources
}

func (pe *policyEvaluatorImpl) PolicyRefForAPI(resName string) string {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[2], 1);
	app, exists := pe.bundle.ApplicationConfig()
	if !exists {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[5], 1);
		return ""
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[3], 1);pm := app.APIPolicyMapper()
	if pm == nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[6], 1);
		return ""
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[4], 1);return pm.PolicyRefForAPI(resName)
}

func (pe *policyEvaluatorImpl) Evaluate(polName string, sd []*common.SignedData) error {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[7], 1);
	policy, ok := pe.bundle.PolicyManager().GetPolicy(polName)
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[9], 1);
		return PolicyNotFound(polName)
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[8], 1);return policy.Evaluate(sd)
}

//------ resourcePolicyProvider ----------

//aclmgmtPolicyProvider is the interface implemented by resource based ACL.
type aclmgmtPolicyProvider interface {
	//GetPolicyName returns policy name given resource name
	GetPolicyName(resName string) string

	//CheckACL backs ACLProvider interface
	CheckACL(polName string, idinfo interface{}) error
}

//aclmgmtPolicyProviderImpl holds the bytes from state of the ledger
type aclmgmtPolicyProviderImpl struct {
	pEvaluator policyEvaluator
}

//GetPolicyName returns the policy name given the resource string
func (rp *aclmgmtPolicyProviderImpl) GetPolicyName(resName string) string {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[10], 1);
	return rp.pEvaluator.PolicyRefForAPI(resName)
}

//CheckACL implements AClProvider's CheckACL interface so it can be registered
//as a provider with aclmgmt
func (rp *aclmgmtPolicyProviderImpl) CheckACL(polName string, idinfo interface{}) error {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[11], 1);
	aclLogger.Debugf("acl check(%s)", polName)

	//we will implement other identifiers. In the end we just need a SignedData
	var sd []*common.SignedData
	var err error
	switch idinfo.(type) {
	case *pb.SignedProposal:_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[14], 1);
		signedProp, _ := idinfo.(*pb.SignedProposal)
		// Prepare SignedData
		proposal, err := utils.GetProposal(signedProp.ProposalBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[20], 1);
			return fmt.Errorf("Failing extracting proposal during check policy with policy [%s]: [%s]", polName, err)
		}

		_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[15], 1);header, err := utils.GetHeader(proposal.Header)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[21], 1);
			return fmt.Errorf("Failing extracting header during check policy [%s]: [%s]", polName, err)
		}

		_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[16], 1);shdr, err := utils.GetSignatureHeader(header.SignatureHeader)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[22], 1);
			return fmt.Errorf("Invalid Proposal's SignatureHeader during check policy [%s]: [%s]", polName, err)
		}

		_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[17], 1);sd = []*common.SignedData{{
			Data:      signedProp.ProposalBytes,
			Identity:  shdr.Creator,
			Signature: signedProp.Signature,
		}}
	case *common.Envelope:_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[18], 1);
		sd, err = idinfo.(*common.Envelope).AsSignedData()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[23], 1);
			return err
		}
	default:_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[19], 1);
		return InvalidIdInfo(polName)
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[12], 1);err = rp.pEvaluator.Evaluate(polName, sd)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[24], 1);
		return fmt.Errorf("failed evaluating policy on signed data during check policy [%s]: [%s]", polName, err)
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[13], 1);return nil
}

//-------- resource provider - entry point API used by aclmgmtimpl for doing resource based ACL ----------

//resource getter gets channelconfig.Resources given channel ID
type ResourceGetter func(channelID string) channelconfig.Resources

//resource provider that uses the resource configuration information to provide ACL support
type resourceProvider struct {
	//resource getter
	resGetter ResourceGetter

	//default provider to be used for undefined resources
	defaultProvider ACLProvider
}

//create a new resourceProvider
func newResourceProvider(rg ResourceGetter, defprov ACLProvider) *resourceProvider {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[25], 1);
	return &resourceProvider{rg, defprov}
}

//CheckACL implements the ACL
func (rp *resourceProvider) CheckACL(resName string, channelID string, idinfo interface{}) error {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[26], 1);
	resCfg := rp.resGetter(channelID)

	if resCfg != nil {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[28], 1);
		pp := &aclmgmtPolicyProviderImpl{&policyEvaluatorImpl{resCfg}}
		policyName := pp.GetPolicyName(resName)
		if policyName != "" {_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[30], 1);
			aclLogger.Debugf("acl policy %s found in config for resource %s", policyName, resName)
			return pp.CheckACL(policyName, idinfo)
		}
		_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[29], 1);aclLogger.Debugf("acl policy not found in config for resource %s", resName)
	}

	_cover_atomic_.AddUint32(&GoCover_3_333530613935626133663963.Count[27], 1);return rp.defaultProvider.CheckACL(resName, channelID, idinfo)
}

var GoCover_3_333530613935626133663963 = struct {
	Count     [31]uint32
	Pos       [3 * 31]uint32
	NumStmt   [31]uint16
} {
	Pos: [3 * 31]uint32{
		23, 25, 0x20028, // [0]
		30, 32, 0x20027, // [1]
		47, 49, 0xd0047, // [2]
		53, 54, 0xf0002, // [3]
		58, 58, 0x240002, // [4]
		49, 51, 0x3000d, // [5]
		54, 56, 0x3000f, // [6]
		61, 63, 0x90058, // [7]
		67, 67, 0x1c0002, // [8]
		63, 65, 0x30009, // [9]
		87, 89, 0x2004b, // [10]
		93, 99, 0x170059, // [11]
		132, 133, 0x100002, // [12]
		137, 137, 0xc0002, // [13]
		100, 104, 0x11001a, // [14]
		108, 109, 0x110003, // [15]
		113, 114, 0x110003, // [16]
		118, 122, 0x50003, // [17]
		123, 125, 0x110018, // [18]
		128, 129, 0x20000a, // [19]
		104, 106, 0x40011, // [20]
		109, 111, 0x40011, // [21]
		114, 116, 0x40011, // [22]
		125, 127, 0x40011, // [23]
		133, 135, 0x30010, // [24]
		155, 157, 0x20054, // [25]
		160, 163, 0x130062, // [26]
		173, 173, 0x400002, // [27]
		163, 166, 0x170013, // [28]
		170, 170, 0x4e0003, // [29]
		166, 169, 0x40017, // [30]
	},
	NumStmt: [31]uint16{
		1, // 0
		1, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		4, // 11
		2, // 12
		1, // 13
		3, // 14
		2, // 15
		2, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		1, // 27
		3, // 28
		1, // 29
		2, // 30
	},
}
var _ = _cover_atomic_.LoadUint32
