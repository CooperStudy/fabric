//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/tests/client.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package tests; import _cover_atomic_ "sync/atomic"

import (
	"testing"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/stretchr/testify/assert"
)

// client helps in a transction simulation. The client keeps accumlating the results of each simulated transaction
// in a slice and at a later stage can be used to cut a test block for committing.
// In a test, for each instantiated ledger, a single instance of a client is typically sufficient.
type client struct {
	lgr            ledger.PeerLedger
	simulatedTrans []*txAndPvtdata // accumulates the results of transactions simulations
	assert         *assert.Assertions
}

func newClient(lgr ledger.PeerLedger, t *testing.T) *client {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[0], 1);
	return &client{lgr, nil, assert.New(t)}
}

// simulateDataTx takes a simulation logic and wraps it between
// (A) the pre-simulation tasks (such as obtaining a fresh simulator) and
// (B) the post simulation tasks (such as gathering (public and pvt) simulation results and constructing a transaction)
// Since (A) and (B) both are handled in this function, the test code can be kept simple by just supplying the simulation logic
func (c *client) simulateDataTx(txid string, simulationLogic func(s *simulator)) *txAndPvtdata {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[1], 1);
	if txid == "" {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[3], 1);
		txid = util.GenerateUUID()
	}
	_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[2], 1);ledgerSimulator, err := c.lgr.NewTxSimulator(txid)
	c.assert.NoError(err)
	sim := &simulator{ledgerSimulator, txid, c.assert}
	simulationLogic(sim)
	txAndPvtdata := sim.done()
	c.simulatedTrans = append(c.simulatedTrans, txAndPvtdata)
	return txAndPvtdata
}

// simulateDeployTx mimics a transction that deploys a chaincode. This in turn calls the function 'simulateDataTx'
// with supplying the simulation logic that mimics the inoke funciton of 'lscc' for the ledger tests
func (c *client) simulateDeployTx(ccName string, collConfs []*collConf) *txAndPvtdata {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[4], 1);
	ccData := &ccprovider.ChaincodeData{Name: ccName}
	ccDataBytes, err := proto.Marshal(ccData)
	c.assert.NoError(err)

	psudoLSCCInvokeFunc := func(s *simulator) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[6], 1);
		s.setState("lscc", ccName, string(ccDataBytes))
		if collConfs != nil {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[7], 1);
			protoBytes, err := convertToCollConfigProtoBytes(collConfs)
			c.assert.NoError(err)
			s.setState("lscc", privdata.BuildCollectionKVSKey(ccName), string(protoBytes))
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[5], 1);return c.simulateDataTx("", psudoLSCCInvokeFunc)
}

// simulateUpgradeTx see comments on function 'simulateDeployTx'
func (c *client) simulateUpgradeTx(ccName string, collConfs []*collConf) *txAndPvtdata {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[8], 1);
	return c.simulateDeployTx(ccName, collConfs)
}

///////////////////////   simulator wrapper functions  ///////////////////////
type simulator struct {
	ledger.TxSimulator
	txid   string
	assert *assert.Assertions
}

func (s *simulator) getState(ns, key string) string {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[9], 1);
	val, err := s.GetState(ns, key)
	s.assert.NoError(err)
	return string(val)
}

func (s *simulator) setState(ns, key string, val string) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[10], 1);
	s.assert.NoError(
		s.SetState(ns, key, []byte(val)),
	)
}

func (s *simulator) delState(ns, key string) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[11], 1);
	s.assert.NoError(
		s.DeleteState(ns, key),
	)
}

func (s *simulator) getPvtdata(ns, coll, key string) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[12], 1);
	_, err := s.GetPrivateData(ns, coll, key)
	s.assert.NoError(err)
}

func (s *simulator) setPvtdata(ns, coll, key string, val string) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[13], 1);
	s.assert.NoError(
		s.SetPrivateData(ns, coll, key, []byte(val)),
	)
}

func (s *simulator) delPvtdata(ns, coll, key string) {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[14], 1);
	s.assert.NoError(
		s.DeletePrivateData(ns, coll, key),
	)
}

func (s *simulator) done() *txAndPvtdata {_cover_atomic_.AddUint32(&GoCover_0_363234376562373564353161.Count[15], 1);
	s.Done()
	simRes, err := s.GetTxSimulationResults()
	s.assert.NoError(err)
	pubRwsetBytes, err := simRes.GetPubSimulationBytes()
	s.assert.NoError(err)
	envelope, err := constructTransaction(s.txid, pubRwsetBytes)
	s.assert.NoError(err)
	txAndPvtdata := &txAndPvtdata{Txid: s.txid, Envelope: envelope, Pvtws: simRes.PvtSimulationResults}
	return txAndPvtdata
}

var GoCover_0_363234376562373564353161 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		29, 31, 0x2003d, // [0]
		37, 38, 0x100060, // [1]
		41, 47, 0x150002, // [2]
		38, 40, 0x30010, // [3]
		52, 57, 0x2c0057, // [4]
		65, 65, 0x320002, // [5]
		57, 59, 0x17002c, // [6]
		59, 63, 0x40017, // [7]
		69, 71, 0x20058, // [8]
		80, 84, 0x20035, // [9]
		86, 90, 0x2003a, // [10]
		92, 96, 0x2002e, // [11]
		98, 101, 0x20036, // [12]
		103, 107, 0x20042, // [13]
		109, 113, 0x20036, // [14]
		115, 125, 0x2002a, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		1, // 1
		7, // 2
		1, // 3
		4, // 4
		1, // 5
		2, // 6
		3, // 7
		1, // 8
		3, // 9
		1, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		9, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
