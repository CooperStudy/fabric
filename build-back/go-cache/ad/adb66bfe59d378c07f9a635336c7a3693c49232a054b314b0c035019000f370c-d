//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/stateleveldb/stateleveldb.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package stateleveldb; import _cover_atomic_ "sync/atomic"

import (
	"bytes"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb/iterator"
)

var logger = flogging.MustGetLogger("stateleveldb")

var compositeKeySep = []byte{0x00}
var lastKeyIndicator = byte(0x01)
var savePointKey = []byte{0x00}

// VersionedDBProvider implements interface VersionedDBProvider
type VersionedDBProvider struct {
	dbProvider *leveldbhelper.Provider
}

// NewVersionedDBProvider instantiates VersionedDBProvider
func NewVersionedDBProvider() *VersionedDBProvider {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[0], 1);
	dbPath := ledgerconfig.GetStateLevelDBPath()
	logger.Debugf("constructing VersionedDBProvider dbPath=%s", dbPath)
	dbProvider := leveldbhelper.NewProvider(&leveldbhelper.Conf{DBPath: dbPath})
	return &VersionedDBProvider{dbProvider}
}

// GetDBHandle gets the handle to a named database
func (provider *VersionedDBProvider) GetDBHandle(dbName string) (statedb.VersionedDB, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[1], 1);
	return newVersionedDB(provider.dbProvider.GetDBHandle(dbName), dbName), nil
}

// Close closes the underlying db
func (provider *VersionedDBProvider) Close() {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[2], 1);
	provider.dbProvider.Close()
}

// VersionedDB implements VersionedDB interface
type versionedDB struct {
	db     *leveldbhelper.DBHandle
	dbName string
}

// newVersionedDB constructs an instance of VersionedDB
func newVersionedDB(db *leveldbhelper.DBHandle, dbName string) *versionedDB {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[3], 1);
	return &versionedDB{db, dbName}
}

// Open implements method in VersionedDB interface
func (vdb *versionedDB) Open() error {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[4], 1);
	// do nothing because shared db is used
	return nil
}

// Close implements method in VersionedDB interface
func (vdb *versionedDB) Close() {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[5], 1);
	// do nothing because shared db is used
}

// ValidateKeyValue implements method in VersionedDB interface
func (vdb *versionedDB) ValidateKeyValue(key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[6], 1);
	return nil
}

// BytesKeySupported implements method in VersionedDB interface
func (vdb *versionedDB) BytesKeySupported() bool {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[7], 1);
	return true
}

// GetState implements method in VersionedDB interface
func (vdb *versionedDB) GetState(namespace string, key string) (*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[8], 1);
	logger.Debugf("GetState(). ns=%s, key=%s", namespace, key)
	compositeKey := constructCompositeKey(namespace, key)
	dbVal, err := vdb.db.Get(compositeKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[11], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[9], 1);if dbVal == nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[12], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[10], 1);return decodeValue(dbVal)
}

// GetVersion implements method in VersionedDB interface
func (vdb *versionedDB) GetVersion(namespace string, key string) (*version.Height, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[13], 1);
	versionedValue, err := vdb.GetState(namespace, key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[16], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[14], 1);if versionedValue == nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[17], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[15], 1);return versionedValue.Version, nil
}

// GetStateMultipleKeys implements method in VersionedDB interface
func (vdb *versionedDB) GetStateMultipleKeys(namespace string, keys []string) ([]*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[18], 1);
	vals := make([]*statedb.VersionedValue, len(keys))
	for i, key := range keys {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[20], 1);
		val, err := vdb.GetState(namespace, key)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[22], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[21], 1);vals[i] = val
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[19], 1);return vals, nil
}

// GetStateRangeScanIterator implements method in VersionedDB interface
// startKey is inclusive
// endKey is exclusive
func (vdb *versionedDB) GetStateRangeScanIterator(namespace string, startKey string, endKey string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[23], 1);
	return vdb.GetStateRangeScanIteratorWithMetadata(namespace, startKey, endKey, nil)
}

const optionLimit = "limit"

// GetStateRangeScanIteratorWithMetadata implements method in VersionedDB interface
func (vdb *versionedDB) GetStateRangeScanIteratorWithMetadata(namespace string, startKey string, endKey string, metadata map[string]interface{}) (statedb.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[24], 1);

	requestedLimit := int32(0)
	// if metadata is provided, validate and apply options
	if metadata != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[27], 1);
		//validate the metadata
		err := statedb.ValidateRangeMetadata(metadata)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[29], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[28], 1);if limitOption, ok := metadata[optionLimit]; ok {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[30], 1);
			requestedLimit = limitOption.(int32)
		}
	}

	// Note:  metadata is not used for the goleveldb implementation of the range query
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[25], 1);compositeStartKey := constructCompositeKey(namespace, startKey)
	compositeEndKey := constructCompositeKey(namespace, endKey)
	if endKey == "" {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[31], 1);
		compositeEndKey[len(compositeEndKey)-1] = lastKeyIndicator
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[26], 1);dbItr := vdb.db.GetIterator(compositeStartKey, compositeEndKey)

	return newKVScanner(namespace, dbItr, requestedLimit), nil

}

// ExecuteQuery implements method in VersionedDB interface
func (vdb *versionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[32], 1);
	return nil, errors.New("ExecuteQuery not supported for leveldb")
}

// ExecuteQueryWithMetadata implements method in VersionedDB interface
func (vdb *versionedDB) ExecuteQueryWithMetadata(namespace, query string, metadata map[string]interface{}) (statedb.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[33], 1);
	return nil, errors.New("ExecuteQueryWithMetadata not supported for leveldb")
}

// ApplyUpdates implements method in VersionedDB interface
func (vdb *versionedDB) ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) error {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[34], 1);
	dbBatch := leveldbhelper.NewUpdateBatch()
	namespaces := batch.GetUpdatedNamespaces()
	for _, ns := range namespaces {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[38], 1);
		updates := batch.GetUpdates(ns)
		for k, vv := range updates {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[39], 1);
			compositeKey := constructCompositeKey(ns, k)
			logger.Debugf("Channel [%s]: Applying key(string)=[%s] key(bytes)=[%#v]", vdb.dbName, string(compositeKey), compositeKey)

			if vv.Value == nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[40], 1);
				dbBatch.Delete(compositeKey)
			} else{ _cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[41], 1);{
				encodedVal, err := encodeValue(vv)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[43], 1);
					return err
				}
				_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[42], 1);dbBatch.Put(compositeKey, encodedVal)
			}}
		}
	}
	// Record a savepoint at a given height
	// If a given height is nil, it denotes that we are committing pvt data of old blocks.
	// In this case, we should not store a savepoint for recovery. The lastUpdatedOldBlockList
	// in the pvtstore acts as a savepoint for pvt data.
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[35], 1);if height != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[44], 1);
		dbBatch.Put(savePointKey, height.ToBytes())
	}
	// Setting snyc to true as a precaution, false may be an ok optimization after further testing.
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[36], 1);if err := vdb.db.WriteBatch(dbBatch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[45], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[37], 1);return nil
}

// GetLatestSavePoint implements method in VersionedDB interface
func (vdb *versionedDB) GetLatestSavePoint() (*version.Height, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[46], 1);
	versionBytes, err := vdb.db.Get(savePointKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[49], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[47], 1);if versionBytes == nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[50], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[48], 1);version, _ := version.NewHeightFromBytes(versionBytes)
	return version, nil
}

func constructCompositeKey(ns string, key string) []byte {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[51], 1);
	return append(append([]byte(ns), compositeKeySep...), []byte(key)...)
}

func splitCompositeKey(compositeKey []byte) (string, string) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[52], 1);
	split := bytes.SplitN(compositeKey, compositeKeySep, 2)
	return string(split[0]), string(split[1])
}

type kvScanner struct {
	namespace            string
	dbItr                iterator.Iterator
	requestedLimit       int32
	totalRecordsReturned int32
}

func newKVScanner(namespace string, dbItr iterator.Iterator, requestedLimit int32) *kvScanner {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[53], 1);
	return &kvScanner{namespace, dbItr, requestedLimit, 0}
}

func (scanner *kvScanner) Next() (statedb.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[54], 1);

	if scanner.requestedLimit > 0 && scanner.totalRecordsReturned >= scanner.requestedLimit {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[58], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[55], 1);if !scanner.dbItr.Next() {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[59], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[56], 1);dbKey := scanner.dbItr.Key()
	dbVal := scanner.dbItr.Value()
	dbValCopy := make([]byte, len(dbVal))
	copy(dbValCopy, dbVal)
	_, key := splitCompositeKey(dbKey)
	vv, err := decodeValue(dbValCopy)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[60], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[57], 1);scanner.totalRecordsReturned++

	return &statedb.VersionedKV{
		CompositeKey: statedb.CompositeKey{Namespace: scanner.namespace, Key: key},
		// TODO remove dereferrencing below by changing the type of the field
		// `VersionedValue` in `statedb.VersionedKV` to a pointer
		VersionedValue: *vv}, nil
}

func (scanner *kvScanner) Close() {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[61], 1);
	scanner.dbItr.Release()
}

func (scanner *kvScanner) GetBookmarkAndClose() string {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[62], 1);
	retval := ""
	if scanner.dbItr.Next() {_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[64], 1);
		dbKey := scanner.dbItr.Key()
		_, key := splitCompositeKey(dbKey)
		retval = key
	}
	_cover_atomic_.AddUint32(&GoCover_0_623534613733643331386633.Count[63], 1);scanner.Close()
	return retval
}

var GoCover_0_623534613733643331386633 = struct {
	Count     [65]uint32
	Pos       [3 * 65]uint32
	NumStmt   [65]uint16
} {
	Pos: [3 * 65]uint32{
		32, 37, 0x20034, // [0]
		40, 42, 0x2005e, // [1]
		45, 47, 0x2002e, // [2]
		56, 58, 0x2004d, // [3]
		61, 64, 0x20026, // [4]
		67, 69, 0x20022, // [5]
		72, 74, 0x2004a, // [6]
		77, 79, 0x20032, // [7]
		82, 86, 0x100061, // [8]
		89, 89, 0x120002, // [9]
		92, 92, 0x1b0002, // [10]
		86, 88, 0x30010, // [11]
		89, 91, 0x30012, // [12]
		96, 98, 0x10005b, // [13]
		101, 101, 0x1b0002, // [14]
		104, 104, 0x240002, // [15]
		98, 100, 0x30010, // [16]
		101, 103, 0x3001b, // [17]
		108, 110, 0x1b0072, // [18]
		117, 117, 0x120002, // [19]
		110, 112, 0x11001b, // [20]
		115, 115, 0x100003, // [21]
		112, 114, 0x40011, // [22]
		123, 125, 0x20086, // [23]
		130, 134, 0x1500b8, // [24]
		146, 148, 0x120002, // [25]
		151, 153, 0x3c0002, // [26]
		134, 137, 0x110015, // [27]
		140, 140, 0x330003, // [28]
		137, 139, 0x40011, // [29]
		140, 142, 0x40033, // [30]
		148, 150, 0x30012, // [31]
		158, 160, 0x20060, // [32]
		163, 165, 0x20092, // [33]
		168, 171, 0x200060, // [34]
		192, 192, 0x130002, // [35]
		196, 196, 0x390002, // [36]
		199, 199, 0xc0002, // [37]
		171, 173, 0x1e0020, // [38]
		173, 177, 0x17001e, // [39]
		177, 179, 0x50017, // [40]
		179, 181, 0x13000a, // [41]
		184, 184, 0x2a0005, // [42]
		181, 183, 0x60013, // [43]
		192, 194, 0x30013, // [44]
		196, 198, 0x30039, // [45]
		203, 205, 0x100047, // [46]
		208, 208, 0x190002, // [47]
		211, 212, 0x150002, // [48]
		205, 207, 0x30010, // [49]
		208, 210, 0x30019, // [50]
		215, 217, 0x2003a, // [51]
		219, 222, 0x2003e, // [52]
		231, 233, 0x2005f, // [53]
		235, 237, 0x5a003f, // [54]
		241, 241, 0x1b0002, // [55]
		245, 251, 0x100002, // [56]
		255, 261, 0x1c0002, // [57]
		237, 239, 0x3005a, // [58]
		241, 243, 0x3001b, // [59]
		251, 253, 0x30010, // [60]
		264, 266, 0x20023, // [61]
		268, 270, 0x1a0038, // [62]
		275, 276, 0xf0002, // [63]
		270, 274, 0x3001a, // [64]
	},
	NumStmt: [65]uint16{
		4, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		0, // 5
		1, // 6
		1, // 7
		4, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		2, // 24
		3, // 25
		2, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		3, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		3, // 39
		1, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		2, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		2, // 52
		1, // 53
		1, // 54
		1, // 55
		7, // 56
		2, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		2, // 62
		2, // 63
		3, // 64
	},
}
var _ = _cover_atomic_.LoadUint32
