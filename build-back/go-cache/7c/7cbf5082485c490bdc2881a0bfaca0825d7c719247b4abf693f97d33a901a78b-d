//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blockledger/json/impl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package jsonledger; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/golang/protobuf/jsonpb"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/blockledger"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("common.ledger.blockledger.json")

var closedChan chan struct{}
var fileLock sync.Mutex

func init() {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[0], 1);
	closedChan = make(chan struct{})
	close(closedChan)
}

const (
	blockFileFormatString      = "block_%020d.json"
	chainDirectoryFormatString = "chain_%s"
)

type cursor struct {
	jl          *jsonLedger
	blockNumber uint64
}

type jsonLedger struct {
	directory string
	height    uint64
	lastHash  []byte
	marshaler *jsonpb.Marshaler

	mutex  sync.Mutex
	signal chan struct{}
}

// readBlock returns the block or nil, and whether the block was found or not, (nil,true) generally indicates an irrecoverable problem
func (jl *jsonLedger) readBlock(number uint64) (*cb.Block, bool) {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[1], 1);
	name := jl.blockFilename(number)

	// In case of ongoing write, reading the block file may result in `unexpected EOF` error.
	// Therefore, we use file mutex here to prevent this race condition.
	fileLock.Lock()
	defer fileLock.Unlock()

	file, err := os.Open(name)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[3], 1);
		defer file.Close()
		block := &cb.Block{}
		err = jsonpb.Unmarshal(file, block)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[5], 1);
			return nil, true
		}
		_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[4], 1);logger.Debugf("Read block %d", block.Header.Number)
		return block, true
	}
	_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[2], 1);return nil, false
}

// Next blocks until there is a new block available, or returns an error if the
// next block is no longer retrievable
func (cu *cursor) Next() (*cb.Block, cb.Status) {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[6], 1);
	// This only loops once, as signal reading
	// indicates the new block has been written
	for {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[7], 1);
		block, found := cu.jl.readBlock(cu.blockNumber)
		if found {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[9], 1);
			if block == nil {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[11], 1);
				return nil, cb.Status_SERVICE_UNAVAILABLE
			}
			_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[10], 1);cu.blockNumber++
			return block, cb.Status_SUCCESS
		}

		// copy the signal channel under lock to avoid race
		// with new signal channel in append
		_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[8], 1);cu.jl.mutex.Lock()
		signal := cu.jl.signal
		cu.jl.mutex.Unlock()
		<-signal
	}
}

func (cu *cursor) Close() {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[12], 1);}

// Iterator returns an Iterator, as specified by a ab.SeekInfo message, and its
// starting block number
func (jl *jsonLedger) Iterator(startPosition *ab.SeekPosition) (blockledger.Iterator, uint64) {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[13], 1);
	switch start := startPosition.Type.(type) {
	case *ab.SeekPosition_Oldest:_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[14], 1);
		return &cursor{jl: jl, blockNumber: 0}, 0
	case *ab.SeekPosition_Newest:_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[15], 1);
		high := jl.height - 1
		return &cursor{jl: jl, blockNumber: high}, high
	case *ab.SeekPosition_Specified:_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[16], 1);
		if start.Specified.Number > jl.height {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[19], 1);
			return &blockledger.NotFoundErrorIterator{}, 0
		}
		_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[17], 1);return &cursor{jl: jl, blockNumber: start.Specified.Number}, start.Specified.Number
	default:_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[18], 1);
		return &blockledger.NotFoundErrorIterator{}, 0
	}
}

// Height returns the number of blocks on the ledger
func (jl *jsonLedger) Height() uint64 {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[20], 1);
	return jl.height
}

// Append appends a new block to the ledger
func (jl *jsonLedger) Append(block *cb.Block) error {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[21], 1);
	if block.Header.Number != jl.height {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[24], 1);
		return errors.Errorf("block number should have been %d but was %d", jl.height, block.Header.Number)
	}

	_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[22], 1);if !bytes.Equal(block.Header.PreviousHash, jl.lastHash) {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[25], 1);
		return errors.Errorf("block should have had previous hash of %x but was %x", jl.lastHash, block.Header.PreviousHash)
	}

	_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[23], 1);jl.writeBlock(block)
	jl.lastHash = block.Header.Hash()
	jl.height++

	// Manage the signal channel under lock to avoid race with read in Next
	jl.mutex.Lock()
	close(jl.signal)
	jl.signal = make(chan struct{})
	jl.mutex.Unlock()
	return nil
}

// writeBlock commits a block to disk
func (jl *jsonLedger) writeBlock(block *cb.Block) {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[26], 1);
	name := jl.blockFilename(block.Header.Number)

	fileLock.Lock()
	defer fileLock.Unlock()

	file, err := os.Create(name)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[28], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[27], 1);defer file.Close()

	err = jl.marshaler.Marshal(file, block)
	logger.Debugf("Wrote block %d", block.Header.Number)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[29], 1);
		logger.Panicf("Error marshalling with block number [%d]: %s", block.Header.Number, err)
	}
}

// blockFilename returns the fully qualified path to where a block
// of a given number should be stored on disk
func (jl *jsonLedger) blockFilename(number uint64) string {_cover_atomic_.AddUint32(&GoCover_1_663330323533613930316531.Count[30], 1);
	return filepath.Join(jl.directory, fmt.Sprintf(blockFileFormatString, number))
}

var GoCover_1_663330323533613930316531 = struct {
	Count     [31]uint32
	Pos       [3 * 31]uint32
	NumStmt   [31]uint16
} {
	Pos: [3 * 31]uint32{
		29, 32, 0x2000d, // [0]
		55, 64, 0x100042, // [1]
		74, 74, 0x130002, // [2]
		64, 68, 0x110010, // [3]
		71, 72, 0x150003, // [4]
		68, 70, 0x40011, // [5]
		79, 82, 0x60031, // [6]
		82, 84, 0xc0006, // [7]
		94, 97, 0xb0003, // [8]
		84, 85, 0x14000c, // [9]
		88, 89, 0x230004, // [10]
		85, 87, 0x50014, // [11]
		101, 101, 0x1d001c, // [12]
		105, 106, 0x2c005f, // [13]
		107, 108, 0x2c001f, // [14]
		109, 111, 0x32001f, // [15]
		112, 113, 0x290022, // [16]
		116, 116, 0x560003, // [17]
		117, 118, 0x31000a, // [18]
		113, 115, 0x40029, // [19]
		123, 125, 0x20027, // [20]
		128, 129, 0x260035, // [21]
		133, 133, 0x3a0002, // [22]
		137, 146, 0xc0002, // [23]
		129, 131, 0x30026, // [24]
		133, 135, 0x3003a, // [25]
		150, 157, 0x100033, // [26]
		160, 164, 0x100002, // [27]
		157, 158, 0xd0010, // [28]
		164, 166, 0x30010, // [29]
		171, 173, 0x2003b, // [30]
	},
	NumStmt: [31]uint16{
		2, // 0
		5, // 1
		1, // 2
		4, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		4, // 8
		1, // 9
		2, // 10
		1, // 11
		0, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		8, // 23
		1, // 24
		1, // 25
		5, // 26
		4, // 27
		1, // 28
		1, // 29
		1, // 30
	},
}
var _ = _cover_atomic_.LoadUint32
