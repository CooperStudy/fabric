//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/util/ioutil.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package util; import _cover_atomic_ "sync/atomic"

import (
	"io"
	"io/ioutil"
	"os"
	"path"
	"strings"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("kvledger.util")

// CreateDirIfMissing creates a dir for dirPath if not already exists. If the dir is empty it returns true
func CreateDirIfMissing(dirPath string) (bool, error) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[0], 1);
	// if dirPath does not end with a path separator, it leaves out the last segment while creating directories
	if !strings.HasSuffix(dirPath, "/") {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[3], 1);
		dirPath = dirPath + "/"
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[1], 1);logger.Debugf("CreateDirIfMissing [%s]", dirPath)
	logDirStatus("Before creating dir", dirPath)
	err := os.MkdirAll(path.Dir(dirPath), 0755)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[4], 1);
		logger.Debugf("Error creating dir [%s]", dirPath)
		return false, errors.Wrapf(err, "error creating dir [%s]", dirPath)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[2], 1);logDirStatus("After creating dir", dirPath)
	return DirEmpty(dirPath)
}

// DirEmpty returns true if the dir at dirPath is empty
func DirEmpty(dirPath string) (bool, error) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[5], 1);
	f, err := os.Open(dirPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[8], 1);
		logger.Debugf("Error opening dir [%s]: %+v", dirPath, err)
		return false, errors.Wrapf(err, "error opening dir [%s]", dirPath)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[6], 1);defer f.Close()

	_, err = f.Readdir(1)
	if err == io.EOF {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[9], 1);
		return true, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[7], 1);err = errors.Wrapf(err, "error checking if dir [%s] is empty", dirPath)
	return false, err
}

// FileExists checks whether the given file exists.
// If the file exists, this method also returns the size of the file.
func FileExists(filePath string) (bool, int64, error) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[10], 1);
	fileInfo, err := os.Stat(filePath)
	if os.IsNotExist(err) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[13], 1);
		return false, 0, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[11], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[14], 1);
		return false, 0, errors.Wrapf(err, "error checking if file [%s] exists", filePath)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[12], 1);return true, fileInfo.Size(), nil
}

// ListSubdirs returns the subdirectories
func ListSubdirs(dirPath string) ([]string, error) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[15], 1);
	subdirs := []string{}
	files, err := ioutil.ReadDir(dirPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[18], 1);
		return nil, errors.Wrapf(err, "error reading dir %s", dirPath)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[16], 1);for _, f := range files {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[19], 1);
		if f.IsDir() {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[20], 1);
			subdirs = append(subdirs, f.Name())
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[17], 1);return subdirs, nil
}

func logDirStatus(msg string, dirPath string) {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[21], 1);
	exists, _, err := FileExists(dirPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[23], 1);
		logger.Errorf("Error checking for dir existence")
	}
	_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[22], 1);if exists {_cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[24], 1);
		logger.Debugf("%s - [%s] exists", msg, dirPath)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_333237633366653837323561.Count[25], 1);{
		logger.Debugf("%s - [%s] does not exist", msg, dirPath)
	}}
}

var GoCover_0_333237633366653837323561 = struct {
	Count     [26]uint32
	Pos       [3 * 26]uint32
	NumStmt   [26]uint16
} {
	Pos: [3 * 26]uint32{
		23, 25, 0x260037, // [0]
		28, 31, 0x100002, // [1]
		35, 36, 0x1a0002, // [2]
		25, 27, 0x30026, // [3]
		31, 34, 0x30010, // [4]
		40, 42, 0x10002d, // [5]
		46, 49, 0x130002, // [6]
		52, 53, 0x130002, // [7]
		42, 45, 0x30010, // [8]
		49, 51, 0x30013, // [9]
		58, 60, 0x180037, // [10]
		63, 63, 0x100002, // [11]
		66, 66, 0x230002, // [12]
		60, 62, 0x30018, // [13]
		63, 65, 0x30010, // [14]
		70, 73, 0x100034, // [15]
		76, 76, 0x1a0002, // [16]
		81, 81, 0x150002, // [17]
		73, 75, 0x30010, // [18]
		76, 77, 0x10001a, // [19]
		77, 79, 0x40010, // [20]
		84, 86, 0x10002f, // [21]
		89, 89, 0xc0002, // [22]
		86, 88, 0x30010, // [23]
		89, 91, 0x3000c, // [24]
		91, 93, 0x30008, // [25]
	},
	NumStmt: [26]uint16{
		1, // 0
		4, // 1
		2, // 2
		1, // 3
		2, // 4
		2, // 5
		3, // 6
		2, // 7
		2, // 8
		1, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		3, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
	},
}
var _ = _cover_atomic_.LoadUint32
