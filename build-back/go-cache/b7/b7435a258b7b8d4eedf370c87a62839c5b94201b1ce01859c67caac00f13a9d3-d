//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/tests/test_helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package tests; import _cover_atomic_ "sync/atomic"

import (
	"testing"

	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
	"github.com/stretchr/testify/assert"
)

// testhelper embeds (1) a client, (2) a committer and (3) a verifier, all three operate on
// a ledger instance and add helping/resuable functionality on top of ledger apis that helps
// in avoiding the repeation in the actual tests code.
// the 'client' adds value to the simulation relation apis, the 'committer' helps in cutting the
// next block and committing the block, and finally, the verifier helps in veryfying that the
// ledger apis returns correct values based on the blocks submitted
type testhelper struct {
	*client
	*committer
	*verifier
	lgr    ledger.PeerLedger
	lgrid  string
	assert *assert.Assertions
}

// newTestHelperCreateLgr creates a new ledger and retruns a 'testhelper' for the ledger
func newTestHelperCreateLgr(id string, t *testing.T) *testhelper {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[0], 1);
	genesisBlk, err := constructTestGenesisBlock(id)
	assert.NoError(t, err)
	lgr, err := ledgermgmt.CreateLedger(genesisBlk)
	assert.NoError(t, err)
	client, committer, verifier := newClient(lgr, t), newCommitter(lgr, t), newVerifier(lgr, t)
	return &testhelper{client, committer, verifier, lgr, id, assert.New(t)}
}

// newTestHelperOpenLgr opens an existing ledger and retruns a 'testhelper' for the ledger
func newTestHelperOpenLgr(id string, t *testing.T) *testhelper {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[1], 1);
	lgr, err := ledgermgmt.OpenLedger(id)
	assert.NoError(t, err)
	client, committer, verifier := newClient(lgr, t), newCommitter(lgr, t), newVerifier(lgr, t)
	return &testhelper{client, committer, verifier, lgr, id, assert.New(t)}
}

// cutBlockAndCommitWithPvtdata gathers all the transactions simulated by the test code (by calling
// the functions available in the 'client') and cuts the next block and commits to the ledger
func (h *testhelper) cutBlockAndCommitWithPvtdata() *ledger.BlockAndPvtData {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[2], 1);
	defer func() {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[4], 1); h.simulatedTrans = nil }()
	_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[3], 1);return h.committer.cutBlockAndCommitWithPvtdata(h.simulatedTrans...)
}

func (h *testhelper) cutBlockAndCommitExpectError() (*ledger.BlockAndPvtData, error) {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[5], 1);
	defer func() {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[7], 1); h.simulatedTrans = nil }()
	_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[6], 1);return h.committer.cutBlockAndCommitExpectError(h.simulatedTrans...)
}

// assertError is a helper function that can be called as assertError(f()) where 'f' is some other function
// this function assumes that the last return type of function 'f' is of type 'error'
func (h *testhelper) assertError(output ...interface{}) {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[8], 1);
	lastParam := output[len(output)-1]
	assert.NotNil(h.t, lastParam)
	h.assert.Error(lastParam.(error))
}

// assertNoError see comment on function 'assertError'
func (h *testhelper) assertNoError(output ...interface{}) {_cover_atomic_.AddUint32(&GoCover_4_363234376562373564353161.Count[9], 1);
	h.assert.Nil(output[len(output)-1])
}

var GoCover_4_363234376562373564353161 = struct {
	Count     [10]uint32
	Pos       [3 * 10]uint32
	NumStmt   [10]uint16
} {
	Pos: [3 * 10]uint32{
		33, 40, 0x20042, // [0]
		43, 48, 0x20040, // [1]
		52, 53, 0xf004d, // [2]
		54, 54, 0x460002, // [3]
		53, 53, 0x29000f, // [4]
		57, 58, 0xf0056, // [5]
		59, 59, 0x460002, // [6]
		58, 58, 0x29000f, // [7]
		64, 68, 0x20039, // [8]
		71, 73, 0x2003b, // [9]
	},
	NumStmt: [10]uint16{
		6, // 0
		4, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
	},
}
var _ = _cover_atomic_.LoadUint32
