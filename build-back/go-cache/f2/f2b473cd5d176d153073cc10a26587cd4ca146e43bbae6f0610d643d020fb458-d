//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/chaincode_support.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/container/ccintf"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/peer"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

// Runtime is used to manage chaincode runtime instances.
type Runtime interface {
	Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []byte) error
	Stop(ccci *ccprovider.ChaincodeContainerInfo) error
}

// Launcher is used to launch chaincode runtimes.
type Launcher interface {
	Launch(ccci *ccprovider.ChaincodeContainerInfo) error
}

// Lifecycle provides a way to retrieve chaincode definitions and the packages necessary to run them
type Lifecycle interface {
	// ChaincodeDefinition returns the details for a chaincode by name
	ChaincodeDefinition(chaincodeName string, qe ledger.QueryExecutor) (ccprovider.ChaincodeDefinition, error)

	// ChaincodeContainerInfo returns the package necessary to launch a chaincode
	ChaincodeContainerInfo(chaincodeName string, qe ledger.QueryExecutor) (*ccprovider.ChaincodeContainerInfo, error)
}

// ChaincodeSupport responsible for providing interfacing with chaincodes from the Peer.
type ChaincodeSupport struct {
	Keepalive        time.Duration
	ExecuteTimeout   time.Duration
	UserRunsCC       bool
	Runtime          Runtime
	ACLProvider      ACLProvider
	HandlerRegistry  *HandlerRegistry
	Launcher         Launcher
	SystemCCProvider sysccprovider.SystemChaincodeProvider
	Lifecycle        Lifecycle
	appConfig        ApplicationConfigRetriever
	HandlerMetrics   *HandlerMetrics
	LaunchMetrics    *LaunchMetrics
}

// NewChaincodeSupport creates a new ChaincodeSupport instance.
func NewChaincodeSupport(
	config *Config,
	peerAddress string,
	userRunsCC bool,
	caCert []byte,
	certGenerator CertGenerator,
	packageProvider PackageProvider,
	lifecycle Lifecycle,
	aclProvider ACLProvider,
	processor Processor,
	SystemCCProvider sysccprovider.SystemChaincodeProvider,
	platformRegistry *platforms.Registry,
	appConfig ApplicationConfigRetriever,
	metricsProvider metrics.Provider,
) *ChaincodeSupport {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[0], 1);
	cs := &ChaincodeSupport{
		UserRunsCC:       userRunsCC,
		Keepalive:        config.Keepalive,
		ExecuteTimeout:   config.ExecuteTimeout,
		HandlerRegistry:  NewHandlerRegistry(userRunsCC),
		ACLProvider:      aclProvider,
		SystemCCProvider: SystemCCProvider,
		Lifecycle:        lifecycle,
		appConfig:        appConfig,
		HandlerMetrics:   NewHandlerMetrics(metricsProvider),
		LaunchMetrics:    NewLaunchMetrics(metricsProvider),
	}

	// Keep TestQueries working
	if !config.TLSEnabled {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[2], 1);
		certGenerator = nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[1], 1);cs.Runtime = &ContainerRuntime{
		CertGenerator:    certGenerator,
		Processor:        processor,
		CACert:           caCert,
		PeerAddress:      peerAddress,
		PlatformRegistry: platformRegistry,
		CommonEnv: []string{
			"CORE_CHAINCODE_LOGGING_LEVEL=" + config.LogLevel,
			"CORE_CHAINCODE_LOGGING_SHIM=" + config.ShimLogLevel,
			"CORE_CHAINCODE_LOGGING_FORMAT=" + config.LogFormat,
		},
	}

	cs.Launcher = &RuntimeLauncher{
		Runtime:         cs.Runtime,
		Registry:        cs.HandlerRegistry,
		PackageProvider: packageProvider,
		StartupTimeout:  config.StartupTimeout,
		Metrics:         cs.LaunchMetrics,
	}

	return cs
}

// LaunchInit bypasses getting the chaincode spec from the LSCC table
// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be
// defined in the LSCC table
func (cs *ChaincodeSupport) LaunchInit(ccci *ccprovider.ChaincodeContainerInfo) error {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[3], 1);
	cname := ccci.Name + ":" + ccci.Version
	if cs.HandlerRegistry.Handler(cname) != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[5], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[4], 1);return cs.Launcher.Launch(ccci)
}

// Launch starts executing chaincode if it is not already running. This method
// blocks until the peer side handler gets into ready state or encounters a fatal
// error. If the chaincode is already running, it simply returns.
func (cs *ChaincodeSupport) Launch(chainID, chaincodeName, chaincodeVersion string, qe ledger.QueryExecutor) (*Handler, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[6], 1);
	cname := chaincodeName + ":" + chaincodeVersion
	if h := cs.HandlerRegistry.Handler(cname); h != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[11], 1);
		return h, nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[7], 1);ccci, err := cs.Lifecycle.ChaincodeContainerInfo(chaincodeName, qe)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[12], 1);
		// TODO: There has to be a better way to do this...
		if cs.UserRunsCC {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[14], 1);
			chaincodeLogger.Error(
				"You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?",
			)
		}

		_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[13], 1);return nil, errors.Wrapf(err, "[channel %s] failed to get chaincode container info for %s", chainID, cname)
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[8], 1);if err := cs.Launcher.Launch(ccci); err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[15], 1);
		return nil, errors.Wrapf(err, "[channel %s] could not launch chaincode %s", chainID, cname)
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[9], 1);h := cs.HandlerRegistry.Handler(cname)
	if h == nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[16], 1);
		return nil, errors.Wrapf(err, "[channel %s] claimed to start chaincode container for %s but could not find handler", chainID, cname)
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[10], 1);return h, nil
}

// Stop stops a chaincode if running.
func (cs *ChaincodeSupport) Stop(ccci *ccprovider.ChaincodeContainerInfo) error {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[17], 1);
	return cs.Runtime.Stop(ccci)
}

// HandleChaincodeStream implements ccintf.HandleChaincodeStream for all vms to call with appropriate stream
func (cs *ChaincodeSupport) HandleChaincodeStream(stream ccintf.ChaincodeStream) error {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[18], 1);
	handler := &Handler{
		Invoker:                    cs,
		DefinitionGetter:           cs.Lifecycle,
		Keepalive:                  cs.Keepalive,
		Registry:                   cs.HandlerRegistry,
		ACLProvider:                cs.ACLProvider,
		TXContexts:                 NewTransactionContexts(),
		ActiveTransactions:         NewActiveTransactions(),
		SystemCCProvider:           cs.SystemCCProvider,
		SystemCCVersion:            util.GetSysCCVersion(),
		InstantiationPolicyChecker: CheckInstantiationPolicyFunc(ccprovider.CheckInstantiationPolicy),
		QueryResponseBuilder:       &QueryResponseGenerator{MaxResultLimit: 100},
		UUIDGenerator:              UUIDGeneratorFunc(util.GenerateUUID),
		LedgerGetter:               peer.Default,
		AppConfig:                  cs.appConfig,
		Metrics:                    cs.HandlerMetrics,
	}

	return handler.ProcessStream(stream)
}

// Register the bidi stream entry point called by chaincode to register with the Peer.
func (cs *ChaincodeSupport) Register(stream pb.ChaincodeSupport_RegisterServer) error {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[19], 1);
	return cs.HandleChaincodeStream(stream)
}

// createCCMessage creates a transaction message.
func createCCMessage(messageType pb.ChaincodeMessage_Type, cid string, txid string, cMsg *pb.ChaincodeInput) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[20], 1);
	payload, err := proto.Marshal(cMsg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[22], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[21], 1);ccmsg := &pb.ChaincodeMessage{
		Type:      messageType,
		Payload:   payload,
		Txid:      txid,
		ChannelId: cid,
	}
	return ccmsg, nil
}

// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle
// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.
// It does not attempt to start the chaincode based on the information from lifecycle, but instead
// accepts the container information directly in the form of a ChaincodeDeploymentSpec.
func (cs *ChaincodeSupport) ExecuteLegacyInit(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[23], 1);
	ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)
	ccci.Version = cccid.Version

	err := cs.LaunchInit(ccci)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[26], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[24], 1);cname := ccci.Name + ":" + ccci.Version
	h := cs.HandlerRegistry.Handler(cname)
	if h == nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[27], 1);
		return nil, nil, errors.Wrapf(err, "[channel %s] claimed to start chaincode container for %s but could not find handler", txParams.ChannelID, cname)
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[25], 1);resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)
	return processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)
}

// Execute invokes chaincode and returns the original response.
func (cs *ChaincodeSupport) Execute(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[28], 1);
	resp, err := cs.Invoke(txParams, cccid, input)
	return processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)
}

func processChaincodeExecutionResult(txid, ccName string, resp *pb.ChaincodeMessage, err error) (*pb.Response, *pb.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[29], 1);
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[33], 1);
		return nil, nil, errors.Wrapf(err, "failed to execute transaction %s", txid)
	}
	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[30], 1);if resp == nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[34], 1);
		return nil, nil, errors.Errorf("nil response from transaction %s", txid)
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[31], 1);if resp.ChaincodeEvent != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[35], 1);
		resp.ChaincodeEvent.ChaincodeId = ccName
		resp.ChaincodeEvent.TxId = txid
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[32], 1);switch resp.Type {
	case pb.ChaincodeMessage_COMPLETED:_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[36], 1);
		res := &pb.Response{}
		err := proto.Unmarshal(resp.Payload, res)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[40], 1);
			return nil, nil, errors.Wrapf(err, "failed to unmarshal response for transaction %s", txid)
		}
		_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[37], 1);return res, resp.ChaincodeEvent, nil

	case pb.ChaincodeMessage_ERROR:_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[38], 1);
		return nil, resp.ChaincodeEvent, errors.Errorf("transaction returned with failure: %s", resp.Payload)

	default:_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[39], 1);
		return nil, nil, errors.Errorf("unexpected response type %d for transaction %s", resp.Type, txid)
	}
}

func (cs *ChaincodeSupport) InvokeInit(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[41], 1);
	h, err := cs.Launch(txParams.ChannelID, cccid.Name, cccid.Version, txParams.TXSimulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[43], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[42], 1);return cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, input, h)
}

// Invoke will invoke chaincode and return the message containing the response.
// The chaincode will be launched if it is not already running.
func (cs *ChaincodeSupport) Invoke(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[44], 1);
	h, err := cs.Launch(txParams.ChannelID, cccid.Name, cccid.Version, txParams.TXSimulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[46], 1);
		return nil, err
	}

	// TODO add Init exactly once semantics here once new lifecycle
	// is available.  Enforced if the target channel is using the new lifecycle
	//
	// First, the function name of the chaincode to invoke should be checked.  If it is
	// "init", then consider this invocation to be of type pb.ChaincodeMessage_INIT,
	// otherwise consider it to be of type pb.ChaincodeMessage_TRANSACTION,
	//
	// Secondly, A check should be made whether the chaincode has been
	// inited, then, if true, only allow cctyp pb.ChaincodeMessage_TRANSACTION,
	// otherwise, only allow cctype pb.ChaincodeMessage_INIT,
	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[45], 1);cctype := pb.ChaincodeMessage_TRANSACTION

	return cs.execute(cctype, txParams, cccid, input, h)
}

// execute executes a transaction and waits for it to complete until a timeout value.
func (cs *ChaincodeSupport) execute(cctyp pb.ChaincodeMessage_Type, txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput, h *Handler) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[47], 1);
	input.Decorations = txParams.ProposalDecorations
	ccMsg, err := createCCMessage(cctyp, txParams.ChannelID, txParams.TxID, input)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[50], 1);
		return nil, errors.WithMessage(err, "failed to create chaincode message")
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[48], 1);ccresp, err := h.Execute(txParams, cccid, ccMsg, cs.ExecuteTimeout)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[51], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error sending"))
	}

	_cover_atomic_.AddUint32(&GoCover_2_323839383963343337363361.Count[49], 1);return ccresp, nil
}

var GoCover_2_323839383963343337363361 = struct {
	Count     [52]uint32
	Pos       [3 * 52]uint32
	NumStmt   [52]uint16
} {
	Pos: [3 * 52]uint32{
		77, 92, 0x180015, // [0]
		96, 117, 0xb0002, // [1]
		92, 94, 0x30018, // [2]
		123, 125, 0x2e0057, // [3]
		129, 129, 0x210002, // [4]
		125, 127, 0x3002e, // [5]
		135, 137, 0x360080, // [6]
		141, 142, 0x100002, // [7]
		153, 153, 0x310002, // [8]
		157, 158, 0xe0002, // [9]
		162, 162, 0xf0002, // [10]
		137, 139, 0x30036, // [11]
		142, 144, 0x140010, // [12]
		150, 150, 0x6e0003, // [13]
		144, 148, 0x40014, // [14]
		153, 155, 0x30031, // [15]
		158, 160, 0x3000e, // [16]
		166, 168, 0x20051, // [17]
		171, 191, 0x20058, // [18]
		194, 196, 0x20057, // [19]
		199, 201, 0x10008c, // [20]
		204, 210, 0x130002, // [21]
		201, 203, 0x30010, // [22]
		217, 222, 0x1000c0, // [23]
		226, 228, 0xe0002, // [24]
		232, 233, 0x4e0002, // [25]
		222, 224, 0x30010, // [26]
		228, 230, 0x3000e, // [27]
		237, 240, 0x200ae, // [28]
		242, 243, 0x10008b, // [29]
		246, 246, 0x110002, // [30]
		250, 250, 0x200002, // [31]
		255, 255, 0x130002, // [32]
		243, 245, 0x30010, // [33]
		246, 248, 0x30011, // [34]
		250, 253, 0x30020, // [35]
		256, 259, 0x110025, // [36]
		262, 262, 0x270003, // [37]
		264, 265, 0x680021, // [38]
		267, 268, 0x64000a, // [39]
		259, 261, 0x40011, // [40]
		272, 274, 0x1000a5, // [41]
		278, 278, 0x480002, // [42]
		274, 276, 0x30010, // [43]
		283, 285, 0x1000a1, // [44]
		299, 301, 0x360002, // [45]
		285, 287, 0x30010, // [46]
		305, 308, 0x1000ce, // [47]
		312, 313, 0x100002, // [48]
		317, 317, 0x140002, // [49]
		308, 310, 0x30010, // [50]
		313, 315, 0x30010, // [51]
	},
	NumStmt: [52]uint16{
		2, // 0
		3, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		2, // 6
		2, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		2, // 20
		2, // 21
		1, // 22
		4, // 23
		3, // 24
		2, // 25
		1, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		2, // 35
		3, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		1, // 43
		2, // 44
		2, // 45
		1, // 46
		3, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
	},
}
var _ = _cover_atomic_.LoadUint32
