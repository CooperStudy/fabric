//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/msp.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/msp/cache"
	mspprotos "github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
)

type pendingMSPConfig struct {
	mspConfig *mspprotos.MSPConfig
	msp       msp.MSP
}

// MSPConfigHandler
type MSPConfigHandler struct {
	version msp.MSPVersion
	idMap   map[string]*pendingMSPConfig
}

func NewMSPConfigHandler(mspVersion msp.MSPVersion) *MSPConfigHandler {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[0], 1);
	return &MSPConfigHandler{
		version: mspVersion,
		idMap:   make(map[string]*pendingMSPConfig),
	}
}

// ProposeValue called when an org defines an MSP
func (bh *MSPConfigHandler) ProposeMSP(mspConfig *mspprotos.MSPConfig) (msp.MSP, error) {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[1], 1);
	var theMsp msp.MSP
	var err error

	switch mspConfig.Type {
	case int32(msp.FABRIC):_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[6], 1);
		// create the bccsp msp instance
		mspInst, err := msp.New(&msp.BCCSPNewOpts{NewBaseOpts: msp.NewBaseOpts{Version: bh.version}})
		if err != nil {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[10], 1);
			return nil, errors.WithMessage(err, "creating the MSP manager failed")
		}

		// add a cache layer on top
		_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[7], 1);theMsp, err = cache.New(mspInst)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[11], 1);
			return nil, errors.WithMessage(err, "creating the MSP cache failed")
		}
	case int32(msp.IDEMIX):_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[8], 1);
		// create the idemix msp instance
		theMsp, err = msp.New(&msp.IdemixNewOpts{
			NewBaseOpts: msp.NewBaseOpts{Version: bh.version},
		})
		if err != nil {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[12], 1);
			return nil, errors.WithMessage(err, "creating the MSP manager failed")
		}
	default:_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[9], 1);
		return nil, errors.New(fmt.Sprintf("Setup error: unsupported msp type %d", mspConfig.Type))
	}

	// set it up
	_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[2], 1);err = theMsp.Setup(mspConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[13], 1);
		return nil, errors.WithMessage(err, "setting up the MSP manager failed")
	}

	// add the MSP to the map of pending MSPs
	_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[3], 1);mspID, _ := theMsp.GetIdentifier()

	existingPendingMSPConfig, ok := bh.idMap[mspID]
	if ok && !proto.Equal(existingPendingMSPConfig.mspConfig, mspConfig) {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[14], 1);
		return nil, errors.New(fmt.Sprintf("Attempted to define two different versions of MSP: %s", mspID))
	}

	_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[4], 1);if !ok {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[15], 1);
		bh.idMap[mspID] = &pendingMSPConfig{
			mspConfig: mspConfig,
			msp:       theMsp,
		}
	}

	_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[5], 1);return theMsp, nil
}

func (bh *MSPConfigHandler) CreateMSPManager() (msp.MSPManager, error) {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[16], 1);
	mspList := make([]msp.MSP, len(bh.idMap))
	i := 0
	for _, pendingMSP := range bh.idMap {_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[18], 1);
		mspList[i] = pendingMSP.msp
		i++
	}

	_cover_atomic_.AddUint32(&GoCover_10_373339383034363064316135.Count[17], 1);manager := msp.NewMSPManager()
	err := manager.Setup(mspList)
	return manager, err
}

var GoCover_10_373339383034363064316135 = struct {
	Count     [19]uint32
	Pos       [3 * 19]uint32
	NumStmt   [19]uint16
} {
	Pos: [3 * 19]uint32{
		30, 35, 0x20047, // [0]
		38, 42, 0x180059, // [1]
		68, 69, 0x100002, // [2]
		74, 77, 0x470002, // [3]
		81, 81, 0x90002, // [4]
		88, 88, 0x140002, // [5]
		43, 46, 0x110019, // [6]
		51, 52, 0x110003, // [7]
		55, 60, 0x110019, // [8]
		63, 64, 0x5e000a, // [9]
		46, 48, 0x40011, // [10]
		52, 54, 0x40011, // [11]
		60, 62, 0x40011, // [12]
		69, 71, 0x30010, // [13]
		77, 79, 0x30047, // [14]
		81, 86, 0x30009, // [15]
		91, 94, 0x260048, // [16]
		99, 101, 0x150002, // [17]
		94, 97, 0x30026, // [18]
	},
	NumStmt: [19]uint16{
		1, // 0
		3, // 1
		2, // 2
		3, // 3
		1, // 4
		1, // 5
		2, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		3, // 17
		2, // 18
	},
}
var _ = _cover_atomic_.LoadUint32
