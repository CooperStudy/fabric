//line /home/cooper/go/src/github.com/hyperledger/fabric/core/deliverservice/blocksprovider/blocksprovider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package blocksprovider; import _cover_atomic_ "sync/atomic"

import (
	"math"
	"sync/atomic"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/gossip/api"
	gossipcommon "github.com/hyperledger/fabric/gossip/common"
	"github.com/hyperledger/fabric/gossip/discovery"
	"github.com/hyperledger/fabric/gossip/util"
	"github.com/hyperledger/fabric/protos/common"
	gossip_proto "github.com/hyperledger/fabric/protos/gossip"
	"github.com/hyperledger/fabric/protos/orderer"
)

// LedgerInfo an adapter to provide the interface to query
// the ledger committer for current ledger height
type LedgerInfo interface {
	// LedgerHeight returns current local ledger height
	LedgerHeight() (uint64, error)
}

// GossipServiceAdapter serves to provide basic functionality
// required from gossip service by delivery service
type GossipServiceAdapter interface {
	// PeersOfChannel returns slice with members of specified channel
	PeersOfChannel(gossipcommon.ChainID) []discovery.NetworkMember

	// AddPayload adds payload to the local state sync buffer
	AddPayload(chainID string, payload *gossip_proto.Payload) error

	// Gossip the message across the peers
	Gossip(msg *gossip_proto.GossipMessage)
}

// BlocksProvider used to read blocks from the ordering service
// for specified chain it subscribed to
type BlocksProvider interface {
	// DeliverBlocks starts delivering and disseminating blocks
	DeliverBlocks()

	// UpdateClientEndpoints update endpoints
	UpdateOrderingEndpoints(endpoints []string)

	// Stop shutdowns blocks provider and stops delivering new blocks
	Stop()
}

// BlocksDeliverer defines interface which actually helps
// to abstract the AtomicBroadcast_DeliverClient with only
// required method for blocks provider.
// This also decouples the production implementation of the gRPC stream
// from the code in order for the code to be more modular and testable.
type BlocksDeliverer interface {
	// Recv retrieves a response from the ordering service
	Recv() (*orderer.DeliverResponse, error)

	// Send sends an envelope to the ordering service
	Send(*common.Envelope) error
}

type streamClient interface {
	BlocksDeliverer

	// UpdateEndpoint update ordering service endpoints
	UpdateEndpoints(endpoints []string)

	// GetEndpoints
	GetEndpoints() []string

	// Close closes the stream and its underlying connection
	Close()

	// Disconnect disconnects from the remote node and disable reconnect to current endpoint for predefined period of time
	Disconnect(disableEndpoint bool)
}

// blocksProviderImpl the actual implementation for BlocksProvider interface
type blocksProviderImpl struct {
	chainID string

	client streamClient

	gossip GossipServiceAdapter

	mcs api.MessageCryptoService

	done int32

	wrongStatusThreshold int
}

const wrongStatusThreshold = 10

var maxRetryDelay = time.Second * 10
var logger = flogging.MustGetLogger("blocksProvider")

// NewBlocksProvider constructor function to create blocks deliverer instance
func NewBlocksProvider(chainID string, client streamClient, gossip GossipServiceAdapter, mcs api.MessageCryptoService) BlocksProvider {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[0], 1);
	return &blocksProviderImpl{
		chainID:              chainID,
		client:               client,
		gossip:               gossip,
		mcs:                  mcs,
		wrongStatusThreshold: wrongStatusThreshold,
	}
}

// DeliverBlocks used to pull out blocks from the ordering service to
// distributed them across peers
func (b *blocksProviderImpl) DeliverBlocks() {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[1], 1);
	errorStatusCounter := 0
	statusCounter := 0
	defer b.client.Close()
	for !b.isDone() {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[2], 1);
		msg, err := b.client.Recv()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[4], 1);
			logger.Warningf("[%s] Receive error: %s", b.chainID, err.Error())
			return
		}
		_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[3], 1);switch t := msg.Type.(type) {
		case *orderer.DeliverResponse_Status:_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[5], 1);
			if t.Status == common.Status_SUCCESS {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[15], 1);
				logger.Warningf("[%s] ERROR! Received success for a seek that should never complete", b.chainID)
				return
			}
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[6], 1);if t.Status == common.Status_BAD_REQUEST || t.Status == common.Status_FORBIDDEN {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[16], 1);
				logger.Errorf("[%s] Got error %v", b.chainID, t)
				errorStatusCounter++
				if errorStatusCounter > b.wrongStatusThreshold {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[17], 1);
					logger.Criticalf("[%s] Wrong statuses threshold passed, stopping block provider", b.chainID)
					return
				}
			} else{ _cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[18], 1);{
				errorStatusCounter = 0
				logger.Warningf("[%s] Got error %v", b.chainID, t)
			}}
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[7], 1);maxDelay := float64(maxRetryDelay)
			currDelay := float64(time.Duration(math.Pow(2, float64(statusCounter))) * 100 * time.Millisecond)
			time.Sleep(time.Duration(math.Min(maxDelay, currDelay)))
			if currDelay < maxDelay {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[19], 1);
				statusCounter++
			}
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[8], 1);if t.Status == common.Status_BAD_REQUEST {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[20], 1);
				b.client.Disconnect(false)
			} else{ _cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[21], 1);{
				b.client.Disconnect(true)
			}}
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[9], 1);continue
		case *orderer.DeliverResponse_Block:_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[10], 1);
			errorStatusCounter = 0
			statusCounter = 0
			blockNum := t.Block.Header.Number

			marshaledBlock, err := proto.Marshal(t.Block)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[22], 1);
				logger.Errorf("[%s] Error serializing block with sequence number %d, due to %s", b.chainID, blockNum, err)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[11], 1);if err := b.mcs.VerifyBlock(gossipcommon.ChainID(b.chainID), blockNum, marshaledBlock); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[23], 1);
				logger.Errorf("[%s] Error verifying block with sequnce number %d, due to %s", b.chainID, blockNum, err)
				continue
			}

			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[12], 1);numberOfPeers := len(b.gossip.PeersOfChannel(gossipcommon.ChainID(b.chainID)))
			// Create payload with a block received
			payload := createPayload(blockNum, marshaledBlock)
			// Use payload to create gossip message
			gossipMsg := createGossipMsg(b.chainID, payload)

			logger.Debugf("[%s] Adding payload to local buffer, blockNum = [%d]", b.chainID, blockNum)
			// Add payload to local state payloads buffer
			if err := b.gossip.AddPayload(b.chainID, payload); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[24], 1);
				logger.Warningf("Block [%d] received from ordering service wasn't added to payload buffer: %v", blockNum, err)
			}

			// Gossip messages with other nodes
			_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[13], 1);logger.Debugf("[%s] Gossiping block [%d], peers number [%d]", b.chainID, blockNum, numberOfPeers)
			if !b.isDone() {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[25], 1);
				b.gossip.Gossip(gossipMsg)
			}
		default:_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[14], 1);
			logger.Warningf("[%s] Received unknown: %v", b.chainID, t)
			return
		}
	}
}

// Stop stops blocks delivery provider
func (b *blocksProviderImpl) Stop() {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[26], 1);
	atomic.StoreInt32(&b.done, 1)
	b.client.Close()
}

// UpdateOrderingEndpoints update endpoints of ordering service
func (b *blocksProviderImpl) UpdateOrderingEndpoints(endpoints []string) {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[27], 1);
	if !b.isEndpointsUpdated(endpoints) {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[29], 1);
		// No new endpoints for ordering service were provided
		return
	}
	// We have got new set of endpoints, updating client
	_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[28], 1);logger.Debug("Updating endpoint, to %s", endpoints)
	b.client.UpdateEndpoints(endpoints)
	logger.Debug("Disconnecting so endpoints update will take effect")
	// We need to disconnect the client to make it reconnect back
	// to newly updated endpoints
	b.client.Disconnect(false)
}
func (b *blocksProviderImpl) isEndpointsUpdated(endpoints []string) bool {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[30], 1);
	if len(endpoints) != len(b.client.GetEndpoints()) {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[33], 1);
		return true
	}
	// Check that endpoints was actually updated
	_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[31], 1);for _, endpoint := range endpoints {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[34], 1);
		if !util.Contains(endpoint, b.client.GetEndpoints()) {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[35], 1);
			// Found new endpoint
			return true
		}
	}
	// Nothing has changed
	_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[32], 1);return false
}

// Check whenever provider is stopped
func (b *blocksProviderImpl) isDone() bool {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[36], 1);
	return atomic.LoadInt32(&b.done) == 1
}

func createGossipMsg(chainID string, payload *gossip_proto.Payload) *gossip_proto.GossipMessage {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[37], 1);
	gossipMsg := &gossip_proto.GossipMessage{
		Nonce:   0,
		Tag:     gossip_proto.GossipMessage_CHAN_AND_ORG,
		Channel: []byte(chainID),
		Content: &gossip_proto.GossipMessage_DataMsg{
			DataMsg: &gossip_proto.DataMessage{
				Payload: payload,
			},
		},
	}
	return gossipMsg
}

func createPayload(seqNum uint64, marshaledBlock []byte) *gossip_proto.Payload {_cover_atomic_.AddUint32(&GoCover_0_623461336263663566323432.Count[38], 1);
	return &gossip_proto.Payload{
		Data:   marshaledBlock,
		SeqNum: seqNum,
	}
}

var GoCover_0_623461336263663566323432 = struct {
	Count     [39]uint32
	Pos       [3 * 39]uint32
	NumStmt   [39]uint16
} {
	Pos: [3 * 39]uint32{
		108, 116, 0x20087, // [0]
		120, 124, 0x12002e, // [1]
		124, 126, 0x110012, // [2]
		130, 130, 0x1f0003, // [3]
		126, 129, 0x40011, // [4]
		131, 132, 0x290028, // [5]
		136, 136, 0x540004, // [6]
		147, 150, 0x1c0004, // [7]
		153, 153, 0x2d0004, // [8]
		158, 158, 0xc0004, // [9]
		159, 165, 0x120027, // [10]
		169, 169, 0x670004, // [11]
		174, 182, 0x420004, // [12]
		187, 188, 0x130004, // [13]
		191, 193, 0xa000b, // [14]
		132, 135, 0x50029, // [15]
		136, 139, 0x340054, // [16]
		139, 142, 0x60034, // [17]
		143, 146, 0x5000a, // [18]
		150, 152, 0x5001c, // [19]
		153, 155, 0x5002d, // [20]
		155, 157, 0x5000a, // [21]
		165, 167, 0xd0012, // [22]
		169, 171, 0xd0067, // [23]
		182, 184, 0x50042, // [24]
		188, 190, 0x50013, // [25]
		199, 202, 0x20025, // [26]
		205, 206, 0x26004a, // [27]
		211, 216, 0x1c0002, // [28]
		206, 209, 0x30026, // [29]
		218, 219, 0x34004a, // [30]
		223, 223, 0x250002, // [31]
		230, 230, 0xe0002, // [32]
		219, 221, 0x30034, // [33]
		223, 224, 0x380025, // [34]
		224, 227, 0x40038, // [35]
		234, 236, 0x2002c, // [36]
		238, 250, 0x20061, // [37]
		252, 257, 0x20050, // [38]
	},
	NumStmt: [39]uint16{
		1, // 0
		4, // 1
		2, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		4, // 7
		1, // 8
		1, // 9
		5, // 10
		1, // 11
		5, // 12
		2, // 13
		2, // 14
		2, // 15
		3, // 16
		2, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		2, // 22
		2, // 23
		1, // 24
		1, // 25
		2, // 26
		1, // 27
		4, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		2, // 37
		1, // 38
	},
}
var _ = _cover_atomic_.LoadUint32
