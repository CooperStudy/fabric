//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/clilogging/setlevel.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package clilogging; import _cover_atomic_ "sync/atomic"

import (
	"context"

	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/spf13/cobra"
)

func setLevelCmd(cf *LoggingCmdFactory) *cobra.Command {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[0], 1);
	var loggingSetLevelCmd = &cobra.Command{
		Use:   "setlevel <logger> <log level>",
		Short: "Adds the logger and log level to the current logging spec.",
		Long:  `Adds the logger and log level to the current logging specification.`,
		RunE: func(cmd *cobra.Command, args []string) error {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[2], 1);
			return setLevel(cf, cmd, args)
		},
	}
	_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[1], 1);return loggingSetLevelCmd
}

func setLevel(cf *LoggingCmdFactory, cmd *cobra.Command, args []string) (err error) {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[3], 1);
	err = checkLoggingCmdParams(cmd, args)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[5], 1);
		// Parsing of the command line is done so silence cmd usage
		cmd.SilenceUsage = true

		if cf == nil {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[8], 1);
			cf, err = InitCmdFactory()
			if err != nil {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[9], 1);
				return err
			}
		}
		_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[6], 1);op := &pb.AdminOperation{
			Content: &pb.AdminOperation_LogReq{
				LogReq: &pb.LogLevelRequest{
					LogModule: args[0],
					LogLevel:  args[1],
				},
			},
		}
		env := cf.wrapWithEnvelope(op)
		logResponse, err := cf.AdminClient.SetModuleLogLevel(context.Background(), env)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[10], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[7], 1);logger.Infof("Log level set for logger name/prefix '%s': %s", logResponse.LogModule, logResponse.LogLevel)
	}
	_cover_atomic_.AddUint32(&GoCover_5_303930383430333338303032.Count[4], 1);return err
}

var GoCover_5_303930383430333338303032 = struct {
	Count     [11]uint32
	Pos       [3 * 11]uint32
	NumStmt   [11]uint16
} {
	Pos: [3 * 11]uint32{
		16, 21, 0x370038, // [0]
		25, 25, 0x1b0002, // [1]
		21, 23, 0x40037, // [2]
		28, 30, 0x100055, // [3]
		55, 55, 0xc0002, // [4]
		30, 34, 0x100010, // [5]
		40, 50, 0x110003, // [6]
		53, 53, 0x6d0003, // [7]
		34, 36, 0x120010, // [8]
		36, 38, 0x50012, // [9]
		50, 52, 0x40011, // [10]
	},
	NumStmt: [11]uint16{
		1, // 0
		1, // 1
		1, // 2
		2, // 3
		1, // 4
		2, // 5
		4, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
	},
}
var _ = _cover_atomic_.LoadUint32
