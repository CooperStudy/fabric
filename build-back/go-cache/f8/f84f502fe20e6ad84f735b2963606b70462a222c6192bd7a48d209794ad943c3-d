//line /home/cooper/go/src/github.com/hyperledger/fabric/common/metrics/gendoc/table.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package gendoc; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/metrics/internal/namer"
)

// A Field represents data that is included in the reference table for metrics.
type Field uint8

const (
	Name        Field = iota // Name is the meter name.
	Type                     // Type is the type of meter option.
	Description              // Description is the help text from the meter option.
	Labels                   // Labels is the meter's label information.
	Bucket                   // Bucket is the statsd bucket format
)

// A Column represents a column of data in the reference table.
type Column struct {
	Field Field
	Name  string
	Width int
}

// NewPrometheusTable creates a table that can be used to document Prometheus
// metrics maintained by Fabric.
func NewPrometheusTable(cells Cells) Table {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[0], 1);
	return Table{
		Cells: cells,
		Columns: []Column{
			{Field: Name, Name: "Name", Width: max(cells.MaxLen(Name)+2, 20)},
			{Field: Type, Name: "Type", Width: 11},
			{Field: Description, Name: "Description", Width: 60},
			{Field: Labels, Name: "Labels", Width: 20},
		},
	}
}

// NewStatsdTable creates a table that can be used to document StatsD metrics
// maintained by Fabric.
func NewStatsdTable(cells Cells) Table {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[1], 1);
	return Table{
		Cells: cells,
		Columns: []Column{
			{Field: Bucket, Name: "Bucket", Width: max(cells.MaxLen(Bucket)+2, 20)},
			{Field: Type, Name: "Type", Width: 11},
			{Field: Description, Name: "Description", Width: 60},
		},
	}
}

// A Table maintains the cells and columns used to generate the restructured text
// formatted reference documentation.
type Table struct {
	Columns []Column
	Cells   Cells
}

// Generate generates a restructured text formatted table from the cells and
// columns contained in the table.
func (t Table) Generate(w io.Writer) {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[2], 1);
	fmt.Fprint(w, t.header())
	for _, c := range t.Cells {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[3], 1);
		fmt.Fprint(w, t.formatCell(c))
		fmt.Fprint(w, t.rowSeparator())
	}
}

func (t Table) rowSeparator() string    {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[4], 1); return t.separator("-") }
func (t Table) headerSeparator() string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[5], 1); return t.separator("=") }

func (t Table) separator(delim string) string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[6], 1);
	var s string
	for _, c := range t.Columns {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[8], 1);
		s += "+" + strings.Repeat(delim, c.Width)
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[7], 1);return s + "+\n"
}

func (t Table) header() string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[9], 1);
	var h string
	h += t.rowSeparator()
	for _, c := range t.Columns {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[11], 1);
		h += "| " + printWidth(c.Name, c.Width-2) + " "
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[10], 1);h += "|\n"
	h += t.headerSeparator()
	return h
}

func (t Table) formatCell(cell Cell) string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[12], 1);
	contents := map[Field][]string{}
	lineCount := 0

	// wrap lines
	for _, c := range t.Columns {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[16], 1);
		lines := wrapWidths(cell.Field(c.Field), c.Width-2)
		if l := len(lines); l > lineCount {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[18], 1);
			lineCount = l
		}
		_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[17], 1);contents[c.Field] = lines
	}

	// add extra lines
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[13], 1);for _, col := range t.Columns {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[19], 1);
		lines := contents[col.Field]
		contents[col.Field] = padLines(lines, col.Width-2, lineCount)
	}

	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[14], 1);var c string
	for i := 0; i < lineCount; i++ {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[20], 1);
		for _, col := range t.Columns {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[22], 1);
			c += "| " + contents[col.Field][i] + " "
		}
		_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[21], 1);c += "|\n"
	}

	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[15], 1);return c
}

func wrapWidths(s string, width int) []string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[23], 1);
	var result []string
	for _, s := range strings.Split(s, "\n") {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[25], 1);
		result = append(result, wrapWidth(s, width)...)
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[24], 1);return result
}

func wrapWidth(s string, width int) []string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[26], 1);
	words := strings.Fields(strings.TrimSpace(s))
	if len(words) == 0 {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[29], 1); // only white space
		return []string{s}
	}

	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[27], 1);result := words[0]
	remaining := width - len(words[0])
	for _, w := range words[1:] {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[30], 1);
		if len(w)+1 > remaining {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[31], 1);
			result += "\n" + w
			remaining = width - len(w) - 1
		} else{ _cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[32], 1);{
			result += " " + w
			remaining -= len(w) + 1
		}}
	}

	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[28], 1);return strings.Split(result, "\n")
}

func padLines(lines []string, w, h int) []string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[33], 1);
	for len(lines) < h {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[36], 1);
		lines = append(lines, "")
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[34], 1);for idx, line := range lines {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[37], 1);
		lines[idx] = printWidth(line, w)
	}

	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[35], 1);return lines
}

func printWidth(s string, w int) string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[38], 1);
	s = strings.TrimSpace(s)
	if len(s) < w {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[40], 1);
		return s + strings.Repeat(" ", w-len(s))
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[39], 1);return s
}

func max(x, y int) int {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[41], 1);
	if x > y {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[43], 1);
		return x
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[42], 1);return y
}

type Cell struct {
	meterType   string
	namer       *namer.Namer
	description string
	labels      []string
}

func (c Cell) Field(f Field) string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[44], 1);
	switch f {
	case Name:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[45], 1);
		return c.Name()
	case Type:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[46], 1);
		return c.Type()
	case Description:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[47], 1);
		return c.Description()
	case Labels:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[48], 1);
		return c.Labels()
	case Bucket:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[49], 1);
		return c.BucketFormat()
	default:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[50], 1);
		panic(fmt.Sprintf("unknown field type: %d", f))
	}
}

func (c Cell) Name() string        {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[51], 1); return strings.Replace(c.namer.FullyQualifiedName(), ".", "_", -1) }
func (c Cell) Type() string        {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[52], 1); return c.meterType }
func (c Cell) Description() string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[53], 1); return c.description }
func (c Cell) Labels() string      {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[54], 1); return strings.Join(c.labels, "\n") }

func (c Cell) BucketFormat() string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[55], 1);
	var lvs []string
	for _, label := range c.labels {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[57], 1);
		lvs = append(lvs, label, asBucketVar(label))
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[56], 1);return c.namer.Format(lvs...)
}

func asBucketVar(s string) string {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[58], 1); return "%{" + s + "}" }

type Cells []Cell

func (c Cells) Len() int           {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[59], 1); return len(c) }
func (c Cells) Less(i, j int) bool {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[60], 1); return c[i].Name() < c[j].Name() }
func (c Cells) Swap(i, j int)      {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[61], 1); c[i], c[j] = c[j], c[i] }

func (c Cells) MaxLen(f Field) int {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[62], 1);
	var maxlen int
	for _, c := range c {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[64], 1);
		if l := len(c.Field(f)); l > maxlen {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[65], 1);
			maxlen = l
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[63], 1);return maxlen
}

// NewCells transforms metrics options to cells that can be used for doc
// generation.
func NewCells(options []interface{}) (Cells, error) {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[66], 1);
	var cells Cells
	for _, o := range options {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[68], 1);
		switch m := o.(type) {
		case metrics.CounterOpts:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[69], 1);
			cells = append(cells, counterCell(m))
		case metrics.GaugeOpts:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[70], 1);
			cells = append(cells, gaugeCell(m))
		case metrics.HistogramOpts:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[71], 1);
			cells = append(cells, histogramCell(m))
		default:_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[72], 1);
			return nil, fmt.Errorf("unknown option type: %t", o)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[67], 1);sort.Sort(cells)
	return cells, nil
}

func counterCell(c metrics.CounterOpts) Cell {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[73], 1);
	if c.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[75], 1);
		c.StatsdFormat = "%{#fqname}"
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[74], 1);return Cell{
		namer:       namer.NewCounterNamer(c),
		meterType:   "counter",
		description: c.Help,
		labels:      c.LabelNames,
	}
}

func gaugeCell(g metrics.GaugeOpts) Cell {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[76], 1);
	if g.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[78], 1);
		g.StatsdFormat = "%{#fqname}"
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[77], 1);return Cell{
		namer:       namer.NewGaugeNamer(g),
		meterType:   "gauge",
		description: g.Help,
		labels:      g.LabelNames,
	}
}

func histogramCell(h metrics.HistogramOpts) Cell {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[79], 1);
	if h.StatsdFormat == "" {_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[81], 1);
		h.StatsdFormat = "%{#fqname}"
	}
	_cover_atomic_.AddUint32(&GoCover_1_613837646237656166666432.Count[80], 1);return Cell{
		namer:       namer.NewHistogramNamer(h),
		meterType:   "histogram",
		description: h.Help,
		labels:      h.LabelNames,
	}
}

var GoCover_1_613837646237656166666432 = struct {
	Count     [82]uint32
	Pos       [3 * 82]uint32
	NumStmt   [82]uint16
} {
	Pos: [3 * 82]uint32{
		39, 49, 0x2002c, // [0]
		53, 62, 0x20028, // [1]
		73, 75, 0x1c0026, // [2]
		75, 78, 0x3001c, // [3]
		81, 81, 0x440029, // [4]
		82, 82, 0x440029, // [5]
		84, 86, 0x1e002f, // [6]
		89, 89, 0x120002, // [7]
		86, 88, 0x3001e, // [8]
		92, 95, 0x1e0020, // [9]
		98, 100, 0xa0002, // [10]
		95, 97, 0x3001e, // [11]
		103, 108, 0x1e002d, // [12]
		117, 117, 0x200002, // [13]
		122, 123, 0x210002, // [14]
		130, 130, 0xa0002, // [15]
		108, 110, 0x25001e, // [16]
		113, 113, 0x1c0003, // [17]
		110, 112, 0x40025, // [18]
		117, 120, 0x30020, // [19]
		123, 124, 0x210021, // [20]
		127, 127, 0xd0003, // [21]
		124, 126, 0x40021, // [22]
		133, 135, 0x2b002f, // [23]
		138, 138, 0xf0002, // [24]
		135, 137, 0x3002b, // [25]
		141, 143, 0x15002e, // [26]
		147, 149, 0x1e0002, // [27]
		159, 159, 0x240002, // [28]
		143, 145, 0x30015, // [29]
		149, 150, 0x1b001e, // [30]
		150, 153, 0x4001b, // [31]
		153, 156, 0x40009, // [32]
		162, 163, 0x150032, // [33]
		166, 166, 0x1f0002, // [34]
		170, 170, 0xe0002, // [35]
		163, 165, 0x30015, // [36]
		166, 168, 0x3001f, // [37]
		173, 175, 0x100029, // [38]
		178, 178, 0xa0002, // [39]
		175, 177, 0x30010, // [40]
		181, 182, 0xb0018, // [41]
		185, 185, 0xa0002, // [42]
		182, 184, 0x3000b, // [43]
		195, 196, 0xb0025, // [44]
		197, 198, 0x12000c, // [45]
		199, 200, 0x12000c, // [46]
		201, 202, 0x190013, // [47]
		203, 204, 0x14000e, // [48]
		205, 206, 0x1a000e, // [49]
		207, 208, 0x32000a, // [50]
		212, 212, 0x6a0024, // [51]
		213, 213, 0x3a0024, // [52]
		214, 214, 0x3c0024, // [53]
		215, 215, 0x4b0024, // [54]
		217, 219, 0x210025, // [55]
		222, 222, 0x1f0002, // [56]
		219, 221, 0x30021, // [57]
		225, 225, 0x3c0023, // [58]
		229, 229, 0x350024, // [59]
		230, 230, 0x480024, // [60]
		231, 231, 0x3f0024, // [61]
		233, 235, 0x160024, // [62]
		240, 240, 0xf0002, // [63]
		235, 236, 0x270016, // [64]
		236, 238, 0x40027, // [65]
		245, 247, 0x1c0035, // [66]
		259, 260, 0x130002, // [67]
		247, 248, 0x18001c, // [68]
		249, 250, 0x29001c, // [69]
		251, 252, 0x27001a, // [70]
		253, 254, 0x2b001e, // [71]
		255, 256, 0x38000b, // [72]
		263, 264, 0x1a002e, // [73]
		267, 272, 0x30002, // [74]
		264, 266, 0x3001a, // [75]
		275, 276, 0x1a002a, // [76]
		279, 284, 0x30002, // [77]
		276, 278, 0x3001a, // [78]
		287, 288, 0x1a0032, // [79]
		291, 296, 0x30002, // [80]
		288, 290, 0x3001a, // [81]
	},
	NumStmt: [82]uint16{
		1, // 0
		1, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		3, // 9
		3, // 10
		1, // 11
		3, // 12
		1, // 13
		2, // 14
		1, // 15
		2, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		1, // 25
		2, // 26
		3, // 27
		1, // 28
		1, // 29
		1, // 30
		2, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		2, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		2, // 62
		1, // 63
		1, // 64
		1, // 65
		2, // 66
		2, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
	},
}
var _ = _cover_atomic_.LoadUint32
