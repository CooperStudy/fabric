//line /home/cooper/go/src/github.com/hyperledger/fabric/core/scc/cscc/configure.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

// Package cscc chaincode configer provides functions to manage
// configuration transactions as the network is being reconfigured. The
// configuration transactions arrive from the ordering service to the committer
// who calls this chaincode. The chaincode also provides peer configuration
// services such as joining a chain or getting configuration data.
package cscc; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/config"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/aclmgmt"
	"github.com/hyperledger/fabric/core/aclmgmt/resources"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/core/peer"
	"github.com/hyperledger/fabric/core/policy"
	"github.com/hyperledger/fabric/msp/mgmt"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

// New creates a new instance of the CSCC.
// Typically, only one will be created per peer instance.
func New(ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider, aclProvider aclmgmt.ACLProvider) *PeerConfiger {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[0], 1);
	return &PeerConfiger{
		policyChecker: policy.NewPolicyChecker(
			peer.NewChannelPolicyManagerGetter(),
			mgmt.GetLocalMSP(),
			mgmt.NewLocalMSPPrincipalGetter(),
		),
		configMgr:   peer.NewConfigSupport(),
		ccp:         ccp,
		sccp:        sccp,
		aclProvider: aclProvider,
	}
}

func (e *PeerConfiger) Name() string              {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[1], 1); return "cscc" }
func (e *PeerConfiger) Path() string              {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[2], 1); return "github.com/hyperledger/fabric/core/scc/cscc" }
func (e *PeerConfiger) InitArgs() [][]byte        {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[3], 1); return nil }
func (e *PeerConfiger) Chaincode() shim.Chaincode {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[4], 1); return e }
func (e *PeerConfiger) InvokableExternal() bool   {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[5], 1); return true }
func (e *PeerConfiger) InvokableCC2CC() bool      {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[6], 1); return false }
func (e *PeerConfiger) Enabled() bool             {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[7], 1); return true }

// PeerConfiger implements the configuration handler for the peer. For every
// configuration transaction coming in from the ordering service, the
// committer calls this system chaincode to process the transaction.
type PeerConfiger struct {
	policyChecker policy.PolicyChecker
	configMgr     config.Manager
	ccp           ccprovider.ChaincodeProvider
	sccp          sysccprovider.SystemChaincodeProvider
	aclProvider   aclmgmt.ACLProvider
}

var cnflogger = flogging.MustGetLogger("cscc")

// These are function names from Invoke first parameter
const (
	JoinChain                string = "JoinChain"
	GetConfigBlock           string = "GetConfigBlock"
	GetChannels              string = "GetChannels"
	GetConfigTree            string = "GetConfigTree"
	SimulateConfigTreeUpdate string = "SimulateConfigTreeUpdate"
)

// Init is mostly useless from an SCC perspective
func (e *PeerConfiger) Init(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[8], 1);
	cnflogger.Info("Init CSCC")
	return shim.Success(nil)
}

// Invoke is called for the following:
// # to process joining a chain (called by app as a transaction proposal)
// # to get the current configuration block (called by app)
// # to update the configuration block (called by committer)
// Peer calls this function with 2 arguments:
// # args[0] is the function name, which must be JoinChain, GetConfigBlock or
// UpdateConfigBlock
// # args[1] is a configuration Block if args[0] is JoinChain or
// UpdateConfigBlock; otherwise it is the chain id
// TODO: Improve the scc interface to avoid marshal/unmarshal args
func (e *PeerConfiger) Invoke(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[9], 1);
	args := stub.GetArgs()

	if len(args) < 1 {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[13], 1);
		return shim.Error(fmt.Sprintf("Incorrect number of arguments, %d", len(args)))
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[10], 1);fname := string(args[0])

	if fname != GetChannels && len(args) < 2 {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[14], 1);
		return shim.Error(fmt.Sprintf("Incorrect number of arguments, %d", len(args)))
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[11], 1);cnflogger.Debugf("Invoke function: %s", fname)

	// Handle ACL:
	// 1. get the signed proposal
	sp, err := stub.GetSignedProposal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[15], 1);
		return shim.Error(fmt.Sprintf("Failed getting signed proposal from stub: [%s]", err))
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[12], 1);return e.InvokeNoShim(args, sp)
}

func (e *PeerConfiger) InvokeNoShim(args [][]byte, sp *pb.SignedProposal) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[16], 1);
	var err error
	fname := string(args[0])

	switch fname {
	case JoinChain:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[18], 1);
		if args[1] == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[33], 1);
			return shim.Error("Cannot join the channel <nil> configuration block provided")
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[19], 1);block, err := utils.GetBlockFromBlockBytes(args[1])
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[34], 1);
			return shim.Error(fmt.Sprintf("Failed to reconstruct the genesis block, %s", err))
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[20], 1);cid, err := utils.GetChainIDFromBlock(block)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[35], 1);
			return shim.Error(fmt.Sprintf("\"JoinChain\" request failed to extract "+
				"channel id from the block due to [%s]", err))
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[21], 1);if err := validateConfigBlock(block); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[36], 1);
			return shim.Error(fmt.Sprintf("\"JoinChain\" for chainID = %s failed because of validation "+
				"of configuration block, because of %s", cid, err))
		}

		// 2. check local MSP Admins policy
		// TODO: move to ACLProvider once it will support chainless ACLs
		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[22], 1);if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Admins, sp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[37], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: [%s]", fname, cid, err))
		}

		// Initialize txsFilter if it does not yet exist. We can do this safely since
		// it's the genesis block anyway
		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[23], 1);txsFilter := util.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
		if len(txsFilter) == 0 {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[38], 1);
			// add array of validation code hardcoded to valid
			txsFilter = util.NewTxValidationFlagsSetValue(len(block.Data.Data), pb.TxValidationCode_VALID)
			block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = txsFilter
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[24], 1);return joinChain(cid, block, e.ccp, e.sccp)
	case GetConfigBlock:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[25], 1);
		// 2. check policy
		if err = e.aclProvider.CheckACL(resources.Cscc_GetConfigBlock, string(args[1]), sp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[39], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: %s", fname, args[1], err))
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[26], 1);return getConfigBlock(args[1])
	case GetConfigTree:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[27], 1);
		// 2. check policy
		if err = e.aclProvider.CheckACL(resources.Cscc_GetConfigTree, string(args[1]), sp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[40], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: %s", fname, args[1], err))
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[28], 1);return e.getConfigTree(args[1])
	case SimulateConfigTreeUpdate:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[29], 1);
		// Check policy
		if err = e.aclProvider.CheckACL(resources.Cscc_SimulateConfigTreeUpdate, string(args[1]), sp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[41], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: %s", fname, args[1], err))
		}
		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[30], 1);return e.simulateConfigTreeUpdate(args[1], args[2])
	case GetChannels:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[31], 1);
		// 2. check local MSP Members policy
		// TODO: move to ACLProvider once it will support chainless ACLs
		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Members, sp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[42], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s]: %s", fname, err))
		}

		_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[32], 1);return getChannels()

	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[17], 1);return shim.Error(fmt.Sprintf("Requested function %s not found.", fname))
}

// validateConfigBlock validate configuration block to see whenever it's contains valid config transaction
func validateConfigBlock(block *common.Block) error {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[43], 1);
	envelopeConfig, err := utils.ExtractEnvelope(block, 0)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[50], 1);
		return errors.Errorf("Failed to %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[44], 1);configEnv := &common.ConfigEnvelope{}
	_, err = utils.UnmarshalEnvelopeOfType(envelopeConfig, common.HeaderType_CONFIG, configEnv)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[51], 1);
		return errors.Errorf("Bad configuration envelope: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[45], 1);if configEnv.Config == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[52], 1);
		return errors.New("Nil config envelope Config")
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[46], 1);if configEnv.Config.ChannelGroup == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[53], 1);
		return errors.New("Nil channel group")
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[47], 1);if configEnv.Config.ChannelGroup.Groups == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[54], 1);
		return errors.New("No channel configuration groups are available")
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[48], 1);_, exists := configEnv.Config.ChannelGroup.Groups[channelconfig.ApplicationGroupKey]
	if !exists {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[55], 1);
		return errors.Errorf("Invalid configuration block, missing %s "+
			"configuration group", channelconfig.ApplicationGroupKey)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[49], 1);return nil
}

// joinChain will join the specified chain in the configuration block.
// Since it is the first block, it is the genesis block containing configuration
// for this chain, so we want to update the Chain object with this info
func joinChain(chainID string, block *common.Block, ccp ccprovider.ChaincodeProvider, sccp sysccprovider.SystemChaincodeProvider) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[56], 1);
	if err := peer.CreateChainFromBlock(block, ccp, sccp); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[58], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[57], 1);peer.InitChain(chainID)

	return shim.Success(nil)
}

// Return the current configuration block for the specified chainID. If the
// peer doesn't belong to the chain, return error
func getConfigBlock(chainID []byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[59], 1);
	if chainID == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[63], 1);
		return shim.Error("ChainID must not be nil.")
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[60], 1);block := peer.GetCurrConfigBlock(string(chainID))
	if block == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[64], 1);
		return shim.Error(fmt.Sprintf("Unknown chain ID, %s", string(chainID)))
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[61], 1);blockBytes, err := utils.Marshal(block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[65], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[62], 1);return shim.Success(blockBytes)
}

// getConfigTree returns the current channel configuration for the specified chainID.
// If the peer doesn't belong to the chain, returns error
func (e *PeerConfiger) getConfigTree(chainID []byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[66], 1);
	if chainID == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[70], 1);
		return shim.Error("Chain ID must not be nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[67], 1);channelCfg := e.configMgr.GetChannelConfig(string(chainID)).ConfigProto()
	if channelCfg == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[71], 1);
		return shim.Error(fmt.Sprintf("Unknown chain ID, %s", string(chainID)))
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[68], 1);agCfg := &pb.ConfigTree{ChannelConfig: channelCfg}
	configBytes, err := utils.Marshal(agCfg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[72], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[69], 1);return shim.Success(configBytes)
}

func (e *PeerConfiger) simulateConfigTreeUpdate(chainID []byte, envb []byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[73], 1);
	if chainID == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[79], 1);
		return shim.Error("Chain ID must not be nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[74], 1);if envb == nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[80], 1);
		return shim.Error("Config delta bytes must not be nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[75], 1);env := &common.Envelope{}
	err := proto.Unmarshal(envb, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[81], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[76], 1);cfg, err := supportByType(e, chainID, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[82], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[77], 1);_, err = cfg.ProposeConfigUpdate(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[83], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[78], 1);return shim.Success([]byte("Simulation is successful"))
}

func supportByType(pc *PeerConfiger, chainID []byte, env *common.Envelope) (config.Config, error) {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[84], 1);
	payload := &common.Payload{}

	if err := proto.Unmarshal(env.Payload, payload); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[88], 1);
		return nil, errors.Errorf("failed unmarshaling payload: %v", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[85], 1);channelHdr := &common.ChannelHeader{}
	if err := proto.Unmarshal(payload.Header.ChannelHeader, channelHdr); err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[89], 1);
		return nil, errors.Errorf("failed unmarshaling payload header: %v", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[86], 1);switch common.HeaderType(channelHdr.Type) {
	case common.HeaderType_CONFIG_UPDATE:_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[90], 1);
		return pc.configMgr.GetChannelConfig(string(chainID)), nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[87], 1);return nil, errors.Errorf("invalid payload header type: %d", channelHdr.Type)
}

// getChannels returns information about all channels for this peer
func getChannels() pb.Response {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[91], 1);
	channelInfoArray := peer.GetChannelsInfo()

	// add array with info about all channels for this peer
	cqr := &pb.ChannelQueryResponse{Channels: channelInfoArray}

	cqrbytes, err := proto.Marshal(cqr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[93], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_343564656332336431343031.Count[92], 1);return shim.Success(cqrbytes)
}

var GoCover_0_343564656332336431343031 = struct {
	Count     [94]uint32
	Pos       [3 * 94]uint32
	NumStmt   [94]uint16
} {
	Pos: [3 * 94]uint32{
		38, 50, 0x20087, // [0]
		52, 52, 0x440033, // [1]
		53, 53, 0x6b0033, // [2]
		54, 54, 0x410033, // [3]
		55, 55, 0x3f0033, // [4]
		56, 56, 0x420033, // [5]
		57, 57, 0x430033, // [6]
		58, 58, 0x420033, // [7]
		83, 86, 0x2004b, // [8]
		98, 101, 0x13004d, // [9]
		105, 107, 0x2b0002, // [10]
		111, 116, 0x100002, // [11]
		120, 120, 0x210002, // [12]
		101, 103, 0x30013, // [13]
		107, 109, 0x3002b, // [14]
		116, 118, 0x30010, // [15]
		123, 127, 0xf0057, // [16]
		195, 195, 0x4b0002, // [17]
		128, 129, 0x150011, // [18]
		133, 134, 0x110003, // [19]
		138, 139, 0x110003, // [20]
		144, 144, 0x340003, // [21]
		151, 151, 0x4e0003, // [22]
		157, 158, 0x1a0003, // [23]
		164, 164, 0x2e0003, // [24]
		165, 167, 0x630016, // [25]
		171, 171, 0x210003, // [26]
		172, 174, 0x620015, // [27]
		178, 178, 0x220003, // [28]
		179, 181, 0x6d0020, // [29]
		184, 184, 0x360003, // [30]
		185, 188, 0x4f0013, // [31]
		192, 192, 0x170003, // [32]
		129, 131, 0x40015, // [33]
		134, 136, 0x40011, // [34]
		139, 142, 0x40011, // [35]
		144, 147, 0x40034, // [36]
		151, 153, 0x4004e, // [37]
		158, 162, 0x4001a, // [38]
		167, 169, 0x40063, // [39]
		174, 176, 0x40062, // [40]
		181, 183, 0x4006d, // [41]
		188, 190, 0x4004f, // [42]
		199, 201, 0x100035, // [43]
		205, 207, 0x100002, // [44]
		211, 211, 0x1d0002, // [45]
		215, 215, 0x2a0002, // [46]
		219, 219, 0x310002, // [47]
		223, 224, 0xd0002, // [48]
		229, 229, 0xc0002, // [49]
		201, 203, 0x30010, // [50]
		207, 209, 0x30010, // [51]
		211, 213, 0x3001d, // [52]
		215, 217, 0x3002a, // [53]
		219, 221, 0x30031, // [54]
		224, 227, 0x3000d, // [55]
		235, 236, 0x44008f, // [56]
		240, 242, 0x1a0002, // [57]
		236, 238, 0x30044, // [58]
		247, 248, 0x140031, // [59]
		251, 252, 0x120002, // [60]
		255, 256, 0x100002, // [61]
		260, 260, 0x210002, // [62]
		248, 250, 0x30014, // [63]
		252, 254, 0x30012, // [64]
		256, 258, 0x30010, // [65]
		265, 266, 0x140042, // [66]
		269, 270, 0x170002, // [67]
		273, 275, 0x100002, // [68]
		278, 278, 0x220002, // [69]
		266, 268, 0x30014, // [70]
		270, 272, 0x30017, // [71]
		275, 277, 0x30010, // [72]
		281, 282, 0x14005a, // [73]
		285, 285, 0x110002, // [74]
		288, 290, 0x100002, // [75]
		293, 294, 0x100002, // [76]
		297, 298, 0x100002, // [77]
		301, 301, 0x390002, // [78]
		282, 284, 0x30014, // [79]
		285, 287, 0x30011, // [80]
		290, 292, 0x30010, // [81]
		294, 296, 0x30010, // [82]
		298, 300, 0x30010, // [83]
		304, 307, 0x3e0063, // [84]
		311, 312, 0x520002, // [85]
		316, 316, 0x2c0002, // [86]
		320, 320, 0x4f0002, // [87]
		307, 309, 0x3003e, // [88]
		312, 314, 0x30052, // [89]
		317, 318, 0x3d0027, // [90]
		324, 331, 0x100020, // [91]
		335, 335, 0x1f0002, // [92]
		331, 333, 0x30010, // [93]
	},
	NumStmt: [94]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		2, // 9
		2, // 10
		3, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		2, // 43
		3, // 44
		1, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		2, // 57
		1, // 58
		1, // 59
		2, // 60
		2, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		2, // 67
		3, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		3, // 75
		2, // 76
		2, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		2, // 84
		2, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		1, // 90
		4, // 91
		1, // 92
		1, // 93
	},
}
var _ = _cover_atomic_.LoadUint32
