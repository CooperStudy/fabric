//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/shim/mockstub.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

// Package shim provides APIs for the chaincode to access its state
// variables, transaction context and call other chaincodes.
package shim; import _cover_atomic_ "sync/atomic"

import (
	"container/list"
	"fmt"
	"strings"

	"github.com/golang/protobuf/ptypes/timestamp"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/protos/ledger/queryresult"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/op/go-logging"
	"github.com/pkg/errors"
)

// Logger for the shim package.
var mockLogger = logging.MustGetLogger("mock")

// MockStub is an implementation of ChaincodeStubInterface for unit testing chaincode.
// Use this instead of ChaincodeStub in your chaincode's unit test calls to Init or Invoke.
type MockStub struct {
	// arguments the stub was called with
	args [][]byte

	// A pointer back to the chaincode that will invoke this, set by constructor.
	// If a peer calls this stub, the chaincode will be invoked from here.
	cc Chaincode

	// A nice name that can be used for logging
	Name string

	// State keeps name value pairs
	State map[string][]byte

	// Keys stores the list of mapped values in lexical order
	Keys *list.List

	// registered list of other MockStub chaincodes that can be called from this MockStub
	Invokables map[string]*MockStub

	// stores a transaction uuid while being Invoked / Deployed
	// TODO if a chaincode uses recursion this may need to be a stack of TxIDs or possibly a reference counting map
	TxID string

	TxTimestamp *timestamp.Timestamp

	// mocked signedProposal
	signedProposal *pb.SignedProposal

	// stores a channel ID of the proposal
	ChannelID string

	PvtState map[string]map[string][]byte

	// stores per-key endorsement policy, first map index is the collection, second map index is the key
	EndorsementPolicies map[string]map[string][]byte

	// channel to store ChaincodeEvents
	ChaincodeEventsChannel chan *pb.ChaincodeEvent

	Decorations map[string][]byte
}

func (stub *MockStub) GetTxID() string {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[0], 1);
	return stub.TxID
}

func (stub *MockStub) GetChannelID() string {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[1], 1);
	return stub.ChannelID
}

func (stub *MockStub) GetArgs() [][]byte {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[2], 1);
	return stub.args
}

func (stub *MockStub) GetStringArgs() []string {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[3], 1);
	args := stub.GetArgs()
	strargs := make([]string, 0, len(args))
	for _, barg := range args {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[5], 1);
		strargs = append(strargs, string(barg))
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[4], 1);return strargs
}

func (stub *MockStub) GetFunctionAndParameters() (function string, params []string) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[6], 1);
	allargs := stub.GetStringArgs()
	function = ""
	params = []string{}
	if len(allargs) >= 1 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[8], 1);
		function = allargs[0]
		params = allargs[1:]
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[7], 1);return
}

// Used to indicate to a chaincode that it is part of a transaction.
// This is important when chaincodes invoke each other.
// MockStub doesn't support concurrent transactions at present.
func (stub *MockStub) MockTransactionStart(txid string) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[9], 1);
	stub.TxID = txid
	stub.setSignedProposal(&pb.SignedProposal{})
	stub.setTxTimestamp(util.CreateUtcTimestamp())
}

// End a mocked transaction, clearing the UUID.
func (stub *MockStub) MockTransactionEnd(uuid string) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[10], 1);
	stub.signedProposal = nil
	stub.TxID = ""
}

// Register a peer chaincode with this MockStub
// invokableChaincodeName is the name or hash of the peer
// otherStub is a MockStub of the peer, already intialised
func (stub *MockStub) MockPeerChaincode(invokableChaincodeName string, otherStub *MockStub) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[11], 1);
	stub.Invokables[invokableChaincodeName] = otherStub
}

// Initialise this chaincode,  also starts and ends a transaction.
func (stub *MockStub) MockInit(uuid string, args [][]byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[12], 1);
	stub.args = args
	stub.MockTransactionStart(uuid)
	res := stub.cc.Init(stub)
	stub.MockTransactionEnd(uuid)
	return res
}

// Invoke this chaincode, also starts and ends a transaction.
func (stub *MockStub) MockInvoke(uuid string, args [][]byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[13], 1);
	stub.args = args
	stub.MockTransactionStart(uuid)
	res := stub.cc.Invoke(stub)
	stub.MockTransactionEnd(uuid)
	return res
}

func (stub *MockStub) GetDecorations() map[string][]byte {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[14], 1);
	return stub.Decorations
}

// Invoke this chaincode, also starts and ends a transaction.
func (stub *MockStub) MockInvokeWithSignedProposal(uuid string, args [][]byte, sp *pb.SignedProposal) pb.Response {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[15], 1);
	stub.args = args
	stub.MockTransactionStart(uuid)
	stub.signedProposal = sp
	res := stub.cc.Invoke(stub)
	stub.MockTransactionEnd(uuid)
	return res
}

func (stub *MockStub) GetPrivateData(collection string, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[16], 1);
	m, in := stub.PvtState[collection]

	if !in {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[18], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[17], 1);return m[key], nil
}

func (stub *MockStub) PutPrivateData(collection string, key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[19], 1);
	m, in := stub.PvtState[collection]
	if !in {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[21], 1);
		stub.PvtState[collection] = make(map[string][]byte)
		m, in = stub.PvtState[collection]
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[20], 1);m[key] = value

	return nil
}

func (stub *MockStub) DelPrivateData(collection string, key string) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[22], 1);
	return errors.New("Not Implemented")
}

func (stub *MockStub) GetPrivateDataByRange(collection, startKey, endKey string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[23], 1);
	return nil, errors.New("Not Implemented")
}

func (stub *MockStub) GetPrivateDataByPartialCompositeKey(collection, objectType string, attributes []string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[24], 1);
	return nil, errors.New("Not Implemented")
}

func (stub *MockStub) GetPrivateDataQueryResult(collection, query string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[25], 1);
	// Not implemented since the mock engine does not have a query engine.
	// However, a very simple query engine that supports string matching
	// could be implemented to test that the framework supports queries
	return nil, errors.New("Not Implemented")
}

// GetState retrieves the value for a given key from the ledger
func (stub *MockStub) GetState(key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[26], 1);
	value := stub.State[key]
	mockLogger.Debug("MockStub", stub.Name, "Getting", key, value)
	return value, nil
}

// PutState writes the specified `value` and `key` into the ledger.
func (stub *MockStub) PutState(key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[27], 1);
	if stub.TxID == "" {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[32], 1);
		err := errors.New("cannot PutState without a transactions - call stub.MockTransactionStart()?")
		mockLogger.Errorf("%+v", err)
		return err
	}

	// If the value is nil or empty, delete the key
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[28], 1);if len(value) == 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[33], 1);
		mockLogger.Debug("MockStub", stub.Name, "PutState called, but value is nil or empty. Delete ", key)
		return stub.DelState(key)
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[29], 1);mockLogger.Debug("MockStub", stub.Name, "Putting", key, value)
	stub.State[key] = value

	// insert key into ordered list of keys
	for elem := stub.Keys.Front(); elem != nil; elem = elem.Next() {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[34], 1);
		elemValue := elem.Value.(string)
		comp := strings.Compare(key, elemValue)
		mockLogger.Debug("MockStub", stub.Name, "Compared", key, elemValue, " and got ", comp)
		if comp < 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[35], 1);
			// key < elem, insert it before elem
			stub.Keys.InsertBefore(key, elem)
			mockLogger.Debug("MockStub", stub.Name, "Key", key, " inserted before", elem.Value)
			break
		} else{ _cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[36], 1);if comp == 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[37], 1);
			// keys exists, no need to change
			mockLogger.Debug("MockStub", stub.Name, "Key", key, "already in State")
			break
		} else{ _cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[38], 1);{ // comp > 0
			// key > elem, keep looking unless this is the end of the list
			if elem.Next() == nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[39], 1);
				stub.Keys.PushBack(key)
				mockLogger.Debug("MockStub", stub.Name, "Key", key, "appended")
				break
			}
		}}}
	}

	// special case for empty Keys list
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[30], 1);if stub.Keys.Len() == 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[40], 1);
		stub.Keys.PushFront(key)
		mockLogger.Debug("MockStub", stub.Name, "Key", key, "is first element in list")
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[31], 1);return nil
}

// DelState removes the specified `key` and its value from the ledger.
func (stub *MockStub) DelState(key string) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[41], 1);
	mockLogger.Debug("MockStub", stub.Name, "Deleting", key, stub.State[key])
	delete(stub.State, key)

	for elem := stub.Keys.Front(); elem != nil; elem = elem.Next() {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[43], 1);
		if strings.Compare(key, elem.Value.(string)) == 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[44], 1);
			stub.Keys.Remove(elem)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[42], 1);return nil
}

func (stub *MockStub) GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[45], 1);
	if err := validateSimpleKeys(startKey, endKey); err != nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[47], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[46], 1);return NewMockStateRangeQueryIterator(stub, startKey, endKey), nil
}

// GetQueryResult function can be invoked by a chaincode to perform a
// rich query against state database.  Only supported by state database implementations
// that support rich query.  The query string is in the syntax of the underlying
// state database. An iterator is returned which can be used to iterate (next) over
// the query result set
func (stub *MockStub) GetQueryResult(query string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[48], 1);
	// Not implemented since the mock engine does not have a query engine.
	// However, a very simple query engine that supports string matching
	// could be implemented to test that the framework supports queries
	return nil, errors.New("not implemented")
}

// GetHistoryForKey function can be invoked by a chaincode to return a history of
// key values across time. GetHistoryForKey is intended to be used for read-only queries.
func (stub *MockStub) GetHistoryForKey(key string) (HistoryQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[49], 1);
	return nil, errors.New("not implemented")
}

//GetStateByPartialCompositeKey function can be invoked by a chaincode to query the
//state based on a given partial composite key. This function returns an
//iterator which can be used to iterate over all composite keys whose prefix
//matches the given partial composite key. This function should be used only for
//a partial composite key. For a full composite key, an iter with empty response
//would be returned.
func (stub *MockStub) GetStateByPartialCompositeKey(objectType string, attributes []string) (StateQueryIteratorInterface, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[50], 1);
	partialCompositeKey, err := stub.CreateCompositeKey(objectType, attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[52], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[51], 1);return NewMockStateRangeQueryIterator(stub, partialCompositeKey, partialCompositeKey+string(maxUnicodeRuneValue)), nil
}

// CreateCompositeKey combines the list of attributes
//to form a composite key.
func (stub *MockStub) CreateCompositeKey(objectType string, attributes []string) (string, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[53], 1);
	return createCompositeKey(objectType, attributes)
}

// SplitCompositeKey splits the composite key into attributes
// on which the composite key was formed.
func (stub *MockStub) SplitCompositeKey(compositeKey string) (string, []string, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[54], 1);
	return splitCompositeKey(compositeKey)
}

func (stub *MockStub) GetStateByRangeWithPagination(startKey, endKey string, pageSize int32,
	bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[55], 1);
	return nil, nil, nil
}

func (stub *MockStub) GetStateByPartialCompositeKeyWithPagination(objectType string, keys []string,
	pageSize int32, bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[56], 1);
	return nil, nil, nil
}

func (stub *MockStub) GetQueryResultWithPagination(query string, pageSize int32,
	bookmark string) (StateQueryIteratorInterface, *pb.QueryResponseMetadata, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[57], 1);
	return nil, nil, nil
}

// InvokeChaincode calls a peered chaincode.
// E.g. stub1.InvokeChaincode("stub2Hash", funcArgs, channel)
// Before calling this make sure to create another MockStub stub2, call stub2.MockInit(uuid, func, args)
// and register it with stub1 by calling stub1.MockPeerChaincode("stub2Hash", stub2)
func (stub *MockStub) InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[58], 1);
	// Internally we use chaincode name as a composite name
	if channel != "" {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[60], 1);
		chaincodeName = chaincodeName + "/" + channel
	}
	// TODO "args" here should possibly be a serialized pb.ChaincodeInput
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[59], 1);otherStub := stub.Invokables[chaincodeName]
	mockLogger.Debug("MockStub", stub.Name, "Invoking peer chaincode", otherStub.Name, args)
	//	function, strings := getFuncArgs(args)
	res := otherStub.MockInvoke(stub.TxID, args)
	mockLogger.Debug("MockStub", stub.Name, "Invoked peer chaincode", otherStub.Name, "got", fmt.Sprintf("%+v", res))
	return res
}

// Not implemented
func (stub *MockStub) GetCreator() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[61], 1);
	return nil, nil
}

// Not implemented
func (stub *MockStub) GetTransient() (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[62], 1);
	return nil, nil
}

// Not implemented
func (stub *MockStub) GetBinding() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[63], 1);
	return nil, nil
}

// Not implemented
func (stub *MockStub) GetSignedProposal() (*pb.SignedProposal, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[64], 1);
	return stub.signedProposal, nil
}

func (stub *MockStub) setSignedProposal(sp *pb.SignedProposal) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[65], 1);
	stub.signedProposal = sp
}

// Not implemented
func (stub *MockStub) GetArgsSlice() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[66], 1);
	return nil, nil
}

func (stub *MockStub) setTxTimestamp(time *timestamp.Timestamp) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[67], 1);
	stub.TxTimestamp = time
}

func (stub *MockStub) GetTxTimestamp() (*timestamp.Timestamp, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[68], 1);
	if stub.TxTimestamp == nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[70], 1);
		return nil, errors.New("TxTimestamp not set.")
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[69], 1);return stub.TxTimestamp, nil
}

func (stub *MockStub) SetEvent(name string, payload []byte) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[71], 1);
	stub.ChaincodeEventsChannel <- &pb.ChaincodeEvent{EventName: name, Payload: payload}
	return nil
}

func (stub *MockStub) SetStateValidationParameter(key string, ep []byte) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[72], 1);
	return stub.SetPrivateDataValidationParameter("", key, ep)
}

func (stub *MockStub) GetStateValidationParameter(key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[73], 1);
	return stub.GetPrivateDataValidationParameter("", key)
}

func (stub *MockStub) SetPrivateDataValidationParameter(collection, key string, ep []byte) error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[74], 1);
	m, in := stub.EndorsementPolicies[collection]
	if !in {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[76], 1);
		stub.EndorsementPolicies[collection] = make(map[string][]byte)
		m, in = stub.EndorsementPolicies[collection]
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[75], 1);m[key] = ep
	return nil
}

func (stub *MockStub) GetPrivateDataValidationParameter(collection, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[77], 1);
	m, in := stub.EndorsementPolicies[collection]

	if !in {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[79], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[78], 1);return m[key], nil
}

// Constructor to initialise the internal State map
func NewMockStub(name string, cc Chaincode) *MockStub {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[80], 1);
	mockLogger.Debug("MockStub(", name, cc, ")")
	s := new(MockStub)
	s.Name = name
	s.cc = cc
	s.State = make(map[string][]byte)
	s.PvtState = make(map[string]map[string][]byte)
	s.EndorsementPolicies = make(map[string]map[string][]byte)
	s.Invokables = make(map[string]*MockStub)
	s.Keys = list.New()
	s.ChaincodeEventsChannel = make(chan *pb.ChaincodeEvent, 100) //define large capacity for non-blocking setEvent calls.
	s.Decorations = make(map[string][]byte)

	return s
}

/*****************************
 Range Query Iterator
*****************************/

type MockStateRangeQueryIterator struct {
	Closed   bool
	Stub     *MockStub
	StartKey string
	EndKey   string
	Current  *list.Element
}

// HasNext returns true if the range query iterator contains additional keys
// and values.
func (iter *MockStateRangeQueryIterator) HasNext() bool {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[81], 1);
	if iter.Closed {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[85], 1);
		// previously called Close()
		mockLogger.Debug("HasNext() but already closed")
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[82], 1);if iter.Current == nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[86], 1);
		mockLogger.Error("HasNext() couldn't get Current")
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[83], 1);current := iter.Current
	for current != nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[87], 1);
		// if this is an open-ended query for all keys, return true
		if iter.StartKey == "" && iter.EndKey == "" {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[90], 1);
			return true
		}
		_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[88], 1);comp1 := strings.Compare(current.Value.(string), iter.StartKey)
		comp2 := strings.Compare(current.Value.(string), iter.EndKey)
		if comp1 >= 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[91], 1);
			if comp2 < 0 {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[92], 1);
				mockLogger.Debug("HasNext() got next")
				return true
			} else{ _cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[93], 1);{
				mockLogger.Debug("HasNext() but no next")
				return false

			}}
		}
		_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[89], 1);current = current.Next()
	}

	// we've reached the end of the underlying values
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[84], 1);mockLogger.Debug("HasNext() but no next")
	return false
}

// Next returns the next key and value in the range query iterator.
func (iter *MockStateRangeQueryIterator) Next() (*queryresult.KV, error) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[94], 1);
	if iter.Closed == true {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[98], 1);
		err := errors.New("MockStateRangeQueryIterator.Next() called after Close()")
		mockLogger.Errorf("%+v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[95], 1);if iter.HasNext() == false {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[99], 1);
		err := errors.New("MockStateRangeQueryIterator.Next() called when it does not HaveNext()")
		mockLogger.Errorf("%+v", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[96], 1);for iter.Current != nil {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[100], 1);
		comp1 := strings.Compare(iter.Current.Value.(string), iter.StartKey)
		comp2 := strings.Compare(iter.Current.Value.(string), iter.EndKey)
		// compare to start and end keys. or, if this is an open-ended query for
		// all keys, it should always return the key and value
		if (comp1 >= 0 && comp2 < 0) || (iter.StartKey == "" && iter.EndKey == "") {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[102], 1);
			key := iter.Current.Value.(string)
			value, err := iter.Stub.GetState(key)
			iter.Current = iter.Current.Next()
			return &queryresult.KV{Key: key, Value: value}, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[101], 1);iter.Current = iter.Current.Next()
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[97], 1);err := errors.New("MockStateRangeQueryIterator.Next() went past end of range")
	mockLogger.Errorf("%+v", err)
	return nil, err
}

// Close closes the range query iterator. This should be called when done
// reading from the iterator to free up resources.
func (iter *MockStateRangeQueryIterator) Close() error {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[103], 1);
	if iter.Closed == true {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[105], 1);
		err := errors.New("MockStateRangeQueryIterator.Close() called after Close()")
		mockLogger.Errorf("%+v", err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[104], 1);iter.Closed = true
	return nil
}

func (iter *MockStateRangeQueryIterator) Print() {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[106], 1);
	mockLogger.Debug("MockStateRangeQueryIterator {")
	mockLogger.Debug("Closed?", iter.Closed)
	mockLogger.Debug("Stub", iter.Stub)
	mockLogger.Debug("StartKey", iter.StartKey)
	mockLogger.Debug("EndKey", iter.EndKey)
	mockLogger.Debug("Current", iter.Current)
	mockLogger.Debug("HasNext?", iter.HasNext())
	mockLogger.Debug("}")
}

func NewMockStateRangeQueryIterator(stub *MockStub, startKey string, endKey string) *MockStateRangeQueryIterator {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[107], 1);
	mockLogger.Debug("NewMockStateRangeQueryIterator(", stub, startKey, endKey, ")")
	iter := new(MockStateRangeQueryIterator)
	iter.Closed = false
	iter.Stub = stub
	iter.StartKey = startKey
	iter.EndKey = endKey
	iter.Current = stub.Keys.Front()

	iter.Print()

	return iter
}

func getBytes(function string, args []string) [][]byte {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[108], 1);
	bytes := make([][]byte, 0, len(args)+1)
	bytes = append(bytes, []byte(function))
	for _, s := range args {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[110], 1);
		bytes = append(bytes, []byte(s))
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[109], 1);return bytes
}

func getFuncArgs(bytes [][]byte) (string, []string) {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[111], 1);
	mockLogger.Debugf("getFuncArgs(%x)", bytes)
	function := string(bytes[0])
	args := make([]string, len(bytes)-1)
	for i := 1; i < len(bytes); i++ {_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[113], 1);
		mockLogger.Debugf("getFuncArgs - i:%x, len(bytes):%x", i, len(bytes))
		args[i-1] = string(bytes[i])
	}
	_cover_atomic_.AddUint32(&GoCover_4_323061643534336238336134.Count[112], 1);return function, args
}

var GoCover_4_323061643534336238336134 = struct {
	Count     [114]uint32
	Pos       [3 * 114]uint32
	NumStmt   [114]uint16
} {
	Pos: [3 * 114]uint32{
		72, 74, 0x20028, // [0]
		76, 78, 0x2002d, // [1]
		80, 82, 0x2002a, // [2]
		84, 87, 0x1c0030, // [3]
		90, 90, 0x100002, // [4]
		87, 89, 0x3001c, // [5]
		93, 97, 0x170055, // [6]
		101, 101, 0x80002, // [7]
		97, 100, 0x30017, // [8]
		107, 111, 0x20039, // [9]
		114, 117, 0x20037, // [10]
		122, 124, 0x2005d, // [11]
		127, 133, 0x20048, // [12]
		136, 142, 0x2004a, // [13]
		144, 146, 0x2003a, // [14]
		149, 156, 0x20073, // [15]
		158, 161, 0x90055, // [16]
		165, 165, 0x140002, // [17]
		161, 163, 0x30009, // [18]
		168, 170, 0x90059, // [19]
		175, 177, 0xc0002, // [20]
		170, 173, 0x30009, // [21]
		180, 182, 0x2004b, // [22]
		184, 186, 0x20077, // [23]
		188, 190, 0x20094, // [24]
		192, 197, 0x20070, // [25]
		200, 204, 0x2003c, // [26]
		207, 208, 0x150040, // [27]
		215, 215, 0x150002, // [28]
		220, 224, 0x410002, // [29]
		248, 248, 0x1a0002, // [30]
		253, 253, 0xc0002, // [31]
		208, 212, 0x30015, // [32]
		215, 218, 0x30015, // [33]
		224, 228, 0xf0041, // [34]
		228, 232, 0x9000f, // [35]
		233, 233, 0x170009, // [36]
		233, 236, 0x90017, // [37]
		237, 239, 0x1a0009, // [38]
		239, 242, 0xa001a, // [39]
		248, 251, 0x3001a, // [40]
		257, 261, 0x410032, // [41]
		267, 267, 0xc0002, // [42]
		261, 262, 0x350041, // [43]
		262, 264, 0x40035, // [44]
		270, 271, 0x3d0065, // [45]
		274, 274, 0x440002, // [46]
		271, 273, 0x3003d, // [47]
		282, 287, 0x20059, // [48]
		291, 293, 0x2005b, // [49]
		301, 303, 0x100082, // [50]
		306, 306, 0x780002, // [51]
		303, 305, 0x30010, // [52]
		311, 313, 0x20062, // [53]
		317, 319, 0x20058, // [54]
		322, 324, 0x20053, // [55]
		327, 329, 0x20063, // [56]
		332, 334, 0x20053, // [57]
		340, 342, 0x130068, // [58]
		346, 351, 0xc0002, // [59]
		342, 344, 0x30013, // [60]
		355, 357, 0x20034, // [61]
		360, 362, 0x20041, // [62]
		365, 367, 0x20034, // [63]
		370, 372, 0x20047, // [64]
		374, 376, 0x20040, // [65]
		379, 381, 0x20036, // [66]
		383, 385, 0x20041, // [67]
		387, 388, 0x1d0046, // [68]
		391, 391, 0x1e0002, // [69]
		388, 390, 0x3001d, // [70]
		394, 397, 0x20043, // [71]
		399, 401, 0x20050, // [72]
		403, 405, 0x2004f, // [73]
		407, 409, 0x90062, // [74]
		414, 415, 0xc0002, // [75]
		409, 412, 0x30009, // [76]
		418, 421, 0x90061, // [77]
		425, 425, 0x140002, // [78]
		421, 423, 0x30009, // [79]
		429, 443, 0x20037, // [80]
		459, 460, 0x110039, // [81]
		466, 466, 0x190002, // [82]
		471, 472, 0x150002, // [83]
		493, 494, 0xe0002, // [84]
		460, 464, 0x30011, // [85]
		466, 469, 0x30019, // [86]
		472, 474, 0x2f0015, // [87]
		477, 479, 0x110003, // [88]
		489, 489, 0x1b0003, // [89]
		474, 476, 0x4002f, // [90]
		479, 480, 0x110011, // [91]
		480, 483, 0x50011, // [92]
		483, 487, 0x5000a, // [93]
		498, 499, 0x19004a, // [94]
		505, 505, 0x1d0002, // [95]
		511, 511, 0x1a0002, // [96]
		524, 526, 0x110002, // [97]
		499, 503, 0x30019, // [98]
		505, 509, 0x3001d, // [99]
		511, 516, 0x4e001a, // [100]
		522, 522, 0x250003, // [101]
		516, 521, 0x4004e, // [102]
		531, 532, 0x190038, // [103]
		538, 539, 0xc0002, // [104]
		532, 536, 0x30019, // [105]
		542, 551, 0x20032, // [106]
		553, 565, 0x20072, // [107]
		567, 570, 0x190038, // [108]
		573, 573, 0xe0002, // [109]
		570, 572, 0x30019, // [110]
		576, 580, 0x220035, // [111]
		584, 584, 0x170002, // [112]
		580, 583, 0x30022, // [113]
	},
	NumStmt: [114]uint16{
		1, // 0
		1, // 1
		1, // 2
		3, // 3
		1, // 4
		1, // 5
		4, // 6
		1, // 7
		2, // 8
		3, // 9
		2, // 10
		1, // 11
		5, // 12
		5, // 13
		1, // 14
		6, // 15
		2, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		3, // 26
		1, // 27
		1, // 28
		3, // 29
		1, // 30
		1, // 31
		3, // 32
		2, // 33
		4, // 34
		3, // 35
		1, // 36
		2, // 37
		1, // 38
		3, // 39
		2, // 40
		3, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		2, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		5, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		2, // 71
		1, // 72
		1, // 73
		2, // 74
		2, // 75
		2, // 76
		2, // 77
		1, // 78
		1, // 79
		12, // 80
		1, // 81
		1, // 82
		2, // 83
		2, // 84
		2, // 85
		2, // 86
		1, // 87
		3, // 88
		1, // 89
		1, // 90
		1, // 91
		2, // 92
		2, // 93
		1, // 94
		1, // 95
		1, // 96
		3, // 97
		3, // 98
		3, // 99
		3, // 100
		1, // 101
		4, // 102
		1, // 103
		2, // 104
		3, // 105
		8, // 106
		9, // 107
		3, // 108
		1, // 109
		1, // 110
		4, // 111
		1, // 112
		2, // 113
	},
}
var _ = _cover_atomic_.LoadUint32
