//line /home/cooper/go/src/github.com/hyperledger/fabric/common/configtx/update.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package configtx; import _cover_atomic_ "sync/atomic"

import (
	"strings"

	"github.com/hyperledger/fabric/common/policies"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

func (vi *ValidatorImpl) verifyReadSet(readSet map[string]comparable) error {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[0], 1);
	for key, value := range readSet {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[2], 1);
		existing, ok := vi.configMap[key]
		if !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[4], 1);
			return errors.Errorf("existing config does not contain element for %s but was in the read set", key)
		}

		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[3], 1);if existing.version() != value.version() {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[5], 1);
			return errors.Errorf("readset expected key %s at version %d, but got version %d", key, value.version(), existing.version())
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[1], 1);return nil
}

func computeDeltaSet(readSet, writeSet map[string]comparable) map[string]comparable {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[6], 1);
	result := make(map[string]comparable)
	for key, value := range writeSet {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[8], 1);
		readVal, ok := readSet[key]

		if ok && readVal.version() == value.version() {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[10], 1);
			continue
		}

		// If the key in the readset is a different version, we include it
		// Error checking on the sanity of the update is done against the config
		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[9], 1);result[key] = value
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[7], 1);return result
}

func validateModPolicy(modPolicy string) error {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[11], 1);
	if modPolicy == "" {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[15], 1);
		return errors.Errorf("mod_policy not set")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[12], 1);trimmed := modPolicy
	if modPolicy[0] == '/' {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[16], 1);
		trimmed = modPolicy[1:]
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[13], 1);for i, pathElement := range strings.Split(trimmed, pathSeparator) {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[17], 1);
		err := validateConfigID(pathElement)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[18], 1);
			return errors.Wrapf(err, "path element at %d is invalid", i)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[14], 1);return nil

}

func (vi *ValidatorImpl) verifyDeltaSet(deltaSet map[string]comparable, signedData []*cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[19], 1);
	if len(deltaSet) == 0 {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[22], 1);
		return errors.Errorf("delta set was empty -- update would have no effect")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[20], 1);for key, value := range deltaSet {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[23], 1);
		logger.Debugf("Processing change to key: %s", key)
		if err := validateModPolicy(value.modPolicy()); err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[28], 1);
			return errors.Wrapf(err, "invalid mod_policy for element %s", key)
		}

		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[24], 1);existing, ok := vi.configMap[key]
		if !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[29], 1);
			if value.version() != 0 {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[31], 1);
				return errors.Errorf("attempted to set key %s to version %d, but key does not exist", key, value.version())
			}

			_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[30], 1);continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[25], 1);if value.version() != existing.version()+1 {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[32], 1);
			return errors.Errorf("attempt to set key %s to version %d, but key is at version %d", key, value.version(), existing.version())
		}

		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[26], 1);policy, ok := vi.policyForItem(existing)
		if !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[33], 1);
			return errors.Errorf("unexpected missing policy %s for item %s", existing.modPolicy(), key)
		}

		// Ensure the policy is satisfied
		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[27], 1);if err := policy.Evaluate(signedData); err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[34], 1);
			return errors.Wrapf(err, "policy for %s not satisfied", key)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[21], 1);return nil
}

func verifyFullProposedConfig(writeSet, fullProposedConfig map[string]comparable) error {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[35], 1);
	for key := range writeSet {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[37], 1);
		if _, ok := fullProposedConfig[key]; !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[38], 1);
			return errors.Errorf("writeset contained key %s which did not appear in proposed config", key)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[36], 1);return nil
}

// authorizeUpdate validates that all modified config has the corresponding modification policies satisfied by the signature set
// it returns a map of the modified config
func (vi *ValidatorImpl) authorizeUpdate(configUpdateEnv *cb.ConfigUpdateEnvelope) (map[string]comparable, error) {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[39], 1);
	if configUpdateEnv == nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[49], 1);
		return nil, errors.Errorf("cannot process nil ConfigUpdateEnvelope")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[40], 1);configUpdate, err := UnmarshalConfigUpdate(configUpdateEnv.ConfigUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[50], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[41], 1);if configUpdate.ChannelId != vi.channelID {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[51], 1);
		return nil, errors.Errorf("ConfigUpdate for channel '%s' but envelope for channel '%s'", configUpdate.ChannelId, vi.channelID)
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[42], 1);readSet, err := mapConfig(configUpdate.ReadSet, vi.namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[52], 1);
		return nil, errors.Wrapf(err, "error mapping ReadSet")
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[43], 1);err = vi.verifyReadSet(readSet)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[53], 1);
		return nil, errors.Wrapf(err, "error validating ReadSet")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[44], 1);writeSet, err := mapConfig(configUpdate.WriteSet, vi.namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[54], 1);
		return nil, errors.Wrapf(err, "error mapping WriteSet")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[45], 1);deltaSet := computeDeltaSet(readSet, writeSet)
	signedData, err := configUpdateEnv.AsSignedData()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[55], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[46], 1);if err = vi.verifyDeltaSet(deltaSet, signedData); err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[56], 1);
		return nil, errors.Wrapf(err, "error validating DeltaSet")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[47], 1);fullProposedConfig := vi.computeUpdateResult(deltaSet)
	if err := verifyFullProposedConfig(writeSet, fullProposedConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[57], 1);
		return nil, errors.Wrapf(err, "full config did not verify")
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[48], 1);return fullProposedConfig, nil
}

func (vi *ValidatorImpl) policyForItem(item comparable) (policies.Policy, bool) {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[58], 1);
	manager := vi.pm

	modPolicy := item.modPolicy()
	logger.Debugf("Getting policy for item %s with mod_policy %s", item.key, modPolicy)

	// If the mod_policy path is relative, get the right manager for the context
	// If the item has a zero length path, it is the root group, use the base policy manager
	// if the mod_policy path is absolute (starts with /) also use the base policy manager
	if len(modPolicy) > 0 && modPolicy[0] != policies.PathSeparator[0] && len(item.path) != 0 {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[60], 1);
		var ok bool

		manager, ok = manager.Manager(item.path[1:])
		if !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[63], 1);
			logger.Debugf("Could not find manager at path: %v", item.path[1:])
			return nil, ok
		}

		// In the case of the group type, its key is part of its path for the purposes of finding the policy manager
		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[61], 1);if item.ConfigGroup != nil {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[64], 1);
			manager, ok = manager.Manager([]string{item.key})
		}
		_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[62], 1);if !ok {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[65], 1);
			logger.Debugf("Could not find group at subpath: %v", item.key)
			return nil, ok
		}
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[59], 1);return manager.GetPolicy(item.modPolicy())
}

// computeUpdateResult takes a configMap generated by an update and produces a new configMap overlaying it onto the old config
func (vi *ValidatorImpl) computeUpdateResult(updatedConfig map[string]comparable) map[string]comparable {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[66], 1);
	newConfigMap := make(map[string]comparable)
	for key, value := range vi.configMap {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[69], 1);
		newConfigMap[key] = value
	}

	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[67], 1);for key, value := range updatedConfig {_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[70], 1);
		newConfigMap[key] = value
	}
	_cover_atomic_.AddUint32(&GoCover_3_346532363364653032376334.Count[68], 1);return newConfigMap
}

var GoCover_3_346532363364653032376334 = struct {
	Count     [71]uint32
	Pos       [3 * 71]uint32
	NumStmt   [71]uint16
} {
	Pos: [3 * 71]uint32{
		17, 18, 0x22004d, // [0]
		28, 28, 0xc0002, // [1]
		18, 20, 0xa0022, // [2]
		24, 24, 0x2c0003, // [3]
		20, 22, 0x4000a, // [4]
		24, 26, 0x4002c, // [5]
		31, 33, 0x230055, // [6]
		44, 44, 0xf0002, // [7]
		33, 36, 0x310023, // [8]
		42, 42, 0x160003, // [9]
		36, 37, 0xc0031, // [10]
		47, 48, 0x150030, // [11]
		52, 53, 0x190002, // [12]
		57, 57, 0x440002, // [13]
		63, 63, 0xc0002, // [14]
		48, 50, 0x30015, // [15]
		53, 55, 0x30019, // [16]
		57, 59, 0x110044, // [17]
		59, 61, 0x40011, // [18]
		67, 68, 0x18006c, // [19]
		72, 72, 0x230002, // [20]
		100, 100, 0xc0002, // [21]
		68, 70, 0x30018, // [22]
		72, 74, 0x3e0023, // [23]
		78, 79, 0xa0003, // [24]
		86, 86, 0x2e0003, // [25]
		90, 91, 0xa0003, // [26]
		96, 96, 0x350003, // [27]
		74, 76, 0x4003e, // [28]
		79, 80, 0x1c000a, // [29]
		84, 84, 0xc0004, // [30]
		80, 82, 0x5001c, // [31]
		86, 88, 0x4002e, // [32]
		91, 93, 0x4000a, // [33]
		96, 98, 0x40035, // [34]
		103, 104, 0x1c0059, // [35]
		109, 109, 0xc0002, // [36]
		104, 105, 0x2c001c, // [37]
		105, 107, 0x4002c, // [38]
		114, 115, 0x1c0073, // [39]
		119, 120, 0x100002, // [40]
		124, 124, 0x2c0002, // [41]
		128, 129, 0x100002, // [42]
		132, 133, 0x100002, // [43]
		137, 138, 0x100002, // [44]
		142, 144, 0x100002, // [45]
		148, 148, 0x3f0002, // [46]
		152, 153, 0x4f0002, // [47]
		157, 157, 0x200002, // [48]
		115, 117, 0x3001c, // [49]
		120, 122, 0x30010, // [50]
		124, 126, 0x3002c, // [51]
		129, 131, 0x30010, // [52]
		133, 135, 0x30010, // [53]
		138, 140, 0x30010, // [54]
		144, 146, 0x30010, // [55]
		148, 150, 0x3003f, // [56]
		153, 155, 0x3004f, // [57]
		160, 169, 0x5c0051, // [58]
		188, 188, 0x2c0002, // [59]
		169, 173, 0xa005c, // [60]
		179, 179, 0x1e0003, // [61]
		182, 182, 0xa0003, // [62]
		173, 176, 0x4000a, // [63]
		179, 181, 0x4001e, // [64]
		182, 185, 0x4000a, // [65]
		192, 194, 0x270069, // [66]
		198, 198, 0x280002, // [67]
		201, 201, 0x150002, // [68]
		194, 196, 0x30027, // [69]
		198, 200, 0x30028, // [70]
	},
	NumStmt: [71]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		2, // 40
		1, // 41
		2, // 42
		2, // 43
		2, // 44
		3, // 45
		1, // 46
		2, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		4, // 58
		1, // 59
		3, // 60
		1, // 61
		1, // 62
		2, // 63
		1, // 64
		2, // 65
		2, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
	},
}
var _ = _cover_atomic_.LoadUint32
