//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/cluster/connections.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cluster; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"crypto/x509"
	"sync"
	"sync/atomic"

	"github.com/pkg/errors"
	"google.golang.org/grpc"
)

// RemoteVerifier verifies the connection to the remote host
type RemoteVerifier func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error

//go:generate mockery -dir . -name SecureDialer -case underscore -output ./mocks/

// SecureDialer connects to a remote address
type SecureDialer interface {
	Dial(address string, verifyFunc RemoteVerifier) (*grpc.ClientConn, error)
}

//go:generate mockery -dir . -name ConnectionMapper -case underscore -output ./mocks/

// ConnectionMapper maps certificates to connections
type ConnectionMapper interface {
	Lookup(cert []byte) (*grpc.ClientConn, bool)
	Put(cert []byte, conn *grpc.ClientConn)
	Remove(cert []byte)
}

// ConnectionStore stores connections to remote nodes
type ConnectionStore struct {
	certsByEndpoints atomic.Value
	lock             sync.RWMutex
	Connections      ConnectionMapper
	dialer           SecureDialer
}

// NewConnectionStore creates a new ConnectionStore with the given SecureDialer
func NewConnectionStore(dialer SecureDialer) *ConnectionStore {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[0], 1);
	connMapping := &ConnectionStore{
		Connections: make(ConnByCertMap),
		dialer:      dialer,
	}
	return connMapping
}

// verifyHandshake returns a predicate that verifies that the remote node authenticates
// itself with the given TLS certificate
func (c *ConnectionStore) verifyHandshake(endpoint string, certificate []byte) RemoteVerifier {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[1], 1);
	return func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[2], 1);
		if bytes.Equal(certificate, rawCerts[0]) {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[4], 1);
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[3], 1);return errors.Errorf("certificate presented by %s doesn't match any authorized certificate", endpoint)
	}
}

// Disconnect closes the gRPC connection that is mapped to the given certificate
func (c *ConnectionStore) Disconnect(expectedServerCert []byte) {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[5], 1);
	c.lock.Lock()
	defer c.lock.Unlock()

	conn, connected := c.Connections.Lookup(expectedServerCert)
	if !connected {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[7], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[6], 1);conn.Close()
	c.Connections.Remove(expectedServerCert)
}

// Connection obtains a connection to the given endpoint and expects the given server certificate
// to be presented by the remote node
func (c *ConnectionStore) Connection(endpoint string, expectedServerCert []byte) (*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[8], 1);
	c.lock.RLock()
	conn, alreadyConnected := c.Connections.Lookup(expectedServerCert)
	c.lock.RUnlock()

	if alreadyConnected {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[10], 1);
		return conn, nil
	}

	// Else, we need to connect to the remote endpoint
	_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[9], 1);return c.connect(endpoint, expectedServerCert)
}

// connect connects to the given endpoint and expects the given TLS server certificate
// to be presented at the time of authentication
func (c *ConnectionStore) connect(endpoint string, expectedServerCert []byte) (*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[11], 1);
	c.lock.Lock()
	defer c.lock.Unlock()
	// Check again to see if some other goroutine has already connected while
	// we were waiting on the lock
	conn, alreadyConnected := c.Connections.Lookup(expectedServerCert)
	if alreadyConnected {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[14], 1);
		return conn, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[12], 1);v := c.verifyHandshake(endpoint, expectedServerCert)
	conn, err := c.dialer.Dial(endpoint, v)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[15], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_363733313532663932376566.Count[13], 1);c.Connections.Put(expectedServerCert, conn)
	return conn, nil
}

var GoCover_1_363733313532663932376566 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		47, 53, 0x2003f, // [0]
		57, 58, 0x4d005f, // [1]
		58, 59, 0x2c004d, // [2]
		62, 62, 0x690003, // [3]
		59, 61, 0x4002c, // [4]
		67, 72, 0x100041, // [5]
		75, 76, 0x2a0002, // [6]
		72, 74, 0x30010, // [7]
		81, 86, 0x16006c, // [8]
		91, 91, 0x300002, // [9]
		86, 88, 0x30016, // [10]
		96, 102, 0x160069, // [11]
		106, 108, 0x100002, // [12]
		112, 113, 0x120002, // [13]
		102, 104, 0x30016, // [14]
		108, 110, 0x30010, // [15]
	},
	NumStmt: [16]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		4, // 5
		2, // 6
		1, // 7
		4, // 8
		1, // 9
		1, // 10
		4, // 11
		3, // 12
		2, // 13
		1, // 14
		1, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
