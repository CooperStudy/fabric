//line /home/cooper/go/src/github.com/hyperledger/fabric/common/flogging/loggerlevels.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package flogging; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"regexp"
	"sort"
	"strings"
	"sync"

	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

// LoggerLevels tracks the logging level of named loggers.
type LoggerLevels struct {
	defaultLevel zapcore.Level

	mutex      sync.RWMutex
	levelCache map[string]zapcore.Level
	specs      map[string]zapcore.Level
}

// DefaultLevel returns the default logging level for loggers that do not have
// an explicit level set.
func (l *LoggerLevels) DefaultLevel() zapcore.Level {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[0], 1);
	l.mutex.RLock()
	lvl := l.defaultLevel
	l.mutex.RUnlock()
	return lvl
}

// ActivateSpec is used to modify logging levels.
//
// The logging specification has the following form:
//   [<logger>[,<logger>...]=]<level>[:[<logger>[,<logger>...]=]<level>...]
func (l *LoggerLevels) ActivateSpec(spec string) error {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[1], 1);
	l.mutex.Lock()
	defer l.mutex.Unlock()

	defaultLevel := zapcore.InfoLevel
	specs := map[string]zapcore.Level{}
	for _, field := range strings.Split(spec, ":") {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[3], 1);
		split := strings.Split(field, "=")
		switch len(split) {
		case 1:_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[4], 1); // level
			if field != "" && !IsValidLevel(field) {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[10], 1);
				return errors.Errorf("invalid logging specification '%s': bad segment '%s'", spec, field)
			}
			_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[5], 1);defaultLevel = NameToLevel(field)

		case 2:_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[6], 1); // <logger>[,<logger>...]=<level>
			if split[0] == "" {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[11], 1);
				return errors.Errorf("invalid logging specification '%s': no logger specified in segment '%s'", spec, field)
			}
			_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[7], 1);if field != "" && !IsValidLevel(split[1]) {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[12], 1);
				return errors.Errorf("invalid logging specification '%s': bad segment '%s'", spec, field)
			}

			_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[8], 1);level := NameToLevel(split[1])
			loggers := strings.Split(split[0], ",")
			for _, logger := range loggers {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[13], 1);
				// check if the logger name in the spec is valid. The
				// trailing period is trimmed as logger names in specs
				// ending with a period signifies that this part of the
				// spec refers to the exact logger name (i.e. is not a prefix)
				if !isValidLoggerName(strings.TrimSuffix(logger, ".")) {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[15], 1);
					return errors.Errorf("invalid logging specification '%s': bad logger name '%s'", spec, logger)
				}
				_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[14], 1);specs[logger] = level
			}

		default:_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[9], 1);
			return errors.Errorf("invalid logging specification '%s': bad segment '%s'", spec, field)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[2], 1);l.defaultLevel = defaultLevel
	l.specs = specs
	l.levelCache = map[string]zapcore.Level{}

	return nil
}

// logggerNameRegexp defines the valid logger names
var loggerNameRegexp = regexp.MustCompile(`^[[:alnum:]_#:-]+(\.[[:alnum:]_#:-]+)*$`)

// isValidLoggerName checks whether a logger name contains only valid
// characters. Names that begin/end with periods or contain special
// characters (other than periods, underscores, pound signs, colons
// and dashes) are invalid.
func isValidLoggerName(loggerName string) bool {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[16], 1);
	return loggerNameRegexp.MatchString(loggerName)
}

// Level returns the effective logging level for a logger. If a level has not
// been explicitly set for the logger, the default logging level will be
// returned.
func (l *LoggerLevels) Level(loggerName string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[17], 1);
	if level, ok := l.cachedLevel(loggerName); ok {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[19], 1);
		return level
	}

	_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[18], 1);l.mutex.Lock()
	level := l.calculateLevel(loggerName)
	l.levelCache[loggerName] = level
	l.mutex.Unlock()

	return level
}

// calculateLevel walks the logger name back to find the appropriate
// log level from the current spec.
func (l *LoggerLevels) calculateLevel(loggerName string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[20], 1);
	candidate := loggerName + "."
	for {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[21], 1);
		if lvl, ok := l.specs[candidate]; ok {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[24], 1);
			return lvl
		}

		_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[22], 1);idx := strings.LastIndex(candidate, ".")
		if idx <= 0 {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[25], 1);
			return l.defaultLevel
		}
		_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[23], 1);candidate = candidate[:idx]
	}
}

// cachedLevel attempts to retrieve the effective log level for a logger from the
// cache. If the logger is not found, ok will be false.
func (l *LoggerLevels) cachedLevel(loggerName string) (lvl zapcore.Level, ok bool) {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[26], 1);
	l.mutex.RLock()
	level, ok := l.levelCache[loggerName]
	l.mutex.RUnlock()
	return level, ok
}

// Spec returns a normalized version of the active logging spec.
func (l *LoggerLevels) Spec() string {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[27], 1);
	l.mutex.RLock()
	defer l.mutex.RUnlock()

	var fields []string
	for k, v := range l.specs {_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[29], 1);
		fields = append(fields, fmt.Sprintf("%s=%s", k, v))
	}

	_cover_atomic_.AddUint32(&GoCover_4_643766633362313436336635.Count[28], 1);sort.Strings(fields)
	fields = append(fields, l.defaultLevel.String())

	return strings.Join(fields, ":")
}

var GoCover_4_643766633362313436336635 = struct {
	Count     [30]uint32
	Pos       [3 * 30]uint32
	NumStmt   [30]uint16
} {
	Pos: [3 * 30]uint32{
		31, 36, 0x20035, // [0]
		42, 48, 0x310038, // [1]
		83, 87, 0xc0002, // [2]
		48, 50, 0x150031, // [3]
		51, 52, 0x2b000a, // [4]
		55, 55, 0x250004, // [5]
		57, 58, 0x16000a, // [6]
		61, 61, 0x2e0004, // [7]
		65, 67, 0x230004, // [8]
		78, 79, 0x5d000b, // [9]
		52, 54, 0x5002b, // [10]
		58, 60, 0x50016, // [11]
		61, 63, 0x5002e, // [12]
		67, 72, 0x3c0023, // [13]
		75, 75, 0x1a0005, // [14]
		72, 74, 0x6003c, // [15]
		97, 99, 0x20030, // [16]
		104, 105, 0x30003f, // [17]
		109, 114, 0xe0002, // [18]
		105, 107, 0x30030, // [19]
		119, 121, 0x60048, // [20]
		121, 122, 0x280006, // [21]
		126, 127, 0xf0003, // [22]
		130, 130, 0x1e0003, // [23]
		122, 124, 0x40028, // [24]
		127, 129, 0x4000f, // [25]
		136, 141, 0x20054, // [26]
		144, 149, 0x1c0026, // [27]
		153, 156, 0x220002, // [28]
		149, 151, 0x3001c, // [29]
	},
	NumStmt: [30]uint16{
		4, // 0
		5, // 1
		4, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		5, // 18
		1, // 19
		2, // 20
		1, // 21
		2, // 22
		1, // 23
		1, // 24
		1, // 25
		4, // 26
		4, // 27
		3, // 28
		1, // 29
	},
}
var _ = _cover_atomic_.LoadUint32
