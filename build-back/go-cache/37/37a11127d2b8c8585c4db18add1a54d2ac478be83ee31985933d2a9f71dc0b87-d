//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/gossip/extensions.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package gossip; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/gossip/api"
	"github.com/hyperledger/fabric/gossip/common"
)

// NewGossipMessageComparator creates a MessageReplacingPolicy given a maximum number of blocks to hold
func NewGossipMessageComparator(dataBlockStorageSize int) common.MessageReplacingPolicy {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[0], 1);
	return (&msgComparator{dataBlockStorageSize: dataBlockStorageSize}).getMsgReplacingPolicy()
}

type msgComparator struct {
	dataBlockStorageSize int
}

func (mc *msgComparator) getMsgReplacingPolicy() common.MessageReplacingPolicy {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[1], 1);
	return func(this interface{}, that interface{}) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[2], 1);
		return mc.invalidationPolicy(this, that)
	}
}

func (mc *msgComparator) invalidationPolicy(this interface{}, that interface{}) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[3], 1);
	thisMsg := this.(*SignedGossipMessage)
	thatMsg := that.(*SignedGossipMessage)

	if thisMsg.IsAliveMsg() && thatMsg.IsAliveMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[9], 1);
		return aliveInvalidationPolicy(thisMsg.GetAliveMsg(), thatMsg.GetAliveMsg())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[4], 1);if thisMsg.IsDataMsg() && thatMsg.IsDataMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[10], 1);
		return mc.dataInvalidationPolicy(thisMsg.GetDataMsg(), thatMsg.GetDataMsg())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[5], 1);if thisMsg.IsStateInfoMsg() && thatMsg.IsStateInfoMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[11], 1);
		return mc.stateInvalidationPolicy(thisMsg.GetStateInfo(), thatMsg.GetStateInfo())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[6], 1);if thisMsg.IsIdentityMsg() && thatMsg.IsIdentityMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[12], 1);
		return mc.identityInvalidationPolicy(thisMsg.GetPeerIdentity(), thatMsg.GetPeerIdentity())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[7], 1);if thisMsg.IsLeadershipMsg() && thatMsg.IsLeadershipMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[13], 1);
		return leaderInvalidationPolicy(thisMsg.GetLeadershipMsg(), thatMsg.GetLeadershipMsg())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[8], 1);return common.MessageNoAction
}

func (mc *msgComparator) stateInvalidationPolicy(thisStateMsg *StateInfo, thatStateMsg *StateInfo) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[14], 1);
	if !bytes.Equal(thisStateMsg.PkiId, thatStateMsg.PkiId) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[16], 1);
		return common.MessageNoAction
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[15], 1);return compareTimestamps(thisStateMsg.Timestamp, thatStateMsg.Timestamp)
}

func (mc *msgComparator) identityInvalidationPolicy(thisIdentityMsg *PeerIdentity, thatIdentityMsg *PeerIdentity) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[17], 1);
	if bytes.Equal(thisIdentityMsg.PkiId, thatIdentityMsg.PkiId) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[19], 1);
		return common.MessageInvalidated
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[18], 1);return common.MessageNoAction
}

func (mc *msgComparator) dataInvalidationPolicy(thisDataMsg *DataMessage, thatDataMsg *DataMessage) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[20], 1);
	if thisDataMsg.Payload.SeqNum == thatDataMsg.Payload.SeqNum {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[24], 1);
		return common.MessageInvalidated
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[21], 1);diff := abs(thisDataMsg.Payload.SeqNum, thatDataMsg.Payload.SeqNum)
	if diff <= uint64(mc.dataBlockStorageSize) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[25], 1);
		return common.MessageNoAction
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[22], 1);if thisDataMsg.Payload.SeqNum > thatDataMsg.Payload.SeqNum {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[26], 1);
		return common.MessageInvalidates
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[23], 1);return common.MessageInvalidated
}

func aliveInvalidationPolicy(thisMsg *AliveMessage, thatMsg *AliveMessage) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[27], 1);
	if !bytes.Equal(thisMsg.Membership.PkiId, thatMsg.Membership.PkiId) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[29], 1);
		return common.MessageNoAction
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[28], 1);return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
}

func leaderInvalidationPolicy(thisMsg *LeadershipMessage, thatMsg *LeadershipMessage) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[30], 1);
	if !bytes.Equal(thisMsg.PkiId, thatMsg.PkiId) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[32], 1);
		return common.MessageNoAction
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[31], 1);return compareTimestamps(thisMsg.Timestamp, thatMsg.Timestamp)
}

func compareTimestamps(thisTS *PeerTime, thatTS *PeerTime) common.InvalidationResult {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[33], 1);
	if thisTS.IncNum == thatTS.IncNum {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[36], 1);
		if thisTS.SeqNum > thatTS.SeqNum {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[38], 1);
			return common.MessageInvalidates
		}

		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[37], 1);return common.MessageInvalidated
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[34], 1);if thisTS.IncNum < thatTS.IncNum {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[39], 1);
		return common.MessageInvalidated
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[35], 1);return common.MessageInvalidates
}

// IsAliveMsg returns whether this GossipMessage is an AliveMessage
func (m *GossipMessage) IsAliveMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[40], 1);
	return m.GetAliveMsg() != nil
}

// IsDataMsg returns whether this GossipMessage is a data message
func (m *GossipMessage) IsDataMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[41], 1);
	return m.GetDataMsg() != nil
}

// IsStateInfoPullRequestMsg returns whether this GossipMessage is a stateInfoPullRequest
func (m *GossipMessage) IsStateInfoPullRequestMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[42], 1);
	return m.GetStateInfoPullReq() != nil
}

// IsStateInfoSnapshot returns whether this GossipMessage is a stateInfo snapshot
func (m *GossipMessage) IsStateInfoSnapshot() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[43], 1);
	return m.GetStateSnapshot() != nil
}

// IsStateInfoMsg returns whether this GossipMessage is a stateInfo message
func (m *GossipMessage) IsStateInfoMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[44], 1);
	return m.GetStateInfo() != nil
}

// IsPullMsg returns whether this GossipMessage is a message that belongs
// to the pull mechanism
func (m *GossipMessage) IsPullMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[45], 1);
	return m.GetDataReq() != nil || m.GetDataUpdate() != nil ||
		m.GetHello() != nil || m.GetDataDig() != nil
}

// IsRemoteStateMessage returns whether this GossipMessage is related to state synchronization
func (m *GossipMessage) IsRemoteStateMessage() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[46], 1);
	return m.GetStateRequest() != nil || m.GetStateResponse() != nil
}

// GetPullMsgType returns the phase of the pull mechanism this GossipMessage belongs to
// for example: Hello, Digest, etc.
// If this isn't a pull message, PullMsgType_UNDEFINED is returned.
func (m *GossipMessage) GetPullMsgType() PullMsgType {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[47], 1);
	if helloMsg := m.GetHello(); helloMsg != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[52], 1);
		return helloMsg.MsgType
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[48], 1);if digMsg := m.GetDataDig(); digMsg != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[53], 1);
		return digMsg.MsgType
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[49], 1);if reqMsg := m.GetDataReq(); reqMsg != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[54], 1);
		return reqMsg.MsgType
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[50], 1);if resMsg := m.GetDataUpdate(); resMsg != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[55], 1);
		return resMsg.MsgType
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[51], 1);return PullMsgType_UNDEFINED
}

// IsChannelRestricted returns whether this GossipMessage should be routed
// only in its channel
func (m *GossipMessage) IsChannelRestricted() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[56], 1);
	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_CHAN_ONLY || m.Tag == GossipMessage_CHAN_OR_ORG
}

// IsOrgRestricted returns whether this GossipMessage should be routed only
// inside the organization
func (m *GossipMessage) IsOrgRestricted() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[57], 1);
	return m.Tag == GossipMessage_CHAN_AND_ORG || m.Tag == GossipMessage_ORG_ONLY
}

// IsIdentityMsg returns whether this GossipMessage is an identity message
func (m *GossipMessage) IsIdentityMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[58], 1);
	return m.GetPeerIdentity() != nil
}

// IsDataReq returns whether this GossipMessage is a data request message
func (m *GossipMessage) IsDataReq() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[59], 1);
	return m.GetDataReq() != nil
}

// IsPrivateDataMsg returns whether this message is related to private data
func (m *GossipMessage) IsPrivateDataMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[60], 1);
	return m.GetPrivateReq() != nil || m.GetPrivateRes() != nil || m.GetPrivateData() != nil
}

// IsAck returns whether this GossipMessage is an acknowledgement
func (m *GossipMessage) IsAck() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[61], 1);
	return m.GetAck() != nil
}

// IsDataUpdate returns whether this GossipMessage is a data update message
func (m *GossipMessage) IsDataUpdate() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[62], 1);
	return m.GetDataUpdate() != nil
}

// IsHelloMsg returns whether this GossipMessage is a hello message
func (m *GossipMessage) IsHelloMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[63], 1);
	return m.GetHello() != nil
}

// IsDigestMsg returns whether this GossipMessage is a digest message
func (m *GossipMessage) IsDigestMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[64], 1);
	return m.GetDataDig() != nil
}

// IsLeadershipMsg returns whether this GossipMessage is a leadership (leader election) message
func (m *GossipMessage) IsLeadershipMsg() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[65], 1);
	return m.GetLeadershipMsg() != nil
}

// MsgConsumer invokes code given a SignedGossipMessage
type MsgConsumer func(message *SignedGossipMessage)

// IdentifierExtractor extracts from a SignedGossipMessage an identifier
type IdentifierExtractor func(*SignedGossipMessage) string

// IsTagLegal checks the GossipMessage tags and inner type
// and returns an error if the tag doesn't match the type.
func (m *GossipMessage) IsTagLegal() error {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[66], 1);
	if m.Tag == GossipMessage_UNDEFINED {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[74], 1);
		return fmt.Errorf("Undefined tag")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[67], 1);if m.IsDataMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[75], 1);
		if m.Tag != GossipMessage_CHAN_AND_ORG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[77], 1);
			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[76], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[68], 1);if m.IsAliveMsg() || m.GetMemReq() != nil || m.GetMemRes() != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[78], 1);
		if m.Tag != GossipMessage_EMPTY {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[80], 1);
			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[79], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[69], 1);if m.IsIdentityMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[81], 1);
		if m.Tag != GossipMessage_ORG_ONLY {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[83], 1);
			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_ORG_ONLY)])
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[82], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[70], 1);if m.IsPullMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[84], 1);
		switch m.GetPullMsgType() {
		case PullMsgType_BLOCK_MSG:_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[85], 1);
			if m.Tag != GossipMessage_CHAN_AND_ORG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[90], 1);
				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
			}
			_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[86], 1);return nil
		case PullMsgType_IDENTITY_MSG:_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[87], 1);
			if m.Tag != GossipMessage_EMPTY {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[91], 1);
				return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_EMPTY)])
			}
			_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[88], 1);return nil
		default:_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[89], 1);
			return fmt.Errorf("Invalid PullMsgType: %s", PullMsgType_name[int32(m.GetPullMsgType())])
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[71], 1);if m.IsStateInfoMsg() || m.IsStateInfoPullRequestMsg() || m.IsStateInfoSnapshot() || m.IsRemoteStateMessage() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[92], 1);
		if m.Tag != GossipMessage_CHAN_OR_ORG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[94], 1);
			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_OR_ORG)])
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[93], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[72], 1);if m.IsLeadershipMsg() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[95], 1);
		if m.Tag != GossipMessage_CHAN_AND_ORG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[97], 1);
			return fmt.Errorf("Tag should be %s", GossipMessage_Tag_name[int32(GossipMessage_CHAN_AND_ORG)])
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[96], 1);return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[73], 1);return fmt.Errorf("Unknown message type: %v", m)
}

// Verifier receives a peer identity, a signature and a message
// and returns nil if the signature on the message could be verified
// using the given identity.
type Verifier func(peerIdentity []byte, signature, message []byte) error

// Signer signs a message, and returns (signature, nil)
// on success, and nil and an error on failure.
type Signer func(msg []byte) ([]byte, error)

// ReceivedMessage is a GossipMessage wrapper that
// enables the user to send a message to the origin from which
// the ReceivedMessage was sent from.
// It also allows to know the identity of the sender,
// to obtain the raw bytes the GossipMessage was un-marshaled from,
// and the signature over these raw bytes.
type ReceivedMessage interface {

	// Respond sends a GossipMessage to the origin from which this ReceivedMessage was sent from
	Respond(msg *GossipMessage)

	// GetGossipMessage returns the underlying GossipMessage
	GetGossipMessage() *SignedGossipMessage

	// GetSourceMessage Returns the Envelope the ReceivedMessage was
	// constructed with
	GetSourceEnvelope() *Envelope

	// GetConnectionInfo returns information about the remote peer
	// that sent the message
	GetConnectionInfo() *ConnectionInfo

	// Ack returns to the sender an acknowledgement for the message
	// An ack can receive an error that indicates that the operation related
	// to the message has failed
	Ack(err error)
}

// ConnectionInfo represents information about
// the remote peer that sent a certain ReceivedMessage
type ConnectionInfo struct {
	ID       common.PKIidType
	Auth     *AuthInfo
	Identity api.PeerIdentityType
	Endpoint string
}

// String returns a string representation of this ConnectionInfo
func (c *ConnectionInfo) String() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[98], 1);
	return fmt.Sprintf("%s %v", c.Endpoint, c.ID)
}

// AuthInfo represents the authentication
// data that was provided by the remote peer
// at the connection time
type AuthInfo struct {
	SignedData []byte
	Signature  []byte
}

// Sign signs a GossipMessage with given Signer.
// Returns an Envelope on success,
// panics on failure.
func (m *SignedGossipMessage) Sign(signer Signer) (*Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[99], 1);
	// If we have a secretEnvelope, don't override it.
	// Back it up, and restore it later
	var secretEnvelope *SecretEnvelope
	if m.Envelope != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[103], 1);
		secretEnvelope = m.Envelope.SecretEnvelope
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[100], 1);m.Envelope = nil
	payload, err := proto.Marshal(m.GossipMessage)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[104], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[101], 1);sig, err := signer(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[105], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[102], 1);e := &Envelope{
		Payload:        payload,
		Signature:      sig,
		SecretEnvelope: secretEnvelope,
	}
	m.Envelope = e
	return e, nil
}

// NoopSign creates a SignedGossipMessage with a nil signature
func (m *GossipMessage) NoopSign() (*SignedGossipMessage, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[106], 1);
	signer := func(msg []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[108], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[107], 1);sMsg := &SignedGossipMessage{
		GossipMessage: m,
	}
	_, err := sMsg.Sign(signer)
	return sMsg, err
}

// Verify verifies a signed GossipMessage with a given Verifier.
// Returns nil on success, error on failure.
func (m *SignedGossipMessage) Verify(peerIdentity []byte, verify Verifier) error {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[109], 1);
	if m.Envelope == nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[115], 1);
		return errors.New("Missing envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[110], 1);if len(m.Envelope.Payload) == 0 {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[116], 1);
		return errors.New("Empty payload")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[111], 1);if len(m.Envelope.Signature) == 0 {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[117], 1);
		return errors.New("Empty signature")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[112], 1);payloadSigVerificationErr := verify(peerIdentity, m.Envelope.Signature, m.Envelope.Payload)
	if payloadSigVerificationErr != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[118], 1);
		return payloadSigVerificationErr
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[113], 1);if m.Envelope.SecretEnvelope != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[119], 1);
		payload := m.Envelope.SecretEnvelope.Payload
		sig := m.Envelope.SecretEnvelope.Signature
		if len(payload) == 0 {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[122], 1);
			return errors.New("Empty payload")
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[120], 1);if len(sig) == 0 {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[123], 1);
			return errors.New("Empty signature")
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[121], 1);return verify(peerIdentity, sig, payload)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[114], 1);return nil
}

// IsSigned returns whether the message
// has a signature in the envelope.
func (m *SignedGossipMessage) IsSigned() bool {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[124], 1);
	return m.Envelope != nil && m.Envelope.Payload != nil && m.Envelope.Signature != nil
}

// ToGossipMessage un-marshals a given envelope and creates a
// SignedGossipMessage out of it.
// Returns an error if un-marshaling fails.
func (e *Envelope) ToGossipMessage() (*SignedGossipMessage, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[125], 1);
	if e == nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[128], 1);
		return nil, errors.New("nil envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[126], 1);msg := &GossipMessage{}
	err := proto.Unmarshal(e.Payload, msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[129], 1);
		return nil, fmt.Errorf("Failed unmarshaling GossipMessage from envelope: %v", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[127], 1);return &SignedGossipMessage{
		GossipMessage: msg,
		Envelope:      e,
	}, nil
}

// SignSecret signs the secret payload and creates
// a secret envelope out of it.
func (e *Envelope) SignSecret(signer Signer, secret *Secret) error {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[130], 1);
	payload, err := proto.Marshal(secret)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[133], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[131], 1);sig, err := signer(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[134], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[132], 1);e.SecretEnvelope = &SecretEnvelope{
		Payload:   payload,
		Signature: sig,
	}
	return nil
}

// InternalEndpoint returns the internal endpoint
// in the secret envelope, or an empty string
// if a failure occurs.
func (s *SecretEnvelope) InternalEndpoint() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[135], 1);
	secret := &Secret{}
	if err := proto.Unmarshal(s.Payload, secret); err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[137], 1);
		return ""
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[136], 1);return secret.GetInternalEndpoint()
}

// SignedGossipMessage contains a GossipMessage
// and the Envelope from which it came from
type SignedGossipMessage struct {
	*Envelope
	*GossipMessage
}

func (p *Payload) toString() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[138], 1);
	return fmt.Sprintf("Block message: {Data: %d bytes, seq: %d}", len(p.Data), p.SeqNum)
}

func (du *DataUpdate) toString() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[139], 1);
	mType := PullMsgType_name[int32(du.MsgType)]
	return fmt.Sprintf("Type: %s, items: %d, nonce: %d", mType, len(du.Data), du.Nonce)
}

func (mr *MembershipResponse) toString() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[140], 1);
	return fmt.Sprintf("MembershipResponse with Alive: %d, Dead: %d", len(mr.Alive), len(mr.Dead))
}

func (sis *StateInfoSnapshot) toString() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[141], 1);
	return fmt.Sprintf("StateInfoSnapshot with %d items", len(sis.Elements))
}

// String returns a string representation
// of a SignedGossipMessage
func (m *SignedGossipMessage) String() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[142], 1);
	env := "No envelope"
	if m.Envelope != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[145], 1);
		var secretEnv string
		if m.SecretEnvelope != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[147], 1);
			pl := len(m.SecretEnvelope.Payload)
			sl := len(m.SecretEnvelope.Signature)
			secretEnv = fmt.Sprintf(" Secret payload: %d bytes, Secret Signature: %d bytes", pl, sl)
		}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[146], 1);env = fmt.Sprintf("%d bytes, Signature: %d bytes%s", len(m.Envelope.Payload), len(m.Envelope.Signature), secretEnv)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[143], 1);gMsg := "No gossipMessage"
	if m.GossipMessage != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[148], 1);
		var isSimpleMsg bool
		if m.GetStateResponse() != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[150], 1);
			gMsg = fmt.Sprintf("StateResponse with %d items", len(m.GetStateResponse().Payloads))
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[151], 1);if m.IsDataMsg() && m.GetDataMsg().Payload != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[152], 1);
			gMsg = m.GetDataMsg().Payload.toString()
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[153], 1);if m.IsDataUpdate() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[154], 1);
			update := m.GetDataUpdate()
			gMsg = fmt.Sprintf("DataUpdate: %s", update.toString())
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[155], 1);if m.GetMemRes() != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[156], 1);
			gMsg = m.GetMemRes().toString()
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[157], 1);if m.IsStateInfoSnapshot() {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[158], 1);
			gMsg = m.GetStateSnapshot().toString()
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[159], 1);if m.GetPrivateRes() != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[160], 1);
			gMsg = m.GetPrivateRes().ToString()
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[161], 1);{
			gMsg = m.GossipMessage.String()
			isSimpleMsg = true
		}}}}}}}
		_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[149], 1);if !isSimpleMsg {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[162], 1);
			desc := fmt.Sprintf("Channel: %s, nonce: %d, tag: %s", string(m.Channel), m.Nonce, GossipMessage_Tag_name[int32(m.Tag)])
			gMsg = fmt.Sprintf("%s %s", desc, gMsg)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[144], 1);return fmt.Sprintf("GossipMessage: %v, Envelope: %s", gMsg, env)
}

func (dd *DataRequest) FormattedDigests() []string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[163], 1);
	if dd.MsgType == PullMsgType_IDENTITY_MSG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[165], 1);
		return digestsToHex(dd.Digests)
	}

	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[164], 1);return digestsAsStrings(dd.Digests)
}

func (dd *DataDigest) FormattedDigests() []string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[166], 1);
	if dd.MsgType == PullMsgType_IDENTITY_MSG {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[168], 1);
		return digestsToHex(dd.Digests)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[167], 1);return digestsAsStrings(dd.Digests)
}

// Hash returns the SHA256 representation of the PvtDataDigest's bytes
func (dig *PvtDataDigest) Hash() (string, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[169], 1);
	b, err := proto.Marshal(dig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[171], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[170], 1);return hex.EncodeToString(util.ComputeSHA256(b)), nil
}

// ToString returns a string representation of this RemotePvtDataResponse
func (res *RemotePvtDataResponse) ToString() string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[172], 1);
	a := make([]string, len(res.Elements))
	for i, el := range res.Elements {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[174], 1);
		a[i] = fmt.Sprintf("%s with %d elements", el.Digest.String(), len(el.Payload))
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[173], 1);return fmt.Sprintf("%v", a)
}

func digestsAsStrings(digests [][]byte) []string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[175], 1);
	a := make([]string, len(digests))
	for i, dig := range digests {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[177], 1);
		a[i] = string(dig)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[176], 1);return a
}

func digestsToHex(digests [][]byte) []string {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[178], 1);
	a := make([]string, len(digests))
	for i, dig := range digests {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[180], 1);
		a[i] = hex.EncodeToString(dig)
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[179], 1);return a
}

// LedgerHeight returns the ledger height that is specified
// in the StateInfo message
func (msg *StateInfo) LedgerHeight() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[181], 1);
	if msg.Properties != nil {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[183], 1);
		return msg.Properties.LedgerHeight, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[182], 1);return 0, errors.New("properties undefined")
}

// Abs returns abs(a-b)
func abs(a, b uint64) uint64 {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[184], 1);
	if a > b {_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[186], 1);
		return a - b
	}
	_cover_atomic_.AddUint32(&GoCover_0_643036306334653135363963.Count[185], 1);return b - a
}

var GoCover_0_643036306334653135363963 = struct {
	Count     [187]uint32
	Pos       [3 * 187]uint32
	NumStmt   [187]uint16
} {
	Pos: [3 * 187]uint32{
		22, 24, 0x20059, // [0]
		30, 31, 0x4c0050, // [1]
		31, 33, 0x3004c, // [2]
		36, 40, 0x32006b, // [3]
		44, 44, 0x300002, // [4]
		48, 48, 0x3a0002, // [5]
		52, 52, 0x380002, // [6]
		56, 56, 0x3c0002, // [7]
		60, 60, 0x1f0002, // [8]
		40, 42, 0x30032, // [9]
		44, 46, 0x30030, // [10]
		48, 50, 0x3003a, // [11]
		52, 54, 0x30038, // [12]
		56, 58, 0x3003c, // [13]
		63, 64, 0x3a007e, // [14]
		67, 67, 0x4a0002, // [15]
		64, 66, 0x3003a, // [16]
		70, 71, 0x3f008d, // [17]
		75, 75, 0x1f0002, // [18]
		71, 73, 0x3003f, // [19]
		78, 79, 0x3e007f, // [20]
		83, 84, 0x2d0002, // [21]
		88, 88, 0x3d0002, // [22]
		91, 91, 0x220002, // [23]
		79, 81, 0x3003e, // [24]
		84, 86, 0x3002d, // [25]
		88, 90, 0x3003d, // [26]
		94, 95, 0x460066, // [27]
		99, 99, 0x400002, // [28]
		95, 97, 0x30046, // [29]
		102, 103, 0x300071, // [30]
		107, 107, 0x400002, // [31]
		103, 105, 0x30030, // [32]
		110, 111, 0x240056, // [33]
		118, 118, 0x230002, // [34]
		121, 121, 0x220002, // [35]
		111, 112, 0x240024, // [36]
		116, 116, 0x230003, // [37]
		112, 114, 0x40024, // [38]
		118, 120, 0x30023, // [39]
		125, 127, 0x2002b, // [40]
		130, 132, 0x2002a, // [41]
		135, 137, 0x2003a, // [42]
		140, 142, 0x20034, // [43]
		145, 147, 0x2002f, // [44]
		151, 154, 0x2002a, // [45]
		157, 159, 0x20035, // [46]
		164, 165, 0x2f0036, // [47]
		169, 169, 0x2d0002, // [48]
		173, 173, 0x2d0002, // [49]
		177, 177, 0x300002, // [50]
		181, 181, 0x1e0002, // [51]
		165, 167, 0x3002f, // [52]
		169, 171, 0x3002d, // [53]
		173, 175, 0x3002d, // [54]
		177, 179, 0x30030, // [55]
		186, 188, 0x20034, // [56]
		192, 194, 0x20030, // [57]
		197, 199, 0x2002e, // [58]
		202, 204, 0x2002a, // [59]
		207, 209, 0x20031, // [60]
		212, 214, 0x20026, // [61]
		217, 219, 0x2002d, // [62]
		222, 224, 0x2002b, // [63]
		227, 229, 0x2002c, // [64]
		232, 234, 0x20030, // [65]
		244, 245, 0x26002c, // [66]
		248, 248, 0x130002, // [67]
		255, 255, 0x440002, // [68]
		262, 262, 0x170002, // [69]
		269, 269, 0x130002, // [70]
		286, 286, 0x700002, // [71]
		293, 293, 0x190002, // [72]
		300, 300, 0x320002, // [73]
		245, 247, 0x30026, // [74]
		248, 249, 0x2a0013, // [75]
		252, 252, 0xd0003, // [76]
		249, 251, 0x4002a, // [77]
		255, 256, 0x230044, // [78]
		259, 259, 0xd0003, // [79]
		256, 258, 0x40023, // [80]
		262, 263, 0x260017, // [81]
		266, 266, 0xd0003, // [82]
		263, 265, 0x40026, // [83]
		269, 270, 0x1d0013, // [84]
		271, 272, 0x2b001e, // [85]
		275, 275, 0xe0004, // [86]
		276, 277, 0x240021, // [87]
		280, 280, 0xe0004, // [88]
		281, 282, 0x5d000b, // [89]
		272, 274, 0x5002b, // [90]
		277, 279, 0x50024, // [91]
		286, 287, 0x290070, // [92]
		290, 290, 0xd0003, // [93]
		287, 289, 0x40029, // [94]
		293, 294, 0x2a0019, // [95]
		297, 297, 0xd0003, // [96]
		294, 296, 0x4002a, // [97]
		350, 352, 0x2002a, // [98]
		365, 369, 0x170046, // [99]
		372, 374, 0x100002, // [100]
		377, 378, 0x100002, // [101]
		382, 388, 0xf0002, // [102]
		369, 371, 0x30017, // [103]
		374, 376, 0x30010, // [104]
		378, 380, 0x30010, // [105]
		392, 393, 0x2d0042, // [106]
		396, 400, 0x120002, // [107]
		393, 395, 0x3002d, // [108]
		405, 406, 0x170052, // [109]
		409, 409, 0x220002, // [110]
		412, 412, 0x240002, // [111]
		415, 416, 0x260002, // [112]
		419, 419, 0x260002, // [113]
		430, 430, 0xc0002, // [114]
		406, 408, 0x30017, // [115]
		409, 411, 0x30022, // [116]
		412, 414, 0x30024, // [117]
		416, 418, 0x30026, // [118]
		419, 422, 0x180026, // [119]
		425, 425, 0x140003, // [120]
		428, 428, 0x2c0003, // [121]
		422, 424, 0x40018, // [122]
		425, 427, 0x40014, // [123]
		435, 437, 0x2002f, // [124]
		442, 443, 0xe0044, // [125]
		446, 448, 0x100002, // [126]
		451, 454, 0x80002, // [127]
		443, 445, 0x3000e, // [128]
		448, 450, 0x30010, // [129]
		459, 461, 0x100044, // [130]
		464, 465, 0x100002, // [131]
		468, 472, 0xc0002, // [132]
		461, 463, 0x30010, // [133]
		465, 467, 0x30010, // [134]
		478, 480, 0x3b0034, // [135]
		483, 483, 0x250002, // [136]
		480, 482, 0x3003b, // [137]
		493, 495, 0x20025, // [138]
		497, 500, 0x20029, // [139]
		502, 504, 0x20031, // [140]
		506, 508, 0x20031, // [141]
		512, 514, 0x17002f, // [142]
		523, 524, 0x1c0002, // [143]
		548, 548, 0x420002, // [144]
		514, 516, 0x1e0017, // [145]
		521, 521, 0x760003, // [146]
		516, 520, 0x4001e, // [147]
		524, 526, 0x22001c, // [148]
		543, 543, 0x130003, // [149]
		526, 528, 0x40022, // [150]
		528, 528, 0x3c0009, // [151]
		528, 530, 0x4003c, // [152]
		530, 530, 0x1e0009, // [153]
		530, 533, 0x4001e, // [154]
		533, 533, 0x220009, // [155]
		533, 535, 0x40022, // [156]
		535, 535, 0x250009, // [157]
		535, 537, 0x40025, // [158]
		537, 537, 0x260009, // [159]
		537, 539, 0x40026, // [160]
		539, 542, 0x40009, // [161]
		543, 546, 0x40013, // [162]
		551, 552, 0x2c0034, // [163]
		556, 556, 0x250002, // [164]
		552, 554, 0x3002c, // [165]
		559, 560, 0x2c0033, // [166]
		563, 563, 0x250002, // [167]
		560, 562, 0x3002c, // [168]
		567, 569, 0x100032, // [169]
		572, 572, 0x370002, // [170]
		569, 571, 0x30010, // [171]
		576, 578, 0x220035, // [172]
		581, 581, 0x1d0002, // [173]
		578, 580, 0x30022, // [174]
		584, 586, 0x1e0032, // [175]
		589, 589, 0xa0002, // [176]
		586, 588, 0x3001e, // [177]
		592, 594, 0x1e002e, // [178]
		597, 597, 0xa0002, // [179]
		594, 596, 0x3001e, // [180]
		602, 603, 0x1b0036, // [181]
		606, 606, 0x2e0002, // [182]
		603, 605, 0x3001b, // [183]
		610, 611, 0xb001e, // [184]
		614, 614, 0xe0002, // [185]
		611, 613, 0x3000b, // [186]
	},
	NumStmt: [187]uint16{
		1, // 0
		1, // 1
		1, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		2, // 99
		3, // 100
		2, // 101
		3, // 102
		1, // 103
		1, // 104
		1, // 105
		1, // 106
		3, // 107
		1, // 108
		1, // 109
		1, // 110
		1, // 111
		2, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		3, // 119
		1, // 120
		1, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		3, // 126
		1, // 127
		1, // 128
		1, // 129
		2, // 130
		2, // 131
		2, // 132
		1, // 133
		1, // 134
		2, // 135
		1, // 136
		1, // 137
		1, // 138
		2, // 139
		1, // 140
		1, // 141
		2, // 142
		2, // 143
		1, // 144
		2, // 145
		1, // 146
		3, // 147
		2, // 148
		1, // 149
		1, // 150
		1, // 151
		1, // 152
		1, // 153
		2, // 154
		1, // 155
		1, // 156
		1, // 157
		1, // 158
		1, // 159
		1, // 160
		2, // 161
		2, // 162
		1, // 163
		1, // 164
		1, // 165
		1, // 166
		1, // 167
		1, // 168
		2, // 169
		1, // 170
		1, // 171
		2, // 172
		1, // 173
		1, // 174
		2, // 175
		1, // 176
		1, // 177
		2, // 178
		1, // 179
		1, // 180
		1, // 181
		1, // 182
		1, // 183
		1, // 184
		1, // 185
		1, // 186
	},
}
var _ = _cover_atomic_.LoadUint32
