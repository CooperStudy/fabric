//line /home/cooper/go/src/github.com/hyperledger/fabric/core/container/inproccontroller/inproccontroller.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package inproccontroller; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/container"
	"github.com/hyperledger/fabric/core/container/ccintf"
	pb "github.com/hyperledger/fabric/protos/peer"
)

// ContainerType is the string which the inproc container type
// is registered with the container.VMController
const ContainerType = "SYSTEM"

type inprocContainer struct {
	ChaincodeSupport ccintf.CCSupport
	chaincode        shim.Chaincode
	running          bool
	args             []string
	env              []string
	stopChan         chan struct{}
}

var (
	inprocLogger = flogging.MustGetLogger("inproccontroller")

	// TODO this is a very hacky way to do testing, we should find other ways
	// to test, or not statically inject these depenencies.
	_shimStartInProc    = shim.StartInProc
	_inprocLoggerErrorf = inprocLogger.Errorf
)

// errors

//SysCCRegisteredErr registered error
type SysCCRegisteredErr string

func (s SysCCRegisteredErr) Error() string {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[0], 1);
	return fmt.Sprintf("%s already registered", string(s))
}

// Registry stores registered system chaincodes.
// It implements container.VMProvider and scc.Registrar
type Registry struct {
	typeRegistry     map[string]*inprocContainer
	instRegistry     map[string]*inprocContainer
	ChaincodeSupport ccintf.CCSupport
}

// NewRegistry creates an initialized registry, ready to register system chaincodes.
// The returned *Registry is _not_ ready to use as is.  You must set the ChaincodeSupport
// as soon as one is available, before any chaincode invocations occur.  This is because
// the chaincode support used to be a latent dependency, snuck in on the context, but now
// it is being made an explicit part of the startup.
func NewRegistry() *Registry {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[1], 1);
	return &Registry{
		typeRegistry: make(map[string]*inprocContainer),
		instRegistry: make(map[string]*inprocContainer),
	}
}

// NewVM creates an inproc VM instance
func (r *Registry) NewVM() container.VM {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[2], 1);
	return NewInprocVM(r)
}

//Register registers system chaincode with given path. The deploy should be called to initialize
func (r *Registry) Register(ccid *ccintf.CCID, cc shim.Chaincode) error {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[3], 1);
	name := ccid.GetName()
	inprocLogger.Debugf("Registering chaincode instance: %s", name)
	tmp := r.typeRegistry[name]
	if tmp != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[5], 1);
		return SysCCRegisteredErr(name)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[4], 1);r.typeRegistry[name] = &inprocContainer{chaincode: cc}
	return nil
}

//InprocVM is a vm. It is identified by a executable name
type InprocVM struct {
	id       string
	registry *Registry
}

// NewInprocVM creates a new InprocVM
func NewInprocVM(r *Registry) *InprocVM {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[6], 1);
	return &InprocVM{
		registry: r,
	}
}

func (vm *InprocVM) getInstance(ipctemplate *inprocContainer, instName string, args []string, env []string) (*inprocContainer, error) {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[7], 1);
	ipc := vm.registry.instRegistry[instName]
	if ipc != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[9], 1);
		inprocLogger.Warningf("chaincode instance exists for %s", instName)
		return ipc, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[8], 1);ipc = &inprocContainer{
		ChaincodeSupport: vm.registry.ChaincodeSupport,
		args:             args,
		env:              env,
		chaincode:        ipctemplate.chaincode,
		stopChan:         make(chan struct{}),
	}
	vm.registry.instRegistry[instName] = ipc
	inprocLogger.Debugf("chaincode instance created for %s", instName)
	return ipc, nil
}

func (ipc *inprocContainer) launchInProc(id string, args []string, env []string) error {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[10], 1);
	if ipc.ChaincodeSupport == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[15], 1);
		inprocLogger.Panicf("Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[11], 1);peerRcvCCSend := make(chan *pb.ChaincodeMessage)
	ccRcvPeerSend := make(chan *pb.ChaincodeMessage)
	var err error
	ccchan := make(chan struct{}, 1)
	ccsupportchan := make(chan struct{}, 1)
	shimStartInProc := _shimStartInProc // shadow to avoid race in test
	go func() {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[16], 1);
		defer close(ccchan)
		inprocLogger.Debugf("chaincode started for %s", id)
		if args == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[20], 1);
			args = ipc.args
		}
		_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[17], 1);if env == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[21], 1);
			env = ipc.env
		}
		_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[18], 1);err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[22], 1);
			err = fmt.Errorf("chaincode-support ended with err: %s", err)
			_inprocLoggerErrorf("%s", err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[19], 1);inprocLogger.Debugf("chaincode ended for %s with err: %s", id, err)
	}()

	// shadow function to avoid data race
	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[12], 1);inprocLoggerErrorf := _inprocLoggerErrorf
	go func() {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[23], 1);
		defer close(ccsupportchan)
		inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)
		inprocLogger.Debugf("chaincode-support started for  %s", id)
		err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[25], 1);
			err = fmt.Errorf("chaincode ended with err: %s", err)
			inprocLoggerErrorf("%s", err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[24], 1);inprocLogger.Debugf("chaincode-support ended for %s with err: %s", id, err)
	}()

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[13], 1);select {
	case <-ccchan:_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[26], 1);
		close(peerRcvCCSend)
		inprocLogger.Debugf("chaincode %s quit", id)
	case <-ccsupportchan:_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[27], 1);
		close(ccRcvPeerSend)
		inprocLogger.Debugf("chaincode support %s quit", id)
	case <-ipc.stopChan:_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[28], 1);
		close(ccRcvPeerSend)
		close(peerRcvCCSend)
		inprocLogger.Debugf("chaincode %s stopped", id)
	}
	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[14], 1);return err
}

//Start starts a previously registered system codechain
func (vm *InprocVM) Start(ccid ccintf.CCID, args []string, env []string, filesToUpload map[string][]byte, builder container.Builder) error {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[29], 1);
	path := ccid.GetName()

	ipctemplate := vm.registry.typeRegistry[path]

	if ipctemplate == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[34], 1);
		return fmt.Errorf(fmt.Sprintf("%s not registered", path))
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[30], 1);instName := vm.GetVMName(ccid)

	ipc, err := vm.getInstance(ipctemplate, instName, args, env)

	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[35], 1);
		return fmt.Errorf(fmt.Sprintf("could not create instance for %s", instName))
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[31], 1);if ipc.running {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[36], 1);
		return fmt.Errorf(fmt.Sprintf("chaincode running %s", path))
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[32], 1);ipc.running = true

	go func() {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[37], 1);
		defer func() {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[39], 1);
			if r := recover(); r != nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[40], 1);
				inprocLogger.Criticalf("caught panic from chaincode  %s", instName)
			}
		}()
		_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[38], 1);ipc.launchInProc(instName, args, env)
	}()

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[33], 1);return nil
}

//Stop stops a system codechain
func (vm *InprocVM) Stop(ccid ccintf.CCID, timeout uint, dontkill bool, dontremove bool) error {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[41], 1);
	path := ccid.GetName()

	ipctemplate := vm.registry.typeRegistry[path]
	if ipctemplate == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[45], 1);
		return fmt.Errorf("%s not registered", path)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[42], 1);instName := vm.GetVMName(ccid)

	ipc := vm.registry.instRegistry[instName]

	if ipc == nil {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[46], 1);
		return fmt.Errorf("%s not found", instName)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[43], 1);if !ipc.running {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[47], 1);
		return fmt.Errorf("%s not running", instName)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[44], 1);ipc.stopChan <- struct{}{}

	delete(vm.registry.instRegistry, instName)
	//TODO stop
	return nil
}

// HealthCheck is provided in order to implement the VMProvider interface.
// It always returns nil..
func (vm *InprocVM) HealthCheck(ctx context.Context) error {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[48], 1);
	return nil
}

// GetVMName ignores the peer and network name as it just needs to be unique in
// process.  It accepts a format function parameter to allow different
// formatting based on the desired use of the name.
func (vm *InprocVM) GetVMName(ccid ccintf.CCID) string {_cover_atomic_.AddUint32(&GoCover_0_626139323335613336336265.Count[49], 1);
	return ccid.GetName()
}

var GoCover_0_626139323335613336336265 = struct {
	Count     [50]uint32
	Pos       [3 * 50]uint32
	NumStmt   [50]uint16
} {
	Pos: [3 * 50]uint32{
		47, 49, 0x2002c, // [0]
		64, 69, 0x2001e, // [1]
		72, 74, 0x20029, // [2]
		77, 81, 0x100049, // [3]
		85, 86, 0xc0002, // [4]
		81, 83, 0x30010, // [5]
		96, 100, 0x20029, // [6]
		102, 104, 0x100087, // [7]
		108, 117, 0x110002, // [8]
		104, 107, 0x30010, // [9]
		120, 121, 0x210058, // [10]
		125, 131, 0xc0002, // [11]
		149, 150, 0xc0002, // [12]
		162, 162, 0x90002, // [13]
		174, 174, 0xc0002, // [14]
		121, 123, 0x30021, // [15]
		131, 134, 0x12000c, // [16]
		137, 137, 0x110003, // [17]
		140, 141, 0x110003, // [18]
		145, 145, 0x460003, // [19]
		134, 136, 0x40012, // [20]
		137, 139, 0x40011, // [21]
		141, 144, 0x40011, // [22]
		150, 155, 0x11000c, // [23]
		159, 159, 0x4e0003, // [24]
		155, 158, 0x40011, // [25]
		163, 165, 0x2f0010, // [26]
		166, 168, 0x370017, // [27]
		169, 172, 0x320016, // [28]
		178, 183, 0x18008c, // [29]
		187, 191, 0x100002, // [30]
		195, 195, 0x110002, // [31]
		199, 201, 0xc0002, // [32]
		210, 210, 0xc0002, // [33]
		183, 185, 0x30018, // [34]
		191, 193, 0x30010, // [35]
		195, 197, 0x30011, // [36]
		201, 202, 0x10000c, // [37]
		207, 207, 0x280003, // [38]
		202, 203, 0x200010, // [39]
		203, 205, 0x50020, // [40]
		214, 218, 0x180060, // [41]
		222, 226, 0x100002, // [42]
		230, 230, 0x120002, // [43]
		234, 238, 0xc0002, // [44]
		218, 220, 0x30018, // [45]
		226, 228, 0x30010, // [46]
		230, 232, 0x30012, // [47]
		243, 245, 0x2003c, // [48]
		250, 252, 0x20038, // [49]
	},
	NumStmt: [50]uint16{
		1, // 0
		1, // 1
		1, // 2
		4, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		4, // 8
		2, // 9
		1, // 10
		7, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		2, // 22
		5, // 23
		1, // 24
		2, // 25
		2, // 26
		2, // 27
		3, // 28
		3, // 29
		3, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		3, // 41
		3, // 42
		1, // 43
		3, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
	},
}
var _ = _cover_atomic_.LoadUint32
