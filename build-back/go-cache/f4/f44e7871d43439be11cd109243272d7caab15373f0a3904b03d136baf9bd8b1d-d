//line /home/cooper/go/src/github.com/hyperledger/fabric/core/deliverservice/client.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package deliverclient; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"sync/atomic"
	"time"

	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/core/deliverservice/blocksprovider"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/orderer"
	"google.golang.org/grpc"
)

// broadcastSetup is a function that is called by the broadcastClient immediately after each
// successful connection to the ordering service
type broadcastSetup func(blocksprovider.BlocksDeliverer) error

// retryPolicy receives as parameters the number of times the attempt has failed
// and a duration that specifies the total elapsed time passed since the first attempt.
// If further attempts should be made, it returns:
// 	- a time duration after which the next attempt would be made, true
// Else, a zero duration, false
type retryPolicy func(attemptNum int, elapsedTime time.Duration) (time.Duration, bool)

// clientFactory creates a gRPC broadcast client out of a ClientConn
type clientFactory func(*grpc.ClientConn) orderer.AtomicBroadcastClient

type broadcastClient struct {
	stopFlag     int32
	stopChan     chan struct{}
	createClient clientFactory
	shouldRetry  retryPolicy
	onConnect    broadcastSetup
	prod         comm.ConnectionProducer

	mutex           sync.Mutex
	blocksDeliverer blocksprovider.BlocksDeliverer
	conn            *connection
	endpoint        string
}

// NewBroadcastClient returns a broadcastClient with the given params
func NewBroadcastClient(prod comm.ConnectionProducer, clFactory clientFactory, onConnect broadcastSetup, bos retryPolicy) *broadcastClient {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[0], 1);
	return &broadcastClient{prod: prod, onConnect: onConnect, shouldRetry: bos, createClient: clFactory, stopChan: make(chan struct{}, 1)}
}

// Recv receives a message from the ordering service
func (bc *broadcastClient) Recv() (*orderer.DeliverResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[1], 1);
	o, err := bc.try(func() (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[4], 1);
		if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[6], 1);
			return nil, errors.New("closing")
		}
		_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[5], 1);return bc.tryReceive()
	})
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[2], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[7], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[3], 1);return o.(*orderer.DeliverResponse), nil
}

// Send sends a message to the ordering service
func (bc *broadcastClient) Send(msg *common.Envelope) error {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[8], 1);
	_, err := bc.try(func() (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[10], 1);
		if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[12], 1);
			return nil, errors.New("closing")
		}
		_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[11], 1);return bc.trySend(msg)
	})
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[9], 1);return err
}

func (bc *broadcastClient) trySend(msg *common.Envelope) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[13], 1);
	bc.mutex.Lock()
	stream := bc.blocksDeliverer
	bc.mutex.Unlock()
	if stream == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[15], 1);
		return nil, errors.New("client stream has been closed")
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[14], 1);return nil, stream.Send(msg)
}

func (bc *broadcastClient) tryReceive() (*orderer.DeliverResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[16], 1);
	bc.mutex.Lock()
	stream := bc.blocksDeliverer
	bc.mutex.Unlock()
	if stream == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[18], 1);
		return nil, errors.New("client stream has been closed")
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[17], 1);return stream.Recv()
}

func (bc *broadcastClient) try(action func() (interface{}, error)) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[19], 1);
	attempt := 0
	var totalRetryTime time.Duration
	var backoffDuration time.Duration
	retry := true
	resetAttemptCounter := func() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[23], 1);
		attempt = 0
		totalRetryTime = 0
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[20], 1);for retry && !bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[24], 1);
		resp, err := bc.doAction(action, resetAttemptCounter)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[26], 1);
			attempt++
			backoffDuration, retry = bc.shouldRetry(attempt, totalRetryTime)
			if !retry {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[28], 1);
				logger.Warning("Got error:", err, "at", attempt, "attempt. Ceasing to retry")
				break
			}
			_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[27], 1);logger.Warning("Got error:", err, ", at", attempt, "attempt. Retrying in", backoffDuration)
			totalRetryTime += backoffDuration
			bc.sleep(backoffDuration)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[25], 1);return resp, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[21], 1);if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[29], 1);
		return nil, errors.New("client is closing")
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[22], 1);return nil, fmt.Errorf("attempts (%d) or elapsed time (%v) exhausted", attempt, totalRetryTime)
}

func (bc *broadcastClient) doAction(action func() (interface{}, error), actionOnNewConnection func()) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[30], 1);
	bc.mutex.Lock()
	conn := bc.conn
	bc.mutex.Unlock()
	if conn == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[33], 1);
		err := bc.connect()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[35], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[34], 1);actionOnNewConnection()
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[31], 1);resp, err := action()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[36], 1);
		bc.Disconnect(false)
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[32], 1);return resp, nil
}

func (bc *broadcastClient) sleep(duration time.Duration) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[37], 1);
	select {
	case <-time.After(duration):_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[38], 1);
	case <-bc.stopChan:_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[39], 1);
	}
}

func (bc *broadcastClient) connect() error {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[40], 1);
	bc.mutex.Lock()
	bc.endpoint = ""
	bc.mutex.Unlock()
	conn, endpoint, err := bc.prod.NewConnection()
	logger.Debug("Connected to", endpoint)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[44], 1);
		logger.Error("Failed obtaining connection:", err)
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[41], 1);ctx, cf := context.WithCancel(context.Background())
	logger.Debug("Establishing gRPC stream with", endpoint, "...")
	abc, err := bc.createClient(conn).Deliver(ctx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[45], 1);
		logger.Error("Connection to ", endpoint, "established but was unable to create gRPC stream:", err)
		conn.Close()
		cf()
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[42], 1);err = bc.afterConnect(conn, abc, cf, endpoint)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[46], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[43], 1);logger.Warning("Failed running post-connection procedures:", err)
	// If we reached here, lets make sure connection is closed
	// and nullified before we return
	bc.Disconnect(false)
	return err
}

func (bc *broadcastClient) afterConnect(conn *grpc.ClientConn, abc orderer.AtomicBroadcast_DeliverClient, cf context.CancelFunc, endpoint string) error {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[47], 1);
	logger.Debug("Entering")
	defer logger.Debug("Exiting")
	bc.mutex.Lock()
	bc.endpoint = endpoint
	bc.conn = &connection{ClientConn: conn, cancel: cf}
	bc.blocksDeliverer = abc
	if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[51], 1);
		bc.mutex.Unlock()
		return errors.New("closing")
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[48], 1);bc.mutex.Unlock()
	// If the client is closed at this point- before onConnect,
	// any use of this object by onConnect would return an error.
	err := bc.onConnect(bc)
	// If the client is closed right after onConnect, but before
	// the following lock- this method would return an error because
	// the client has been closed.
	bc.mutex.Lock()
	defer bc.mutex.Unlock()
	if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[52], 1);
		return errors.New("closing")
	}
	// If the client is closed right after this method exits,
	// it's because this method returned nil and not an error.
	// So- connect() would return nil also, and the flow of the goroutine
	// is returned to doAction(), where action() is invoked - and is configured
	// to check whether the client has closed or not.
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[49], 1);if err == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[53], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[50], 1);logger.Error("Failed setting up broadcast:", err)
	return err
}

func (bc *broadcastClient) shouldStop() bool {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[54], 1);
	return atomic.LoadInt32(&bc.stopFlag) == int32(1)
}

// Close makes the client close its connection and shut down
func (bc *broadcastClient) Close() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[55], 1);
	logger.Debug("Entering")
	defer logger.Debug("Exiting")
	bc.mutex.Lock()
	defer bc.mutex.Unlock()
	if bc.shouldStop() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[58], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[56], 1);atomic.StoreInt32(&bc.stopFlag, int32(1))
	bc.stopChan <- struct{}{}
	if bc.conn == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[59], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[57], 1);bc.endpoint = ""
	bc.conn.Close()
}

// Disconnect makes the client close the existing connection and makes current endpoint unavailable for time interval, if disableEndpoint set to true
func (bc *broadcastClient) Disconnect(disableEndpoint bool) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[60], 1);
	logger.Debug("Entering")
	defer logger.Debug("Exiting")
	bc.mutex.Lock()
	defer bc.mutex.Unlock()
	if disableEndpoint && bc.endpoint != "" {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[63], 1);
		bc.prod.DisableEndpoint(bc.endpoint)
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[61], 1);bc.endpoint = ""
	if bc.conn == nil {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[64], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[62], 1);bc.conn.Close()
	bc.conn = nil
	bc.blocksDeliverer = nil
}

// UpdateEndpoints update endpoints to new values
func (bc *broadcastClient) UpdateEndpoints(endpoints []string) {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[65], 1);
	bc.prod.UpdateEndpoints(endpoints)
}

// GetEndpoints returns ordering service endpoints
func (bc *broadcastClient) GetEndpoints() []string {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[66], 1);
	return bc.prod.GetEndpoints()
}

type connection struct {
	sync.Once
	*grpc.ClientConn
	cancel context.CancelFunc
}

func (c *connection) Close() error {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[67], 1);
	var err error
	c.Once.Do(func() {_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[69], 1);
		c.cancel()
		err = c.ClientConn.Close()
	})
	_cover_atomic_.AddUint32(&GoCover_0_663237323366386536623539.Count[68], 1);return err
}

var GoCover_0_663237323366386536623539 = struct {
	Count     [70]uint32
	Pos       [3 * 70]uint32
	NumStmt   [70]uint16
} {
	Pos: [3 * 70]uint32{
		53, 55, 0x2008c, // [0]
		58, 59, 0x2f0045, // [1]
		65, 65, 0x100002, // [2]
		68, 68, 0x2a0002, // [3]
		59, 60, 0x16002f, // [4]
		63, 63, 0x190003, // [5]
		60, 62, 0x40016, // [6]
		65, 67, 0x30010, // [7]
		72, 73, 0x2f003d, // [8]
		79, 79, 0xc0002, // [9]
		73, 74, 0x16002f, // [10]
		77, 77, 0x190003, // [11]
		74, 76, 0x40016, // [12]
		82, 86, 0x13004f, // [13]
		89, 89, 0x1e0002, // [14]
		86, 88, 0x30013, // [15]
		92, 96, 0x13004b, // [16]
		99, 99, 0x160002, // [17]
		96, 98, 0x30013, // [18]
		102, 107, 0x200059, // [19]
		111, 111, 0x200002, // [20]
		127, 127, 0x150002, // [21]
		130, 130, 0x610002, // [22]
		107, 110, 0x30020, // [23]
		111, 113, 0x110020, // [24]
		125, 125, 0x130003, // [25]
		113, 116, 0xe0011, // [26]
		120, 123, 0xc0004, // [27]
		116, 118, 0xa000e, // [28]
		127, 129, 0x30015, // [29]
		133, 137, 0x11007c, // [30]
		144, 145, 0x100002, // [31]
		149, 149, 0x120002, // [32]
		137, 139, 0x110011, // [33]
		142, 142, 0x1a0003, // [34]
		139, 141, 0x40011, // [35]
		145, 148, 0x30010, // [36]
		152, 153, 0x9003a, // [37]
		154, 154, 0x1e001e, // [38]
		155, 155, 0x150015, // [39]
		159, 165, 0x10002c, // [40]
		169, 172, 0x100002, // [41]
		178, 179, 0x100002, // [42]
		182, 186, 0xc0002, // [43]
		165, 168, 0x30010, // [44]
		172, 177, 0x30010, // [45]
		179, 181, 0x30010, // [46]
		189, 196, 0x150099, // [47]
		200, 209, 0x150002, // [48]
		217, 217, 0x100002, // [49]
		220, 221, 0xc0002, // [50]
		196, 199, 0x30015, // [51]
		209, 211, 0x30015, // [52]
		217, 219, 0x30010, // [53]
		224, 226, 0x2002e, // [54]
		229, 234, 0x150024, // [55]
		237, 239, 0x140002, // [56]
		242, 243, 0x110002, // [57]
		234, 236, 0x30015, // [58]
		239, 241, 0x30014, // [59]
		247, 252, 0x2a003d, // [60]
		255, 256, 0x140002, // [61]
		259, 261, 0x1a0002, // [62]
		252, 254, 0x3002a, // [63]
		256, 258, 0x30014, // [64]
		265, 267, 0x20040, // [65]
		270, 272, 0x20034, // [66]
		280, 282, 0x130024, // [67]
		286, 286, 0xc0002, // [68]
		282, 285, 0x30013, // [69]
	},
	NumStmt: [70]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		4, // 13
		1, // 14
		1, // 15
		4, // 16
		1, // 17
		1, // 18
		5, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		3, // 26
		4, // 27
		2, // 28
		1, // 29
		4, // 30
		2, // 31
		1, // 32
		2, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		0, // 38
		0, // 39
		6, // 40
		4, // 41
		2, // 42
		3, // 43
		2, // 44
		4, // 45
		1, // 46
		7, // 47
		5, // 48
		1, // 49
		2, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		5, // 55
		3, // 56
		2, // 57
		1, // 58
		1, // 59
		5, // 60
		2, // 61
		3, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		2, // 67
		1, // 68
		2, // 69
	},
}
var _ = _cover_atomic_.LoadUint32
