//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/endorsement/collection.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package endorsement; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/gossip/api"
	. "github.com/hyperledger/fabric/protos/discovery"
	"github.com/pkg/errors"
)

func principalsFromCollectionConfig(configBytes []byte) (principalSetsByCollectionName, error) {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[0], 1);
	principalSetsByCollections := make(principalSetsByCollectionName)
	if len(configBytes) == 0 {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[4], 1);
		return principalSetsByCollections, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[1], 1);ccp, err := privdata.ParseCollectionConfig(configBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[5], 1);
		return nil, errors.Wrapf(err, "invalid collection bytes")
	}
	_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[2], 1);for _, colConfig := range ccp.Config {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[6], 1);
		staticCol := colConfig.GetStaticCollectionConfig()
		if staticCol == nil {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[11], 1);
			// Right now we only support static collections, so if we got something else
			// we should refuse to process further
			return nil, errors.Errorf("expected a static collection but got %v instead", colConfig)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[7], 1);if staticCol.MemberOrgsPolicy == nil {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[12], 1);
			return nil, errors.Errorf("MemberOrgsPolicy of %s is nil", staticCol.Name)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[8], 1);pol := staticCol.MemberOrgsPolicy.GetSignaturePolicy()
		if pol == nil {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[13], 1);
			return nil, errors.Errorf("policy of %s is nil", staticCol.Name)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[9], 1);var principals policies.PrincipalSet
		// We now extract all principals from the policy
		for _, principal := range pol.Identities {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[14], 1);
			principals = append(principals, principal)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[10], 1);principalSetsByCollections[staticCol.Name] = principals
	}
	_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[3], 1);return principalSetsByCollections, nil
}

type principalSetsByCollectionName map[string]policies.PrincipalSet

// toIdentityFilter converts this principalSetsByCollectionName mapping to a filter
// which accepts or rejects identities of peers.
func (psbc principalSetsByCollectionName) toIdentityFilter(channel string, evaluator principalEvaluator, cc *ChaincodeCall) (identityFilter, error) {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[15], 1);
	var principalSets policies.PrincipalSets
	for _, col := range cc.CollectionNames {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[17], 1);
		// Each collection we're interested in should exist in the principalSetsByCollectionName mapping.
		// Otherwise, we have no way of computing a filter because we can't locate the principals the peer identities
		// need to satisfy.
		principalSet, exists := psbc[col]
		if !exists {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[19], 1);
			return nil, errors.Errorf("collection %s doesn't exist in collection config for chaincode %s", col, cc.Name)
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[18], 1);principalSets = append(principalSets, principalSet)
	}
	_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[16], 1);return filterForPrincipalSets(channel, evaluator, principalSets), nil
}

// filterForPrincipalSets creates a filter of peer identities out of the given PrincipalSets
func filterForPrincipalSets(channel string, evaluator principalEvaluator, sets policies.PrincipalSets) identityFilter {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[20], 1);
	return func(identity api.PeerIdentityType) bool {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[21], 1);
		// Iterate over all principal sets and ensure each principal set
		// authorizes the identity.
		for _, principalSet := range sets {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[23], 1);
			if !isIdentityAuthorizedByPrincipalSet(channel, evaluator, principalSet, identity) {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[24], 1);
				return false
			}
		}
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[22], 1);return true
	}
}

// isIdentityAuthorizedByPrincipalSet returns whether the given identity satisfies some principal out of the given PrincipalSet
func isIdentityAuthorizedByPrincipalSet(channel string, evaluator principalEvaluator, principalSet policies.PrincipalSet, identity api.PeerIdentityType) bool {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[25], 1);
	// We look for a principal which authorizes the identity
	// among all principals in the principalSet
	for _, principal := range principalSet {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[27], 1);
		err := evaluator.SatisfiesPrincipal(channel, identity, principal)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[29], 1);
			continue
		}
		// Else, err is nil, so we found a principal which authorized
		// the given identity.
		_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[28], 1);return true
	}
	_cover_atomic_.AddUint32(&GoCover_0_373735616263316337623136.Count[26], 1);return false
}

var GoCover_0_373735616263316337623136 = struct {
	Count     [30]uint32
	Pos       [3 * 30]uint32
	NumStmt   [30]uint16
} {
	Pos: [3 * 30]uint32{
		17, 19, 0x1b0060, // [0]
		22, 23, 0x100002, // [1]
		26, 26, 0x270002, // [2]
		47, 47, 0x280002, // [3]
		19, 21, 0x3001b, // [4]
		23, 25, 0x30010, // [5]
		26, 28, 0x170027, // [6]
		33, 33, 0x280003, // [7]
		36, 37, 0x110003, // [8]
		40, 42, 0x2c0003, // [9]
		45, 45, 0x3a0003, // [10]
		28, 32, 0x40017, // [11]
		33, 35, 0x40028, // [12]
		37, 39, 0x40011, // [13]
		42, 44, 0x4002c, // [14]
		54, 56, 0x290095, // [15]
		66, 66, 0x470002, // [16]
		56, 61, 0xe0029, // [17]
		64, 64, 0x360003, // [18]
		61, 63, 0x4000e, // [19]
		70, 71, 0x320077, // [20]
		71, 74, 0x250032, // [21]
		79, 79, 0xe0003, // [22]
		74, 75, 0x570025, // [23]
		75, 77, 0x50057, // [24]
		84, 87, 0x29009f, // [25]
		96, 96, 0xe0002, // [26]
		87, 89, 0x110029, // [27]
		94, 94, 0xe0003, // [28]
		89, 90, 0xc0011, // [29]
	},
	NumStmt: [30]uint16{
		2, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
	},
}
var _ = _cover_atomic_.LoadUint32
