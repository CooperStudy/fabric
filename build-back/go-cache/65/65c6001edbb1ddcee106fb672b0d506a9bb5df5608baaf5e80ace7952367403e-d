//line /home/cooper/go/src/github.com/hyperledger/fabric/common/viperutil/config_util.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package viperutil; import _cover_atomic_ "sync/atomic"

import (
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"math"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/Shopify/sarama"
	version "github.com/hashicorp/go-version"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/mitchellh/mapstructure"
	"github.com/spf13/viper"
)

var logger = flogging.MustGetLogger("viperutil")

type viperGetter func(key string) interface{}

func getKeysRecursively(base string, getKey viperGetter, nodeKeys map[string]interface{}) map[string]interface{} {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[0], 1);
	result := make(map[string]interface{})
	for key := range nodeKeys {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[2], 1);
		fqKey := base + key
		val := getKey(fqKey)
		if m, ok := val.(map[interface{}]interface{}); ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[3], 1);
			logger.Debugf("Found map[interface{}]interface{} value for %s", fqKey)
			tmp := make(map[string]interface{})
			for ik, iv := range m {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[5], 1);
				cik, ok := ik.(string)
				if !ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[7], 1);
					panic("Non string key-entry")
				}
				_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[6], 1);tmp[cik] = iv
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[4], 1);result[key] = getKeysRecursively(fqKey+".", getKey, tmp)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[8], 1);if m, ok := val.(map[string]interface{}); ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[9], 1);
			logger.Debugf("Found map[string]interface{} value for %s", fqKey)
			result[key] = getKeysRecursively(fqKey+".", getKey, m)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[10], 1);if m, ok := unmarshalJSON(val); ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[11], 1);
			logger.Debugf("Found real value for %s setting to map[string]string %v", fqKey, m)
			result[key] = m
		} else{ _cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[12], 1);{
			if val == nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[14], 1);
				fileSubKey := fqKey + ".File"
				fileVal := getKey(fileSubKey)
				if fileVal != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[15], 1);
					result[key] = map[string]interface{}{"File": fileVal}
					continue
				}
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[13], 1);logger.Debugf("Found real value for %s setting to %T %v", fqKey, val, val)
			result[key] = val

		}}}}
	}
	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[1], 1);return result
}

func unmarshalJSON(val interface{}) (map[string]string, bool) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[16], 1);
	mp := map[string]string{}
	s, ok := val.(string)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[19], 1);
		logger.Debugf("Unmarshal JSON: value is not a string: %v", val)
		return nil, false
	}
	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[17], 1);err := json.Unmarshal([]byte(s), &mp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[20], 1);
		logger.Debugf("Unmarshal JSON: value cannot be unmarshalled: %s", err)
		return nil, false
	}
	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[18], 1);return mp, true
}

// customDecodeHook adds the additional functions of parsing durations from strings
// as well as parsing strings of the format "[thing1, thing2, thing3]" into string slices
// Note that whitespace around slice elements is removed
func customDecodeHook() mapstructure.DecodeHookFunc {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[21], 1);
	durationHook := mapstructure.StringToTimeDurationHookFunc()
	return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[22], 1);
		dur, err := mapstructure.DecodeHookExec(durationHook, f, t, data)
		if err == nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[26], 1);
			if _, ok := dur.(time.Duration); ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[27], 1);
				return dur, nil
			}
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[23], 1);if f.Kind() != reflect.String {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[28], 1);
			return data, nil
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[24], 1);raw := data.(string)
		l := len(raw)
		if l > 1 && raw[0] == '[' && raw[l-1] == ']' {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[29], 1);
			slice := strings.Split(raw[1:l-1], ",")
			for i, v := range slice {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[31], 1);
				slice[i] = strings.TrimSpace(v)
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[30], 1);return slice, nil
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[25], 1);return data, nil
	}
}

func byteSizeDecodeHook() mapstructure.DecodeHookFunc {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[32], 1);
	return func(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[33], 1);
		if f != reflect.String || t != reflect.Uint32 {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[37], 1);
			return data, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[34], 1);raw := data.(string)
		if raw == "" {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[38], 1);
			return data, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[35], 1);var re = regexp.MustCompile(`^(?P<size>[0-9]+)\s*(?i)(?P<unit>(k|m|g))b?$`)
		if re.MatchString(raw) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[39], 1);
			size, err := strconv.ParseUint(re.ReplaceAllString(raw, "${size}"), 0, 64)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[43], 1);
				return data, nil
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[40], 1);unit := re.ReplaceAllString(raw, "${unit}")
			switch strings.ToLower(unit) {
			case "g":_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[44], 1);
				size = size << 10
				fallthrough
			case "m":_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[45], 1);
				size = size << 10
				fallthrough
			case "k":_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[46], 1);
				size = size << 10
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[41], 1);if size > math.MaxUint32 {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[47], 1);
				return size, fmt.Errorf("value '%s' overflows uint32", raw)
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[42], 1);return size, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[36], 1);return data, nil
	}
}

func stringFromFileDecodeHook() mapstructure.DecodeHookFunc {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[48], 1);
	return func(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[49], 1);
		// "to" type should be string
		if t != reflect.String {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[53], 1);
			return data, nil
		}
		// "from" type should be map
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[50], 1);if f != reflect.Map {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[54], 1);
			return data, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[51], 1);v := reflect.ValueOf(data)
		switch v.Kind() {
		case reflect.String:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[55], 1);
			return data, nil
		case reflect.Map:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[56], 1);
			d := data.(map[string]interface{})
			fileName, ok := d["File"]
			if !ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[58], 1);
				fileName, ok = d["file"]
			}
			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[57], 1);switch {
			case ok && fileName != nil:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[59], 1);
				bytes, err := ioutil.ReadFile(fileName.(string))
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[62], 1);
					return data, err
				}
				_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[60], 1);return string(bytes), nil
			case ok:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[61], 1);
				// fileName was nil
				return nil, fmt.Errorf("Value of File: was nil")
			}
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[52], 1);return data, nil
	}
}

func pemBlocksFromFileDecodeHook() mapstructure.DecodeHookFunc {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[63], 1);
	return func(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[64], 1);
		// "to" type should be string
		if t != reflect.Slice {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[68], 1);
			return data, nil
		}
		// "from" type should be map
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[65], 1);if f != reflect.Map {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[69], 1);
			return data, nil
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[66], 1);v := reflect.ValueOf(data)
		switch v.Kind() {
		case reflect.String:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[70], 1);
			return data, nil
		case reflect.Map:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[71], 1);
			var fileName string
			var ok bool
			switch d := data.(type) {
			case map[string]string:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[73], 1);
				fileName, ok = d["File"]
				if !ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[76], 1);
					fileName, ok = d["file"]
				}
			case map[string]interface{}:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[74], 1);
				var fileI interface{}
				fileI, ok = d["File"]
				if !ok {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[77], 1);
					fileI, _ = d["file"]
				}
				_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[75], 1);fileName, ok = fileI.(string)
			}

			_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[72], 1);switch {
			case ok && fileName != "":_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[78], 1);
				var result []string
				bytes, err := ioutil.ReadFile(fileName)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[82], 1);
					return data, err
				}
				_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[79], 1);for len(bytes) > 0 {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[83], 1);
					var block *pem.Block
					block, bytes = pem.Decode(bytes)
					if block == nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[86], 1);
						break
					}
					_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[84], 1);if block.Type != "CERTIFICATE" || len(block.Headers) != 0 {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[87], 1);
						continue
					}
					_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[85], 1);result = append(result, string(pem.EncodeToMemory(block)))
				}
				_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[80], 1);return result, nil
			case ok:_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[81], 1);
				// fileName was nil
				return nil, fmt.Errorf("Value of File: was nil")
			}
		}
		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[67], 1);return data, nil
	}
}

var kafkaVersionConstraints map[sarama.KafkaVersion]version.Constraints

func init() {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[88], 1);
	kafkaVersionConstraints = make(map[sarama.KafkaVersion]version.Constraints)
	kafkaVersionConstraints[sarama.V0_8_2_0], _ = version.NewConstraint(">=0.8.2,<0.8.2.1")
	kafkaVersionConstraints[sarama.V0_8_2_1], _ = version.NewConstraint(">=0.8.2.1,<0.8.2.2")
	kafkaVersionConstraints[sarama.V0_8_2_2], _ = version.NewConstraint(">=0.8.2.2,<0.9.0.0")
	kafkaVersionConstraints[sarama.V0_9_0_0], _ = version.NewConstraint(">=0.9.0.0,<0.9.0.1")
	kafkaVersionConstraints[sarama.V0_9_0_1], _ = version.NewConstraint(">=0.9.0.1,<0.10.0.0")
	kafkaVersionConstraints[sarama.V0_10_0_0], _ = version.NewConstraint(">=0.10.0.0,<0.10.0.1")
	kafkaVersionConstraints[sarama.V0_10_0_1], _ = version.NewConstraint(">=0.10.0.1,<0.10.1.0")
	kafkaVersionConstraints[sarama.V0_10_1_0], _ = version.NewConstraint(">=0.10.1.0,<0.10.2.0")
	kafkaVersionConstraints[sarama.V0_10_2_0], _ = version.NewConstraint(">=0.10.2.0,<0.11.0.0")
	kafkaVersionConstraints[sarama.V0_11_0_0], _ = version.NewConstraint(">=0.11.0.0,<1.0.0")
	kafkaVersionConstraints[sarama.V1_0_0_0], _ = version.NewConstraint(">=1.0.0")
}

func kafkaVersionDecodeHook() mapstructure.DecodeHookFunc {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[89], 1);
	return func(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[90], 1);
		if f.Kind() != reflect.String || t != reflect.TypeOf(sarama.KafkaVersion{}) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[94], 1);
			return data, nil
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[91], 1);v, err := version.NewVersion(data.(string))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[95], 1);
			return nil, fmt.Errorf("Unable to parse Kafka version: %s", err)
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[92], 1);for kafkaVersion, constraints := range kafkaVersionConstraints {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[96], 1);
			if constraints.Check(v) {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[97], 1);
				return kafkaVersion, nil
			}
		}

		_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[93], 1);return nil, fmt.Errorf("Unsupported Kafka version: '%s'", data)
	}
}

// EnhancedExactUnmarshal is intended to unmarshal a config file into a structure
// producing error when extraneous variables are introduced and supporting
// the time.Duration type
func EnhancedExactUnmarshal(v *viper.Viper, output interface{}) error {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[98], 1);
	// AllKeys doesn't actually return all keys, it only returns the base ones
	baseKeys := v.AllSettings()
	getterWithClass := func(key string) interface{} {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[101], 1); return v.Get(key) } // hide receiver
	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[99], 1);leafKeys := getKeysRecursively("", getterWithClass, baseKeys)

	logger.Debugf("%+v", leafKeys)
	config := &mapstructure.DecoderConfig{
		ErrorUnused:      true,
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			customDecodeHook(),
			byteSizeDecodeHook(),
			stringFromFileDecodeHook(),
			pemBlocksFromFileDecodeHook(),
			kafkaVersionDecodeHook(),
		),
	}

	decoder, err := mapstructure.NewDecoder(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[102], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[100], 1);return decoder.Decode(leafKeys)
}

// EnhancedExactUnmarshalKey is intended to unmarshal a config file subtreee into a structure
func EnhancedExactUnmarshalKey(baseKey string, output interface{}) error {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[103], 1);
	m := make(map[string]interface{})
	m[baseKey] = nil
	leafKeys := getKeysRecursively("", viper.Get, m)

	logger.Debugf("%+v", leafKeys)

	config := &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
	}

	decoder, err := mapstructure.NewDecoder(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[105], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[104], 1);return decoder.Decode(leafKeys[baseKey])
}

// Decode is used to decode opaque field in configuration
func Decode(input interface{}, output interface{}) error {_cover_atomic_.AddUint32(&GoCover_0_316461623139613838346664.Count[106], 1);
	return mapstructure.Decode(input, output)
}

var GoCover_0_316461623139613838346664 = struct {
	Count     [107]uint32
	Pos       [3 * 107]uint32
	NumStmt   [107]uint16
} {
	Pos: [3 * 107]uint32{
		32, 34, 0x1c0072, // [0]
		68, 68, 0xf0002, // [1]
		34, 37, 0x35001c, // [2]
		37, 40, 0x1a0035, // [3]
		47, 47, 0x3c0004, // [4]
		40, 42, 0xc001a, // [5]
		45, 45, 0x120005, // [6]
		42, 43, 0x23000c, // [7]
		48, 48, 0x370009, // [8]
		48, 51, 0x40037, // [9]
		51, 51, 0x2d0009, // [10]
		51, 54, 0x4002d, // [11]
		54, 55, 0x120009, // [12]
		63, 64, 0x150004, // [13]
		55, 58, 0x170012, // [14]
		58, 60, 0xe0017, // [15]
		71, 74, 0x9003f, // [16]
		78, 79, 0x100002, // [17]
		83, 83, 0x110002, // [18]
		74, 77, 0x30009, // [19]
		79, 82, 0x30010, // [20]
		89, 91, 0x550035, // [21]
		91, 93, 0x110055, // [22]
		99, 99, 0x210003, // [23]
		103, 105, 0x300003, // [24]
		113, 113, 0x130003, // [25]
		93, 94, 0x280011, // [26]
		94, 96, 0x50028, // [27]
		99, 101, 0x40021, // [28]
		105, 107, 0x1c0030, // [29]
		110, 110, 0x150004, // [30]
		107, 109, 0x5001c, // [31]
		117, 118, 0x550037, // [32]
		118, 119, 0x310055, // [33]
		122, 123, 0x100003, // [34]
		126, 127, 0x1a0003, // [35]
		148, 148, 0x130003, // [36]
		119, 121, 0x40031, // [37]
		123, 125, 0x40010, // [38]
		127, 129, 0x12001a, // [39]
		132, 133, 0x210004, // [40]
		143, 143, 0x1d0004, // [41]
		146, 146, 0x140004, // [42]
		129, 131, 0x50012, // [43]
		134, 136, 0x10000d, // [44]
		137, 139, 0x10000d, // [45]
		140, 141, 0x16000d, // [46]
		143, 145, 0x5001d, // [47]
		152, 153, 0x55003d, // [48]
		153, 155, 0x1a0055, // [49]
		159, 159, 0x170003, // [50]
		162, 163, 0x130003, // [51]
		184, 184, 0x130003, // [52]
		155, 157, 0x4001a, // [53]
		159, 161, 0x40017, // [54]
		164, 165, 0x140017, // [55]
		166, 169, 0xb0014, // [56]
		172, 172, 0xb0004, // [57]
		169, 171, 0x5000b, // [58]
		173, 175, 0x13001f, // [59]
		178, 178, 0x1e0005, // [60]
		179, 181, 0x35000c, // [61]
		175, 177, 0x60013, // [62]
		188, 189, 0x550040, // [63]
		189, 191, 0x190055, // [64]
		195, 195, 0x170003, // [65]
		198, 199, 0x130003, // [66]
		244, 244, 0x130003, // [67]
		191, 193, 0x40019, // [68]
		195, 197, 0x40017, // [69]
		200, 201, 0x140017, // [70]
		202, 205, 0x1c0014, // [71]
		220, 220, 0xb0004, // [72]
		206, 208, 0xc001b, // [73]
		211, 214, 0xc0020, // [74]
		217, 217, 0x220005, // [75]
		208, 210, 0x6000c, // [76]
		214, 216, 0x6000c, // [77]
		221, 224, 0x13001e, // [78]
		227, 227, 0x180005, // [79]
		238, 238, 0x170005, // [80]
		239, 241, 0x35000c, // [81]
		224, 226, 0x60013, // [82]
		227, 230, 0x160018, // [83]
		233, 233, 0x400006, // [84]
		236, 236, 0x400006, // [85]
		230, 231, 0xc0016, // [86]
		233, 234, 0xf0040, // [87]
		250, 263, 0x2000d, // [88]
		265, 266, 0x55003b, // [89]
		266, 267, 0x4f0055, // [90]
		271, 272, 0x110003, // [91]
		276, 276, 0x420003, // [92]
		282, 282, 0x420003, // [93]
		267, 269, 0x4004f, // [94]
		272, 274, 0x40011, // [95]
		276, 277, 0x1c0042, // [96]
		277, 279, 0x5001c, // [97]
		289, 292, 0x320047, // [98]
		293, 311, 0x100002, // [99]
		314, 314, 0x210002, // [100]
		292, 292, 0x470032, // [101]
		311, 313, 0x30010, // [102]
		318, 332, 0x10004a, // [103]
		336, 336, 0x2a0002, // [104]
		332, 334, 0x30010, // [105]
		340, 342, 0x2003a, // [106]
	},
	NumStmt: [107]uint16{
		2, // 0
		1, // 1
		3, // 2
		3, // 3
		1, // 4
		2, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		1, // 10
		2, // 11
		1, // 12
		2, // 13
		3, // 14
		2, // 15
		3, // 16
		2, // 17
		1, // 18
		2, // 19
		2, // 20
		2, // 21
		2, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		2, // 34
		2, // 35
		1, // 36
		1, // 37
		1, // 38
		2, // 39
		2, // 40
		1, // 41
		1, // 42
		1, // 43
		2, // 44
		2, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		3, // 56
		1, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		2, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		3, // 71
		1, // 72
		2, // 73
		3, // 74
		1, // 75
		1, // 76
		1, // 77
		3, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		3, // 83
		1, // 84
		1, // 85
		1, // 86
		1, // 87
		12, // 88
		1, // 89
		1, // 90
		2, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		2, // 98
		5, // 99
		1, // 100
		1, // 101
		1, // 102
		7, // 103
		1, // 104
		1, // 105
		1, // 106
	},
}
var _ = _cover_atomic_.LoadUint32
