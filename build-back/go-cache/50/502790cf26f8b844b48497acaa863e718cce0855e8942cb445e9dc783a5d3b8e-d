//line /home/cooper/go/src/github.com/hyperledger/fabric/bccsp/factory/pluginfactory.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package factory; import _cover_atomic_ "sync/atomic"

import (
	"errors"
	"fmt"
	"os"
	"plugin"

	"github.com/hyperledger/fabric/bccsp"
)

const (
	// PluginFactoryName is the factory name for BCCSP plugins
	PluginFactoryName = "PLUGIN"
)

// PluginOpts contains the options for the PluginFactory
type PluginOpts struct {
	// Path to plugin library
	Library string
	// Config map for the plugin library
	Config map[string]interface{}
}

// PluginFactory is the factory for BCCSP plugins
type PluginFactory struct{}

// Name returns the name of this factory
func (f *PluginFactory) Name() string {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[0], 1);
	return PluginFactoryName
}

// Get returns an instance of BCCSP using Opts.
func (f *PluginFactory) Get(config *FactoryOpts) (bccsp.BCCSP, error) {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[1], 1);
	// check for valid config
	if config == nil || config.PluginOpts == nil {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[8], 1);
		return nil, errors.New("Invalid config. It must not be nil.")
	}

	// Library is required property
	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[2], 1);if config.PluginOpts.Library == "" {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[9], 1);
		return nil, errors.New("Invalid config: missing property 'Library'")
	}

	// make sure the library exists
	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[3], 1);if _, err := os.Stat(config.PluginOpts.Library); err != nil {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[10], 1);
		return nil, fmt.Errorf("Could not find library '%s' [%s]", config.PluginOpts.Library, err)
	}

	// attempt to load the library as a plugin
	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[4], 1);plug, err := plugin.Open(config.PluginOpts.Library)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[11], 1);
		return nil, fmt.Errorf("Failed to load plugin '%s' [%s]", config.PluginOpts.Library, err)
	}

	// lookup the required symbol 'New'
	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[5], 1);sym, err := plug.Lookup("New")
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[12], 1);
		return nil, fmt.Errorf("Could not find required symbol 'CryptoServiceProvider' [%s]", err)
	}

	// check to make sure symbol New meets the required function signature
	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[6], 1);new, ok := sym.(func(config map[string]interface{}) (bccsp.BCCSP, error))
	if !ok {_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[13], 1);
		return nil, fmt.Errorf("Plugin does not implement the required function signature for 'New'")
	}

	_cover_atomic_.AddUint32(&GoCover_3_613266356131373465643033.Count[7], 1);return new(config.PluginOpts.Config)
}

var GoCover_3_613266356131373465643033 = struct {
	Count     [14]uint32
	Pos       [3 * 14]uint32
	NumStmt   [14]uint16
} {
	Pos: [3 * 14]uint32{
		34, 36, 0x20027, // [0]
		39, 41, 0x2f0047, // [1]
		46, 46, 0x250002, // [2]
		51, 51, 0x3e0002, // [3]
		56, 57, 0x100002, // [4]
		62, 63, 0x100002, // [5]
		68, 69, 0x90002, // [6]
		73, 73, 0x260002, // [7]
		41, 43, 0x3002f, // [8]
		46, 48, 0x30025, // [9]
		51, 53, 0x3003e, // [10]
		57, 59, 0x30010, // [11]
		63, 65, 0x30010, // [12]
		69, 71, 0x30009, // [13]
	},
	NumStmt: [14]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		2, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
	},
}
var _ = _cover_atomic_.LoadUint32
