//line /home/cooper/go/src/github.com/hyperledger/fabric/common/graph/choose.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package graph; import _cover_atomic_ "sync/atomic"

type orderedSet struct {
	elements []interface{}
}

func (s *orderedSet) add(o interface{}) {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[0], 1);
	s.elements = append(s.elements, o)
}

type indiceSet struct {
	indices []int
}

type indiceSets []*indiceSet

func factorial(n int) int {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[1], 1);
	m := 1
	for i := 1; i <= n; i++ {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[3], 1);
		m *= i
	}
	_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[2], 1);return m
}

func nChooseK(n, k int) int {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[4], 1);
	a := factorial(n)
	b := factorial(n-k) * factorial(k)
	return a / b
}

func chooseKoutOfN(n, k int) indiceSets {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[5], 1);
	var res indiceSets
	subGroups := &orderedSet{}
	choose(n, k, 0, nil, subGroups)
	for _, el := range subGroups.elements {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[7], 1);
		res = append(res, el.(*indiceSet))
	}
	_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[6], 1);return res
}

func choose(n int, targetAmount int, i int, currentSubGroup []int, subGroups *orderedSet) {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[8], 1);
	// Check if we have enough elements in our current subgroup
	if len(currentSubGroup) == targetAmount {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[11], 1);
		subGroups.add(&indiceSet{indices: currentSubGroup})
		return
	}
	// Return early if not enough remaining candidates to pick from
	_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[9], 1);itemsLeftToPick := n - i
	if targetAmount-len(currentSubGroup) > itemsLeftToPick {_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[12], 1);
		return
	}
	// We either pick the current element
	_cover_atomic_.AddUint32(&GoCover_0_333364376162323263303436.Count[10], 1);choose(n, targetAmount, i+1, append(currentSubGroup, i), subGroups)
	// Or don't pick it
	choose(n, targetAmount, i+1, currentSubGroup, subGroups)
}

var GoCover_0_333364376162323263303436 = struct {
	Count     [13]uint32
	Pos       [3 * 13]uint32
	NumStmt   [13]uint16
} {
	Pos: [3 * 13]uint32{
		13, 15, 0x20029, // [0]
		23, 25, 0x1a001b, // [1]
		28, 28, 0xa0002, // [2]
		25, 27, 0x3001a, // [3]
		31, 35, 0x2001d, // [4]
		37, 41, 0x280029, // [5]
		44, 44, 0xc0002, // [6]
		41, 43, 0x30028, // [7]
		47, 49, 0x2a005b, // [8]
		54, 55, 0x390002, // [9]
		59, 61, 0x3a0002, // [10]
		49, 52, 0x3002a, // [11]
		55, 57, 0x30039, // [12]
	},
	NumStmt: [13]uint16{
		1, // 0
		2, // 1
		1, // 2
		1, // 3
		3, // 4
		4, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		2, // 11
		1, // 12
	},
}
var _ = _cover_atomic_.LoadUint32
