//line /home/cooper/go/src/github.com/hyperledger/fabric/core/aclmgmt/aclmgmtimpl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package aclmgmt; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/flogging"
)

var aclMgmtLogger = flogging.MustGetLogger("aclmgmt")

//implementation of aclMgmt. CheckACL calls in fabric result in the following flow
//    if resourceProvider[resourceName]
//       return resourceProvider[resourceName].CheckACL(...)
//    else
//       return defaultProvider[resourceName].CheckACL(...)
//with rescfgProvider encapsulating resourceProvider and defaultProvider
type aclMgmtImpl struct {
	//resource provider gets resource information from config
	rescfgProvider ACLProvider
}

//CheckACL checks the ACL for the resource for the channel using the
//idinfo. idinfo is an object such as SignedProposal from which an
//id can be extracted for testing against a policy
func (am *aclMgmtImpl) CheckACL(resName string, channelID string, idinfo interface{}) error {_cover_atomic_.AddUint32(&GoCover_1_333530613935626133663963.Count[0], 1);
	//use the resource based config provider (which will in turn default to 1.0 provider)
	return am.rescfgProvider.CheckACL(resName, channelID, idinfo)
}

//ACLProvider consists of two providers, supplied one and a default one (1.0 ACL management
//using ChannelReaders and ChannelWriters). If supplied provider is nil, a resource based
//ACL provider is created.
func NewACLProvider(rg ResourceGetter) ACLProvider {_cover_atomic_.AddUint32(&GoCover_1_333530613935626133663963.Count[1], 1);
	return &aclMgmtImpl{
		rescfgProvider: newResourceProvider(rg, NewDefaultACLProvider()),
	}
}

var GoCover_1_333530613935626133663963 = struct {
	Count     [2]uint32
	Pos       [3 * 2]uint32
	NumStmt   [2]uint16
} {
	Pos: [3 * 2]uint32{
		29, 32, 0x2005d, // [0]
		37, 41, 0x20034, // [1]
	},
	NumStmt: [2]uint16{
		1, // 0
		1, // 1
	},
}
var _ = _cover_atomic_.LoadUint32
