//line /home/cooper/go/src/github.com/hyperledger/fabric/core/comm/producer.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"math/rand"
	"sync"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"google.golang.org/grpc"
)

var logger = flogging.MustGetLogger("ConnProducer")

var EndpointDisableInterval = time.Second * 10

// ConnectionFactory creates a connection to a certain endpoint
type ConnectionFactory func(endpoint string) (*grpc.ClientConn, error)

// ConnectionProducer produces connections out of a set of predefined
// endpoints
type ConnectionProducer interface {
	// NewConnection creates a new connection.
	// Returns the connection, the endpoint selected, nil on success.
	// Returns nil, "", error on failure
	NewConnection() (*grpc.ClientConn, string, error)
	// UpdateEndpoints updates the endpoints of the ConnectionProducer
	// to be the given endpoints
	UpdateEndpoints(endpoints []string)
	// DisableEndpoint remove endpoint from endpoint for some time
	DisableEndpoint(endpoint string)
	// GetEndpoints return ordering service endpoints
	GetEndpoints() []string
}

type connProducer struct {
	sync.RWMutex
	endpoints         []string
	disabledEndpoints map[string]time.Time
	connect           ConnectionFactory
}

// NewConnectionProducer creates a new ConnectionProducer with given endpoints and connection factory.
// It returns nil, if the given endpoints slice is empty.
func NewConnectionProducer(factory ConnectionFactory, endpoints []string) ConnectionProducer {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[0], 1);
	if len(endpoints) == 0 {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[2], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[1], 1);return &connProducer{endpoints: endpoints, connect: factory, disabledEndpoints: make(map[string]time.Time)}
}

// NewConnection creates a new connection.
// Returns the connection, the endpoint selected, nil on success.
// Returns nil, "", error on failure
func (cp *connProducer) NewConnection() (*grpc.ClientConn, string, error) {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[3], 1);
	cp.Lock()
	defer cp.Unlock()

	for endpoint, timeout := range cp.disabledEndpoints {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[6], 1);
		if time.Since(timeout) >= EndpointDisableInterval {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[7], 1);
			delete(cp.disabledEndpoints, endpoint)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[4], 1);endpoints := shuffle(cp.endpoints)
	checkedEndpoints := make([]string, 0)
	for _, endpoint := range endpoints {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[8], 1);
		if _, ok := cp.disabledEndpoints[endpoint]; !ok {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[9], 1);
			checkedEndpoints = append(checkedEndpoints, endpoint)
			conn, err := cp.connect(endpoint)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[11], 1);
				logger.Error("Failed connecting to", endpoint, ", error:", err)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[10], 1);return conn, endpoint, nil
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[5], 1);return nil, "", fmt.Errorf("Could not connect to any of the endpoints: %v", checkedEndpoints)
}

// UpdateEndpoints updates the endpoints of the ConnectionProducer
// to be the given endpoints
func (cp *connProducer) UpdateEndpoints(endpoints []string) {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[12], 1);
	if len(endpoints) == 0 {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[15], 1);
		// Ignore updates with empty endpoints
		return
	}
	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[13], 1);cp.Lock()
	defer cp.Unlock()

	newDisabled := make(map[string]time.Time)
	for i := range endpoints {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[16], 1);
		if startTime, ok := cp.disabledEndpoints[endpoints[i]]; ok {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[17], 1);
			newDisabled[endpoints[i]] = startTime
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[14], 1);cp.endpoints = endpoints
	cp.disabledEndpoints = newDisabled
}

func (cp *connProducer) DisableEndpoint(endpoint string) {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[18], 1);
	cp.Lock()
	defer cp.Unlock()

	if len(cp.endpoints)-len(cp.disabledEndpoints) == 1 {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[20], 1);
		logger.Warning("Only 1 endpoint remained, will not black-list it")
		return
	}

	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[19], 1);for _, currEndpoint := range cp.endpoints {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[21], 1);
		if currEndpoint == endpoint {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[22], 1);
			cp.disabledEndpoints[endpoint] = time.Now()
			break
		}
	}
}

func shuffle(a []string) []string {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[23], 1);
	n := len(a)
	returnedSlice := make([]string, n)
	rand.Seed(time.Now().UnixNano())
	indices := rand.Perm(n)
	for i, idx := range indices {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[25], 1);
		returnedSlice[i] = a[idx]
	}
	_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[24], 1);return returnedSlice
}

// GetEndpoints returns configured endpoints for ordering service
func (cp *connProducer) GetEndpoints() []string {_cover_atomic_.AddUint32(&GoCover_5_643230363037383562363632.Count[26], 1);
	cp.RLock()
	defer cp.RUnlock()
	return cp.endpoints
}

var GoCover_5_643230363037383562363632 = struct {
	Count     [27]uint32
	Pos       [3 * 27]uint32
	NumStmt   [27]uint16
} {
	Pos: [3 * 27]uint32{
		51, 52, 0x19005e, // [0]
		55, 55, 0x6d0002, // [1]
		52, 54, 0x30019, // [2]
		61, 65, 0x36004b, // [3]
		71, 73, 0x250002, // [4]
		84, 84, 0x5f0002, // [5]
		65, 66, 0x350036, // [6]
		66, 68, 0x40035, // [7]
		73, 74, 0x330025, // [8]
		74, 77, 0x120033, // [9]
		81, 81, 0x1e0004, // [10]
		77, 79, 0xd0012, // [11]
		89, 90, 0x19003d, // [12]
		94, 98, 0x1b0002, // [13]
		103, 104, 0x240002, // [14]
		90, 93, 0x30019, // [15]
		98, 99, 0x3e001b, // [16]
		99, 101, 0x4003e, // [17]
		107, 111, 0x36003a, // [18]
		116, 116, 0x2c0002, // [19]
		111, 114, 0x30036, // [20]
		116, 117, 0x1f002c, // [21]
		117, 119, 0x9001f, // [22]
		124, 129, 0x1e0023, // [23]
		132, 132, 0x160002, // [24]
		129, 131, 0x3001e, // [25]
		136, 140, 0x20031, // [26]
	},
	NumStmt: [27]uint16{
		1, // 0
		1, // 1
		1, // 2
		3, // 3
		3, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		3, // 9
		1, // 10
		2, // 11
		1, // 12
		4, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		3, // 18
		1, // 19
		2, // 20
		1, // 21
		2, // 22
		5, // 23
		1, // 24
		1, // 25
		3, // 26
	},
}
var _ = _cover_atomic_.LoadUint32
