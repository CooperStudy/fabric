//line /home/cooper/go/src/github.com/hyperledger/fabric/core/container/util/writer.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package util; import _cover_atomic_ "sync/atomic"

import (
	"archive/tar"
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/chaincode/platforms/ccmetadata"
	"github.com/pkg/errors"
)

var vmLogger = flogging.MustGetLogger("container")

// These filetypes are excluded while creating the tar package sent to Docker
// Generated .class and other temporary files can be excluded
var javaExcludeFileTypes = map[string]bool{
	".class": true,
}

// WriteFolderToTarPackage writes source files to a tarball.
// This utility is used for node js chaincode packaging, but not golang chaincode.
// Golang chaincode has more sophisticated file packaging, as implemented in golang/platform.go.
func WriteFolderToTarPackage(tw *tar.Writer, srcPath string, excludeDirs []string, includeFileTypeMap map[string]bool, excludeFileTypeMap map[string]bool) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[0], 1);
	fileCount := 0
	rootDirectory := srcPath

	// trim trailing slash if it was passed
	if rootDirectory[len(rootDirectory)-1] == '/' {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[6], 1);
		rootDirectory = rootDirectory[:len(rootDirectory)-1]
	}

	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[1], 1);vmLogger.Debugf("rootDirectory = %s", rootDirectory)

	//append "/" if necessary
	updatedExcludeDirs := make([]string, 0)
	for _, excludeDir := range excludeDirs {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[7], 1);
		if excludeDir != "" && strings.LastIndex(excludeDir, "/") < len(excludeDir)-1 {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[8], 1);
			excludeDir = excludeDir + "/"
			updatedExcludeDirs = append(updatedExcludeDirs, excludeDir)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[2], 1);rootDirLen := len(rootDirectory)
	walkFn := func(localpath string, info os.FileInfo, err error) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[9], 1);

		// If localpath includes .git, ignore
		if strings.Contains(localpath, ".git") {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[18], 1);
			return nil
		}

		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[10], 1);if info.Mode().IsDir() {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[19], 1);
			return nil
		}

		//exclude any files with excludeDir prefix. They should already be in the tar
		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[11], 1);for _, excludeDir := range updatedExcludeDirs {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[20], 1);
			if strings.Index(localpath, excludeDir) == rootDirLen+1 {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[21], 1);
				return nil
			}
		}
		// Because of scoping we can reference the external rootDirectory variable
		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[12], 1);if len(localpath[rootDirLen:]) == 0 {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[22], 1);
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[13], 1);ext := filepath.Ext(localpath)

		if includeFileTypeMap != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[23], 1);
			// we only want 'fileTypes' source files at this point
			if _, ok := includeFileTypeMap[ext]; ok != true {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[24], 1);
				return nil
			}
		}

		//exclude the given file types
		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[14], 1);if excludeFileTypeMap != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[25], 1);
			if exclude, ok := excludeFileTypeMap[ext]; ok && exclude {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[26], 1);
				return nil
			}
		}

		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[15], 1);var packagepath string

		// if file is metadata, keep the /META-INF directory, e.g: META-INF/statedb/couchdb/indexes/indexOwner.json
		// otherwise file is source code, put it in /src dir, e.g: src/marbles_chaincode.js
		if strings.HasPrefix(localpath, filepath.Join(rootDirectory, "META-INF")) {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[27], 1);
			packagepath = localpath[rootDirLen+1:]

			// Split the tar packagepath into a tar package directory and filename
			_, filename := filepath.Split(packagepath)

			// Hidden files are not supported as metadata, therefore ignore them.
			// User often doesn't know that hidden files are there, and may not be able to delete them, therefore warn user rather than error out.
			if strings.HasPrefix(filename, ".") {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[30], 1);
				vmLogger.Warningf("Ignoring hidden file in metadata directory: %s", packagepath)
				return nil
			}

			_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[28], 1);fileBytes, errRead := ioutil.ReadFile(localpath)
			if errRead != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[31], 1);
				return errRead
			}

			// Validate metadata file for inclusion in tar
			// Validation is based on the fully qualified path of the file
			_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[29], 1);err = ccmetadata.ValidateMetadataFile(packagepath, fileBytes)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[32], 1);
				return err
			}

		} else{ _cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[33], 1);{ // file is not metadata, include in src
			packagepath = fmt.Sprintf("src%s", localpath[rootDirLen:])
		}}

		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[16], 1);err = WriteFileToPackage(localpath, packagepath, tw)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[34], 1);
			return fmt.Errorf("Error writing file to package: %s", err)
		}
		_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[17], 1);fileCount++

		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[3], 1);if err := filepath.Walk(rootDirectory, walkFn); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[35], 1);
		vmLogger.Infof("Error walking rootDirectory: %s", err)
		return err
	}
	// return error if no files were found
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[4], 1);if fileCount == 0 {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[36], 1);
		return errors.Errorf("no source files found in '%s'", srcPath)
	}
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[5], 1);return nil
}

//Package Java project to tar file from the source path
func WriteJavaProjectToPackage(tw *tar.Writer, srcPath string) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[37], 1);

	vmLogger.Debugf("Packaging Java project from path %s", srcPath)

	if err := WriteFolderToTarPackage(tw, srcPath, []string{"target", "build", "out"}, nil, javaExcludeFileTypes); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[40], 1);

		vmLogger.Errorf("Error writing folder to tar package %s", err)
		return err
	}
	// Write the tar file out
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[38], 1);if err := tw.Close(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[41], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[39], 1);return nil

}

//WriteFileToPackage writes a file to the tarball
func WriteFileToPackage(localpath string, packagepath string, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[42], 1);
	vmLogger.Debug("Writing file to tarball:", packagepath)
	fd, err := os.Open(localpath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[44], 1);
		return fmt.Errorf("%s: %s", localpath, err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[43], 1);defer fd.Close()

	is := bufio.NewReader(fd)
	return WriteStreamToPackage(is, localpath, packagepath, tw)

}

//WriteStreamToPackage writes bytes (from a file reader) to the tarball
func WriteStreamToPackage(is io.Reader, localpath string, packagepath string, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[45], 1);
	info, err := os.Stat(localpath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[50], 1);
		return fmt.Errorf("%s: %s", localpath, err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[46], 1);header, err := tar.FileInfoHeader(info, localpath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[51], 1);
		return fmt.Errorf("Error getting FileInfoHeader: %s", err)
	}

	//Let's take the variance out of the tar, make headers identical by using zero time
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[47], 1);oldname := header.Name
	var zeroTime time.Time
	header.AccessTime = zeroTime
	header.ModTime = zeroTime
	header.ChangeTime = zeroTime
	header.Name = packagepath
	header.Mode = 0100644
	header.Uid = 500
	header.Gid = 500

	if err = tw.WriteHeader(header); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[52], 1);
		return fmt.Errorf("Error write header for (path: %s, oldname:%s,newname:%s,sz:%d) : %s", localpath, oldname, packagepath, header.Size, err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[48], 1);if _, err := io.Copy(tw, is); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[53], 1);
		return fmt.Errorf("Error copy (path: %s, oldname:%s,newname:%s,sz:%d) : %s", localpath, oldname, packagepath, header.Size, err)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[49], 1);return nil
}

func WriteBytesToPackage(name string, payload []byte, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_1_323534643032613065626263.Count[54], 1);
	//Make headers identical by using zero time
	var zeroTime time.Time
	tw.WriteHeader(&tar.Header{Name: name, Size: int64(len(payload)), ModTime: zeroTime, AccessTime: zeroTime, ChangeTime: zeroTime})
	tw.Write(payload)

	return nil
}

var GoCover_1_323534643032613065626263 = struct {
	Count     [55]uint32
	Pos       [3 * 55]uint32
	NumStmt   [55]uint16
} {
	Pos: [3 * 55]uint32{
		36, 41, 0x3000a2, // [0]
		45, 49, 0x290002, // [1]
		56, 57, 0x460002, // [2]
		136, 136, 0x3d0002, // [3]
		141, 141, 0x140002, // [4]
		144, 144, 0xc0002, // [5]
		41, 43, 0x30030, // [6]
		49, 50, 0x510029, // [7]
		50, 53, 0x40051, // [8]
		57, 60, 0x2a0046, // [9]
		64, 64, 0x1a0003, // [10]
		69, 69, 0x310003, // [11]
		75, 75, 0x270003, // [12]
		78, 80, 0x200003, // [13]
		88, 88, 0x200003, // [14]
		94, 98, 0x4d0003, // [15]
		127, 128, 0x110003, // [16]
		131, 133, 0xd0003, // [17]
		60, 62, 0x4002a, // [18]
		64, 66, 0x4001a, // [19]
		69, 70, 0x3c0031, // [20]
		70, 72, 0x5003c, // [21]
		75, 77, 0x40027, // [22]
		80, 82, 0x340020, // [23]
		82, 84, 0x50034, // [24]
		88, 89, 0x3d0020, // [25]
		89, 91, 0x5003d, // [26]
		98, 106, 0x28004d, // [27]
		111, 112, 0x160004, // [28]
		118, 119, 0x120004, // [29]
		106, 109, 0x50028, // [30]
		112, 114, 0x50016, // [31]
		119, 121, 0x50012, // [32]
		123, 125, 0x40009, // [33]
		128, 130, 0x40011, // [34]
		136, 139, 0x3003d, // [35]
		141, 143, 0x30014, // [36]
		148, 152, 0x7c0046, // [37]
		158, 158, 0x230002, // [38]
		161, 161, 0xc0002, // [39]
		152, 156, 0x3007c, // [40]
		158, 160, 0x30023, // [41]
		166, 169, 0x100055, // [42]
		172, 175, 0x3d0002, // [43]
		169, 171, 0x30010, // [44]
		180, 182, 0x100065, // [45]
		185, 186, 0x100002, // [46]
		191, 201, 0x2e0002, // [47]
		204, 204, 0x2b0002, // [48]
		208, 208, 0xc0002, // [49]
		182, 184, 0x30010, // [50]
		186, 188, 0x30010, // [51]
		201, 203, 0x3002e, // [52]
		204, 206, 0x3002b, // [53]
		211, 218, 0x2004d, // [54]
	},
	NumStmt: [55]uint16{
		3, // 0
		3, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		2, // 15
		2, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		3, // 27
		2, // 28
		2, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		2, // 35
		1, // 36
		2, // 37
		1, // 38
		1, // 39
		2, // 40
		1, // 41
		3, // 42
		3, // 43
		1, // 44
		2, // 45
		2, // 46
		10, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		4, // 54
	},
}
var _ = _cover_atomic_.LoadUint32
