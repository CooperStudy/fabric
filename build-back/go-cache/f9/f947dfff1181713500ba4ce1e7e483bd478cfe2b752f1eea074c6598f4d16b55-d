//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/cluster/replication.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cluster; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"encoding/pem"
	"time"

	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/orderer/common/localconfig"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

const (
	// RetryTimeout is the time the block puller retries
	RetryTimeout = time.Second * 10
)

// PullerConfigFromTopLevelConfig creates a PullerConfig from a TopLevel config,
// and from a signer and TLS key cert pair.
// The PullerConfig's channel is initialized to be the system channel.
func PullerConfigFromTopLevelConfig(systemChannel string, conf *localconfig.TopLevel, tlsKey, tlsCert []byte, signer crypto.LocalSigner) PullerConfig {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[0], 1);
	return PullerConfig{
		Channel:             systemChannel,
		MaxTotalBufferBytes: conf.General.Cluster.ReplicationBufferSize,
		Timeout:             conf.General.Cluster.RPCTimeout,
		TLSKey:              tlsKey,
		TLSCert:             tlsCert,
		Signer:              signer,
	}
}

//go:generate mockery -dir . -name LedgerWriter -case underscore -output mocks/

// LedgerWriter allows the caller to write blocks and inspect the height
type LedgerWriter interface {
	// Append a new block to the ledger
	Append(block *common.Block) error

	// Height returns the number of blocks on the ledger
	Height() uint64
}

//go:generate mockery -dir . -name LedgerFactory -case underscore -output mocks/

// LedgerFactory retrieves or creates new ledgers by chainID
type LedgerFactory interface {
	// GetOrCreate gets an existing ledger (if it exists)
	// or creates it if it does not
	GetOrCreate(chainID string) (LedgerWriter, error)
}

//go:generate mockery -dir . -name ChannelLister -case underscore -output mocks/

// ChannelLister returns a list of channels
type ChannelLister interface {
	// Channels returns a list of channels
	Channels() []string
	// Close closes the ChannelLister
	Close()
}

// Replicator replicates chains
type Replicator struct {
	SystemChannel    string
	ChannelLister    ChannelLister
	Logger           *flogging.FabricLogger
	Puller           *BlockPuller
	BootBlock        *common.Block
	AmIPartOfChannel selfMembershipPredicate
	LedgerFactory    LedgerFactory
}

// IsReplicationNeeded returns whether replication is needed,
// or the cluster node can resume standard boot flow.
func (r *Replicator) IsReplicationNeeded() (bool, error) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[1], 1);
	systemChannelLedger, err := r.LedgerFactory.GetOrCreate(r.SystemChannel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[5], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[2], 1);height := systemChannelLedger.Height()
	var lastBlockSeq uint64
	// If Height is 0 then lastBlockSeq would be 2^64 - 1,
	// so make it 0 to take care of the overflow.
	if height == 0 {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[6], 1);
		lastBlockSeq = 0
	} else{ _cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[7], 1);{
		lastBlockSeq = height - 1
	}}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[3], 1);if r.BootBlock.Header.Number > lastBlockSeq {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[8], 1);
		return true, nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[4], 1);return false, nil
}

// ReplicateChains pulls chains and commits them.
func (r *Replicator) ReplicateChains() {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[9], 1);
	channels := r.discoverChannels()
	channels2Pull := r.channelsToPull(channels)
	r.Logger.Info("Found myself in", len(channels2Pull), "channels:", channels2Pull)
	for _, channel := range channels2Pull {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[11], 1);
		r.PullChannel(channel)
	}
	// Last, pull the system chain
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[10], 1);if err := r.PullChannel(r.SystemChannel); err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[12], 1);
		r.Logger.Panicf("Failed pulling system channel: %v", err)
	}
}

func (r *Replicator) discoverChannels() []string {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[13], 1);
	r.Logger.Debug("Entering")
	defer r.Logger.Debug("Exiting")
	channels := r.ChannelLister.Channels()
	r.Logger.Info("Discovered", len(channels), "channels:", channels)
	r.ChannelLister.Close()
	return channels
}

// PullChannel pulls the given channel from some orderer,
// and commits it to the ledger.
func (r *Replicator) PullChannel(channel string) error {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[14], 1);
	r.Logger.Info("Pulling channel", channel)
	puller := r.Puller.Clone()
	defer puller.Close()
	puller.Channel = channel

	endpoint, latestHeight := latestHeightAndEndpoint(puller)
	if endpoint == "" {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[17], 1);
		return errors.Errorf("failed obtaining the latest block for channel %s", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[15], 1);r.Logger.Info("Latest block height for channel", channel, "is", latestHeight)
	// Ensure that if we pull the system channel, the latestHeight is bigger or equal to the
	// bootstrap block of the system channel.
	// Otherwise, we'd be left with a block gap.
	if channel == r.SystemChannel && latestHeight-1 < r.BootBlock.Header.Number {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[18], 1);
		return errors.Errorf("latest height found among system channel(%s) orderers is %d, but the boot block's "+
			"sequence is %d", r.SystemChannel, latestHeight, r.BootBlock.Header.Number)
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[16], 1);return r.pullChannelBlocks(channel, puller, latestHeight)
}

func (r *Replicator) pullChannelBlocks(channel string, puller ChainPuller, latestHeight uint64) error {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[19], 1);
	ledger, err := r.LedgerFactory.GetOrCreate(channel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[22], 1);
		r.Logger.Panicf("Failed to create a ledger for channel %s: %v", channel, err)
	}
	// Pull the genesis block and remember its hash.
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[20], 1);genesisBlock := puller.PullBlock(0)
	r.appendBlock(genesisBlock, ledger)
	actualPrevHash := genesisBlock.Header.Hash()

	for seq := uint64(1); seq < latestHeight; seq++ {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[23], 1);
		block := puller.PullBlock(seq)
		reportedPrevHash := block.Header.PreviousHash
		if !bytes.Equal(reportedPrevHash, actualPrevHash) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[26], 1);
			return errors.Errorf("block header mismatch on sequence %d, expected %x, got %x",
				block.Header.Number, actualPrevHash, reportedPrevHash)
		}
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[24], 1);actualPrevHash = block.Header.Hash()
		if channel == r.SystemChannel && block.Header.Number == r.BootBlock.Header.Number {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[27], 1);
			r.compareBootBlockWithSystemChannelLastConfigBlock(block)
			r.appendBlock(block, ledger)
			// No need to pull further blocks from the system channel
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[25], 1);r.appendBlock(block, ledger)
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[21], 1);return nil
}

func (r *Replicator) appendBlock(block *common.Block, ledger LedgerWriter) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[28], 1);
	if err := ledger.Append(block); err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[29], 1);
		r.Logger.Panicf("Failed to write block %d: %v", block.Header.Number, err)
	}
}

func (r *Replicator) compareBootBlockWithSystemChannelLastConfigBlock(block *common.Block) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[30], 1);
	// Overwrite the received block's data hash
	block.Header.DataHash = block.Data.Hash()

	bootBlockHash := r.BootBlock.Header.Hash()
	retrievedBlockHash := block.Header.Hash()
	if bytes.Equal(bootBlockHash, retrievedBlockHash) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[32], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[31], 1);r.Logger.Panicf("Block header mismatch on last system channel block, expected %s, got %s",
		hex.EncodeToString(bootBlockHash), hex.EncodeToString(retrievedBlockHash))
}

func (r *Replicator) channelsToPull(channels []string) []string {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[33], 1);
	r.Logger.Info("Will now pull channels:", channels)
	var channelsToPull []string
	for _, channel := range channels {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[35], 1);
		r.Logger.Info("Pulling chain for", channel)
		puller := r.Puller.Clone()
		puller.Channel = channel
		// Disable puller buffering when we check whether we are in the channel,
		// as we only need to know about a single block.
		bufferSize := puller.MaxTotalBufferBytes
		puller.MaxTotalBufferBytes = 1
		err := Participant(puller, r.AmIPartOfChannel)
		puller.Close()
		// Restore the previous buffer size
		puller.MaxTotalBufferBytes = bufferSize
		if err == ErrNotInChannel {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[38], 1);
			r.Logger.Info("I do not belong to channel", channel, ", skipping chain retrieval")
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[36], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[39], 1);
			r.Logger.Panicf("Failed classifying whether I belong to channel %s: %v, skipping chain retrieval", channel, err)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[37], 1);channelsToPull = append(channelsToPull, channel)
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[34], 1);return channelsToPull
}

// PullerConfig configures a BlockPuller.
type PullerConfig struct {
	TLSKey              []byte
	TLSCert             []byte
	Timeout             time.Duration
	Signer              crypto.LocalSigner
	Channel             string
	MaxTotalBufferBytes int
}

// BlockPullerFromConfigBlock returns a BlockPuller that doesn't verify signatures on blocks.
func BlockPullerFromConfigBlock(conf PullerConfig, block *common.Block) (*BlockPuller, error) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[40], 1);
	if block == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[44], 1);
		return nil, errors.New("nil block")
	}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[41], 1);endpointconfig, err := EndpointconfigFromConfigBlock(block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[45], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[42], 1);dialer := &StandardDialer{
		Dialer: NewTLSPinningDialer(comm.ClientConfig{
			Timeout: conf.Timeout,
			SecOpts: &comm.SecureOptions{
				ServerRootCAs:     endpointconfig.TLSRootCAs,
				Certificate:       conf.TLSCert,
				Key:               conf.TLSKey,
				RequireClientCert: true,
				UseTLS:            true,
			},
		})}

	tlsCertAsDER, _ := pem.Decode(conf.TLSCert)
	if tlsCertAsDER == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[46], 1);
		return nil, errors.Errorf("unable to decode TLS certificate PEM: %s", base64.StdEncoding.EncodeToString(conf.TLSCert))
	}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[43], 1);return &BlockPuller{
		Logger:  flogging.MustGetLogger("orderer.common.cluster.replication"),
		Dialer:  dialer,
		TLSCert: tlsCertAsDER.Bytes,
		VerifyBlockSequence: func(blocks []*common.Block) error {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[47], 1);
			return VerifyBlocks(blocks, &NoopBlockVerifier{})
		},
		MaxTotalBufferBytes: conf.MaxTotalBufferBytes,
		Endpoints:           endpointconfig.Endpoints,
		RetryTimeout:        RetryTimeout,
		FetchTimeout:        conf.Timeout,
		Channel:             conf.Channel,
		Signer:              conf.Signer,
	}, nil
}

// NoopBlockVerifier doesn't verify block signatures
type NoopBlockVerifier struct{}

// VerifyBlockSignature accepts all signatures over blocks.
func (*NoopBlockVerifier) VerifyBlockSignature(sd []*common.SignedData, config *common.ConfigEnvelope) error {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[48], 1);
	return nil
}

//go:generate mockery -dir . -name ChainPuller -case underscore -output mocks/

// ChainPuller pulls blocks from a chain
type ChainPuller interface {
	// PullBlock pulls the given block from some orderer node
	PullBlock(seq uint64) *common.Block

	// HeightsByEndpoints returns the block heights by endpoints of orderers
	HeightsByEndpoints() map[string]uint64

	// Close closes the ChainPuller
	Close()
}

// ChainInspector walks over a chain
type ChainInspector struct {
	Logger          *flogging.FabricLogger
	Puller          ChainPuller
	LastConfigBlock *common.Block
}

// ErrNotInChannel denotes that an ordering node is not in the channel
var ErrNotInChannel = errors.New("not in the channel")

// selfMembershipPredicate determines whether the caller is found in the given config block
type selfMembershipPredicate func(configBlock *common.Block) error

// Participant returns whether the caller participates in the chain.
// It receives a ChainPuller that should already be calibrated for the chain,
// and a selfMembershipPredicate that is used to detect whether the caller should service the chain.
// It returns nil if the caller participates in the chain.
// It may return notInChannelError error in case the caller doesn't participate in the chain.
func Participant(puller ChainPuller, analyzeLastConfBlock selfMembershipPredicate) error {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[49], 1);
	endpoint, latestHeight := latestHeightAndEndpoint(puller)
	if endpoint == "" {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[52], 1);
		return errors.New("no available orderer")
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[50], 1);lastBlock := puller.PullBlock(latestHeight - 1)
	lastConfNumber, err := lastConfigFromBlock(lastBlock)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[53], 1);
		return err
	}
	// The last config block is smaller than the latest height,
	// and a block iterator on the server side is a sequenced one.
	// So we need to reset the puller if we wish to pull an earlier block.
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[51], 1);puller.Close()
	lastConfigBlock := puller.PullBlock(lastConfNumber)
	return analyzeLastConfBlock(lastConfigBlock)
}

func latestHeightAndEndpoint(puller ChainPuller) (string, uint64) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[54], 1);
	var maxHeight uint64
	var mostUpToDateEndpoint string
	for endpoint, height := range puller.HeightsByEndpoints() {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[56], 1);
		if height > maxHeight {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[57], 1);
			maxHeight = height
			mostUpToDateEndpoint = endpoint
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[55], 1);return mostUpToDateEndpoint, maxHeight
}

func lastConfigFromBlock(block *common.Block) (uint64, error) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[58], 1);
	if block.Metadata == nil || len(block.Metadata.Metadata) <= int(common.BlockMetadataIndex_LAST_CONFIG) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[60], 1);
		return 0, errors.New("no metadata in block")
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[59], 1);return utils.GetLastConfigIndexFromBlock(block)
}

// Close closes the ChainInspector
func (ci *ChainInspector) Close() {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[61], 1);
	ci.Puller.Close()
}

// Channels returns the list of channels
// that exist in the chain
func (ci *ChainInspector) Channels() []string {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[62], 1);
	channels := make(map[string]struct{})
	lastConfigBlockNum := ci.LastConfigBlock.Header.Number
	var block *common.Block
	var prevHash []byte
	for seq := uint64(1); seq < lastConfigBlockNum; seq++ {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[65], 1);
		block = ci.Puller.PullBlock(seq)
		ci.validateHashPointer(block, prevHash)
		channel, err := IsNewChannelBlock(block)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[68], 1);
			// If we failed to classify a block, something is wrong in the system chain
			// we're trying to pull, so abort.
			ci.Logger.Panic("Failed classifying block", seq, ":", err)
			continue
		}
		// Set the previous hash for the next iteration
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[66], 1);prevHash = block.Header.Hash()
		if channel == "" {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[69], 1);
			ci.Logger.Info("Block", seq, "doesn't contain a new channel")
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[67], 1);ci.Logger.Info("Block", seq, "contains channel", channel)
		channels[channel] = struct{}{}
	}
	// At this point, block holds reference to the last block pulled.
	// We ensure that the hash of the last block pulled, is the previous hash
	// of the LastConfigBlock we were initialized with.
	// We don't need to verify the entire chain of all blocks we pulled,
	// because the block puller calls VerifyBlockHash on all blocks it pulls.
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[63], 1);last2Blocks := []*common.Block{block, ci.LastConfigBlock}
	if err := VerifyBlockHash(1, last2Blocks); err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[70], 1);
		ci.Logger.Panic("System channel pulled doesn't match the boot last config block:", err)
	}

	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[64], 1);return flattenChannelMap(channels)
}

func (ci *ChainInspector) validateHashPointer(block *common.Block, prevHash []byte) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[71], 1);
	if prevHash == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[74], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[72], 1);if bytes.Equal(block.Header.PreviousHash, prevHash) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[75], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[73], 1);ci.Logger.Panicf("Claimed previous hash of block %d is %x but actual previous hash is %x",
		block.Header.Number, block.Header.PreviousHash, prevHash)
}

func flattenChannelMap(m map[string]struct{}) []string {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[76], 1);
	var res []string
	for channel := range m {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[78], 1);
		res = append(res, channel)
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[77], 1);return res
}

// IsNewChannelBlock returns a name of the channel in case
// it holds a channel create transaction, or empty string otherwise.
func IsNewChannelBlock(block *common.Block) (string, error) {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[79], 1);
	if block == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[92], 1);
		return "", errors.New("nil block")
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[80], 1);env, err := utils.ExtractEnvelope(block, 0)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[93], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[81], 1);payload, err := utils.ExtractPayload(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[94], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[82], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[95], 1);
		return "", errors.New("nil header in payload")
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[83], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[96], 1);
		return "", err
	}
	// The transaction is an orderer transaction
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[84], 1);if common.HeaderType(chdr.Type) != common.HeaderType_ORDERER_TRANSACTION {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[97], 1);
		return "", nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[85], 1);systemChannelName := chdr.ChannelId
	innerEnvelope, err := utils.UnmarshalEnvelope(payload.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[98], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[86], 1);innerPayload, err := utils.UnmarshalPayload(innerEnvelope.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[99], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[87], 1);if innerPayload.Header == nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[100], 1);
		return "", errors.New("inner payload's header is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[88], 1);chdr, err = utils.UnmarshalChannelHeader(innerPayload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[101], 1);
		return "", err
	}
	// The inner payload's header is a config transaction
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[89], 1);if common.HeaderType(chdr.Type) != common.HeaderType_CONFIG {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[102], 1);
		return "", nil
	}
	// In any case, exclude all system channel transactions
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[90], 1);if chdr.ChannelId == systemChannelName {_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[103], 1);
		return "", nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_363733313532663932376566.Count[91], 1);return chdr.ChannelId, nil
}

var GoCover_3_363733313532663932376566 = struct {
	Count     [104]uint32
	Pos       [3 * 104]uint32
	NumStmt   [104]uint16
} {
	Pos: [3 * 104]uint32{
		33, 42, 0x20097, // [0]
		87, 89, 0x10003a, // [1]
		93, 97, 0x110002, // [2]
		103, 103, 0x2e0002, // [3]
		106, 106, 0x130002, // [4]
		89, 91, 0x30010, // [5]
		97, 99, 0x30011, // [6]
		99, 101, 0x30008, // [7]
		103, 105, 0x3002e, // [8]
		110, 114, 0x280028, // [9]
		118, 118, 0x370002, // [10]
		114, 116, 0x30028, // [11]
		118, 120, 0x30037, // [12]
		123, 130, 0x20032, // [13]
		134, 141, 0x140038, // [14]
		144, 148, 0x4e0002, // [15]
		152, 152, 0x3b0002, // [16]
		141, 143, 0x30014, // [17]
		148, 151, 0x3004e, // [18]
		155, 157, 0x100067, // [19]
		161, 165, 0x320002, // [20]
		181, 181, 0xc0002, // [21]
		157, 159, 0x30010, // [22]
		165, 168, 0x350032, // [23]
		172, 173, 0x550003, // [24]
		179, 179, 0x1f0003, // [25]
		168, 171, 0x40035, // [26]
		173, 178, 0x40055, // [27]
		184, 185, 0x2d004c, // [28]
		185, 187, 0x3002d, // [29]
		190, 196, 0x34005c, // [30]
		199, 200, 0x4d0002, // [31]
		196, 198, 0x30034, // [32]
		203, 206, 0x230041, // [33]
		228, 228, 0x170002, // [34]
		206, 218, 0x1d0023, // [35]
		222, 222, 0x110003, // [36]
		226, 226, 0x330003, // [37]
		218, 220, 0xc001d, // [38]
		222, 224, 0xc0011, // [39]
		242, 243, 0x12005f, // [40]
		247, 248, 0x100002, // [41]
		252, 265, 0x190002, // [42]
		269, 273, 0x3b0002, // [43]
		243, 245, 0x30012, // [44]
		248, 250, 0x30010, // [45]
		265, 267, 0x30019, // [46]
		273, 275, 0x4003b, // [47]
		289, 291, 0x2006e, // [48]
		325, 327, 0x14005a, // [49]
		330, 332, 0x100002, // [50]
		338, 340, 0x2e0002, // [51]
		327, 329, 0x30014, // [52]
		332, 334, 0x30010, // [53]
		343, 346, 0x3c0043, // [54]
		352, 352, 0x280002, // [55]
		346, 347, 0x19003c, // [56]
		347, 350, 0x40019, // [57]
		355, 356, 0x69003f, // [58]
		359, 359, 0x310002, // [59]
		356, 358, 0x30069, // [60]
		363, 365, 0x20023, // [61]
		369, 374, 0x38002f, // [62]
		398, 399, 0x380002, // [63]
		403, 403, 0x240002, // [64]
		374, 378, 0x110038, // [65]
		385, 386, 0x140003, // [66]
		390, 391, 0x210003, // [67]
		378, 382, 0xc0011, // [68]
		386, 388, 0xc0014, // [69]
		399, 401, 0x30038, // [70]
		406, 407, 0x150055, // [71]
		410, 410, 0x360002, // [72]
		413, 414, 0x3c0002, // [73]
		407, 409, 0x30015, // [74]
		410, 412, 0x30036, // [75]
		417, 419, 0x190038, // [76]
		422, 422, 0xc0002, // [77]
		419, 421, 0x30019, // [78]
		427, 428, 0x12003d, // [79]
		431, 432, 0x100002, // [80]
		435, 436, 0x100002, // [81]
		439, 439, 0x1b0002, // [82]
		442, 443, 0x100002, // [83]
		447, 447, 0x4b0002, // [84]
		450, 452, 0x100002, // [85]
		455, 456, 0x100002, // [86]
		459, 459, 0x200002, // [87]
		462, 463, 0x100002, // [88]
		467, 467, 0x3e0002, // [89]
		471, 471, 0x290002, // [90]
		474, 474, 0x1c0002, // [91]
		428, 430, 0x30012, // [92]
		432, 434, 0x30010, // [93]
		436, 438, 0x30010, // [94]
		439, 441, 0x3001b, // [95]
		443, 445, 0x30010, // [96]
		447, 449, 0x3004b, // [97]
		452, 454, 0x30010, // [98]
		456, 458, 0x30010, // [99]
		459, 461, 0x30020, // [100]
		463, 465, 0x30010, // [101]
		467, 469, 0x3003e, // [102]
		471, 473, 0x30029, // [103]
	},
	NumStmt: [104]uint16{
		1, // 0
		2, // 1
		3, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		4, // 9
		1, // 10
		1, // 11
		1, // 12
		6, // 13
		6, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		4, // 20
		1, // 21
		1, // 22
		3, // 23
		2, // 24
		1, // 25
		1, // 26
		3, // 27
		1, // 28
		1, // 29
		4, // 30
		1, // 31
		1, // 32
		3, // 33
		1, // 34
		9, // 35
		1, // 36
		1, // 37
		2, // 38
		2, // 39
		1, // 40
		2, // 41
		3, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		3, // 50
		3, // 51
		1, // 52
		1, // 53
		3, // 54
		1, // 55
		1, // 56
		2, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		5, // 62
		2, // 63
		1, // 64
		4, // 65
		2, // 66
		2, // 67
		2, // 68
		2, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		1, // 78
		1, // 79
		2, // 80
		2, // 81
		1, // 82
		2, // 83
		1, // 84
		3, // 85
		2, // 86
		1, // 87
		2, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
		1, // 103
	},
}
var _ = _cover_atomic_.LoadUint32
