//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/collection_val.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package lockbasedtxmgr; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
)

// collNameValidator validates the presence of a collection in a namespace
// This is expected to be instantiated in the context of a simulator/queryexecutor
type collNameValidator struct {
	ccInfoProvider ledger.DeployedChaincodeInfoProvider
	queryExecutor  *lockBasedQueryExecutor
	cache          collConfigCache
}

func newCollNameValidator(ccInfoProvider ledger.DeployedChaincodeInfoProvider, qe *lockBasedQueryExecutor) *collNameValidator {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[0], 1);
	return &collNameValidator{ccInfoProvider, qe, make(collConfigCache)}
}

func (v *collNameValidator) validateCollName(ns, coll string) error {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[1], 1);
	if !v.cache.isPopulatedFor(ns) {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[4], 1);
		conf, err := v.retrieveCollConfigFromStateDB(ns)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[6], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[5], 1);v.cache.populate(ns, conf)
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[2], 1);if !v.cache.containsCollName(ns, coll) {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[7], 1);
		return &ledger.InvalidCollNameError{
			Ns:   ns,
			Coll: coll,
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[3], 1);return nil
}

func (v *collNameValidator) retrieveCollConfigFromStateDB(ns string) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[8], 1);
	logger.Debugf("retrieveCollConfigFromStateDB() begin - ns=[%s]", ns)
	ccInfo, err := v.ccInfoProvider.ChaincodeInfo(ns, v.queryExecutor)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[11], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[9], 1);if ccInfo == nil || ccInfo.CollectionConfigPkg == nil {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[12], 1);
		return nil, &ledger.CollConfigNotDefinedError{Ns: ns}
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[10], 1);confPkg := ccInfo.CollectionConfigPkg
	logger.Debugf("retrieveCollConfigFromStateDB() successfully retrieved - ns=[%s], confPkg=[%s]", ns, confPkg)
	return confPkg, nil
}

type collConfigCache map[collConfigkey]bool

type collConfigkey struct {
	ns, coll string
}

func (c collConfigCache) populate(ns string, pkg *common.CollectionConfigPackage) {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[13], 1);
	// an entry with an empty collection name to indicate that the cache is populated for the namespace 'ns'
	// see function 'isPopulatedFor'
	c[collConfigkey{ns, ""}] = true
	for _, config := range pkg.Config {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[14], 1);
		sConfig := config.GetStaticCollectionConfig()
		if sConfig == nil {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[16], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[15], 1);c[collConfigkey{ns, sConfig.Name}] = true
	}
}

func (c collConfigCache) isPopulatedFor(ns string) bool {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[17], 1);
	return c[collConfigkey{ns, ""}]
}

func (c collConfigCache) containsCollName(ns, coll string) bool {_cover_atomic_.AddUint32(&GoCover_0_386331373365306636336339.Count[18], 1);
	return c[collConfigkey{ns, coll}]
}

var GoCover_0_386331373365306636336339 = struct {
	Count     [19]uint32
	Pos       [3 * 19]uint32
	NumStmt   [19]uint16
} {
	Pos: [3 * 19]uint32{
		21, 23, 0x2007f, // [0]
		25, 26, 0x210045, // [1]
		33, 33, 0x290002, // [2]
		39, 39, 0xc0002, // [3]
		26, 28, 0x110021, // [4]
		31, 31, 0x1d0003, // [5]
		28, 30, 0x40011, // [6]
		33, 38, 0x30029, // [7]
		42, 45, 0x10006f, // [8]
		48, 48, 0x380002, // [9]
		51, 53, 0x150002, // [10]
		45, 47, 0x30010, // [11]
		48, 50, 0x30038, // [12]
		62, 66, 0x240053, // [13]
		66, 68, 0x150024, // [14]
		71, 71, 0x2c0003, // [15]
		68, 69, 0xc0015, // [16]
		75, 77, 0x20039, // [17]
		79, 81, 0x20041, // [18]
	},
	NumStmt: [19]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		3, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
	},
}
var _ = _cover_atomic_.LoadUint32
