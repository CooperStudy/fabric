//line /home/cooper/go/src/github.com/hyperledger/fabric/core/admin/admin.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package admin; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"
	"strings"

	"github.com/golang/protobuf/ptypes/empty"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var logger = flogging.MustGetLogger("server")

type requestValidator interface {
	validate(ctx context.Context, env *common.Envelope) (*pb.AdminOperation, error)
}

// AccessControlEvaluator evaluates whether the creator of the given SignedData
// is eligible of using the admin service
type AccessControlEvaluator interface {
	// Evaluate evaluates the eligibility of the creator of the given SignedData
	// for being serviced by the admin service
	Evaluate(signatureSet []*common.SignedData) error
}

// NewAdminServer creates and returns a Admin service instance.
func NewAdminServer(ace AccessControlEvaluator) *ServerAdmin {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[0], 1);
	s := &ServerAdmin{
		v: &validator{
			ace: ace,
		},
		specAtStartup: flogging.Global.Spec(),
	}
	return s
}

// ServerAdmin implementation of the Admin service for the Peer
type ServerAdmin struct {
	v requestValidator

	specAtStartup string
}

func (s *ServerAdmin) GetStatus(ctx context.Context, env *common.Envelope) (*pb.ServerStatus, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[1], 1);
	if _, err := s.v.validate(ctx, env); err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[3], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[2], 1);status := &pb.ServerStatus{Status: pb.ServerStatus_STARTED}
	logger.Debugf("returning status: %s", status)
	return status, nil
}

func (s *ServerAdmin) StartServer(ctx context.Context, env *common.Envelope) (*pb.ServerStatus, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[4], 1);
	if _, err := s.v.validate(ctx, env); err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[6], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[5], 1);status := &pb.ServerStatus{Status: pb.ServerStatus_STARTED}
	logger.Debugf("returning status: %s", status)
	return status, nil
}

func (s *ServerAdmin) GetModuleLogLevel(ctx context.Context, env *common.Envelope) (*pb.LogLevelResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[7], 1);
	op, err := s.v.validate(ctx, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[10], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[8], 1);request := op.GetLogReq()
	if request == nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[11], 1);
		return nil, errors.New("request is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[9], 1);logLevelString := flogging.GetLoggerLevel(request.LogModule)
	logResponse := &pb.LogLevelResponse{LogModule: request.LogModule, LogLevel: logLevelString}
	return logResponse, nil
}

func (s *ServerAdmin) SetModuleLogLevel(ctx context.Context, env *common.Envelope) (*pb.LogLevelResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[12], 1);
	op, err := s.v.validate(ctx, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[16], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[13], 1);request := op.GetLogReq()
	if request == nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[17], 1);
		return nil, errors.New("request is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[14], 1);spec := fmt.Sprintf("%s:%s=%s", flogging.Global.Spec(), request.LogModule, request.LogLevel)
	err = flogging.Global.ActivateSpec(spec)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[18], 1);
		err = status.Errorf(codes.InvalidArgument, "error setting log spec to '%s': %s", spec, err.Error())
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[15], 1);logResponse := &pb.LogLevelResponse{LogModule: request.LogModule, LogLevel: strings.ToUpper(request.LogLevel)}
	return logResponse, nil
}

func (s *ServerAdmin) RevertLogLevels(ctx context.Context, env *common.Envelope) (*empty.Empty, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[19], 1);
	if _, err := s.v.validate(ctx, env); err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[21], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[20], 1);flogging.ActivateSpec(s.specAtStartup)
	return &empty.Empty{}, nil
}

func (s *ServerAdmin) GetLogSpec(ctx context.Context, env *common.Envelope) (*pb.LogSpecResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[22], 1);
	if _, err := s.v.validate(ctx, env); err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[24], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[23], 1);logSpec := flogging.Global.Spec()
	logResponse := &pb.LogSpecResponse{LogSpec: logSpec}
	return logResponse, nil
}

func (s *ServerAdmin) SetLogSpec(ctx context.Context, env *common.Envelope) (*pb.LogSpecResponse, error) {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[25], 1);
	op, err := s.v.validate(ctx, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[29], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[26], 1);request := op.GetLogSpecReq()
	if request == nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[30], 1);
		return nil, errors.New("request is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[27], 1);err = flogging.Global.ActivateSpec(request.LogSpec)
	logResponse := &pb.LogSpecResponse{
		LogSpec: request.LogSpec,
	}
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[31], 1);
		logResponse.Error = err.Error()
	}
	_cover_atomic_.AddUint32(&GoCover_0_353964393634633462376530.Count[28], 1);return logResponse, nil
}

var GoCover_0_353964393634633462376530 = struct {
	Count     [32]uint32
	Pos       [3 * 32]uint32
	NumStmt   [32]uint16
} {
	Pos: [3 * 32]uint32{
		38, 46, 0x2003e, // [0]
		55, 56, 0x320066, // [1]
		59, 61, 0x140002, // [2]
		56, 58, 0x30032, // [3]
		64, 65, 0x320068, // [4]
		68, 70, 0x140002, // [5]
		65, 67, 0x30032, // [6]
		73, 75, 0x100072, // [7]
		78, 79, 0x140002, // [8]
		82, 84, 0x190002, // [9]
		75, 77, 0x30010, // [10]
		79, 81, 0x30014, // [11]
		87, 89, 0x100072, // [12]
		92, 93, 0x140002, // [13]
		97, 99, 0x100002, // [14]
		104, 105, 0x190002, // [15]
		89, 91, 0x30010, // [16]
		93, 95, 0x30014, // [17]
		99, 102, 0x30010, // [18]
		108, 109, 0x320068, // [19]
		112, 113, 0x1c0002, // [20]
		109, 111, 0x30032, // [21]
		116, 117, 0x32006a, // [22]
		120, 122, 0x190002, // [23]
		117, 119, 0x30032, // [24]
		125, 127, 0x10006a, // [25]
		130, 131, 0x140002, // [26]
		134, 138, 0x100002, // [27]
		141, 141, 0x190002, // [28]
		127, 129, 0x30010, // [29]
		131, 133, 0x30014, // [30]
		138, 140, 0x30010, // [31]
	},
	NumStmt: [32]uint16{
		2, // 0
		1, // 1
		3, // 2
		1, // 3
		1, // 4
		3, // 5
		1, // 6
		2, // 7
		2, // 8
		3, // 9
		1, // 10
		1, // 11
		2, // 12
		2, // 13
		3, // 14
		2, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		2, // 20
		1, // 21
		1, // 22
		3, // 23
		1, // 24
		2, // 25
		2, // 26
		3, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
	},
}
var _ = _cover_atomic_.LoadUint32
