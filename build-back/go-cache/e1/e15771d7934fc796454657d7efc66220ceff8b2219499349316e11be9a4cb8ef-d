//line /home/cooper/go/src/github.com/hyperledger/fabric/core/handlers/validation/builtin/v13/validation_logic.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package v13; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"regexp"

	commonerrors "github.com/hyperledger/fabric/common/errors"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/chaincode/platforms/ccmetadata"
	. "github.com/hyperledger/fabric/core/common/validation/statebased"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/capabilities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/identities"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/policies"
	. "github.com/hyperledger/fabric/core/handlers/validation/api/state"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
)

var logger = flogging.MustGetLogger("vscc")

var validCollectionNameRegex = regexp.MustCompile(ccmetadata.AllowedCharsCollectionName)

//go:generate mockery -dir ../../api/capabilities/ -name Capabilities -case underscore -output mocks/
//go:generate mockery -dir ../../api/state/ -name StateFetcher -case underscore -output mocks/
//go:generate mockery -dir ../../api/identities/ -name IdentityDeserializer -case underscore -output mocks/
//go:generate mockery -dir ../../api/policies/ -name PolicyEvaluator -case underscore -output mocks/
//go:generate mockery -dir . -name StateBasedValidator -case underscore -output mocks/

// New creates a new instance of the default VSCC
// Typically this will only be invoked once per peer
func New(c Capabilities, s StateFetcher, d IdentityDeserializer, pe PolicyEvaluator) *Validator {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[0], 1);
	vpmgr := &KeyLevelValidationParameterManagerImpl{StateFetcher: s}
	sbv := NewKeyLevelValidator(pe, vpmgr)

	return &Validator{
		capabilities:        c,
		stateFetcher:        s,
		deserializer:        d,
		policyEvaluator:     pe,
		stateBasedValidator: sbv,
	}
}

// Validator implements the default transaction validation policy,
// which is to check the correctness of the read-write set and the endorsement
// signatures against an endorsement policy that is supplied as argument to
// every invoke
type Validator struct {
	deserializer        IdentityDeserializer
	capabilities        Capabilities
	stateFetcher        StateFetcher
	policyEvaluator     PolicyEvaluator
	stateBasedValidator StateBasedValidator
}

type validationArtifacts struct {
	rwset        []byte
	prp          []byte
	endorsements []*peer.Endorsement
	chdr         *common.ChannelHeader
	env          *common.Envelope
	payl         *common.Payload
	cap          *peer.ChaincodeActionPayload
}

func (vscc *Validator) extractValidationArtifacts(
	block *common.Block,
	txPosition int,
	actionPosition int,
) (*validationArtifacts, error) {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[1], 1);
	// get the envelope...
	env, err := utils.GetEnvelopeFromBlock(block.Data.Data[txPosition])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[11], 1);
		logger.Errorf("VSCC error: GetEnvelope failed, err %s", err)
		return nil, err
	}

	// ...and the payload...
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[2], 1);payl, err := utils.GetPayload(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[12], 1);
		logger.Errorf("VSCC error: GetPayload failed, err %s", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[3], 1);chdr, err := utils.UnmarshalChannelHeader(payl.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[13], 1);
		return nil, err
	}

	// validate the payload type
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[4], 1);if common.HeaderType(chdr.Type) != common.HeaderType_ENDORSER_TRANSACTION {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[14], 1);
		logger.Errorf("Only Endorser Transactions are supported, provided type %d", chdr.Type)
		err = fmt.Errorf("Only Endorser Transactions are supported, provided type %d", chdr.Type)
		return nil, err
	}

	// ...and the transaction...
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[5], 1);tx, err := utils.GetTransaction(payl.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[15], 1);
		logger.Errorf("VSCC error: GetTransaction failed, err %s", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[6], 1);cap, err := utils.GetChaincodeActionPayload(tx.Actions[actionPosition].Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[16], 1);
		logger.Errorf("VSCC error: GetChaincodeActionPayload failed, err %s", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[7], 1);pRespPayload, err := utils.GetProposalResponsePayload(cap.Action.ProposalResponsePayload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[17], 1);
		err = fmt.Errorf("GetProposalResponsePayload error %s", err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[8], 1);if pRespPayload.Extension == nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[18], 1);
		err = fmt.Errorf("nil pRespPayload.Extension")
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[9], 1);respPayload, err := utils.GetChaincodeAction(pRespPayload.Extension)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[19], 1);
		err = fmt.Errorf("GetChaincodeAction error %s", err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[10], 1);return &validationArtifacts{
		rwset:        respPayload.Results,
		prp:          cap.Action.ProposalResponsePayload,
		endorsements: cap.Action.Endorsements,
		chdr:         chdr,
		env:          env,
		payl:         payl,
		cap:          cap,
	}, nil
}

// Validate validates the given envelope corresponding to a transaction with an endorsement
// policy as given in its serialized form.
// Note that in the case of dependencies in a block, such as tx_n modifying the endorsement policy
// for key a and tx_n+1 modifying the value of key a, Validate(tx_n+1) will block until Validate(tx_n)
// has been resolved. If working with a limited number of goroutines for parallel validation, ensure
// that they are allocated to transactions in ascending order.
func (vscc *Validator) Validate(
	block *common.Block,
	namespace string,
	txPosition int,
	actionPosition int,
	policyBytes []byte,
) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[20], 1);
	vscc.stateBasedValidator.PreValidate(uint64(txPosition), block)

	va, err := vscc.extractValidationArtifacts(block, txPosition, actionPosition)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[24], 1);
		vscc.stateBasedValidator.PostValidate(namespace, block.Header.Number, uint64(txPosition), err)
		return policyErr(err)
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[21], 1);txverr := vscc.stateBasedValidator.Validate(
		namespace,
		block.Header.Number,
		uint64(txPosition),
		va.rwset,
		va.prp,
		policyBytes,
		va.endorsements,
	)
	if txverr != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[25], 1);
		logger.Errorf("VSCC error: stateBasedValidator.Validate failed, err %s", txverr)
		vscc.stateBasedValidator.PostValidate(namespace, block.Header.Number, uint64(txPosition), txverr)
		return txverr
	}

	// do some extra validation that is specific to lscc
	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[22], 1);if namespace == "lscc" {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[26], 1);
		logger.Debugf("VSCC info: doing special validation for LSCC")
		err := vscc.ValidateLSCCInvocation(va.chdr.ChannelId, va.env, va.cap, va.payl, vscc.capabilities)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[27], 1);
			logger.Errorf("VSCC error: ValidateLSCCInvocation failed, err %s", err)
			vscc.stateBasedValidator.PostValidate(namespace, block.Header.Number, uint64(txPosition), err)
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[23], 1);vscc.stateBasedValidator.PostValidate(namespace, block.Header.Number, uint64(txPosition), nil)
	return nil
}

func policyErr(err error) *commonerrors.VSCCEndorsementPolicyError {_cover_atomic_.AddUint32(&GoCover_1_333464623263633231393534.Count[28], 1);
	return &commonerrors.VSCCEndorsementPolicyError{
		Err: err,
	}
}

var GoCover_1_333464623263633231393534 = struct {
	Count     [29]uint32
	Pos       [3 * 29]uint32
	NumStmt   [29]uint16
} {
	Pos: [3 * 29]uint32{
		38, 49, 0x20061, // [0]
		77, 80, 0x100021, // [1]
		86, 87, 0x100002, // [2]
		92, 93, 0x100002, // [3]
		98, 98, 0x4c0002, // [4]
		105, 106, 0x100002, // [5]
		111, 112, 0x100002, // [6]
		117, 118, 0x100002, // [7]
		122, 122, 0x230002, // [8]
		126, 127, 0x100002, // [9]
		132, 140, 0x80002, // [10]
		80, 83, 0x30010, // [11]
		87, 90, 0x30010, // [12]
		93, 95, 0x30010, // [13]
		98, 102, 0x3004c, // [14]
		106, 109, 0x30010, // [15]
		112, 115, 0x30010, // [16]
		118, 121, 0x30010, // [17]
		122, 125, 0x30023, // [18]
		127, 130, 0x30010, // [19]
		155, 159, 0x100022, // [20]
		164, 173, 0x130002, // [21]
		180, 180, 0x190002, // [22]
		190, 191, 0xc0002, // [23]
		159, 162, 0x30010, // [24]
		173, 177, 0x30013, // [25]
		180, 183, 0x110019, // [26]
		183, 187, 0x40011, // [27]
		194, 198, 0x20044, // [28]
	},
	NumStmt: [29]uint16{
		3, // 0
		2, // 1
		2, // 2
		2, // 3
		1, // 4
		2, // 5
		2, // 6
		2, // 7
		1, // 8
		2, // 9
		1, // 10
		2, // 11
		2, // 12
		1, // 13
		3, // 14
		2, // 15
		2, // 16
		2, // 17
		2, // 18
		2, // 19
		3, // 20
		2, // 21
		1, // 22
		2, // 23
		2, // 24
		3, // 25
		3, // 26
		3, // 27
		1, // 28
	},
}
var _ = _cover_atomic_.LoadUint32
