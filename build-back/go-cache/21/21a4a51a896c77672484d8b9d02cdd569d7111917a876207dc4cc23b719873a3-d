//line /home/cooper/go/src/github.com/hyperledger/fabric/common/policies/implicitmeta.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package policies; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	cb "github.com/hyperledger/fabric/protos/common"
	"go.uber.org/zap/zapcore"
)

type implicitMetaPolicy struct {
	threshold   int
	subPolicies []Policy

	// Only used for logging
	managers      map[string]*ManagerImpl
	subPolicyName string
}

// NewPolicy creates a new policy based on the policy bytes
func newImplicitMetaPolicy(data []byte, managers map[string]*ManagerImpl) (*implicitMetaPolicy, error) {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[0], 1);
	definition := &cb.ImplicitMetaPolicy{}
	if err := proto.Unmarshal(data, definition); err != nil {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[5], 1);
		return nil, fmt.Errorf("Error unmarshaling to ImplicitMetaPolicy: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[1], 1);subPolicies := make([]Policy, len(managers))

	i := 0
	for _, manager := range managers {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[6], 1);
		subPolicies[i], _ = manager.GetPolicy(definition.SubPolicy)
		i++
	}

	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[2], 1);var threshold int

	switch definition.Rule {
	case cb.ImplicitMetaPolicy_ANY:_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[7], 1);
		threshold = 1
	case cb.ImplicitMetaPolicy_ALL:_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[8], 1);
		threshold = len(subPolicies)
	case cb.ImplicitMetaPolicy_MAJORITY:_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[9], 1);
		threshold = len(subPolicies)/2 + 1
	}

	// In the special case that there are no policies, consider 0 to be a majority or any
	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[3], 1);if len(subPolicies) == 0 {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[10], 1);
		threshold = 0
	}

	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[4], 1);return &implicitMetaPolicy{
		subPolicies:   subPolicies,
		threshold:     threshold,
		managers:      managers,
		subPolicyName: definition.SubPolicy,
	}, nil
}

// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy
func (imp *implicitMetaPolicy) Evaluate(signatureSet []*cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[11], 1);
	logger.Debugf("This is an implicit meta policy, it will trigger other policy evaluations, whose failures may be benign")
	remaining := imp.threshold

	defer func() {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[15], 1);
		if remaining != 0 {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[16], 1);
			// This log message may be large and expensive to construct, so worth checking the log level
			if logger.IsEnabledFor(zapcore.DebugLevel) {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[17], 1);
				var b bytes.Buffer
				b.WriteString(fmt.Sprintf("Evaluation Failed: Only %d policies were satisfied, but needed %d of [ ", imp.threshold-remaining, imp.threshold))
				for m := range imp.managers {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[19], 1);
					b.WriteString(m)
					b.WriteString(".")
					b.WriteString(imp.subPolicyName)
					b.WriteString(" ")
				}
				_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[18], 1);b.WriteString("]")
				logger.Debugf(b.String())
			}
		}
	}()

	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[12], 1);for _, policy := range imp.subPolicies {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[20], 1);
		if policy.Evaluate(signatureSet) == nil {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[21], 1);
			remaining--
			if remaining == 0 {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[22], 1);
				return nil
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[13], 1);if remaining == 0 {_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[23], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_306461616464623964633937.Count[14], 1);return fmt.Errorf("Failed to reach implicit threshold of %d sub-policies, required %d remaining", imp.threshold, remaining)
}

var GoCover_0_306461616464623964633937 = struct {
	Count     [24]uint32
	Pos       [3 * 24]uint32
	NumStmt   [24]uint16
} {
	Pos: [3 * 24]uint32{
		28, 30, 0x3a0068, // [0]
		34, 37, 0x230002, // [1]
		42, 44, 0x190002, // [2]
		54, 54, 0x1b0002, // [3]
		58, 63, 0x80002, // [4]
		30, 32, 0x3003a, // [5]
		37, 40, 0x30023, // [6]
		45, 46, 0x100021, // [7]
		47, 48, 0x1f0021, // [8]
		49, 50, 0x250026, // [9]
		54, 56, 0x3001b, // [10]
		67, 71, 0xf004e, // [11]
		89, 89, 0x290002, // [12]
		97, 97, 0x140002, // [13]
		100, 100, 0x7d0002, // [14]
		71, 72, 0x15000f, // [15]
		72, 74, 0x2f0015, // [16]
		74, 77, 0x21002f, // [17]
		83, 84, 0x1e0005, // [18]
		77, 82, 0x60021, // [19]
		89, 90, 0x2b0029, // [20]
		90, 92, 0x16002b, // [21]
		92, 94, 0x50016, // [22]
		97, 99, 0x30014, // [23]
	},
	NumStmt: [24]uint16{
		2, // 0
		3, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		3, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		3, // 17
		2, // 18
		4, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
	},
}
var _ = _cover_atomic_.LoadUint32
