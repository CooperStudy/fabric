//line /home/cooper/go/src/github.com/hyperledger/fabric/core/scc/lscc/deployedcc_infoprovider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package lscc; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
	"github.com/pkg/errors"
)

const (
	lsccNamespace = "lscc"
)

// DeployedCCInfoProvider implements ineterface ledger.DeployedChaincodeInfoProvider
type DeployedCCInfoProvider struct {
}

// Namespaces implements function in interface ledger.DeployedChaincodeInfoProvider
func (p *DeployedCCInfoProvider) Namespaces() []string {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[0], 1);
	return []string{lsccNamespace}
}

// UpdatedChaincodes implements function in interface ledger.DeployedChaincodeInfoProvider
func (p *DeployedCCInfoProvider) UpdatedChaincodes(stateUpdates map[string][]*kvrwset.KVWrite) ([]*ledger.ChaincodeLifecycleInfo, error) {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[1], 1);
	lsccUpdates := stateUpdates[lsccNamespace]
	lifecycleInfo := []*ledger.ChaincodeLifecycleInfo{}
	updatedCCNames := map[string]bool{}

	for _, kvWrite := range lsccUpdates {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[4], 1);
		if kvWrite.IsDelete {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[7], 1);
			// lscc namespace is not expected to have deletes
			continue
		}
		// There are LSCC entries for the chaincode and for the chaincode collections.
		// We can detect collections based on the presence of a CollectionSeparator,
		// which never exists in chaincode names.
		_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[5], 1);if privdata.IsCollectionConfigKey(kvWrite.Key) {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[8], 1);
			ccname := privdata.GetCCNameFromCollectionConfigKey(kvWrite.Key)
			updatedCCNames[ccname] = true
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[6], 1);updatedCCNames[kvWrite.Key] = true
	}

	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[2], 1);for updatedCCNames := range updatedCCNames {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[9], 1);
		lifecycleInfo = append(lifecycleInfo, &ledger.ChaincodeLifecycleInfo{Name: updatedCCNames})
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[3], 1);return lifecycleInfo, nil
}

// ChaincodeInfo implements function in interface ledger.DeployedChaincodeInfoProvider
func (p *DeployedCCInfoProvider) ChaincodeInfo(chaincodeName string, qe ledger.SimpleQueryExecutor) (*ledger.DeployedChaincodeInfo, error) {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[10], 1);
	chaincodeDataBytes, err := qe.GetState(lsccNamespace, chaincodeName)
	if err != nil || chaincodeDataBytes == nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[14], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[11], 1);chaincodeData := &ccprovider.ChaincodeData{}
	if err := proto.Unmarshal(chaincodeDataBytes, chaincodeData); err != nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[15], 1);
		return nil, errors.Wrap(err, "error unmarshalling chaincode state data")
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[12], 1);collConfigPkg, err := fetchCollConfigPkg(chaincodeName, qe)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[16], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[13], 1);return &ledger.DeployedChaincodeInfo{
		Name:                chaincodeName,
		Hash:                chaincodeData.Id,
		Version:             chaincodeData.Version,
		CollectionConfigPkg: collConfigPkg,
	}, nil
}

// CollectionInfo implements function in interface ledger.DeployedChaincodeInfoProvider
func (p *DeployedCCInfoProvider) CollectionInfo(chaincodeName, collectionName string, qe ledger.SimpleQueryExecutor) (*common.StaticCollectionConfig, error) {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[17], 1);
	collConfigPkg, err := fetchCollConfigPkg(chaincodeName, qe)
	if err != nil || collConfigPkg == nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[20], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[18], 1);for _, conf := range collConfigPkg.Config {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[21], 1);
		staticCollConfig := conf.GetStaticCollectionConfig()
		if staticCollConfig != nil && staticCollConfig.Name == collectionName {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[22], 1);
			return staticCollConfig, nil
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[19], 1);return nil, nil
}

func fetchCollConfigPkg(chaincodeName string, qe ledger.SimpleQueryExecutor) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[23], 1);
	collKey := privdata.BuildCollectionKVSKey(chaincodeName)
	collectionConfigPkgBytes, err := qe.GetState(lsccNamespace, collKey)
	if err != nil || collectionConfigPkgBytes == nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[26], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[24], 1);collectionConfigPkg := &common.CollectionConfigPackage{}
	if err := proto.Unmarshal(collectionConfigPkgBytes, collectionConfigPkg); err != nil {_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[27], 1);
		return nil, errors.Wrap(err, "error unmarshalling chaincode collection config pkg")
	}
	_cover_atomic_.AddUint32(&GoCover_0_386331393235373732613932.Count[25], 1);return collectionConfigPkg, nil
}

var GoCover_0_386331393235373732613932 = struct {
	Count     [28]uint32
	Pos       [3 * 28]uint32
	NumStmt   [28]uint16
} {
	Pos: [3 * 28]uint32{
		28, 30, 0x20038, // [0]
		33, 38, 0x26008a, // [1]
		54, 54, 0x2d0002, // [2]
		57, 57, 0x1b0002, // [3]
		38, 39, 0x170026, // [4]
		46, 46, 0x320003, // [5]
		51, 51, 0x250003, // [6]
		39, 41, 0xc0017, // [7]
		46, 49, 0xc0032, // [8]
		54, 56, 0x3002d, // [9]
		61, 63, 0x2d008c, // [10]
		66, 67, 0x4b0002, // [11]
		70, 71, 0x100002, // [12]
		74, 79, 0x80002, // [13]
		63, 65, 0x3002d, // [14]
		67, 69, 0x3004b, // [15]
		71, 73, 0x30010, // [16]
		83, 85, 0x28009e, // [17]
		88, 88, 0x2c0002, // [18]
		94, 94, 0x110002, // [19]
		85, 87, 0x30028, // [20]
		88, 90, 0x49002c, // [21]
		90, 92, 0x40049, // [22]
		97, 100, 0x330077, // [23]
		103, 104, 0x570002, // [24]
		107, 107, 0x210002, // [25]
		100, 102, 0x30033, // [26]
		104, 106, 0x30057, // [27]
	},
	NumStmt: [28]uint16{
		1, // 0
		4, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		2, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		3, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
	},
}
var _ = _cover_atomic_.LoadUint32
