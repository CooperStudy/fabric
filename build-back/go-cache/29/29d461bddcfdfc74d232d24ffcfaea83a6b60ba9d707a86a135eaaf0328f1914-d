//line /home/cooper/go/src/github.com/hyperledger/fabric/common/configtx/compare.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package configtx; import _cover_atomic_ "sync/atomic"

import (
	"bytes"

	cb "github.com/hyperledger/fabric/protos/common"
)

type comparable struct {
	*cb.ConfigGroup
	*cb.ConfigValue
	*cb.ConfigPolicy
	key  string
	path []string
}

func (cg comparable) equals(other comparable) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[0], 1);
	switch {
	case cg.ConfigGroup != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[2], 1);
		if other.ConfigGroup == nil {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[8], 1);
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[3], 1);return equalConfigGroup(cg.ConfigGroup, other.ConfigGroup)
	case cg.ConfigValue != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[4], 1);
		if other.ConfigValue == nil {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[9], 1);
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[5], 1);return equalConfigValues(cg.ConfigValue, other.ConfigValue)
	case cg.ConfigPolicy != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[6], 1);
		if other.ConfigPolicy == nil {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[10], 1);
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[7], 1);return equalConfigPolicies(cg.ConfigPolicy, other.ConfigPolicy)
	}

	// Unreachable
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[1], 1);return false
}

func (cg comparable) version() uint64 {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[11], 1);
	switch {
	case cg.ConfigGroup != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[13], 1);
		return cg.ConfigGroup.Version
	case cg.ConfigValue != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[14], 1);
		return cg.ConfigValue.Version
	case cg.ConfigPolicy != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[15], 1);
		return cg.ConfigPolicy.Version
	}

	// Unreachable
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[12], 1);return 0
}

func (cg comparable) modPolicy() string {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[16], 1);
	switch {
	case cg.ConfigGroup != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[18], 1);
		return cg.ConfigGroup.ModPolicy
	case cg.ConfigValue != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[19], 1);
		return cg.ConfigValue.ModPolicy
	case cg.ConfigPolicy != nil:_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[20], 1);
		return cg.ConfigPolicy.ModPolicy
	}

	// Unreachable
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[17], 1);return ""
}

func equalConfigValues(lhs, rhs *cb.ConfigValue) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[21], 1);
	return lhs.Version == rhs.Version &&
		lhs.ModPolicy == rhs.ModPolicy &&
		bytes.Equal(lhs.Value, rhs.Value)
}

func equalConfigPolicies(lhs, rhs *cb.ConfigPolicy) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[22], 1);
	if lhs.Version != rhs.Version ||
		lhs.ModPolicy != rhs.ModPolicy {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[25], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[23], 1);if lhs.Policy == nil || rhs.Policy == nil {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[26], 1);
		return lhs.Policy == rhs.Policy
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[24], 1);return lhs.Policy.Type == rhs.Policy.Type &&
		bytes.Equal(lhs.Policy.Value, rhs.Policy.Value)
}

// The subset functions check if inner is a subset of outer
// TODO, try to consolidate these three methods into one, as the code
// contents are the same, but the function signatures need to be different
func subsetOfGroups(inner, outer map[string]*cb.ConfigGroup) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[27], 1);
	// The empty set is a subset of all sets
	if len(inner) == 0 {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[31], 1);
		return true
	}

	// If inner has more elements than outer, it cannot be a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[28], 1);if len(inner) > len(outer) {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[32], 1);
		return false
	}

	// If any element in inner is not in outer, it is not a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[29], 1);for key := range inner {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[33], 1);
		if _, ok := outer[key]; !ok {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[34], 1);
			return false
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[30], 1);return true
}

func subsetOfPolicies(inner, outer map[string]*cb.ConfigPolicy) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[35], 1);
	// The empty set is a subset of all sets
	if len(inner) == 0 {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[39], 1);
		return true
	}

	// If inner has more elements than outer, it cannot be a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[36], 1);if len(inner) > len(outer) {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[40], 1);
		return false
	}

	// If any element in inner is not in outer, it is not a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[37], 1);for key := range inner {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[41], 1);
		if _, ok := outer[key]; !ok {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[42], 1);
			return false
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[38], 1);return true
}

func subsetOfValues(inner, outer map[string]*cb.ConfigValue) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[43], 1);
	// The empty set is a subset of all sets
	if len(inner) == 0 {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[47], 1);
		return true
	}

	// If inner has more elements than outer, it cannot be a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[44], 1);if len(inner) > len(outer) {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[48], 1);
		return false
	}

	// If any element in inner is not in outer, it is not a subset
	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[45], 1);for key := range inner {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[49], 1);
		if _, ok := outer[key]; !ok {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[50], 1);
			return false
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[46], 1);return true
}

func equalConfigGroup(lhs, rhs *cb.ConfigGroup) bool {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[51], 1);
	if lhs.Version != rhs.Version ||
		lhs.ModPolicy != rhs.ModPolicy {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[54], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[52], 1);if !subsetOfGroups(lhs.Groups, rhs.Groups) ||
		!subsetOfGroups(rhs.Groups, lhs.Groups) ||
		!subsetOfPolicies(lhs.Policies, rhs.Policies) ||
		!subsetOfPolicies(rhs.Policies, lhs.Policies) ||
		!subsetOfValues(lhs.Values, rhs.Values) ||
		!subsetOfValues(rhs.Values, lhs.Values) {_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[55], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_0_346532363364653032376334.Count[53], 1);return true
}

var GoCover_0_346532363364653032376334 = struct {
	Count     [56]uint32
	Pos       [3 * 56]uint32
	NumStmt   [56]uint16
} {
	Pos: [3 * 56]uint32{
		23, 24, 0x90034, // [0]
		43, 43, 0xe0002, // [1]
		25, 26, 0x1f001d, // [2]
		29, 29, 0x3d0003, // [3]
		30, 31, 0x1f001d, // [4]
		34, 34, 0x3e0003, // [5]
		35, 36, 0x20001e, // [6]
		39, 39, 0x420003, // [7]
		26, 28, 0x4001f, // [8]
		31, 33, 0x4001f, // [9]
		36, 38, 0x40020, // [10]
		46, 47, 0x90027, // [11]
		57, 57, 0xa0002, // [12]
		48, 49, 0x20001d, // [13]
		50, 51, 0x20001d, // [14]
		52, 53, 0x21001e, // [15]
		60, 61, 0x90029, // [16]
		71, 71, 0xb0002, // [17]
		62, 63, 0x22001d, // [18]
		64, 65, 0x22001d, // [19]
		66, 67, 0x23001e, // [20]
		74, 78, 0x20037, // [21]
		80, 82, 0x22003a, // [22]
		86, 86, 0x2c0002, // [23]
		90, 91, 0x320002, // [24]
		82, 84, 0x30022, // [25]
		86, 88, 0x3002c, // [26]
		97, 99, 0x150043, // [27]
		104, 104, 0x1d0002, // [28]
		109, 109, 0x190002, // [29]
		115, 115, 0xd0002, // [30]
		99, 101, 0x30015, // [31]
		104, 106, 0x3001d, // [32]
		109, 110, 0x1f0019, // [33]
		110, 112, 0x4001f, // [34]
		118, 120, 0x150046, // [35]
		125, 125, 0x1d0002, // [36]
		130, 130, 0x190002, // [37]
		136, 136, 0xd0002, // [38]
		120, 122, 0x30015, // [39]
		125, 127, 0x3001d, // [40]
		130, 131, 0x1f0019, // [41]
		131, 133, 0x4001f, // [42]
		139, 141, 0x150043, // [43]
		146, 146, 0x1d0002, // [44]
		151, 151, 0x190002, // [45]
		157, 157, 0xd0002, // [46]
		141, 143, 0x30015, // [47]
		146, 148, 0x3001d, // [48]
		151, 152, 0x1f0019, // [49]
		152, 154, 0x4001f, // [50]
		160, 162, 0x220036, // [51]
		166, 171, 0x2b0002, // [52]
		175, 175, 0xd0002, // [53]
		162, 164, 0x30022, // [54]
		171, 173, 0x3002b, // [55]
	},
	NumStmt: [56]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
	},
}
var _ = _cover_atomic_.LoadUint32
