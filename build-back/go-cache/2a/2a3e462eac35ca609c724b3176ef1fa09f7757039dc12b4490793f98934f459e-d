//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecouchdb/statecouchdb.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package statecouchdb; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/util/couchdb"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("statecouchdb")

// querySkip is implemented for future use by query paging
// currently defaulted to 0 and is not used
const querySkip = 0

// LsccCacheSize denotes the number of entries allowed in the lsccStateCache
const lsccCacheSize = 50

// VersionedDBProvider implements interface VersionedDBProvider
type VersionedDBProvider struct {
	couchInstance *couchdb.CouchInstance
	databases     map[string]*VersionedDB
	mux           sync.Mutex
	openCounts    uint64
}

// NewVersionedDBProvider instantiates VersionedDBProvider
func NewVersionedDBProvider(metricsProvider metrics.Provider) (*VersionedDBProvider, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[0], 1);
	logger.Debugf("constructing CouchDB VersionedDBProvider")
	couchDBDef := couchdb.GetCouchDBDefinition()
	couchInstance, err := couchdb.CreateCouchInstance(couchDBDef.URL, couchDBDef.Username, couchDBDef.Password,
		couchDBDef.MaxRetries, couchDBDef.MaxRetriesOnStartup, couchDBDef.RequestTimeout, couchDBDef.CreateGlobalChangesDB, metricsProvider)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[2], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[1], 1);return &VersionedDBProvider{couchInstance, make(map[string]*VersionedDB), sync.Mutex{}, 0}, nil
}

// GetDBHandle gets the handle to a named database
func (provider *VersionedDBProvider) GetDBHandle(dbName string) (statedb.VersionedDB, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[3], 1);
	provider.mux.Lock()
	defer provider.mux.Unlock()
	vdb := provider.databases[dbName]
	if vdb == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[5], 1);
		var err error
		vdb, err = newVersionedDB(provider.couchInstance, dbName)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[7], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[6], 1);provider.databases[dbName] = vdb
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[4], 1);return vdb, nil
}

// Close closes the underlying db instance
func (provider *VersionedDBProvider) Close() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[8], 1);
	// No close needed on Couch
}

// VersionedDB implements VersionedDB interface
type VersionedDB struct {
	couchInstance      *couchdb.CouchInstance
	metadataDB         *couchdb.CouchDatabase            // A database per channel to store metadata such as savepoint.
	chainName          string                            // The name of the chain/channel.
	namespaceDBs       map[string]*couchdb.CouchDatabase // One database per deployed chaincode.
	committedDataCache *versionsCache                    // Used as a local cache during bulk processing of a block.
	verCacheLock       sync.RWMutex
	mux                sync.RWMutex
	lsccStateCache     *lsccStateCache
}

type lsccStateCache struct {
	cache   map[string]*statedb.VersionedValue
	rwMutex sync.RWMutex
}

func (l *lsccStateCache) getState(key string) *statedb.VersionedValue {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[9], 1);
	l.rwMutex.RLock()
	defer l.rwMutex.RUnlock()

	if versionedValue, ok := l.cache[key]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[11], 1);
		logger.Debugf("key:[%s] found in the lsccStateCache", key)
		return versionedValue
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[10], 1);return nil
}

func (l *lsccStateCache) updateState(key string, value *statedb.VersionedValue) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[12], 1);
	l.rwMutex.Lock()
	defer l.rwMutex.Unlock()

	if _, ok := l.cache[key]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[13], 1);
		logger.Debugf("key:[%s] is updated in lsccStateCache", key)
		l.cache[key] = value
	}
}

func (l *lsccStateCache) setState(key string, value *statedb.VersionedValue) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[14], 1);
	l.rwMutex.Lock()
	defer l.rwMutex.Unlock()

	if l.isCacheFull() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[16], 1);
		l.evictARandomEntry()
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[15], 1);logger.Debugf("key:[%s] is stoed in lsccStateCache", key)
	l.cache[key] = value
}

func (l *lsccStateCache) isCacheFull() bool {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[17], 1);
	return len(l.cache) == lsccCacheSize
}

func (l *lsccStateCache) evictARandomEntry() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[18], 1);
	for key := range l.cache {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[19], 1);
		delete(l.cache, key)
		return
	}
}

// newVersionedDB constructs an instance of VersionedDB
func newVersionedDB(couchInstance *couchdb.CouchInstance, dbName string) (*VersionedDB, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[20], 1);
	// CreateCouchDatabase creates a CouchDB database object, as well as the underlying database if it does not exist
	chainName := dbName
	dbName = couchdb.ConstructMetadataDBName(dbName)

	metadataDB, err := couchdb.CreateCouchDatabase(couchInstance, dbName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[22], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[21], 1);namespaceDBMap := make(map[string]*couchdb.CouchDatabase)
	return &VersionedDB{
		couchInstance:      couchInstance,
		metadataDB:         metadataDB,
		chainName:          chainName,
		namespaceDBs:       namespaceDBMap,
		committedDataCache: newVersionCache(),
		lsccStateCache: &lsccStateCache{
			cache: make(map[string]*statedb.VersionedValue),
		},
	}, nil
}

// getNamespaceDBHandle gets the handle to a named chaincode database
func (vdb *VersionedDB) getNamespaceDBHandle(namespace string) (*couchdb.CouchDatabase, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[23], 1);
	vdb.mux.RLock()
	db := vdb.namespaceDBs[namespace]
	vdb.mux.RUnlock()
	if db != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[26], 1);
		return db, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[24], 1);namespaceDBName := couchdb.ConstructNamespaceDBName(vdb.chainName, namespace)
	vdb.mux.Lock()
	defer vdb.mux.Unlock()
	db = vdb.namespaceDBs[namespace]
	if db == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[27], 1);
		var err error
		db, err = couchdb.CreateCouchDatabase(vdb.couchInstance, namespaceDBName)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[29], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[28], 1);vdb.namespaceDBs[namespace] = db
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[25], 1);return db, nil
}

// ProcessIndexesForChaincodeDeploy creates indexes for a specified namespace
func (vdb *VersionedDB) ProcessIndexesForChaincodeDeploy(namespace string, fileEntries []*ccprovider.TarFileEntry) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[30], 1);
	db, err := vdb.getNamespaceDBHandle(namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[33], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[31], 1);for _, fileEntry := range fileEntries {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[34], 1);
		indexData := fileEntry.FileContent
		filename := fileEntry.FileHeader.Name
		_, err = db.CreateIndex(string(indexData))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[35], 1);
			return errors.WithMessage(err, fmt.Sprintf(
				"error creating index from file [%s] for channel [%s]", filename, namespace))
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[32], 1);return nil
}

// GetDBType returns the hosted stateDB
func (vdb *VersionedDB) GetDBType() string {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[36], 1);
	return "couchdb"
}

// LoadCommittedVersions populates committedVersions and revisionNumbers into cache.
// A bulk retrieve from couchdb is used to populate the cache.
// committedVersions cache will be used for state validation of readsets
// revisionNumbers cache will be used during commit phase for couchdb bulk updates
func (vdb *VersionedDB) LoadCommittedVersions(keys []*statedb.CompositeKey) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[37], 1);
	nsKeysMap := map[string][]string{}
	committedDataCache := newVersionCache()
	for _, compositeKey := range keys {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[41], 1);
		ns, key := compositeKey.Namespace, compositeKey.Key
		committedDataCache.setVerAndRev(ns, key, nil, "")
		logger.Debugf("Load into version cache: %s~%s", ns, key)
		nsKeysMap[ns] = append(nsKeysMap[ns], key)
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[38], 1);nsMetadataMap, err := vdb.retrieveMetadata(nsKeysMap)
	logger.Debugf("nsKeysMap=%s", nsKeysMap)
	logger.Debugf("nsMetadataMap=%s", nsMetadataMap)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[42], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[39], 1);for ns, nsMetadata := range nsMetadataMap {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[43], 1);
		for _, keyMetadata := range nsMetadata {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[44], 1);
			// TODO - why would version be ever zero if loaded from db?
			if len(keyMetadata.Version) != 0 {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[45], 1);
				version, _, err := decodeVersionAndMetadata(keyMetadata.Version)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[47], 1);
					return err
				}
				_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[46], 1);committedDataCache.setVerAndRev(ns, keyMetadata.ID, version, keyMetadata.Rev)
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[40], 1);vdb.verCacheLock.Lock()
	defer vdb.verCacheLock.Unlock()
	vdb.committedDataCache = committedDataCache
	return nil
}

// GetVersion implements method in VersionedDB interface
func (vdb *VersionedDB) GetVersion(namespace string, key string) (*version.Height, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[48], 1);
	returnVersion, keyFound := vdb.GetCachedVersion(namespace, key)
	if !keyFound {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[50], 1);
		// This if block get executed only during simulation because during commit
		// we always call `LoadCommittedVersions` before calling `GetVersion`
		vv, err := vdb.GetState(namespace, key)
		if err != nil || vv == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[52], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[51], 1);returnVersion = vv.Version
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[49], 1);return returnVersion, nil
}

// GetCachedVersion returns version from cache. `LoadCommittedVersions` function populates the cache
func (vdb *VersionedDB) GetCachedVersion(namespace string, key string) (*version.Height, bool) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[53], 1);
	logger.Debugf("Retrieving cached version: %s~%s", key, namespace)
	vdb.verCacheLock.RLock()
	defer vdb.verCacheLock.RUnlock()
	return vdb.committedDataCache.getVersion(namespace, key)
}

// ValidateKeyValue implements method in VersionedDB interface
func (vdb *VersionedDB) ValidateKeyValue(key string, value []byte) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[54], 1);
	err := validateKey(key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[56], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[55], 1);return validateValue(value)
}

// BytesKeySupported implements method in VersionedDB interface
func (vdb *VersionedDB) BytesKeySupported() bool {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[57], 1);
	return false
}

// GetState implements method in VersionedDB interface
func (vdb *VersionedDB) GetState(namespace string, key string) (*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[58], 1);
	logger.Debugf("GetState(). ns=%s, key=%s", namespace, key)
	if namespace == "lscc" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[65], 1);
		if value := vdb.lsccStateCache.getState(key); value != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[66], 1);
			return value, nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[59], 1);db, err := vdb.getNamespaceDBHandle(namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[67], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[60], 1);couchDoc, _, err := db.ReadDoc(key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[68], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[61], 1);if couchDoc == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[69], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[62], 1);kv, err := couchDocToKeyValue(couchDoc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[70], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[63], 1);if namespace == "lscc" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[71], 1);
		vdb.lsccStateCache.setState(key, kv.VersionedValue)
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[64], 1);return kv.VersionedValue, nil
}

// GetStateMultipleKeys implements method in VersionedDB interface
func (vdb *VersionedDB) GetStateMultipleKeys(namespace string, keys []string) ([]*statedb.VersionedValue, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[72], 1);
	vals := make([]*statedb.VersionedValue, len(keys))
	for i, key := range keys {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[74], 1);
		val, err := vdb.GetState(namespace, key)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[76], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[75], 1);vals[i] = val
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[73], 1);return vals, nil
}

// GetStateRangeScanIterator implements method in VersionedDB interface
// startKey is inclusive
// endKey is exclusive
func (vdb *VersionedDB) GetStateRangeScanIterator(namespace string, startKey string, endKey string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[77], 1);
	return vdb.GetStateRangeScanIteratorWithMetadata(namespace, startKey, endKey, nil)
}

const optionBookmark = "bookmark"
const optionLimit = "limit"
const returnCount = "count"

// GetStateRangeScanIteratorWithMetadata implements method in VersionedDB interface
// startKey is inclusive
// endKey is exclusive
// metadata contains a map of additional query options
func (vdb *VersionedDB) GetStateRangeScanIteratorWithMetadata(namespace string, startKey string, endKey string, metadata map[string]interface{}) (statedb.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[78], 1);
	logger.Debugf("Entering GetStateRangeScanIteratorWithMetadata  namespace: %s  startKey: %s  endKey: %s  metadata: %v", namespace, startKey, endKey, metadata)
	// Get the internalQueryLimit from core.yaml
	internalQueryLimit := int32(ledgerconfig.GetInternalQueryLimit())
	requestedLimit := int32(0)
	// if metadata is provided, validate and apply options
	if metadata != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[81], 1);
		//validate the metadata
		err := statedb.ValidateRangeMetadata(metadata)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[83], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[82], 1);if limitOption, ok := metadata[optionLimit]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[84], 1);
			requestedLimit = limitOption.(int32)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[79], 1);db, err := vdb.getNamespaceDBHandle(namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[85], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[80], 1);return newQueryScanner(namespace, db, "", internalQueryLimit, requestedLimit, "", startKey, endKey)
}

func (scanner *queryScanner) getNextStateRangeScanResults() error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[86], 1);
	queryLimit := scanner.queryDefinition.internalQueryLimit
	if scanner.paginationInfo.requestedLimit > 0 {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[89], 1);
		moreResultsNeeded := scanner.paginationInfo.requestedLimit - scanner.resultsInfo.totalRecordsReturned
		if moreResultsNeeded < scanner.queryDefinition.internalQueryLimit {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[90], 1);
			queryLimit = moreResultsNeeded
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[87], 1);queryResult, nextStartKey, err := rangeScanFilterCouchInternalDocs(scanner.db,
		scanner.queryDefinition.startKey, scanner.queryDefinition.endKey, queryLimit)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[91], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[88], 1);scanner.resultsInfo.results = queryResult
	scanner.queryDefinition.startKey = nextStartKey
	scanner.paginationInfo.cursor = 0
	return nil
}

func rangeScanFilterCouchInternalDocs(db *couchdb.CouchDatabase,
	startKey, endKey string, queryLimit int32,
) ([]*couchdb.QueryResult, string, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[92], 1);
	var finalResults []*couchdb.QueryResult
	var finalNextStartKey string
	for {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[95], 1);
		results, nextStartKey, err := db.ReadDocRange(startKey, endKey, queryLimit)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[99], 1);
			logger.Debugf("Error calling ReadDocRange(): %s\n", err.Error())
			return nil, "", err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[96], 1);var filteredResults []*couchdb.QueryResult
		for _, doc := range results {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[100], 1);
			if !isCouchInternalKey(doc.ID) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[101], 1);
				filteredResults = append(filteredResults, doc)
			}
		}

		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[97], 1);finalResults = append(finalResults, filteredResults...)
		finalNextStartKey = nextStartKey
		queryLimit = int32(len(results) - len(filteredResults))
		if queryLimit == 0 || finalNextStartKey == "" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[102], 1);
			break
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[98], 1);startKey = finalNextStartKey
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[93], 1);var err error
	for i := 0; isCouchInternalKey(finalNextStartKey); i++ {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[103], 1);
		_, finalNextStartKey, err = db.ReadDocRange(finalNextStartKey, endKey, 1)
		logger.Debugf("i=%d, finalNextStartKey=%s", i, finalNextStartKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[104], 1);
			return nil, "", err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[94], 1);return finalResults, finalNextStartKey, nil
}

func isCouchInternalKey(key string) bool {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[105], 1);
	return len(key) != 0 && key[0] == '_'
}

// ExecuteQuery implements method in VersionedDB interface
func (vdb *VersionedDB) ExecuteQuery(namespace, query string) (statedb.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[106], 1);
	queryResult, err := vdb.ExecuteQueryWithMetadata(namespace, query, nil)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[108], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[107], 1);return queryResult, nil
}

// ExecuteQueryWithMetadata implements method in VersionedDB interface
func (vdb *VersionedDB) ExecuteQueryWithMetadata(namespace, query string, metadata map[string]interface{}) (statedb.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[109], 1);
	logger.Debugf("Entering ExecuteQueryWithMetadata  namespace: %s,  query: %s,  metadata: %v", namespace, query, metadata)
	// Get the querylimit from core.yaml
	internalQueryLimit := int32(ledgerconfig.GetInternalQueryLimit())
	bookmark := ""
	requestedLimit := int32(0)
	// if metadata is provided, then validate and set provided options
	if metadata != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[113], 1);
		err := validateQueryMetadata(metadata)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[116], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[114], 1);if limitOption, ok := metadata[optionLimit]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[117], 1);
			requestedLimit = limitOption.(int32)
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[115], 1);if bookmarkOption, ok := metadata[optionBookmark]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[118], 1);
			bookmark = bookmarkOption.(string)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[110], 1);queryString, err := applyAdditionalQueryOptions(query, internalQueryLimit, bookmark)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[119], 1);
		logger.Errorf("Error calling applyAdditionalQueryOptions(): %s", err.Error())
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[111], 1);db, err := vdb.getNamespaceDBHandle(namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[120], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[112], 1);return newQueryScanner(namespace, db, queryString, internalQueryLimit, requestedLimit, bookmark, "", "")
}

// executeQueryWithBookmark executes a "paging" query with a bookmark, this method allows a
// paged query without returning a new query iterator
func (scanner *queryScanner) executeQueryWithBookmark() error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[121], 1);
	queryLimit := scanner.queryDefinition.internalQueryLimit
	if scanner.paginationInfo.requestedLimit > 0 {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[125], 1);
		if scanner.paginationInfo.requestedLimit-scanner.resultsInfo.totalRecordsReturned < scanner.queryDefinition.internalQueryLimit {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[126], 1);
			queryLimit = scanner.paginationInfo.requestedLimit - scanner.resultsInfo.totalRecordsReturned
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[122], 1);queryString, err := applyAdditionalQueryOptions(scanner.queryDefinition.query,
		queryLimit, scanner.paginationInfo.bookmark)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[127], 1);
		logger.Debugf("Error calling applyAdditionalQueryOptions(): %s\n", err.Error())
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[123], 1);queryResult, bookmark, err := scanner.db.QueryDocuments(queryString)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[128], 1);
		logger.Debugf("Error calling QueryDocuments(): %s\n", err.Error())
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[124], 1);scanner.resultsInfo.results = queryResult
	scanner.paginationInfo.bookmark = bookmark
	scanner.paginationInfo.cursor = 0
	return nil
}

func validateQueryMetadata(metadata map[string]interface{}) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[129], 1);
	for key, keyVal := range metadata {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[131], 1);
		switch key {
		case optionBookmark:_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[132], 1);
			//Verify the bookmark is a string
			if _, ok := keyVal.(string); ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[137], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[133], 1);return fmt.Errorf("Invalid entry, \"bookmark\" must be a string")

		case optionLimit:_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[134], 1);
			//Verify the limit is an integer
			if _, ok := keyVal.(int32); ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[138], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[135], 1);return fmt.Errorf("Invalid entry, \"limit\" must be an int32")

		default:_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[136], 1);
			return fmt.Errorf("Invalid entry, option %s not recognized", key)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[130], 1);return nil
}

// ApplyUpdates implements method in VersionedDB interface
func (vdb *VersionedDB) ApplyUpdates(updates *statedb.UpdateBatch, height *version.Height) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[139], 1);
	// TODO a note about https://jira.hyperledger.org/browse/FAB-8622
	// the function `Apply update can be split into three functions. Each carrying out one of the following three stages`.
	// The write lock is needed only for the stage 2.

	// stage 1 - PrepareForUpdates - db transforms the given batch in the form of underlying db
	// and keep it in memory
	var updateBatches []batch
	var err error
	if updateBatches, err = vdb.buildCommitters(updates); err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[144], 1);
		return err
	}
	// stage 2 - ApplyUpdates push the changes to the DB
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[140], 1);if err = executeBatches(updateBatches); err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[145], 1);
		return err
	}

	// Stgae 3 - PostUpdateProcessing - flush and record savepoint.
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[141], 1);namespaces := updates.GetUpdatedNamespaces()
	// Record a savepoint at a given height
	if err = vdb.ensureFullCommitAndRecordSavepoint(height, namespaces); err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[146], 1);
		logger.Errorf("Error during recordSavepoint: %s", err.Error())
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[142], 1);lsccUpdates := updates.GetUpdates("lscc")
	for key, value := range lsccUpdates {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[147], 1);
		vdb.lsccStateCache.updateState(key, value)
	}

	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[143], 1);return nil
}

// ClearCachedVersions clears committedVersions and revisionNumbers
func (vdb *VersionedDB) ClearCachedVersions() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[148], 1);
	logger.Debugf("Clear Cache")
	vdb.verCacheLock.Lock()
	defer vdb.verCacheLock.Unlock()
	vdb.committedDataCache = newVersionCache()
}

// Open implements method in VersionedDB interface
func (vdb *VersionedDB) Open() error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[149], 1);
	// no need to open db since a shared couch instance is used
	return nil
}

// Close implements method in VersionedDB interface
func (vdb *VersionedDB) Close() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[150], 1);
	// no need to close db since a shared couch instance is used
}

// Savepoint docid (key) for couchdb
const savepointDocID = "statedb_savepoint"

// ensureFullCommitAndRecordSavepoint flushes all the dbs (corresponding to `namespaces`) to disk
// and Record a savepoint in the metadata db.
// Couch parallelizes writes in cluster or sharded setup and ordering is not guaranteed.
// Hence we need to fence the savepoint with sync. So ensure_full_commit on all updated
// namespace DBs is called before savepoint to ensure all block writes are flushed. Savepoint
// itself is flushed to the metadataDB.
func (vdb *VersionedDB) ensureFullCommitAndRecordSavepoint(height *version.Height, namespaces []string) error {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[151], 1);
	// ensure full commit to flush all changes on updated namespaces until now to disk
	// namespace also includes empty namespace which is nothing but metadataDB
	var dbs []*couchdb.CouchDatabase
	for _, ns := range namespaces {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[157], 1);
		db, err := vdb.getNamespaceDBHandle(ns)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[159], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[158], 1);dbs = append(dbs, db)
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[152], 1);if err := vdb.ensureFullCommit(dbs); err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[160], 1);
		return err
	}

	// If a given height is nil, it denotes that we are committing pvt data of old blocks.
	// In this case, we should not store a savepoint for recovery. The lastUpdatedOldBlockList
	// in the pvtstore acts as a savepoint for pvt data.
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[153], 1);if height == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[161], 1);
		return nil
	}

	// construct savepoint document and save
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[154], 1);savepointCouchDoc, err := encodeSavepoint(height)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[162], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[155], 1);_, err = vdb.metadataDB.SaveDoc(savepointDocID, "", savepointCouchDoc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[163], 1);
		logger.Errorf("Failed to save the savepoint to DB %s", err.Error())
		return err
	}
	// Note: Ensure full commit on metadataDB after storing the savepoint is not necessary
	// as CouchDB syncs states to disk periodically (every 1 second). If peer fails before
	// syncing the savepoint to disk, ledger recovery process kicks in to ensure consistency
	// between CouchDB and block store on peer restart
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[156], 1);return nil
}

// GetLatestSavePoint implements method in VersionedDB interface
func (vdb *VersionedDB) GetLatestSavePoint() (*version.Height, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[164], 1);
	var err error
	couchDoc, _, err := vdb.metadataDB.ReadDoc(savepointDocID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[167], 1);
		logger.Errorf("Failed to read savepoint data %s", err.Error())
		return nil, err
	}
	// ReadDoc() not found (404) will result in nil response, in these cases return height nil
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[165], 1);if couchDoc == nil || couchDoc.JSONValue == nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[168], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[166], 1);return decodeSavepoint(couchDoc)
}

// applyAdditionalQueryOptions will add additional fields to the query required for query processing
func applyAdditionalQueryOptions(queryString string, queryLimit int32, queryBookmark string) (string, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[169], 1);
	const jsonQueryFields = "fields"
	const jsonQueryLimit = "limit"
	const jsonQueryBookmark = "bookmark"
	//create a generic map for the query json
	jsonQueryMap := make(map[string]interface{})
	//unmarshal the selector json into the generic map
	decoder := json.NewDecoder(bytes.NewBuffer([]byte(queryString)))
	decoder.UseNumber()
	err := decoder.Decode(&jsonQueryMap)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[174], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[170], 1);if fieldsJSONArray, ok := jsonQueryMap[jsonQueryFields]; ok {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[175], 1);
		switch fieldsJSONArray.(type) {
		case []interface{}:_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[176], 1);
			//Add the "_id", and "version" fields,  these are needed by default
			jsonQueryMap[jsonQueryFields] = append(fieldsJSONArray.([]interface{}),
				idField, versionField)
		default:_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[177], 1);
			return "", errors.New("fields definition must be an array")
		}
	}
	// Add limit
	// This will override any limit passed in the query.
	// Explicit paging not yet supported.
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[171], 1);jsonQueryMap[jsonQueryLimit] = queryLimit
	// Add the bookmark if provided
	if queryBookmark != "" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[178], 1);
		jsonQueryMap[jsonQueryBookmark] = queryBookmark
	}
	//Marshal the updated json query
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[172], 1);editedQuery, err := json.Marshal(jsonQueryMap)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[179], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[173], 1);logger.Debugf("Rewritten query: %s", editedQuery)
	return string(editedQuery), nil
}

type queryScanner struct {
	namespace       string
	db              *couchdb.CouchDatabase
	queryDefinition *queryDefinition
	paginationInfo  *paginationInfo
	resultsInfo     *resultsInfo
}

type queryDefinition struct {
	startKey           string
	endKey             string
	query              string
	internalQueryLimit int32
}

type paginationInfo struct {
	cursor         int32
	requestedLimit int32
	bookmark       string
}

type resultsInfo struct {
	totalRecordsReturned int32
	results              []*couchdb.QueryResult
}

func newQueryScanner(namespace string, db *couchdb.CouchDatabase, query string, internalQueryLimit,
	limit int32, bookmark, startKey, endKey string) (*queryScanner, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[180], 1);
	scanner := &queryScanner{namespace, db, &queryDefinition{startKey, endKey, query, internalQueryLimit}, &paginationInfo{-1, limit, bookmark}, &resultsInfo{0, nil}}
	var err error
	// query is defined, then execute the query and return the records and bookmark
	if scanner.queryDefinition.query != "" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[183], 1);
		err = scanner.executeQueryWithBookmark()
	} else{ _cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[184], 1);{
		err = scanner.getNextStateRangeScanResults()
	}}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[181], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[185], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[182], 1);scanner.paginationInfo.cursor = -1
	return scanner, nil
}

func (scanner *queryScanner) Next() (statedb.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[186], 1);
	//test for no results case
	if len(scanner.resultsInfo.results) == 0 {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[191], 1);
		return nil, nil
	}
	// increment the cursor
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[187], 1);scanner.paginationInfo.cursor++
	// check to see if additional records are needed
	// requery if the cursor exceeds the internalQueryLimit
	if scanner.paginationInfo.cursor >= scanner.queryDefinition.internalQueryLimit {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[192], 1);
		var err error
		// query is defined, then execute the query and return the records and bookmark
		if scanner.queryDefinition.query != "" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[195], 1);
			err = scanner.executeQueryWithBookmark()
		} else{ _cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[196], 1);{
			err = scanner.getNextStateRangeScanResults()
		}}
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[193], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[197], 1);
			return nil, err
		}
		//if no more results, then return
		_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[194], 1);if len(scanner.resultsInfo.results) == 0 {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[198], 1);
			return nil, nil
		}
	}
	//If the cursor is greater than or equal to the number of result records, return
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[188], 1);if scanner.paginationInfo.cursor >= int32(len(scanner.resultsInfo.results)) {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[199], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[189], 1);selectedResultRecord := scanner.resultsInfo.results[scanner.paginationInfo.cursor]
	key := selectedResultRecord.ID
	// remove the reserved fields from CouchDB JSON and return the value and version
	kv, err := couchDocToKeyValue(&couchdb.CouchDoc{JSONValue: selectedResultRecord.Value, Attachments: selectedResultRecord.Attachments})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[200], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[190], 1);scanner.resultsInfo.totalRecordsReturned++
	return &statedb.VersionedKV{
		CompositeKey:   statedb.CompositeKey{Namespace: scanner.namespace, Key: key},
		VersionedValue: *kv.VersionedValue}, nil
}

func (scanner *queryScanner) Close() {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[201], 1);
	scanner = nil
}

func (scanner *queryScanner) GetBookmarkAndClose() string {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[202], 1);
	retval := ""
	if scanner.queryDefinition.query != "" {_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[204], 1);
		retval = scanner.paginationInfo.bookmark
	} else{ _cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[205], 1);{
		retval = scanner.queryDefinition.startKey
	}}
	_cover_atomic_.AddUint32(&GoCover_4_613461656536306435636636.Count[203], 1);scanner.Close()
	return retval
}

var GoCover_4_613461656536306435636636 = struct {
	Count     [206]uint32
	Pos       [3 * 206]uint32
	NumStmt   [206]uint16
} {
	Pos: [3 * 206]uint32{
		42, 47, 0x10005d, // [0]
		50, 50, 0x610002, // [1]
		47, 49, 0x30010, // [2]
		54, 58, 0x10005e, // [3]
		66, 66, 0x110002, // [4]
		58, 61, 0x110010, // [5]
		64, 64, 0x230003, // [6]
		61, 63, 0x40011, // [7]
		70, 72, 0x2002f, // [8]
		91, 95, 0x2c0047, // [9]
		99, 99, 0xc0002, // [10]
		95, 98, 0x3002c, // [11]
		102, 106, 0x1f0051, // [12]
		106, 109, 0x3001f, // [13]
		112, 116, 0x15004e, // [14]
		120, 121, 0x160002, // [15]
		116, 118, 0x30015, // [16]
		124, 126, 0x2002d, // [17]
		128, 129, 0x1b002e, // [18]
		129, 132, 0x3001b, // [19]
		136, 142, 0x100060, // [20]
		145, 155, 0x80002, // [21]
		142, 144, 0x30010, // [22]
		159, 163, 0xf0060, // [23]
		166, 170, 0xf0002, // [24]
		178, 178, 0x100002, // [25]
		163, 165, 0x3000f, // [26]
		170, 173, 0x11000f, // [27]
		176, 176, 0x230003, // [28]
		173, 175, 0x40011, // [29]
		182, 184, 0x10007a, // [30]
		187, 187, 0x280002, // [31]
		196, 196, 0xc0002, // [32]
		184, 186, 0x30010, // [33]
		187, 191, 0x110028, // [34]
		191, 194, 0x40011, // [35]
		200, 202, 0x2002c, // [36]
		208, 211, 0x240053, // [37]
		217, 220, 0x100002, // [38]
		223, 223, 0x2c0002, // [39]
		235, 238, 0xc0002, // [40]
		211, 216, 0x30024, // [41]
		220, 222, 0x30010, // [42]
		223, 224, 0x2a002c, // [43]
		224, 226, 0x25002a, // [44]
		226, 228, 0x130025, // [45]
		231, 231, 0x520005, // [46]
		228, 230, 0x60013, // [47]
		242, 244, 0xf005b, // [48]
		253, 253, 0x1b0002, // [49]
		244, 248, 0x1e000f, // [50]
		251, 251, 0x1d0003, // [51]
		248, 250, 0x4001e, // [52]
		257, 262, 0x20060, // [53]
		265, 267, 0x10004a, // [54]
		270, 270, 0x1d0002, // [55]
		267, 269, 0x30010, // [56]
		274, 276, 0x20032, // [57]
		279, 281, 0x190061, // [58]
		287, 288, 0x100002, // [59]
		291, 292, 0x100002, // [60]
		295, 295, 0x150002, // [61]
		298, 299, 0x100002, // [62]
		303, 303, 0x190002, // [63]
		307, 307, 0x1f0002, // [64]
		281, 282, 0x3e0019, // [65]
		282, 284, 0x4003e, // [66]
		288, 290, 0x30010, // [67]
		292, 294, 0x30010, // [68]
		295, 297, 0x30015, // [69]
		299, 301, 0x30010, // [70]
		303, 305, 0x30019, // [71]
		311, 313, 0x1b0072, // [72]
		320, 320, 0x120002, // [73]
		313, 315, 0x11001b, // [74]
		318, 318, 0x100003, // [75]
		315, 317, 0x40011, // [76]
		326, 328, 0x20086, // [77]
		338, 344, 0x1500b8, // [78]
		354, 355, 0x100002, // [79]
		358, 358, 0x650002, // [80]
		344, 347, 0x110015, // [81]
		350, 350, 0x330003, // [82]
		347, 349, 0x40011, // [83]
		350, 352, 0x40033, // [84]
		355, 357, 0x30010, // [85]
		361, 363, 0x2f0043, // [86]
		369, 371, 0x100002, // [87]
		374, 377, 0xc0002, // [88]
		363, 365, 0x45002f, // [89]
		365, 367, 0x40045, // [90]
		371, 373, 0x30010, // [91]
		382, 385, 0x6002b, // [92]
		406, 407, 0x390002, // [93]
		414, 414, 0x2d0002, // [94]
		385, 387, 0x110006, // [95]
		391, 392, 0x1f0003, // [96]
		398, 401, 0x310003, // [97]
		404, 404, 0x1f0003, // [98]
		387, 390, 0x40011, // [99]
		392, 393, 0x23001f, // [100]
		393, 395, 0x50023, // [101]
		401, 402, 0x90031, // [102]
		407, 410, 0x110039, // [103]
		410, 412, 0x40011, // [104]
		417, 419, 0x2002a, // [105]
		422, 424, 0x100060, // [106]
		427, 427, 0x190002, // [107]
		424, 426, 0x30010, // [108]
		431, 438, 0x150092, // [109]
		450, 451, 0x100002, // [110]
		455, 456, 0x100002, // [111]
		459, 459, 0x6a0002, // [112]
		438, 440, 0x110015, // [113]
		443, 443, 0x330003, // [114]
		446, 446, 0x390003, // [115]
		440, 442, 0x40011, // [116]
		443, 445, 0x40033, // [117]
		446, 448, 0x40039, // [118]
		451, 454, 0x30010, // [119]
		456, 458, 0x30010, // [120]
		464, 466, 0x2f003f, // [121]
		471, 473, 0x100002, // [122]
		477, 478, 0x100002, // [123]
		482, 485, 0xc0002, // [124]
		466, 467, 0x82002f, // [125]
		467, 469, 0x40082, // [126]
		473, 476, 0x30010, // [127]
		478, 481, 0x30010, // [128]
		488, 489, 0x240043, // [129]
		509, 509, 0xc0002, // [130]
		489, 490, 0xe0024, // [131]
		491, 493, 0x240017, // [132]
		496, 496, 0x450004, // [133]
		498, 500, 0x230014, // [134]
		503, 503, 0x420004, // [135]
		505, 506, 0x45000b, // [136]
		493, 494, 0xd0024, // [137]
		500, 501, 0xd0023, // [138]
		513, 522, 0x430062, // [139]
		526, 526, 0x350002, // [140]
		531, 533, 0x520002, // [141]
		538, 539, 0x260002, // [142]
		543, 543, 0xc0002, // [143]
		522, 524, 0x30043, // [144]
		526, 528, 0x30035, // [145]
		533, 536, 0x30052, // [146]
		539, 541, 0x30026, // [147]
		547, 552, 0x2002f, // [148]
		555, 558, 0x20026, // [149]
		561, 563, 0x20022, // [150]
		574, 578, 0x20006f, // [151]
		585, 585, 0x320002, // [152]
		592, 592, 0x130002, // [153]
		597, 598, 0x100002, // [154]
		601, 602, 0x100002, // [155]
		610, 610, 0xc0002, // [156]
		578, 580, 0x110020, // [157]
		583, 583, 0x180003, // [158]
		580, 582, 0x40011, // [159]
		585, 587, 0x30032, // [160]
		592, 594, 0x30013, // [161]
		598, 600, 0x30010, // [162]
		602, 605, 0x30010, // [163]
		614, 617, 0x100047, // [164]
		622, 622, 0x320002, // [165]
		625, 625, 0x220002, // [166]
		617, 620, 0x30010, // [167]
		622, 624, 0x30032, // [168]
		629, 639, 0x10006e, // [169]
		642, 642, 0x3e0002, // [170]
		655, 657, 0x190002, // [171]
		661, 662, 0x100002, // [172]
		665, 666, 0x210002, // [173]
		639, 641, 0x30010, // [174]
		642, 643, 0x21003e, // [175]
		644, 647, 0x1b0016, // [176]
		648, 649, 0x3f000b, // [177]
		657, 659, 0x30019, // [178]
		662, 664, 0x30010, // [179]
		696, 700, 0x290049, // [180]
		705, 705, 0x100002, // [181]
		708, 709, 0x150002, // [182]
		700, 702, 0x30029, // [183]
		702, 704, 0x30008, // [184]
		705, 707, 0x30010, // [185]
		712, 714, 0x2b0042, // [186]
		718, 721, 0x510002, // [187]
		738, 738, 0x4e0002, // [188]
		741, 745, 0x100002, // [189]
		748, 751, 0x2b0002, // [190]
		714, 716, 0x3002b, // [191]
		721, 724, 0x2a0051, // [192]
		729, 729, 0x110003, // [193]
		733, 733, 0x2c0003, // [194]
		724, 726, 0x4002a, // [195]
		726, 728, 0x40009, // [196]
		729, 731, 0x40011, // [197]
		733, 735, 0x4002c, // [198]
		738, 740, 0x3004e, // [199]
		745, 747, 0x30010, // [200]
		754, 756, 0x20026, // [201]
		758, 760, 0x29003b, // [202]
		765, 766, 0xf0002, // [203]
		760, 762, 0x30029, // [204]
		762, 764, 0x30008, // [205]
	},
	NumStmt: [206]uint16{
		4, // 0
		1, // 1
		1, // 2
		4, // 3
		1, // 4
		3, // 5
		1, // 6
		1, // 7
		0, // 8
		3, // 9
		1, // 10
		2, // 11
		3, // 12
		2, // 13
		3, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		4, // 20
		2, // 21
		1, // 22
		4, // 23
		5, // 24
		1, // 25
		1, // 26
		3, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		4, // 34
		1, // 35
		1, // 36
		3, // 37
		4, // 38
		1, // 39
		4, // 40
		4, // 41
		1, // 42
		1, // 43
		1, // 44
		2, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		2, // 50
		1, // 51
		1, // 52
		4, // 53
		2, // 54
		1, // 55
		1, // 56
		1, // 57
		2, // 58
		2, // 59
		2, // 60
		1, // 61
		2, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		2, // 72
		1, // 73
		2, // 74
		1, // 75
		1, // 76
		1, // 77
		4, // 78
		2, // 79
		1, // 80
		2, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		2, // 86
		2, // 87
		4, // 88
		2, // 89
		1, // 90
		1, // 91
		3, // 92
		2, // 93
		1, // 94
		2, // 95
		2, // 96
		4, // 97
		1, // 98
		2, // 99
		1, // 100
		1, // 101
		1, // 102
		3, // 103
		1, // 104
		1, // 105
		2, // 106
		1, // 107
		1, // 108
		5, // 109
		2, // 110
		2, // 111
		1, // 112
		2, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		2, // 119
		1, // 120
		2, // 121
		2, // 122
		2, // 123
		4, // 124
		1, // 125
		1, // 126
		2, // 127
		2, // 128
		1, // 129
		1, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		1, // 135
		1, // 136
		1, // 137
		1, // 138
		3, // 139
		1, // 140
		2, // 141
		2, // 142
		1, // 143
		1, // 144
		1, // 145
		2, // 146
		1, // 147
		4, // 148
		1, // 149
		0, // 150
		2, // 151
		1, // 152
		1, // 153
		2, // 154
		2, // 155
		1, // 156
		2, // 157
		1, // 158
		1, // 159
		1, // 160
		1, // 161
		1, // 162
		2, // 163
		3, // 164
		1, // 165
		1, // 166
		2, // 167
		1, // 168
		8, // 169
		1, // 170
		2, // 171
		2, // 172
		2, // 173
		1, // 174
		1, // 175
		1, // 176
		1, // 177
		1, // 178
		1, // 179
		3, // 180
		1, // 181
		2, // 182
		1, // 183
		1, // 184
		1, // 185
		1, // 186
		2, // 187
		1, // 188
		4, // 189
		2, // 190
		1, // 191
		2, // 192
		1, // 193
		1, // 194
		1, // 195
		1, // 196
		1, // 197
		1, // 198
		1, // 199
		1, // 200
		1, // 201
		2, // 202
		2, // 203
		1, // 204
		1, // 205
	},
}
var _ = _cover_atomic_.LoadUint32
