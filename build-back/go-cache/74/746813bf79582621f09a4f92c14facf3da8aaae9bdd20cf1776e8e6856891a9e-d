//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/persistence/persistence.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package persistence; import _cover_atomic_ "sync/atomic"

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/hyperledger/fabric/common/chaincode"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/util"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("chaincode.persistence")

// IOReadWriter defines the interface needed for reading, writing, removing, and
// checking for existence of a specified file
type IOReadWriter interface {
	ReadDir(string) ([]os.FileInfo, error)
	ReadFile(string) ([]byte, error)
	Remove(name string) error
	Stat(string) (os.FileInfo, error)
	WriteFile(string, []byte, os.FileMode) error
}

// FilesystemIO is the production implementation of the IOWriter interface
type FilesystemIO struct {
}

// WriteFile writes a file to the filesystem
func (f *FilesystemIO) WriteFile(filename string, data []byte, perm os.FileMode) error {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[0], 1);
	return ioutil.WriteFile(filename, data, perm)
}

// Stat checks for existence of the file on the filesystem
func (f *FilesystemIO) Stat(name string) (os.FileInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[1], 1);
	return os.Stat(name)
}

// Remove removes a file from the filesystem - used for rolling back an in-flight
// Save operation upon a failure
func (f *FilesystemIO) Remove(name string) error {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[2], 1);
	return os.Remove(name)
}

// ReadFile reads a file from the filesystem
func (f *FilesystemIO) ReadFile(filename string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[3], 1);
	return ioutil.ReadFile(filename)
}

// ReadDir reads a directory from the filesystem
func (f *FilesystemIO) ReadDir(dirname string) ([]os.FileInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[4], 1);
	return ioutil.ReadDir(dirname)
}

// Store holds the information needed for persisting a chaincode install package
type Store struct {
	Path       string
	ReadWriter IOReadWriter
}

// Save persists chaincode install package bytes with the given name
// and version
func (s *Store) Save(name, version string, ccInstallPkg []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[5], 1);
	metadataJSON, err := toJSON(name, version)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[11], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[6], 1);hash := util.ComputeSHA256(ccInstallPkg)
	hashString := hex.EncodeToString(hash)
	metadataPath := filepath.Join(s.Path, hashString+".json")
	if _, err := s.ReadWriter.Stat(metadataPath); err == nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[12], 1);
		return nil, errors.Errorf("chaincode metadata already exists at %s", metadataPath)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[7], 1);ccInstallPkgPath := filepath.Join(s.Path, hashString+".bin")
	if _, err := s.ReadWriter.Stat(ccInstallPkgPath); err == nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[13], 1);
		return nil, errors.Errorf("ChaincodeInstallPackage already exists at %s", ccInstallPkgPath)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[8], 1);if err := s.ReadWriter.WriteFile(metadataPath, metadataJSON, 0600); err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[14], 1);
		return nil, errors.Wrapf(err, "error writing metadata file to %s", metadataPath)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[9], 1);if err := s.ReadWriter.WriteFile(ccInstallPkgPath, ccInstallPkg, 0600); err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[15], 1);
		err = errors.Wrapf(err, "error writing chaincode install package to %s", ccInstallPkgPath)
		logger.Error(err.Error())

		// need to roll back metadata write above on error
		if err2 := s.ReadWriter.Remove(metadataPath); err2 != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[17], 1);
			logger.Errorf("error removing metadata file at %s: %s", metadataPath, err2)
		}
		_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[16], 1);return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[10], 1);return hash, nil
}

// Load loads a persisted chaincode install package bytes with the given hash
// and also returns the name and version
func (s *Store) Load(hash []byte) (ccInstallPkg []byte, name, version string, err error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[18], 1);
	hashString := hex.EncodeToString(hash)
	ccInstallPkgPath := filepath.Join(s.Path, hashString+".bin")
	ccInstallPkg, err = s.ReadWriter.ReadFile(ccInstallPkgPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[21], 1);
		err = errors.Wrapf(err, "error reading chaincode install package at %s", ccInstallPkgPath)
		return nil, "", "", err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[19], 1);metadataPath := filepath.Join(s.Path, hashString+".json")
	name, version, err = s.LoadMetadata(metadataPath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[22], 1);
		return nil, "", "", err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[20], 1);return ccInstallPkg, name, version, nil
}

// LoadMetadata loads the chaincode metadata stored at the specified path
func (s *Store) LoadMetadata(path string) (name, version string, err error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[23], 1);
	metadataBytes, err := s.ReadWriter.ReadFile(path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[26], 1);
		err = errors.Wrapf(err, "error reading metadata at %s", path)
		return "", "", err
	}
	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[24], 1);ccMetadata := &ChaincodeMetadata{}
	err = json.Unmarshal(metadataBytes, ccMetadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[27], 1);
		err = errors.Wrapf(err, "error unmarshaling metadata at %s", path)
		return "", "", err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[25], 1);return ccMetadata.Name, ccMetadata.Version, nil
}

// CodePackageNotFoundErr is the error returned when a code package cannot
// be found in the persistence store
type CodePackageNotFoundErr struct {
	Name    string
	Version string
}

func (e *CodePackageNotFoundErr) Error() string {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[28], 1);
	return fmt.Sprintf("chaincode install package not found with name '%s', version '%s'", e.Name, e.Version)
}

// RetrieveHash retrieves the hash of a chaincode install package given the
// name and version of the chaincode
func (s *Store) RetrieveHash(name string, version string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[29], 1);
	installedChaincodes, err := s.ListInstalledChaincodes()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[32], 1);
		return nil, errors.WithMessage(err, "error getting installed chaincodes")
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[30], 1);for _, installedChaincode := range installedChaincodes {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[33], 1);
		if installedChaincode.Name == name && installedChaincode.Version == version {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[34], 1);
			return installedChaincode.Id, nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[31], 1);err = &CodePackageNotFoundErr{
		Name:    name,
		Version: version,
	}

	return nil, err
}

// ListInstalledChaincodes returns an array with information about the
// chaincodes installed in the persistence store
func (s *Store) ListInstalledChaincodes() ([]chaincode.InstalledChaincode, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[35], 1);
	files, err := s.ReadWriter.ReadDir(s.Path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[38], 1);
		return nil, errors.Wrapf(err, "error reading chaincode directory at %s", s.Path)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[36], 1);installedChaincodes := []chaincode.InstalledChaincode{}
	for _, file := range files {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[39], 1);
		if strings.HasSuffix(file.Name(), ".json") {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[40], 1);
			metadataPath := filepath.Join(s.Path, file.Name())
			ccName, ccVersion, err := s.LoadMetadata(metadataPath)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[43], 1);
				logger.Warning(err.Error())
				continue
			}

			// split the file name and get just the hash
			_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[41], 1);hashString := strings.Split(file.Name(), ".")[0]
			hash, err := hex.DecodeString(hashString)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[44], 1);
				return nil, errors.Wrapf(err, "error decoding hash from hex string: %s", hashString)
			}
			_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[42], 1);installedChaincode := chaincode.InstalledChaincode{
				Name:    ccName,
				Version: ccVersion,
				Id:      hash,
			}
			installedChaincodes = append(installedChaincodes, installedChaincode)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[37], 1);return installedChaincodes, nil
}

// GetChaincodeInstallPath returns the path where chaincodes
// are installed
func (s *Store) GetChaincodeInstallPath() string {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[45], 1);
	return s.Path
}

// ChaincodeMetadata holds the name and version of a chaincode
type ChaincodeMetadata struct {
	Name    string `json:"Name"`
	Version string `json:"Version"`
}

func toJSON(name, version string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[46], 1);
	metadata := &ChaincodeMetadata{
		Name:    name,
		Version: version,
	}

	metadataBytes, err := json.Marshal(metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[48], 1);
		return nil, errors.Wrap(err, "error marshaling name and version into JSON")
	}

	_cover_atomic_.AddUint32(&GoCover_2_346661366563343863376234.Count[47], 1);return metadataBytes, nil
}

var GoCover_2_346661366563343863376234 = struct {
	Count     [49]uint32
	Pos       [3 * 49]uint32
	NumStmt   [49]uint16
} {
	Pos: [3 * 49]uint32{
		41, 43, 0x20058, // [0]
		46, 48, 0x2003f, // [1]
		52, 54, 0x20032, // [2]
		57, 59, 0x20042, // [3]
		62, 64, 0x20047, // [4]
		74, 76, 0x100051, // [5]
		80, 83, 0x3b0002, // [6]
		87, 88, 0x3f0002, // [7]
		92, 92, 0x510002, // [8]
		96, 96, 0x550002, // [9]
		107, 107, 0x120002, // [10]
		76, 78, 0x30010, // [11]
		83, 85, 0x3003b, // [12]
		88, 90, 0x3003f, // [13]
		92, 94, 0x30051, // [14]
		96, 101, 0x3d0055, // [15]
		104, 104, 0x120003, // [16]
		101, 103, 0x4003d, // [17]
		112, 116, 0x10005a, // [18]
		121, 123, 0x100002, // [19]
		127, 127, 0x290002, // [20]
		116, 119, 0x30010, // [21]
		123, 125, 0x30010, // [22]
		131, 133, 0x10004d, // [23]
		137, 139, 0x100002, // [24]
		144, 144, 0x310002, // [25]
		133, 136, 0x30010, // [26]
		139, 142, 0x30010, // [27]
		154, 156, 0x20031, // [28]
		160, 162, 0x10004b, // [29]
		166, 166, 0x390002, // [30]
		172, 177, 0x110002, // [31]
		162, 164, 0x30010, // [32]
		166, 167, 0x4f0039, // [33]
		167, 169, 0x4004f, // [34]
		182, 184, 0x100053, // [35]
		188, 189, 0x1d0002, // [36]
		212, 212, 0x210002, // [37]
		184, 186, 0x30010, // [38]
		189, 190, 0x2e001d, // [39]
		190, 193, 0x12002e, // [40]
		199, 201, 0x120004, // [41]
		204, 209, 0x490004, // [42]
		193, 195, 0xd0012, // [43]
		201, 203, 0x50012, // [44]
		217, 219, 0x20032, // [45]
		227, 234, 0x100033, // [46]
		238, 238, 0x1b0002, // [47]
		234, 236, 0x30010, // [48]
	},
	NumStmt: [49]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		4, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		3, // 15
		1, // 16
		1, // 17
		4, // 18
		3, // 19
		1, // 20
		2, // 21
		1, // 22
		2, // 23
		3, // 24
		1, // 25
		2, // 26
		2, // 27
		1, // 28
		2, // 29
		1, // 30
		2, // 31
		1, // 32
		1, // 33
		1, // 34
		2, // 35
		2, // 36
		1, // 37
		1, // 38
		1, // 39
		3, // 40
		3, // 41
		2, // 42
		2, // 43
		1, // 44
		1, // 45
		3, // 46
		1, // 47
		1, // 48
	},
}
var _ = _cover_atomic_.LoadUint32
