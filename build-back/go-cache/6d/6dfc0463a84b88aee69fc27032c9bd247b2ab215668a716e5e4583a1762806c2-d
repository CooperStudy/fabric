//line /home/cooper/go/src/github.com/hyperledger/fabric/msp/mspimpl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msp; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/hex"
	"encoding/pem"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/bccsp/signer"
	m "github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
)

// mspSetupFuncType is the prototype of the setup function
type mspSetupFuncType func(config *m.FabricMSPConfig) error

// validateIdentityOUsFuncType is the prototype of the function to validate identity's OUs
type validateIdentityOUsFuncType func(id *identity) error

// satisfiesPrincipalInternalFuncType is the prototype of the function to check if principals are satisfied
type satisfiesPrincipalInternalFuncType func(id Identity, principal *m.MSPPrincipal) error

// This is an instantiation of an MSP that
// uses BCCSP for its cryptographic primitives.
type bccspmsp struct {
	// version specifies the behaviour of this msp
	version MSPVersion
	// The following function pointers are used to change the behaviour
	// of this MSP depending on its version.
	// internalSetupFunc is the pointer to the setup function
	internalSetupFunc mspSetupFuncType

	// internalValidateIdentityOusFunc is the pointer to the function to validate identity's OUs
	internalValidateIdentityOusFunc validateIdentityOUsFuncType

	// internalSatisfiesPrincipalInternalFunc is the pointer to the function to check if principals are satisfied
	internalSatisfiesPrincipalInternalFunc satisfiesPrincipalInternalFuncType

	// list of CA certs we trust
	rootCerts []Identity

	// list of intermediate certs we trust
	intermediateCerts []Identity

	// list of CA TLS certs we trust
	tlsRootCerts [][]byte

	// list of intermediate TLS certs we trust
	tlsIntermediateCerts [][]byte

	// certificationTreeInternalNodesMap whose keys correspond to the raw material
	// (DER representation) of a certificate casted to a string, and whose values
	// are boolean. True means that the certificate is an internal node of the certification tree.
	// False means that the certificate corresponds to a leaf of the certification tree.
	certificationTreeInternalNodesMap map[string]bool

	// list of signing identities
	signer SigningIdentity

	// list of admin identities
	admins []Identity

	// the crypto provider
	bccsp bccsp.BCCSP

	// the provider identifier for this MSP
	name string

	// verification options for MSP members
	opts *x509.VerifyOptions

	// list of certificate revocation lists
	CRL []*pkix.CertificateList

	// list of OUs
	ouIdentifiers map[string][][]byte

	// cryptoConfig contains
	cryptoConfig *m.FabricCryptoConfig

	// NodeOUs configuration
	ouEnforcement bool
	// These are the OUIdentifiers of the clients, peers and orderers.
	// They are used to tell apart these entities
	clientOU, peerOU *OUIdentifier
}

// newBccspMsp returns an MSP instance backed up by a BCCSP
// crypto provider. It handles x.509 certificates and can
// generate identities and signing identities backed by
// certificates and keypairs
func newBccspMsp(version MSPVersion) (MSP, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[0], 1);
	mspLogger.Debugf("Creating BCCSP-based MSP instance")

	bccsp := factory.GetDefault()
	theMsp := &bccspmsp{}
	theMsp.version = version
	theMsp.bccsp = bccsp
	switch version {
	case MSPv1_0:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[2], 1);
		theMsp.internalSetupFunc = theMsp.setupV1
		theMsp.internalValidateIdentityOusFunc = theMsp.validateIdentityOUsV1
		theMsp.internalSatisfiesPrincipalInternalFunc = theMsp.satisfiesPrincipalInternalPreV13
	case MSPv1_1:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[3], 1);
		theMsp.internalSetupFunc = theMsp.setupV11
		theMsp.internalValidateIdentityOusFunc = theMsp.validateIdentityOUsV11
		theMsp.internalSatisfiesPrincipalInternalFunc = theMsp.satisfiesPrincipalInternalPreV13
	case MSPv1_3:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[4], 1);
		theMsp.internalSetupFunc = theMsp.setupV11
		theMsp.internalValidateIdentityOusFunc = theMsp.validateIdentityOUsV11
		theMsp.internalSatisfiesPrincipalInternalFunc = theMsp.satisfiesPrincipalInternalV13
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[5], 1);
		return nil, errors.Errorf("Invalid MSP version [%v]", version)
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[1], 1);return theMsp, nil
}

func (msp *bccspmsp) getCertFromPem(idBytes []byte) (*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[6], 1);
	if idBytes == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[10], 1);
		return nil, errors.New("getCertFromPem error: nil idBytes")
	}

	// Decode the pem bytes
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[7], 1);pemCert, _ := pem.Decode(idBytes)
	if pemCert == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[11], 1);
		return nil, errors.Errorf("getCertFromPem error: could not decode pem bytes [%v]", idBytes)
	}

	// get a cert
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[8], 1);var cert *x509.Certificate
	cert, err := x509.ParseCertificate(pemCert.Bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[12], 1);
		return nil, errors.Wrap(err, "getCertFromPem error: failed to parse x509 cert")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[9], 1);return cert, nil
}

func (msp *bccspmsp) getIdentityFromConf(idBytes []byte) (Identity, bccsp.Key, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[13], 1);
	// get a cert
	cert, err := msp.getCertFromPem(idBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[16], 1);
		return nil, nil, err
	}

	// get the public key in the right format
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[14], 1);certPubK, err := msp.bccsp.KeyImport(cert, &bccsp.X509PublicKeyImportOpts{Temporary: true})

	mspId, err := newIdentity(cert, certPubK, msp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[17], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[15], 1);return mspId, certPubK, nil
}

func (msp *bccspmsp) getSigningIdentityFromConf(sidInfo *m.SigningIdentityInfo) (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[18], 1);
	if sidInfo == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[23], 1);
		return nil, errors.New("getIdentityFromBytes error: nil sidInfo")
	}

	// Extract the public part of the identity
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[19], 1);idPub, pubKey, err := msp.getIdentityFromConf(sidInfo.PublicSigner)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[24], 1);
		return nil, err
	}

	// Find the matching private key in the BCCSP keystore
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[20], 1);privKey, err := msp.bccsp.GetKey(pubKey.SKI())
	// Less Secure: Attempt to import Private Key from KeyInfo, if BCCSP was not able to find the key
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[25], 1);
		mspLogger.Debugf("Could not find SKI [%s], trying KeyMaterial field: %+v\n", hex.EncodeToString(pubKey.SKI()), err)
		if sidInfo.PrivateSigner == nil || sidInfo.PrivateSigner.KeyMaterial == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[27], 1);
			return nil, errors.New("KeyMaterial not found in SigningIdentityInfo")
		}

		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[26], 1);pemKey, _ := pem.Decode(sidInfo.PrivateSigner.KeyMaterial)
		privKey, err = msp.bccsp.KeyImport(pemKey.Bytes, &bccsp.ECDSAPrivateKeyImportOpts{Temporary: true})
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[28], 1);
			return nil, errors.WithMessage(err, "getIdentityFromBytes error: Failed to import EC private key")
		}
	}

	// get the peer signer
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[21], 1);peerSigner, err := signer.New(msp.bccsp, privKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[29], 1);
		return nil, errors.WithMessage(err, "getIdentityFromBytes error: Failed initializing bccspCryptoSigner")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[22], 1);return newSigningIdentity(idPub.(*identity).cert, idPub.(*identity).pk, peerSigner, msp)
}

// Setup sets up the internal data structures
// for this MSP, given an MSPConfig ref; it
// returns nil in case of success or an error otherwise
func (msp *bccspmsp) Setup(conf1 *m.MSPConfig) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[30], 1);
	if conf1 == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[33], 1);
		return errors.New("Setup error: nil conf reference")
	}

	// given that it's an msp of type fabric, extract the MSPConfig instance
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[31], 1);conf := &m.FabricMSPConfig{}
	err := proto.Unmarshal(conf1.Config, conf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[34], 1);
		return errors.Wrap(err, "failed unmarshalling fabric msp config")
	}

	// set the name for this msp
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[32], 1);msp.name = conf.Name
	mspLogger.Debugf("Setting up MSP instance %s", msp.name)

	// setup
	return msp.internalSetupFunc(conf)
}

// GetVersion returns the version of this MSP
func (msp *bccspmsp) GetVersion() MSPVersion {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[35], 1);
	return msp.version
}

// GetType returns the type for this MSP
func (msp *bccspmsp) GetType() ProviderType {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[36], 1);
	return FABRIC
}

// GetIdentifier returns the MSP identifier for this instance
func (msp *bccspmsp) GetIdentifier() (string, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[37], 1);
	return msp.name, nil
}

// GetTLSRootCerts returns the root certificates for this MSP
func (msp *bccspmsp) GetTLSRootCerts() [][]byte {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[38], 1);
	return msp.tlsRootCerts
}

// GetTLSIntermediateCerts returns the intermediate root certificates for this MSP
func (msp *bccspmsp) GetTLSIntermediateCerts() [][]byte {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[39], 1);
	return msp.tlsIntermediateCerts
}

// GetDefaultSigningIdentity returns the
// default signing identity for this MSP (if any)
func (msp *bccspmsp) GetDefaultSigningIdentity() (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[40], 1);
	mspLogger.Debugf("Obtaining default signing identity")

	if msp.signer == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[42], 1);
		return nil, errors.New("this MSP does not possess a valid default signing identity")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[41], 1);return msp.signer, nil
}

// GetSigningIdentity returns a specific signing
// identity identified by the supplied identifier
func (msp *bccspmsp) GetSigningIdentity(identifier *IdentityIdentifier) (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[43], 1);
	// TODO
	return nil, errors.Errorf("no signing identity for %#v", identifier)
}

// Validate attempts to determine whether
// the supplied identity is valid according
// to this MSP's roots of trust; it returns
// nil in case the identity is valid or an
// error otherwise
func (msp *bccspmsp) Validate(id Identity) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[44], 1);
	mspLogger.Debugf("MSP %s validating identity", msp.name)

	switch id := id.(type) {
	// If this identity is of this specific type,
	// this is how I can validate it given the
	// root of trust this MSP has
	case *identity:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[45], 1);
		return msp.validateIdentity(id)
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[46], 1);
		return errors.New("identity type not recognized")
	}
}

// hasOURole checks that the identity belongs to the organizational unit
// associated to the specified MSPRole.
// This function does not check the certifiers identifier.
// Appropriate validation needs to be enforced before.
func (msp *bccspmsp) hasOURole(id Identity, mspRole m.MSPRole_MSPRoleType) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[47], 1);
	// Check NodeOUs
	if !msp.ouEnforcement {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[49], 1);
		return errors.New("NodeOUs not activated. Cannot tell apart identities.")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[48], 1);mspLogger.Debugf("MSP %s checking if the identity is a client", msp.name)

	switch id := id.(type) {
	// If this identity is of this specific type,
	// this is how I can validate it given the
	// root of trust this MSP has
	case *identity:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[50], 1);
		return msp.hasOURoleInternal(id, mspRole)
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[51], 1);
		return errors.New("Identity type not recognized")
	}
}

func (msp *bccspmsp) hasOURoleInternal(id *identity, mspRole m.MSPRole_MSPRoleType) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[52], 1);
	var nodeOUValue string
	switch mspRole {
	case m.MSPRole_CLIENT:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[55], 1);
		nodeOUValue = msp.clientOU.OrganizationalUnitIdentifier
	case m.MSPRole_PEER:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[56], 1);
		nodeOUValue = msp.peerOU.OrganizationalUnitIdentifier
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[57], 1);
		return fmt.Errorf("Invalid MSPRoleType. It must be CLIENT, PEER or ORDERER")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[53], 1);for _, OU := range id.GetOrganizationalUnits() {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[58], 1);
		if OU.OrganizationalUnitIdentifier == nodeOUValue {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[59], 1);
			return nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[54], 1);return fmt.Errorf("The identity does not contain OU [%s], MSP: [%s]", mspRole, msp.name)
}

// DeserializeIdentity returns an Identity given the byte-level
// representation of a SerializedIdentity struct
func (msp *bccspmsp) DeserializeIdentity(serializedID []byte) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[60], 1);
	mspLogger.Debug("Obtaining identity")

	// We first deserialize to a SerializedIdentity to get the MSP ID
	sId := &m.SerializedIdentity{}
	err := proto.Unmarshal(serializedID, sId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[63], 1);
		return nil, errors.Wrap(err, "could not deserialize a SerializedIdentity")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[61], 1);if sId.Mspid != msp.name {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[64], 1);
		return nil, errors.Errorf("expected MSP ID %s, received %s", msp.name, sId.Mspid)
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[62], 1);return msp.deserializeIdentityInternal(sId.IdBytes)
}

// deserializeIdentityInternal returns an identity given its byte-level representation
func (msp *bccspmsp) deserializeIdentityInternal(serializedIdentity []byte) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[65], 1);
	// This MSP will always deserialize certs this way
	bl, _ := pem.Decode(serializedIdentity)
	if bl == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[69], 1);
		return nil, errors.New("could not decode the PEM structure")
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[66], 1);cert, err := x509.ParseCertificate(bl.Bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[70], 1);
		return nil, errors.Wrap(err, "parseCertificate failed")
	}

	// Now we have the certificate; make sure that its fields
	// (e.g. the Issuer.OU or the Subject.OU) match with the
	// MSP id that this MSP has; otherwise it might be an attack
	// TODO!
	// We can't do it yet because there is no standardized way
	// (yet) to encode the MSP ID into the x.509 body of a cert

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[67], 1);pub, err := msp.bccsp.KeyImport(cert, &bccsp.X509PublicKeyImportOpts{Temporary: true})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[71], 1);
		return nil, errors.WithMessage(err, "failed to import certificate's public key")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[68], 1);return newIdentity(cert, pub, msp)
}

// SatisfiesPrincipal returns null if the identity matches the principal or an error otherwise
func (msp *bccspmsp) SatisfiesPrincipal(id Identity, principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[72], 1);
	principals, err := collectPrincipals(principal, msp.GetVersion())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[75], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[73], 1);for _, principal := range principals {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[76], 1);
		err = msp.internalSatisfiesPrincipalInternalFunc(id, principal)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[77], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[74], 1);return nil
}

// collectPrincipals collects principals from combined principals into a single MSPPrincipal slice.
func collectPrincipals(principal *m.MSPPrincipal, mspVersion MSPVersion) ([]*m.MSPPrincipal, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[78], 1);
	switch principal.PrincipalClassification {
	case m.MSPPrincipal_COMBINED:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[79], 1);
		// Combined principals are not supported in MSP v1.0 or v1.1
		if mspVersion <= MSPv1_1 {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[85], 1);
			return nil, errors.Errorf("invalid principal type %d", int32(principal.PrincipalClassification))
		}
		// Principal is a combination of multiple principals.
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[80], 1);principals := &m.CombinedPrincipal{}
		err := proto.Unmarshal(principal.Principal, principals)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[86], 1);
			return nil, errors.Wrap(err, "could not unmarshal CombinedPrincipal from principal")
		}
		// Return an error if there are no principals in the combined principal.
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[81], 1);if len(principals.Principals) == 0 {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[87], 1);
			return nil, errors.New("No principals in CombinedPrincipal")
		}
		// Recursively call msp.collectPrincipals for all combined principals.
		// There is no limit for the levels of nesting for the combined principals.
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[82], 1);var principalsSlice []*m.MSPPrincipal
		for _, cp := range principals.Principals {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[88], 1);
			internalSlice, err := collectPrincipals(cp, mspVersion)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[90], 1);
				return nil, err
			}
			_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[89], 1);principalsSlice = append(principalsSlice, internalSlice...)
		}
		// All the combined principals have been collected into principalsSlice
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[83], 1);return principalsSlice, nil
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[84], 1);
		return []*m.MSPPrincipal{principal}, nil
	}
}

// satisfiesPrincipalInternalPreV13 takes as arguments the identity and the principal.
// The function returns an error if one occurred.
// The function implements the behavior of an MSP up to and including v1.1.
func (msp *bccspmsp) satisfiesPrincipalInternalPreV13(id Identity, principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[91], 1);
	switch principal.PrincipalClassification {
	// in this case, we have to check whether the
	// identity has a role in the msp - member or admin
	case m.MSPPrincipal_ROLE:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[92], 1);
		// Principal contains the msp role
		mspRole := &m.MSPRole{}
		err := proto.Unmarshal(principal.Principal, mspRole)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[104], 1);
			return errors.Wrap(err, "could not unmarshal MSPRole from principal")
		}

		// at first, we check whether the MSP
		// identifier is the same as that of the identity
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[93], 1);if mspRole.MspIdentifier != msp.name {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[105], 1);
			return errors.Errorf("the identity is a member of a different MSP (expected %s, got %s)", mspRole.MspIdentifier, id.GetMSPIdentifier())
		}

		// now we validate the different msp roles
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[94], 1);switch mspRole.Role {
		case m.MSPRole_MEMBER:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[106], 1);
			// in the case of member, we simply check
			// whether this identity is valid for the MSP
			mspLogger.Debugf("Checking if identity satisfies MEMBER role for %s", msp.name)
			return msp.Validate(id)
		case m.MSPRole_ADMIN:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[107], 1);
			mspLogger.Debugf("Checking if identity satisfies ADMIN role for %s", msp.name)
			// in the case of admin, we check that the
			// id is exactly one of our admins
			for _, admincert := range msp.admins {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[114], 1);
				if bytes.Equal(id.(*identity).cert.Raw, admincert.(*identity).cert.Raw) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[115], 1);
					// we do not need to check whether the admin is a valid identity
					// according to this MSP, since we already check this at Setup time
					// if there is a match, we can just return
					return nil
				}
			}
			_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[108], 1);return errors.New("This identity is not an admin")
		case m.MSPRole_CLIENT:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[109], 1);
			fallthrough
		case m.MSPRole_PEER:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[110], 1);
			mspLogger.Debugf("Checking if identity satisfies role [%s] for %s", m.MSPRole_MSPRoleType_name[int32(mspRole.Role)], msp.name)
			if err := msp.Validate(id); err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[116], 1);
				return errors.Wrapf(err, "The identity is not valid under this MSP [%s]", msp.name)
			}

			_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[111], 1);if err := msp.hasOURole(id, mspRole.Role); err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[117], 1);
				return errors.Wrapf(err, "The identity is not a [%s] under this MSP [%s]", m.MSPRole_MSPRoleType_name[int32(mspRole.Role)], msp.name)
			}
			_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[112], 1);return nil
		default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[113], 1);
			return errors.Errorf("invalid MSP role type %d", int32(mspRole.Role))
		}
	case m.MSPPrincipal_IDENTITY:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[95], 1);
		// in this case we have to deserialize the principal's identity
		// and compare it byte-by-byte with our cert
		principalId, err := msp.DeserializeIdentity(principal.Principal)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[118], 1);
			return errors.WithMessage(err, "invalid identity principal, not a certificate")
		}

		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[96], 1);if bytes.Equal(id.(*identity).cert.Raw, principalId.(*identity).cert.Raw) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[119], 1);
			return principalId.Validate()
		}

		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[97], 1);return errors.New("The identities do not match")
	case m.MSPPrincipal_ORGANIZATION_UNIT:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[98], 1);
		// Principal contains the OrganizationUnit
		OU := &m.OrganizationUnit{}
		err := proto.Unmarshal(principal.Principal, OU)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[120], 1);
			return errors.Wrap(err, "could not unmarshal OrganizationUnit from principal")
		}

		// at first, we check whether the MSP
		// identifier is the same as that of the identity
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[99], 1);if OU.MspIdentifier != msp.name {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[121], 1);
			return errors.Errorf("the identity is a member of a different MSP (expected %s, got %s)", OU.MspIdentifier, id.GetMSPIdentifier())
		}

		// we then check if the identity is valid with this MSP
		// and fail if it is not
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[100], 1);err = msp.Validate(id)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[122], 1);
			return err
		}

		// now we check whether any of this identity's OUs match the requested one
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[101], 1);for _, ou := range id.GetOrganizationalUnits() {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[123], 1);
			if ou.OrganizationalUnitIdentifier == OU.OrganizationalUnitIdentifier &&
				bytes.Equal(ou.CertifiersIdentifier, OU.CertifiersIdentifier) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[124], 1);
				return nil
			}
		}

		// if we are here, no match was found, return an error
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[102], 1);return errors.New("The identities do not match")
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[103], 1);
		return errors.Errorf("invalid principal type %d", int32(principal.PrincipalClassification))
	}
}

// satisfiesPrincipalInternalV13 takes as arguments the identity and the principal.
// The function returns an error if one occurred.
// The function implements the additional behavior expected of an MSP starting from v1.3.
// For pre-v1.3 functionality, the function calls the satisfiesPrincipalInternalPreV13.
func (msp *bccspmsp) satisfiesPrincipalInternalV13(id Identity, principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[125], 1);
	switch principal.PrincipalClassification {
	case m.MSPPrincipal_COMBINED:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[126], 1);
		return errors.New("SatisfiesPrincipalInternal shall not be called with a CombinedPrincipal")
	case m.MSPPrincipal_ANONYMITY:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[127], 1);
		anon := &m.MSPIdentityAnonymity{}
		err := proto.Unmarshal(principal.Principal, anon)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[130], 1);
			return errors.Wrap(err, "could not unmarshal MSPIdentityAnonymity from principal")
		}
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[128], 1);switch anon.AnonymityType {
		case m.MSPIdentityAnonymity_ANONYMOUS:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[131], 1);
			return errors.New("Principal is anonymous, but X.509 MSP does not support anonymous identities")
		case m.MSPIdentityAnonymity_NOMINAL:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[132], 1);
			return nil
		default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[133], 1);
			return errors.Errorf("Unknown principal anonymity type: %d", anon.AnonymityType)
		}

	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[129], 1);
		// Use the pre-v1.3 function to check other principal types
		return msp.satisfiesPrincipalInternalPreV13(id, principal)
	}
}

// getCertificationChain returns the certification chain of the passed identity within this msp
func (msp *bccspmsp) getCertificationChain(id Identity) ([]*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[134], 1);
	mspLogger.Debugf("MSP %s getting certification chain", msp.name)

	switch id := id.(type) {
	// If this identity is of this specific type,
	// this is how I can validate it given the
	// root of trust this MSP has
	case *identity:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[135], 1);
		return msp.getCertificationChainForBCCSPIdentity(id)
	default:_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[136], 1);
		return nil, errors.New("identity type not recognized")
	}
}

// getCertificationChainForBCCSPIdentity returns the certification chain of the passed bccsp identity within this msp
func (msp *bccspmsp) getCertificationChainForBCCSPIdentity(id *identity) ([]*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[137], 1);
	if id == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[141], 1);
		return nil, errors.New("Invalid bccsp identity. Must be different from nil.")
	}

	// we expect to have a valid VerifyOptions instance
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[138], 1);if msp.opts == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[142], 1);
		return nil, errors.New("Invalid msp instance")
	}

	// CAs cannot be directly used as identities..
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[139], 1);if id.cert.IsCA {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[143], 1);
		return nil, errors.New("An X509 certificate with Basic Constraint: " +
			"Certificate Authority equals true cannot be used as an identity")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[140], 1);return msp.getValidationChain(id.cert, false)
}

func (msp *bccspmsp) getUniqueValidationChain(cert *x509.Certificate, opts x509.VerifyOptions) ([]*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[144], 1);
	// ask golang to validate the cert for us based on the options that we've built at setup time
	if msp.opts == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[148], 1);
		return nil, errors.New("the supplied identity has no verify options")
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[145], 1);validationChains, err := cert.Verify(opts)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[149], 1);
		return nil, errors.WithMessage(err, "the supplied identity is not valid")
	}

	// we only support a single validation chain;
	// if there's more than one then there might
	// be unclarity about who owns the identity
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[146], 1);if len(validationChains) != 1 {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[150], 1);
		return nil, errors.Errorf("this MSP only supports a single validation chain, got %d", len(validationChains))
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[147], 1);return validationChains[0], nil
}

func (msp *bccspmsp) getValidationChain(cert *x509.Certificate, isIntermediateChain bool) ([]*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[151], 1);
	validationChain, err := msp.getUniqueValidationChain(cert, msp.getValidityOptsForCert(cert))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[156], 1);
		return nil, errors.WithMessage(err, "failed getting validation chain")
	}

	// we expect a chain of length at least 2
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[152], 1);if len(validationChain) < 2 {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[157], 1);
		return nil, errors.Errorf("expected a chain of length at least 2, got %d", len(validationChain))
	}

	// check that the parent is a leaf of the certification tree
	// if validating an intermediate chain, the first certificate will the parent
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[153], 1);parentPosition := 1
	if isIntermediateChain {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[158], 1);
		parentPosition = 0
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[154], 1);if msp.certificationTreeInternalNodesMap[string(validationChain[parentPosition].Raw)] {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[159], 1);
		return nil, errors.Errorf("invalid validation chain. Parent certificate should be a leaf of the certification tree [%v]", cert.Raw)
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[155], 1);return validationChain, nil
}

// getCertificationChainIdentifier returns the certification chain identifier of the passed identity within this msp.
// The identifier is computes as the SHA256 of the concatenation of the certificates in the chain.
func (msp *bccspmsp) getCertificationChainIdentifier(id Identity) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[160], 1);
	chain, err := msp.getCertificationChain(id)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[162], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("failed getting certification chain for [%v]", id))
	}

	// chain[0] is the certificate representing the identity.
	// It will be discarded
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[161], 1);return msp.getCertificationChainIdentifierFromChain(chain[1:])
}

func (msp *bccspmsp) getCertificationChainIdentifierFromChain(chain []*x509.Certificate) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[163], 1);
	// Hash the chain
	// Use the hash of the identity's certificate as id in the IdentityIdentifier
	hashOpt, err := bccsp.GetHashOpt(msp.cryptoConfig.IdentityIdentifierHashFunction)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[167], 1);
		return nil, errors.WithMessage(err, "failed getting hash function options")
	}

	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[164], 1);hf, err := msp.bccsp.GetHash(hashOpt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[168], 1);
		return nil, errors.WithMessage(err, "failed getting hash function when computing certification chain identifier")
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[165], 1);for i := 0; i < len(chain); i++ {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[169], 1);
		hf.Write(chain[i].Raw)
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[166], 1);return hf.Sum(nil), nil
}

// sanitizeCert ensures that x509 certificates signed using ECDSA
// do have signatures in Low-S. If this is not the case, the certificate
// is regenerated to have a Low-S signature.
func (msp *bccspmsp) sanitizeCert(cert *x509.Certificate) (*x509.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[170], 1);
	if isECDSASignedCert(cert) {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[172], 1);
		// Lookup for a parent certificate to perform the sanitization
		var parentCert *x509.Certificate
		chain, err := msp.getUniqueValidationChain(cert, msp.getValidityOptsForCert(cert))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[175], 1);
			return nil, err
		}

		// at this point, cert might be a root CA certificate
		// or an intermediate CA certificate
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[173], 1);if cert.IsCA && len(chain) == 1 {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[176], 1);
			// cert is a root CA certificate
			parentCert = cert
		} else{ _cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[177], 1);{
			parentCert = chain[1]
		}}

		// Sanitize
		_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[174], 1);cert, err = sanitizeECDSASignedCert(cert, parentCert)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[178], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[171], 1);return cert, nil
}

// IsWellFormed checks if the given identity can be deserialized into its provider-specific form.
// In this MSP implementation, well formed means that the PEM has a Type which is either
// the string 'CERTIFICATE' or the Type is missing altogether.
func (msp *bccspmsp) IsWellFormed(identity *m.SerializedIdentity) error {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[179], 1);
	bl, _ := pem.Decode(identity.IdBytes)
	if bl == nil {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[182], 1);
		return errors.New("PEM decoding resulted in an empty block")
	}
	// Important: This method looks very similar to getCertFromPem(idBytes []byte) (*x509.Certificate, error)
	// But we:
	// 1) Must ensure PEM block is of type CERTIFICATE or is empty
	// 2) Must not replace getCertFromPem with this method otherwise we will introduce
	//    a change in validation logic which will result in a chain fork.
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[180], 1);if bl.Type != "CERTIFICATE" && bl.Type != "" {_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[183], 1);
		return errors.Errorf("pem type is %s, should be 'CERTIFICATE' or missing", bl.Type)
	}
	_cover_atomic_.AddUint32(&GoCover_7_636433306662306231613333.Count[181], 1);_, err := x509.ParseCertificate(bl.Bytes)
	return err
}

var GoCover_7_636433306662306231613333 = struct {
	Count     [184]uint32
	Pos       [3 * 184]uint32
	NumStmt   [184]uint16
} {
	Pos: [3 * 184]uint32{
		103, 110, 0x110033, // [0]
		127, 127, 0x140002, // [1]
		111, 114, 0x5a000f, // [2]
		115, 118, 0x5a000f, // [3]
		119, 122, 0x57000f, // [4]
		123, 124, 0x41000a, // [5]
		130, 131, 0x140050, // [6]
		136, 137, 0x140002, // [7]
		142, 144, 0x100002, // [8]
		148, 148, 0x120002, // [9]
		131, 133, 0x30014, // [10]
		137, 139, 0x30014, // [11]
		144, 146, 0x30010, // [12]
		151, 154, 0x100057, // [13]
		159, 162, 0x100002, // [14]
		166, 166, 0x1d0002, // [15]
		154, 156, 0x30010, // [16]
		162, 164, 0x30010, // [17]
		169, 170, 0x14006a, // [18]
		175, 176, 0x100002, // [19]
		181, 183, 0x100002, // [20]
		197, 198, 0x100002, // [21]
		202, 202, 0x5a0002, // [22]
		170, 172, 0x30014, // [23]
		176, 178, 0x30010, // [24]
		183, 185, 0x4f0010, // [25]
		189, 191, 0x110003, // [26]
		185, 187, 0x4004f, // [27]
		191, 193, 0x40011, // [28]
		198, 200, 0x30010, // [29]
		208, 209, 0x120036, // [30]
		214, 216, 0x100002, // [31]
		221, 225, 0x240002, // [32]
		209, 211, 0x30012, // [33]
		216, 218, 0x30010, // [34]
		229, 231, 0x2002e, // [35]
		234, 236, 0x2002d, // [36]
		239, 241, 0x20036, // [37]
		244, 246, 0x20031, // [38]
		249, 251, 0x20039, // [39]
		255, 258, 0x17004b, // [40]
		262, 262, 0x180002, // [41]
		258, 260, 0x30017, // [42]
		267, 270, 0x20062, // [43]
		277, 280, 0x190032, // [44]
		284, 285, 0x220011, // [45]
		286, 287, 0x34000a, // [46]
		295, 297, 0x180052, // [47]
		301, 303, 0x190002, // [48]
		297, 299, 0x30018, // [49]
		307, 308, 0x2c0011, // [50]
		309, 310, 0x34000a, // [51]
		314, 316, 0x11005b, // [52]
		325, 325, 0x310002, // [53]
		331, 331, 0x5a0002, // [54]
		317, 318, 0x3a0018, // [55]
		319, 320, 0x380016, // [56]
		321, 322, 0x4f000a, // [57]
		325, 326, 0x350031, // [58]
		326, 328, 0x40035, // [59]
		336, 342, 0x100051, // [60]
		346, 346, 0x1b0002, // [61]
		350, 350, 0x350002, // [62]
		342, 344, 0x30010, // [63]
		346, 348, 0x3001b, // [64]
		354, 357, 0xf005f, // [65]
		360, 361, 0x100002, // [66]
		372, 373, 0x100002, // [67]
		377, 377, 0x240002, // [68]
		357, 359, 0x3000f, // [69]
		361, 363, 0x30010, // [70]
		373, 375, 0x30010, // [71]
		381, 383, 0x100057, // [72]
		386, 386, 0x270002, // [73]
		392, 392, 0xc0002, // [74]
		383, 385, 0x30010, // [75]
		386, 388, 0x110027, // [76]
		388, 390, 0x40011, // [77]
		396, 397, 0x2b0065, // [78]
		398, 400, 0x1c001f, // [79]
		404, 406, 0x110003, // [80]
		410, 410, 0x260003, // [81]
		415, 416, 0x2c0003, // [82]
		424, 424, 0x1e0003, // [83]
		425, 426, 0x2b000a, // [84]
		400, 402, 0x4001c, // [85]
		406, 408, 0x40011, // [86]
		410, 412, 0x40026, // [87]
		416, 418, 0x12002c, // [88]
		421, 421, 0x3f0004, // [89]
		418, 420, 0x50012, // [90]
		433, 434, 0x2b0065, // [91]
		437, 441, 0x11001b, // [92]
		447, 447, 0x280003, // [93]
		452, 452, 0x170003, // [94]
		486, 490, 0x11001f, // [95]
		494, 494, 0x4d0003, // [96]
		498, 498, 0x330003, // [97]
		499, 503, 0x110028, // [98]
		509, 509, 0x230003, // [99]
		515, 516, 0x110003, // [100]
		521, 521, 0x320003, // [101]
		529, 529, 0x330003, // [102]
		530, 531, 0x5e000a, // [103]
		441, 443, 0x40011, // [104]
		447, 449, 0x40028, // [105]
		453, 457, 0x1b0019, // [106]
		458, 462, 0x290018, // [107]
		470, 470, 0x360004, // [108]
		471, 472, 0xf0019, // [109]
		473, 475, 0x2b0017, // [110]
		479, 479, 0x3a0004, // [111]
		482, 482, 0xe0004, // [112]
		483, 484, 0x49000b, // [113]
		462, 463, 0x4d0029, // [114]
		463, 468, 0x6004d, // [115]
		475, 477, 0x5002b, // [116]
		479, 481, 0x5003a, // [117]
		490, 492, 0x40011, // [118]
		494, 496, 0x4004d, // [119]
		503, 505, 0x40011, // [120]
		509, 511, 0x40023, // [121]
		516, 518, 0x40011, // [122]
		521, 523, 0x430032, // [123]
		523, 525, 0x50043, // [124]
		539, 540, 0x2b0062, // [125]
		541, 542, 0x5f001f, // [126]
		543, 546, 0x110020, // [127]
		549, 549, 0x1d0003, // [128]
		558, 560, 0x3d000a, // [129]
		546, 548, 0x40011, // [130]
		550, 551, 0x640029, // [131]
		552, 553, 0xe0027, // [132]
		554, 555, 0x54000b, // [133]
		565, 568, 0x190056, // [134]
		572, 573, 0x370011, // [135]
		574, 575, 0x39000a, // [136]
		580, 581, 0xf0067, // [137]
		586, 586, 0x150002, // [138]
		591, 591, 0x120002, // [139]
		596, 596, 0x2f0002, // [140]
		581, 583, 0x3000f, // [141]
		586, 588, 0x30015, // [142]
		591, 594, 0x30012, // [143]
		599, 601, 0x15007d, // [144]
		604, 605, 0x100002, // [145]
		612, 612, 0x200002, // [146]
		616, 616, 0x210002, // [147]
		601, 603, 0x30015, // [148]
		605, 607, 0x30010, // [149]
		612, 614, 0x30020, // [150]
		619, 621, 0x100078, // [151]
		626, 626, 0x1e0002, // [152]
		632, 633, 0x190002, // [153]
		636, 636, 0x580002, // [154]
		639, 639, 0x1d0002, // [155]
		621, 623, 0x30010, // [156]
		626, 628, 0x3001e, // [157]
		633, 635, 0x30019, // [158]
		636, 638, 0x30058, // [159]
		644, 646, 0x100053, // [160]
		652, 652, 0x400002, // [161]
		646, 648, 0x30010, // [162]
		655, 659, 0x10006a, // [163]
		663, 664, 0x100002, // [164]
		667, 667, 0x220002, // [165]
		670, 670, 0x190002, // [166]
		659, 661, 0x30010, // [167]
		664, 666, 0x30010, // [168]
		667, 669, 0x30022, // [169]
		676, 677, 0x1d0056, // [170]
		700, 700, 0x120002, // [171]
		677, 681, 0x11001d, // [172]
		687, 687, 0x230003, // [173]
		695, 696, 0x110003, // [174]
		681, 683, 0x40011, // [175]
		687, 690, 0x40023, // [176]
		690, 692, 0x40009, // [177]
		696, 698, 0x40011, // [178]
		706, 708, 0xf0049, // [179]
		716, 716, 0x2f0002, // [180]
		719, 720, 0xc0002, // [181]
		708, 710, 0x3000f, // [182]
		716, 718, 0x3002f, // [183]
	},
	NumStmt: [184]uint16{
		6, // 0
		1, // 1
		3, // 2
		3, // 3
		3, // 4
		1, // 5
		1, // 6
		2, // 7
		3, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		3, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		3, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		3, // 31
		3, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		2, // 40
		1, // 41
		1, // 42
		1, // 43
		2, // 44
		1, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		2, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		4, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		2, // 65
		2, // 66
		2, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		2, // 72
		1, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		1, // 78
		1, // 79
		3, // 80
		1, // 81
		2, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		1, // 87
		2, // 88
		1, // 89
		1, // 90
		1, // 91
		3, // 92
		1, // 93
		1, // 94
		2, // 95
		1, // 96
		1, // 97
		3, // 98
		1, // 99
		2, // 100
		1, // 101
		1, // 102
		1, // 103
		1, // 104
		1, // 105
		2, // 106
		2, // 107
		1, // 108
		1, // 109
		2, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		1, // 119
		1, // 120
		1, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		1, // 126
		3, // 127
		1, // 128
		1, // 129
		1, // 130
		1, // 131
		1, // 132
		1, // 133
		2, // 134
		1, // 135
		1, // 136
		1, // 137
		1, // 138
		1, // 139
		1, // 140
		1, // 141
		1, // 142
		1, // 143
		1, // 144
		2, // 145
		1, // 146
		1, // 147
		1, // 148
		1, // 149
		1, // 150
		2, // 151
		1, // 152
		2, // 153
		1, // 154
		1, // 155
		1, // 156
		1, // 157
		1, // 158
		1, // 159
		2, // 160
		1, // 161
		1, // 162
		2, // 163
		2, // 164
		1, // 165
		1, // 166
		1, // 167
		1, // 168
		1, // 169
		1, // 170
		1, // 171
		3, // 172
		1, // 173
		2, // 174
		1, // 175
		1, // 176
		1, // 177
		1, // 178
		2, // 179
		1, // 180
		2, // 181
		1, // 182
		1, // 183
	},
}
var _ = _cover_atomic_.LoadUint32
