//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/platforms/java/platform.go:1
/*
Copyright DTCC 2016 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package java; import _cover_atomic_ "sync/atomic"

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"errors"
	"fmt"
	"io"
	"net/url"
	"regexp"
	"strings"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/chaincode/platforms/ccmetadata"
	"github.com/hyperledger/fabric/core/chaincode/platforms/util"
	cutil "github.com/hyperledger/fabric/core/container/util"
	pb "github.com/hyperledger/fabric/protos/peer"
)

var logger = flogging.MustGetLogger("chaincode.platform.java")

// Platform for java chaincodes in java
type Platform struct {
}

// Name returns the name of this platform
func (javaPlatform *Platform) Name() string {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[0], 1);
	return pb.ChaincodeSpec_JAVA.String()
}

//ValidatePath validates the java chaincode paths
func (javaPlatform *Platform) ValidatePath(rawPath string) error {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[1], 1);
	path, err := url.Parse(rawPath)
	if err != nil || path == nil {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[3], 1);
		logger.Errorf("invalid chaincode path %s %v", rawPath, err)
		return fmt.Errorf("invalid path: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[2], 1);return nil
}

func (javaPlatform *Platform) ValidateCodePackage(code []byte) error {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[4], 1);
	if len(code) == 0 {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[8], 1);
		// Nothing to validate if no CodePackage was included
		return nil
	}

	// File to be valid should match first RegExp and not match second one.
	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[5], 1);filesToMatch := regexp.MustCompile(`^(/)?src/((src|META-INF)/.*|(build\.gradle|settings\.gradle|pom\.xml))`)
	filesToIgnore := regexp.MustCompile(`.*\.class$`)
	is := bytes.NewReader(code)
	gr, err := gzip.NewReader(is)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[9], 1);
		return fmt.Errorf("failure opening codepackage gzip stream: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[6], 1);tr := tar.NewReader(gr)

	for {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[10], 1);
		header, err := tr.Next()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[13], 1);
			if err == io.EOF {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[14], 1);
				// We only get here if there are no more entries to scan
				break
			} else{ _cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[15], 1);{
				return err
			}}
		}

		// --------------------------------------------------------------------------------------
		// Check name for conforming path
		// --------------------------------------------------------------------------------------
		_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[11], 1);if !filesToMatch.MatchString(header.Name) || filesToIgnore.MatchString(header.Name) {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[16], 1);
			return fmt.Errorf("illegal file detected in payload: \"%s\"", header.Name)
		}

		// --------------------------------------------------------------------------------------
		// Check that file mode makes sense
		// --------------------------------------------------------------------------------------
		// Acceptable flags:
		//      ISREG      == 0100000
		//      -rw-rw-rw- == 0666
		//
		// Anything else is suspect in this context and will be rejected
		// --------------------------------------------------------------------------------------
		_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[12], 1);if header.Mode&^0100666 != 0 {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[17], 1);
			return fmt.Errorf("illegal file mode detected for file %s: %o", header.Name, header.Mode)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[7], 1);return nil
}

// WritePackage writes the java chaincode package
func (javaPlatform *Platform) GetDeploymentPayload(path string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[18], 1);

	logger.Debugf("Packaging java project from path %s", path)
	var err error

	// --------------------------------------------------------------------------------------
	// Write out our tar package
	// --------------------------------------------------------------------------------------
	payload := bytes.NewBuffer(nil)
	gw := gzip.NewWriter(payload)
	tw := tar.NewWriter(gw)

	folder := path
	if folder == "" {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[22], 1);
		logger.Error("ChaincodeSpec's path cannot be empty")
		return nil, errors.New("ChaincodeSpec's path cannot be empty")
	}

	// trim trailing slash if it exists
	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[19], 1);if folder[len(folder)-1] == '/' {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[23], 1);
		folder = folder[:len(folder)-1]
	}

	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[20], 1);if err = cutil.WriteJavaProjectToPackage(tw, folder); err != nil {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[24], 1);

		logger.Errorf("Error writing java project to tar package %s", err)
		return nil, fmt.Errorf("Error writing Chaincode package contents: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[21], 1);tw.Close()
	gw.Close()

	return payload.Bytes(), nil
}

func (javaPlatform *Platform) GenerateDockerfile() (string, error) {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[25], 1);
	var buf []string

	buf = append(buf, "FROM "+cutil.GetDockerfileFromConfig("chaincode.java.runtime"))
	buf = append(buf, "ADD binpackage.tar /root/chaincode-java/chaincode")

	dockerFileContents := strings.Join(buf, "\n")

	return dockerFileContents, nil
}

func (javaPlatform *Platform) GenerateDockerBuild(path string, code []byte, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[26], 1);
	codepackage := bytes.NewReader(code)
	binpackage := bytes.NewBuffer(nil)
	buildOptions := util.DockerBuildOptions{
		Image:        cutil.GetDockerfileFromConfig("chaincode.java.runtime"),
		Cmd:          "./build.sh",
		InputStream:  codepackage,
		OutputStream: binpackage,
	}
	logger.Debugf("Executing docker build %v, %v", buildOptions.Image, buildOptions.Cmd)
	err := util.DockerBuild(buildOptions)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[28], 1);
		logger.Errorf("Can't build java chaincode %v", err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[27], 1);resultBytes := binpackage.Bytes()
	return cutil.WriteBytesToPackage("binpackage.tar", resultBytes, tw)
}

//GetMetadataProvider fetches metadata provider given deployment spec
func (javaPlatform *Platform) GetMetadataProvider(code []byte) platforms.MetadataProvider {_cover_atomic_.AddUint32(&GoCover_0_373836386532633839383437.Count[29], 1);
	return &ccmetadata.TargzMetadataProvider{Code: code}
}

var GoCover_0_373836386532633839383437 = struct {
	Count     [30]uint32
	Pos       [3 * 30]uint32
	NumStmt   [30]uint16
} {
	Pos: [3 * 30]uint32{
		34, 36, 0x2002d, // [0]
		39, 41, 0x1f0042, // [1]
		46, 46, 0xc0002, // [2]
		41, 44, 0x3001f, // [3]
		49, 50, 0x140046, // [4]
		56, 60, 0x100002, // [5]
		63, 65, 0x60002, // [6]
		96, 96, 0xc0002, // [7]
		50, 53, 0x30014, // [8]
		60, 62, 0x30010, // [9]
		65, 67, 0x110006, // [10]
		79, 79, 0x570003, // [11]
		92, 92, 0x200003, // [12]
		67, 68, 0x150011, // [13]
		68, 70, 0xa0015, // [14]
		71, 73, 0x5000a, // [15]
		79, 81, 0x40057, // [16]
		92, 94, 0x40020, // [17]
		100, 113, 0x120051, // [18]
		119, 119, 0x220002, // [19]
		123, 123, 0x430002, // [20]
		129, 132, 0x1d0002, // [21]
		113, 116, 0x30012, // [22]
		119, 121, 0x30022, // [23]
		123, 127, 0x30043, // [24]
		135, 144, 0x20044, // [25]
		146, 157, 0x100063, // [26]
		162, 163, 0x450002, // [27]
		157, 160, 0x30010, // [28]
		167, 169, 0x2005b, // [29]
	},
	NumStmt: [30]uint16{
		1, // 0
		2, // 1
		1, // 2
		2, // 3
		1, // 4
		5, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		7, // 18
		1, // 19
		1, // 20
		3, // 21
		2, // 22
		1, // 23
		2, // 24
		5, // 25
		6, // 26
		2, // 27
		2, // 28
		1, // 29
	},
}
var _ = _cover_atomic_.LoadUint32
