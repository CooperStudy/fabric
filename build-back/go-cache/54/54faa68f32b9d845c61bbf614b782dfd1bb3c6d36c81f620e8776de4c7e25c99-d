//line /home/cooper/go/src/github.com/hyperledger/fabric/common/configtx/configmap.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package configtx; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"strings"

	"github.com/golang/protobuf/proto"
	cb "github.com/hyperledger/fabric/protos/common"
)

const (
	groupPrefix  = "[Group]  "
	valuePrefix  = "[Value]  "
	policyPrefix = "[Policy] "

	pathSeparator = "/"

	// Hacky fix constants, used in recurseConfigMap
	hackyFixOrdererCapabilities = "[Value]  /Channel/Orderer/Capabilities"
	hackyFixNewModPolicy        = "Admins"
)

// mapConfig is intended to be called outside this file
// it takes a ConfigGroup and generates a map of fqPath to comparables (or error on invalid keys)
func mapConfig(channelGroup *cb.ConfigGroup, rootGroupKey string) (map[string]comparable, error) {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[0], 1);
	result := make(map[string]comparable)
	if channelGroup != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[2], 1);
		err := recurseConfig(result, []string{rootGroupKey}, channelGroup)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[3], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[1], 1);return result, nil
}

// addToMap is used only internally by mapConfig
func addToMap(cg comparable, result map[string]comparable) error {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[4], 1);
	var fqPath string

	switch {
	case cg.ConfigGroup != nil:_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[8], 1);
		fqPath = groupPrefix
	case cg.ConfigValue != nil:_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[9], 1);
		fqPath = valuePrefix
	case cg.ConfigPolicy != nil:_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[10], 1);
		fqPath = policyPrefix
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[5], 1);if err := validateConfigID(cg.key); err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[11], 1);
		return fmt.Errorf("Illegal characters in key: %s", fqPath)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[6], 1);if len(cg.path) == 0 {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[12], 1);
		fqPath += pathSeparator + cg.key
	} else{ _cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[13], 1);{
		fqPath += pathSeparator + strings.Join(cg.path, pathSeparator) + pathSeparator + cg.key
	}}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[7], 1);logger.Debugf("Adding to config map: %s", fqPath)

	result[fqPath] = cg

	return nil
}

// recurseConfig is used only internally by mapConfig
func recurseConfig(result map[string]comparable, path []string, group *cb.ConfigGroup) error {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[14], 1);
	if err := addToMap(comparable{key: path[len(path)-1], path: path[:len(path)-1], ConfigGroup: group}, result); err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[19], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[15], 1);for key, group := range group.Groups {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[20], 1);
		nextPath := make([]string, len(path)+1)
		copy(nextPath, path)
		nextPath[len(nextPath)-1] = key
		if err := recurseConfig(result, nextPath, group); err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[21], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[16], 1);for key, value := range group.Values {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[22], 1);
		if err := addToMap(comparable{key: key, path: path, ConfigValue: value}, result); err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[23], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[17], 1);for key, policy := range group.Policies {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[24], 1);
		if err := addToMap(comparable{key: key, path: path, ConfigPolicy: policy}, result); err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[25], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[18], 1);return nil
}

// configMapToConfig is intended to be called from outside this file
// It takes a configMap and converts it back into a *cb.ConfigGroup structure
func configMapToConfig(configMap map[string]comparable, rootGroupKey string) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[26], 1);
	rootPath := pathSeparator + rootGroupKey
	return recurseConfigMap(rootPath, configMap)
}

// recurseConfigMap is used only internally by configMapToConfig
// Note, this function no longer mutates the cb.Config* entries within configMap
func recurseConfigMap(path string, configMap map[string]comparable) (*cb.ConfigGroup, error) {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[27], 1);
	groupPath := groupPrefix + path
	group, ok := configMap[groupPath]
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[34], 1);
		return nil, fmt.Errorf("Missing group at path: %s", groupPath)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[28], 1);if group.ConfigGroup == nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[35], 1);
		return nil, fmt.Errorf("ConfigGroup not found at group path: %s", groupPath)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[29], 1);newConfigGroup := cb.NewConfigGroup()
	proto.Merge(newConfigGroup, group.ConfigGroup)

	for key := range group.Groups {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[36], 1);
		updatedGroup, err := recurseConfigMap(path+pathSeparator+key, configMap)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[38], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[37], 1);newConfigGroup.Groups[key] = updatedGroup
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[30], 1);for key := range group.Values {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[39], 1);
		valuePath := valuePrefix + path + pathSeparator + key
		value, ok := configMap[valuePath]
		if !ok {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[42], 1);
			return nil, fmt.Errorf("Missing value at path: %s", valuePath)
		}
		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[40], 1);if value.ConfigValue == nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[43], 1);
			return nil, fmt.Errorf("ConfigValue not found at value path: %s", valuePath)
		}
		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[41], 1);newConfigGroup.Values[key] = proto.Clone(value.ConfigValue).(*cb.ConfigValue)
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[31], 1);for key := range group.Policies {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[44], 1);
		policyPath := policyPrefix + path + pathSeparator + key
		policy, ok := configMap[policyPath]
		if !ok {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[47], 1);
			return nil, fmt.Errorf("Missing policy at path: %s", policyPath)
		}
		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[45], 1);if policy.ConfigPolicy == nil {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[48], 1);
			return nil, fmt.Errorf("ConfigPolicy not found at policy path: %s", policyPath)
		}
		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[46], 1);newConfigGroup.Policies[key] = proto.Clone(policy.ConfigPolicy).(*cb.ConfigPolicy)
		logger.Debugf("Setting policy for key %s to %+v", key, group.Policies[key])
	}

	// This is a really very hacky fix to facilitate upgrading channels which were constructed
	// using the channel generation from v1.0 with bugs FAB-5309, and FAB-6080.
	// In summary, these channels were constructed with a bug which left mod_policy unset in some cases.
	// If mod_policy is unset, it's impossible to modify the element, and current code disallows
	// unset mod_policy values.  This hack 'fixes' existing config with empty mod_policy values.
	// If the capabilities framework is on, it sets any unset mod_policy to 'Admins'.
	// This code needs to sit here until validation of v1.0 chains is deprecated from the codebase.
	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[32], 1);if _, ok := configMap[hackyFixOrdererCapabilities]; ok {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[49], 1);
		// Hacky fix constants, used in recurseConfigMap
		if newConfigGroup.ModPolicy == "" {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[52], 1);
			logger.Debugf("Performing upgrade of group %s empty mod_policy", groupPath)
			newConfigGroup.ModPolicy = hackyFixNewModPolicy
		}

		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[50], 1);for key, value := range newConfigGroup.Values {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[53], 1);
			if value.ModPolicy == "" {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[54], 1);
				logger.Debugf("Performing upgrade of value %s empty mod_policy", valuePrefix+path+pathSeparator+key)
				value.ModPolicy = hackyFixNewModPolicy
			}
		}

		_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[51], 1);for key, policy := range newConfigGroup.Policies {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[55], 1);
			if policy.ModPolicy == "" {_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[56], 1);
				logger.Debugf("Performing upgrade of policy %s empty mod_policy", policyPrefix+path+pathSeparator+key)

				policy.ModPolicy = hackyFixNewModPolicy
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_346532363364653032376334.Count[33], 1);return newConfigGroup, nil
}

var GoCover_1_346532363364653032376334 = struct {
	Count     [57]uint32
	Pos       [3 * 57]uint32
	NumStmt   [57]uint16
} {
	Pos: [3 * 57]uint32{
		31, 33, 0x190062, // [0]
		39, 39, 0x140002, // [1]
		33, 35, 0x110019, // [2]
		35, 37, 0x40011, // [3]
		43, 46, 0x90042, // [4]
		55, 55, 0x310002, // [5]
		59, 59, 0x170002, // [6]
		65, 69, 0xc0002, // [7]
		47, 48, 0x17001d, // [8]
		49, 50, 0x17001d, // [9]
		51, 52, 0x18001e, // [10]
		55, 57, 0x30031, // [11]
		59, 61, 0x30017, // [12]
		61, 63, 0x30008, // [13]
		73, 74, 0x7b005e, // [14]
		78, 78, 0x270002, // [15]
		87, 87, 0x270002, // [16]
		93, 93, 0x2a0002, // [17]
		99, 99, 0xc0002, // [18]
		74, 76, 0x3007b, // [19]
		78, 82, 0x400027, // [20]
		82, 84, 0x40040, // [21]
		87, 88, 0x600027, // [22]
		88, 90, 0x40060, // [23]
		93, 94, 0x62002a, // [24]
		94, 96, 0x40062, // [25]
		104, 107, 0x20067, // [26]
		111, 114, 0x9005e, // [27]
		118, 118, 0x1e0002, // [28]
		122, 125, 0x200002, // [29]
		133, 133, 0x200002, // [30]
		145, 145, 0x220002, // [31]
		165, 165, 0x390002, // [32]
		188, 188, 0x1c0002, // [33]
		114, 116, 0x30009, // [34]
		118, 120, 0x3001e, // [35]
		125, 127, 0x110020, // [36]
		130, 130, 0x2c0003, // [37]
		127, 129, 0x40011, // [38]
		133, 136, 0xa0020, // [39]
		139, 139, 0x1f0003, // [40]
		142, 142, 0x500003, // [41]
		136, 138, 0x4000a, // [42]
		139, 141, 0x4001f, // [43]
		145, 148, 0xa0022, // [44]
		151, 151, 0x210003, // [45]
		154, 155, 0x4e0003, // [46]
		148, 150, 0x4000a, // [47]
		151, 153, 0x40021, // [48]
		165, 167, 0x250039, // [49]
		172, 172, 0x310003, // [50]
		179, 179, 0x340003, // [51]
		167, 170, 0x40025, // [52]
		172, 173, 0x1d0031, // [53]
		173, 176, 0x5001d, // [54]
		179, 180, 0x1e0034, // [55]
		180, 184, 0x5001e, // [56]
	},
	NumStmt: [57]uint16{
		2, // 0
		1, // 1
		2, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		3, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		4, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		3, // 27
		1, // 28
		3, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		1, // 38
		3, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		3, // 44
		1, // 45
		2, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		2, // 52
		1, // 53
		2, // 54
		1, // 55
		2, // 56
	},
}
var _ = _cover_atomic_.LoadUint32
