//line /home/cooper/go/src/github.com/hyperledger/fabric/token/client/tx_submitter.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package client; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"
	"io/ioutil"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/ptypes"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/comm"
	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
	peercommon "github.com/hyperledger/fabric/peer/common"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("token.client")

type TxSubmitter struct {
	Config        *ClientConfig
	Signer        SignerIdentity
	Creator       []byte
	OrdererClient OrdererClient
	DeliverClient DeliverClient
}

// TxEvent contains information for token transaction commit
// If application wants to be notified when a token transaction is committed,
// do the following:
// - create a event chan with size 1 or bigger, e.g. txChan := make(chan TxEvent, 1)
// - call client.SubmitTransactionWithChan(txBytes, txChan)
// - implement a function to read TxEvent from txChan so that it will be notified when transaction is committed or failed
type TxEvent struct {
	Txid       string
	Committed  bool
	CommitPeer string
	Err        error
}

// NewTransactionSubmitter creates a new TxSubmitter from token client config
func NewTxSubmitter(config *ClientConfig) (*TxSubmitter, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[0], 1);
	err := ValidateClientConfig(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[6], 1);
		return nil, err
	}

	// TODO: make mspType configurable
	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[1], 1);mspType := "bccsp"
	peercommon.InitCrypto(config.MspDir, config.MspId, mspType)

	Signer, err := mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[7], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[2], 1);creator, err := Signer.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[8], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[3], 1);ordererClient, err := NewOrdererClient(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[9], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[4], 1);deliverClient, err := NewDeliverClient(config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[10], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[5], 1);return &TxSubmitter{
		Config:        config,
		Signer:        Signer,
		Creator:       creator,
		OrdererClient: ordererClient,
		DeliverClient: deliverClient,
	}, nil
}

// SubmitTransaction submits a token transaction to fabric.
// It takes TokenTransaction bytes and waitTimeInSeconds as input parameters.
// The 'waitTimeInSeconds' indicates how long to wait for transaction commit event.
// If it is 0, the function will not wait for transaction to be committed.
// If it is greater than 0, the function will wait until timeout or transaction is committed, whichever is earlier
func (s *TxSubmitter) SubmitTransaction(txEnvelope *common.Envelope, waitTimeInSeconds int) (committed bool, txId string, err error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[11], 1);
	if waitTimeInSeconds > 0 {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[12], 1);
		waitTime := time.Second * time.Duration(waitTimeInSeconds)
		ctx, cancelFunc := context.WithTimeout(context.Background(), waitTime)
		defer cancelFunc()
		localCh := make(chan TxEvent, 1)
		committed, txId, err = s.sendTransactionInternal(txEnvelope, ctx, localCh, true)
		close(localCh)
		return
	} else{ _cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[13], 1);{
		committed, txId, err = s.sendTransactionInternal(txEnvelope, context.Background(), nil, false)
		return
	}}
}

// SubmitTransactionWithChan submits a token transaction to fabric with an event channel.
// This function does not wait for transaction commit and returns as soon as the orderer client receives the response.
// The application will be notified on transaction completion by reading events from the eventCh.
// When the transaction is committed or failed, an event will be added to eventCh so that the application will be notified.
// If eventCh has buffer size 0 or its buffer is full, an error will be returned.
func (s *TxSubmitter) SubmitTransactionWithChan(txEnvelope *common.Envelope, eventCh chan TxEvent) (committed bool, txId string, err error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[14], 1);
	committed, txId, err = s.sendTransactionInternal(txEnvelope, context.Background(), eventCh, false)
	return
}

func (s *TxSubmitter) sendTransactionInternal(txEnvelope *common.Envelope, ctx context.Context, eventCh chan TxEvent, waitForCommit bool) (bool, string, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[15], 1);
	if eventCh != nil && cap(eventCh) == 0 {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[23], 1);
		return false, "", errors.New("eventCh buffer size must be greater than 0")
	}
	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[16], 1);if eventCh != nil && len(eventCh) == cap(eventCh) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[24], 1);
		return false, "", errors.New("eventCh buffer is full. Read events and try again")
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[17], 1);txid, err := getTransactionId(txEnvelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[25], 1);
		return false, "", err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[18], 1);broadcast, err := s.OrdererClient.NewBroadcast(context.Background())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[26], 1);
		return false, "", err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[19], 1);committed := false
	if eventCh != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[27], 1);
		deliverFiltered, err := s.DeliverClient.NewDeliverFiltered(ctx)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[31], 1);
			return false, "", err
		}
		_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[28], 1);blockEnvelope, err := CreateDeliverEnvelope(s.Config.ChannelId, s.Creator, s.Signer, s.DeliverClient.Certificate())
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[32], 1);
			return false, "", err
		}
		_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[29], 1);err = DeliverSend(deliverFiltered, s.Config.CommitPeerCfg.Address, blockEnvelope)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[33], 1);
			return false, "", err
		}
		_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[30], 1);go DeliverReceive(deliverFiltered, s.Config.CommitPeerCfg.Address, txid, eventCh)
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[20], 1);err = BroadcastSend(broadcast, s.Config.OrdererCfg.Address, txEnvelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[34], 1);
		return false, txid, err
	}

	// wait for response from orderer broadcast - it does not wait for commit peer response
	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[21], 1);responses := make(chan common.Status)
	errs := make(chan error, 1)
	go BroadcastReceive(broadcast, s.Config.OrdererCfg.Address, responses, errs)
	_, err = BroadcastWaitForResponse(responses, errs)

	// wait for commit event from deliver service in this case
	if eventCh != nil && waitForCommit {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[35], 1);
		committed, err = DeliverWaitForResponse(ctx, eventCh, txid)
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[22], 1);return committed, txid, err
}

func (s *TxSubmitter) CreateTxEnvelope(txBytes []byte) (string, *common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[36], 1);
	// channelId string, creator []byte, signer SignerIdentity, cert *tls.Certificate
	// , s.Config.ChannelId, s.Creator, s.Signer, s.OrdererClient.Certificate()
	var tlsCertHash []byte
	var err error
	// check for client certificate and compute SHA2-256 on certificate if present
	cert := s.OrdererClient.Certificate()
	if cert != nil && len(cert.Certificate) > 0 {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[39], 1);
		tlsCertHash, err = factory.GetDefault().Hash(cert.Certificate[0], &bccsp.SHA256Opts{})
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[40], 1);
			err = errors.New("failed to compute SHA256 on client certificate")
			logger.Errorf("%s", err)
			return "", nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[37], 1);txid, header, err := CreateHeader(common.HeaderType_TOKEN_TRANSACTION, s.Config.ChannelId, s.Creator, tlsCertHash)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[41], 1);
		return txid, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[38], 1);txEnvelope, err := CreateEnvelope(txBytes, header, s.Signer)
	return txid, txEnvelope, err
}

// CreateHeader creates common.Header for a token transaction
// tlsCertHash is for client TLS cert, only applicable when ClientAuthRequired is true
func CreateHeader(txType common.HeaderType, channelId string, creator []byte, tlsCertHash []byte) (string, *common.Header, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[42], 1);
	ts, err := ptypes.TimestampProto(time.Now())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[48], 1);
		return "", nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[43], 1);nonce, err := crypto.GetRandomNonce()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[49], 1);
		return "", nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[44], 1);txId, err := utils.ComputeTxID(nonce, creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[50], 1);
		return "", nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[45], 1);chdr := &common.ChannelHeader{
		Type:        int32(txType),
		ChannelId:   channelId,
		TxId:        txId,
		Epoch:       uint64(0),
		Timestamp:   ts,
		TlsCertHash: tlsCertHash,
	}
	chdrBytes, err := proto.Marshal(chdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[51], 1);
		return "", nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[46], 1);shdr := &common.SignatureHeader{
		Creator: creator,
		Nonce:   nonce,
	}
	shdrBytes, err := proto.Marshal(shdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[52], 1);
		return "", nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[47], 1);header := &common.Header{
		ChannelHeader:   chdrBytes,
		SignatureHeader: shdrBytes,
	}

	return txId, header, nil
}

// CreateEnvelope creates a common.Envelope with given tx bytes, header, and Signer
func CreateEnvelope(data []byte, header *common.Header, signer SignerIdentity) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[53], 1);
	payload := &common.Payload{
		Header: header,
		Data:   data,
	}

	payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[56], 1);
		return nil, errors.Wrap(err, "failed to marshal common.Payload")
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[54], 1);signature, err := signer.Sign(payloadBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[57], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[55], 1);txEnvelope := &common.Envelope{
		Payload:   payloadBytes,
		Signature: signature,
	}

	return txEnvelope, nil
}

func getTransactionId(txEnvelope *common.Envelope) (string, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[58], 1);
	payload := common.Payload{}
	err := proto.Unmarshal(txEnvelope.Payload, &payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[61], 1);
		return "", errors.Wrapf(err, "failed to unmarshal envelope payload")
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[59], 1);channelHeader := common.ChannelHeader{}
	err = proto.Unmarshal(payload.Header.ChannelHeader, &channelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[62], 1);
		return "", errors.Wrapf(err, "failed to unmarshal channel header")
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[60], 1);return channelHeader.TxId, nil
}

// createGrpcClient returns a comm.GRPCClient based on toke client config
func createGrpcClient(cfg *ConnectionConfig, tlsEnabled bool) (*comm.GRPCClient, error) {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[63], 1);
	clientConfig := comm.ClientConfig{Timeout: time.Second}

	if tlsEnabled {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[65], 1);
		if cfg.TlsRootCertFile == "" {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[68], 1);
			return nil, errors.New("missing TlsRootCertFile in client config")
		}
		_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[66], 1);caPEM, err := ioutil.ReadFile(cfg.TlsRootCertFile)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[69], 1);
			return nil, errors.WithMessage(err, fmt.Sprintf("unable to load TLS cert from %s", cfg.TlsRootCertFile))
		}
		_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[67], 1);secOpts := &comm.SecureOptions{
			UseTLS:            true,
			ServerRootCAs:     [][]byte{caPEM},
			RequireClientCert: false,
		}
		clientConfig.SecOpts = secOpts
	}

	_cover_atomic_.AddUint32(&GoCover_6_386238643262613636363863.Count[64], 1);return comm.NewGRPCClient(clientConfig)
}

var GoCover_6_386238643262613636363863 = struct {
	Count     [70]uint32
	Pos       [3 * 70]uint32
	NumStmt   [70]uint16
} {
	Pos: [3 * 70]uint32{
		52, 54, 0x100041, // [0]
		59, 63, 0x100002, // [1]
		66, 67, 0x100002, // [2]
		71, 72, 0x100002, // [3]
		76, 77, 0x100002, // [4]
		81, 87, 0x80002, // [5]
		54, 56, 0x30010, // [6]
		63, 65, 0x30010, // [7]
		67, 69, 0x30010, // [8]
		72, 74, 0x30010, // [9]
		77, 79, 0x30010, // [10]
		95, 96, 0x1b0086, // [11]
		96, 104, 0x3001b, // [12]
		104, 107, 0x30008, // [13]
		115, 118, 0x2008d, // [14]
		120, 121, 0x2900a1, // [15]
		124, 124, 0x340002, // [16]
		128, 129, 0x100002, // [17]
		133, 134, 0x100002, // [18]
		138, 139, 0x140002, // [19]
		155, 156, 0x100002, // [20]
		161, 167, 0x250002, // [21]
		171, 171, 0x1d0002, // [22]
		121, 123, 0x30029, // [23]
		124, 126, 0x30034, // [24]
		129, 131, 0x30010, // [25]
		134, 136, 0x30010, // [26]
		139, 141, 0x110014, // [27]
		144, 145, 0x110003, // [28]
		148, 149, 0x110003, // [29]
		152, 152, 0x540003, // [30]
		141, 143, 0x40011, // [31]
		145, 147, 0x40011, // [32]
		149, 151, 0x40011, // [33]
		156, 158, 0x30010, // [34]
		167, 169, 0x30025, // [35]
		174, 181, 0x2e005a, // [36]
		190, 191, 0x100002, // [37]
		195, 196, 0x1e0002, // [38]
		181, 183, 0x11002e, // [39]
		183, 187, 0x40011, // [40]
		191, 193, 0x30010, // [41]
		201, 203, 0x100083, // [42]
		207, 208, 0x100002, // [43]
		212, 213, 0x100002, // [44]
		217, 226, 0x100002, // [45]
		230, 235, 0x100002, // [46]
		239, 244, 0x1a0002, // [47]
		203, 205, 0x30010, // [48]
		208, 210, 0x30010, // [49]
		213, 215, 0x30010, // [50]
		226, 228, 0x30010, // [51]
		235, 237, 0x30010, // [52]
		248, 255, 0x10006a, // [53]
		259, 260, 0x100002, // [54]
		264, 269, 0x180002, // [55]
		255, 257, 0x30010, // [56]
		260, 262, 0x30010, // [57]
		272, 275, 0x100044, // [58]
		279, 281, 0x100002, // [59]
		285, 285, 0x200002, // [60]
		275, 277, 0x30010, // [61]
		281, 283, 0x30010, // [62]
		289, 292, 0x100059, // [63]
		308, 308, 0x290002, // [64]
		292, 293, 0x200010, // [65]
		296, 297, 0x110003, // [66]
		300, 305, 0x210003, // [67]
		293, 295, 0x40020, // [68]
		297, 299, 0x40011, // [69]
	},
	NumStmt: [70]uint16{
		2, // 0
		4, // 1
		2, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		7, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		2, // 17
		2, // 18
		2, // 19
		2, // 20
		5, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		2, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		4, // 36
		2, // 37
		2, // 38
		2, // 39
		3, // 40
		1, // 41
		2, // 42
		2, // 43
		2, // 44
		3, // 45
		3, // 46
		2, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		3, // 53
		2, // 54
		2, // 55
		1, // 56
		1, // 57
		3, // 58
		3, // 59
		1, // 60
		1, // 61
		1, // 62
		2, // 63
		1, // 64
		1, // 65
		2, // 66
		2, // 67
		1, // 68
		1, // 69
	},
}
var _ = _cover_atomic_.LoadUint32
