//line /home/cooper/go/src/github.com/hyperledger/fabric/core/cclifecycle/subscription.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cc; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"sync"

	"github.com/hyperledger/fabric/common/chaincode"
	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
)

// Subscription channels information flow
// about a specific channel into the Lifecycle
type Subscription struct {
	sync.Mutex
	lc             *Lifecycle
	channel        string
	queryCreator   QueryCreator
	pendingUpdates chan *cceventmgmt.ChaincodeDefinition
}

type depCCsRetriever func(Query, ChaincodePredicate, bool, ...string) (chaincode.MetadataSet, error)

// HandleChaincodeDeploy is expected to be invoked when a chaincode is deployed via a deploy transaction and the chaicndoe was already
// installed on the peer. This also gets invoked when an already deployed chaincode is installed on the peer
func (sub *Subscription) HandleChaincodeDeploy(chaincodeDefinition *cceventmgmt.ChaincodeDefinition, dbArtifactsTar []byte) error {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[0], 1);
	Logger.Debug("Channel", sub.channel, "got a new deployment:", chaincodeDefinition)
	sub.pendingUpdates <- chaincodeDefinition
	return nil
}

func (sub *Subscription) processPendingUpdate(ccDef *cceventmgmt.ChaincodeDefinition) {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[1], 1);
	query, err := sub.queryCreator.NewQuery()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[4], 1);
		Logger.Errorf("Failed creating a new query for channel %s: %v", sub.channel, err)
		return
	}
	_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[2], 1);installedCC := []chaincode.InstalledChaincode{{
		Name:    ccDef.Name,
		Version: ccDef.Version,
		Id:      ccDef.Hash,
	}}
	ccs, err := queryChaincodeDefinitions(query, installedCC, DeployedChaincodes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[5], 1);
		Logger.Errorf("Query for channel %s for %v failed with error %v", sub.channel, ccDef, err)
		return
	}
	_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[3], 1);Logger.Debug("Updating channel", sub.channel, "with", ccs.AsChaincodes())
	sub.lc.updateState(sub.channel, ccs)
	sub.lc.fireChangeListeners(sub.channel)
}

// ChaincodeDeployDone gets invoked when the chaincode deploy transaction or chaincode install
// (the context in which the above function was invoked)
func (sub *Subscription) ChaincodeDeployDone(succeeded bool) {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[6], 1);
	// Run a new goroutine which would dispatch a single pending update.
	// This is to prevent any ledger locks being obtained during the state query
	// to affect the locks held while invoking this method by the ledger itself.
	// We first lock and then take the pending update, to preserve order.
	sub.Lock()
	go func() {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[7], 1);
		defer sub.Unlock()
		update := <-sub.pendingUpdates
		// If we haven't succeeded in deploying the chaincode, just skip the update
		if !succeeded {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[9], 1);
			Logger.Error("Chaincode deploy for", update.Name, "failed")
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[8], 1);sub.processPendingUpdate(update)
	}()
}

func queryChaincodeDefinitions(query Query, ccs []chaincode.InstalledChaincode, deployedCCs depCCsRetriever) (chaincode.MetadataSet, error) {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[10], 1);
	// map from string and version to chaincode ID
	installedCCsToIDs := make(map[nameVersion][]byte)
	// Populate the map
	for _, cc := range ccs {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[13], 1);
		Logger.Debug("Chaincode", cc, "'s version is", cc.Version, "and Id is", cc.Id)
		installedCCsToIDs[installedCCToNameVersion(cc)] = cc.Id
	}

	_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[11], 1);filter := func(cc chaincode.Metadata) bool {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[14], 1);
		installedID, exists := installedCCsToIDs[deployedCCToNameVersion(cc)]
		if !exists {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[17], 1);
			Logger.Debug("Chaincode", cc, "is instantiated but a different version is installed")
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[15], 1);if !bytes.Equal(installedID, cc.Id) {_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[18], 1);
			Logger.Debug("ID of chaincode", cc, "on filesystem doesn't match ID in ledger")
			return false
		}
		_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[16], 1);return true
	}

	_cover_atomic_.AddUint32(&GoCover_1_303966633866396236633762.Count[12], 1);return deployedCCs(query, filter, false, names(ccs)...)
}

var GoCover_1_303966633866396236633762 = struct {
	Count     [19]uint32
	Pos       [3 * 19]uint32
	NumStmt   [19]uint16
} {
	Pos: [3 * 19]uint32{
		31, 35, 0x20083, // [0]
		37, 39, 0x100057, // [1]
		43, 49, 0x100002, // [2]
		53, 55, 0x290002, // [3]
		39, 42, 0x30010, // [4]
		49, 52, 0x30010, // [5]
		60, 66, 0xc003e, // [6]
		66, 70, 0x11000c, // [7]
		74, 74, 0x230003, // [8]
		70, 73, 0x40011, // [9]
		78, 82, 0x19008d, // [10]
		87, 87, 0x2d0002, // [11]
		100, 100, 0x390002, // [12]
		82, 85, 0x30019, // [13]
		87, 89, 0xe002d, // [14]
		93, 93, 0x270003, // [15]
		97, 97, 0xe0003, // [16]
		89, 92, 0x4000e, // [17]
		93, 96, 0x40027, // [18]
	},
	NumStmt: [19]uint16{
		3, // 0
		2, // 1
		3, // 2
		3, // 3
		2, // 4
		2, // 5
		2, // 6
		3, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		2, // 17
		2, // 18
	},
}
var _ = _cover_atomic_.LoadUint32
