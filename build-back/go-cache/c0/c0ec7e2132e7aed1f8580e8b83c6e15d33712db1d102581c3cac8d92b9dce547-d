//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/handler.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"io"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/flogging"
	commonledger "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/core/aclmgmt/resources"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/container/ccintf"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/peer"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

var chaincodeLogger = flogging.MustGetLogger("chaincode")

// An ACLProvider performs access control checks when invoking
// chaincode.
type ACLProvider interface {
	CheckACL(resName string, channelID string, idinfo interface{}) error
}

// A Registry is responsible for tracking handlers.
type Registry interface {
	Register(*Handler) error
	Ready(cname string)
	Failed(cname string, err error)
	Deregister(cname string) error
}

// An Invoker invokes chaincode.
type Invoker interface {
	Invoke(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeInput) (*pb.ChaincodeMessage, error)
}

// SystemCCProvider provides system chaincode metadata.
type SystemCCProvider interface {
	IsSysCC(name string) bool
	IsSysCCAndNotInvokableCC2CC(name string) bool
}

// TransactionRegistry tracks active transactions for each channel.
type TransactionRegistry interface {
	Add(channelID, txID string) bool
	Remove(channelID, txID string)
}

// A ContextRegistry is responsible for managing transaction contexts.
type ContextRegistry interface {
	Create(txParams *ccprovider.TransactionParams) (*TransactionContext, error)
	Get(chainID, txID string) *TransactionContext
	Delete(chainID, txID string)
	Close()
}

// InstantiationPolicyChecker is used to evaluate instantiation policies.
type InstantiationPolicyChecker interface {
	CheckInstantiationPolicy(name, version string, cd *ccprovider.ChaincodeData) error
}

// Adapter from function to InstantiationPolicyChecker interface.
type CheckInstantiationPolicyFunc func(name, version string, cd *ccprovider.ChaincodeData) error

func (c CheckInstantiationPolicyFunc) CheckInstantiationPolicy(name, version string, cd *ccprovider.ChaincodeData) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[0], 1);
	return c(name, version, cd)
}

// QueryResponseBuilder is responsible for building QueryResponse messages for query
// transactions initiated by chaincode.
type QueryResponseBuilder interface {
	BuildQueryResponse(txContext *TransactionContext, iter commonledger.ResultsIterator,
		iterID string, isPaginated bool, totalReturnLimit int32) (*pb.QueryResponse, error)
}

// ChaincodeDefinitionGetter is responsible for retrieving a chaincode definition
// from the system. The definition is used by the InstantiationPolicyChecker.
type ChaincodeDefinitionGetter interface {
	ChaincodeDefinition(chaincodeName string, txSim ledger.QueryExecutor) (ccprovider.ChaincodeDefinition, error)
}

// LedgerGetter is used to get ledgers for chaincode.
type LedgerGetter interface {
	GetLedger(cid string) ledger.PeerLedger
}

// UUIDGenerator is responsible for creating unique query identifiers.
type UUIDGenerator interface {
	New() string
}
type UUIDGeneratorFunc func() string

func (u UUIDGeneratorFunc) New() string {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[1], 1); return u() }

// ApplicationConfigRetriever to retrieve the application configuration for a channel
type ApplicationConfigRetriever interface {
	// GetApplicationConfig returns the channelconfig.Application for the channel
	// and whether the Application config exists
	GetApplicationConfig(cid string) (channelconfig.Application, bool)
}

// Handler implements the peer side of the chaincode stream.
type Handler struct {
	// Keepalive specifies the interval at which keep-alive messages are sent.
	Keepalive time.Duration
	// SystemCCVersion specifies the current system chaincode version
	SystemCCVersion string
	// DefinitionGetter is used to retrieve the chaincode definition from the
	// Lifecycle System Chaincode.
	DefinitionGetter ChaincodeDefinitionGetter
	// Invoker is used to invoke chaincode.
	Invoker Invoker
	// Registry is used to track active handlers.
	Registry Registry
	// ACLProvider is used to check if a chaincode invocation should be allowed.
	ACLProvider ACLProvider
	// TXContexts is a collection of TransactionContext instances
	// that are accessed by channel name and transaction ID.
	TXContexts ContextRegistry
	// activeTransactions holds active transaction identifiers.
	ActiveTransactions TransactionRegistry
	// SystemCCProvider provides access to system chaincode metadata
	SystemCCProvider SystemCCProvider
	// InstantiationPolicyChecker is used to evaluate the chaincode instantiation policies.
	InstantiationPolicyChecker InstantiationPolicyChecker
	// QueryResponeBuilder is used to build query responses
	QueryResponseBuilder QueryResponseBuilder
	// LedgerGetter is used to get the ledger associated with a channel
	LedgerGetter LedgerGetter
	// UUIDGenerator is used to generate UUIDs
	UUIDGenerator UUIDGenerator
	// AppConfig is used to retrieve the application config for a channel
	AppConfig ApplicationConfigRetriever

	// state holds the current handler state. It will be created, established, or
	// ready.
	state State
	// chaincodeID holds the ID of the chaincode that registered with the peer.
	chaincodeID *pb.ChaincodeID
	// ccInstances holds information about the chaincode instance associated with
	// the peer.
	ccInstance *sysccprovider.ChaincodeInstance

	// serialLock is used to serialize sends across the grpc chat stream.
	serialLock sync.Mutex
	// chatStream is the bidirectional grpc stream used to communicate with the
	// chaincode instance.
	chatStream ccintf.ChaincodeStream
	// errChan is used to communicate errors from the async send to the receive loop
	errChan chan error
	// Metrics holds chaincode handler metrics
	Metrics *HandlerMetrics
}

// handleMessage is called by ProcessStream to dispatch messages.
func (h *Handler) handleMessage(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[2], 1);
	chaincodeLogger.Debugf("[%s] Fabric side handling ChaincodeMessage of type: %s in state %s", shorttxid(msg.Txid), msg.Type, h.state)

	if msg.Type == pb.ChaincodeMessage_KEEPALIVE {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[4], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[3], 1);switch h.state {
	case Created:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[5], 1);
		return h.handleMessageCreatedState(msg)
	case Ready:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[6], 1);
		return h.handleMessageReadyState(msg)
	default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[7], 1);
		return errors.Errorf("handle message: invalid state %s for transaction %s", h.state, msg.Txid)
	}
}

func (h *Handler) handleMessageCreatedState(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[8], 1);
	switch msg.Type {
	case pb.ChaincodeMessage_REGISTER:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[10], 1);
		h.HandleRegister(msg)
	default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[11], 1);
		return fmt.Errorf("[%s] Fabric side handler cannot handle message (%s) while in created state", msg.Txid, msg.Type)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[9], 1);return nil
}

func (h *Handler) handleMessageReadyState(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[12], 1);
	switch msg.Type {
	case pb.ChaincodeMessage_COMPLETED, pb.ChaincodeMessage_ERROR:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[14], 1);
		h.Notify(msg)

	case pb.ChaincodeMessage_PUT_STATE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[15], 1);
		go h.HandleTransaction(msg, h.HandlePutState)
	case pb.ChaincodeMessage_DEL_STATE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[16], 1);
		go h.HandleTransaction(msg, h.HandleDelState)
	case pb.ChaincodeMessage_INVOKE_CHAINCODE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[17], 1);
		go h.HandleTransaction(msg, h.HandleInvokeChaincode)

	case pb.ChaincodeMessage_GET_STATE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[18], 1);
		go h.HandleTransaction(msg, h.HandleGetState)
	case pb.ChaincodeMessage_GET_STATE_BY_RANGE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[19], 1);
		go h.HandleTransaction(msg, h.HandleGetStateByRange)
	case pb.ChaincodeMessage_GET_QUERY_RESULT:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[20], 1);
		go h.HandleTransaction(msg, h.HandleGetQueryResult)
	case pb.ChaincodeMessage_GET_HISTORY_FOR_KEY:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[21], 1);
		go h.HandleTransaction(msg, h.HandleGetHistoryForKey)
	case pb.ChaincodeMessage_QUERY_STATE_NEXT:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[22], 1);
		go h.HandleTransaction(msg, h.HandleQueryStateNext)
	case pb.ChaincodeMessage_QUERY_STATE_CLOSE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[23], 1);
		go h.HandleTransaction(msg, h.HandleQueryStateClose)

	case pb.ChaincodeMessage_GET_STATE_METADATA:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[24], 1);
		go h.HandleTransaction(msg, h.HandleGetStateMetadata)
	case pb.ChaincodeMessage_PUT_STATE_METADATA:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[25], 1);
		go h.HandleTransaction(msg, h.HandlePutStateMetadata)
	default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[26], 1);
		return fmt.Errorf("[%s] Fabric side handler cannot handle message (%s) while in ready state", msg.Txid, msg.Type)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[13], 1);return nil
}

type MessageHandler interface {
	Handle(*pb.ChaincodeMessage, *TransactionContext) (*pb.ChaincodeMessage, error)
}

type handleFunc func(*pb.ChaincodeMessage, *TransactionContext) (*pb.ChaincodeMessage, error)

// HandleTransaction is a middleware function that obtains and verifies a transaction
// context prior to forwarding the message to the provided delegate. Response messages
// returned by the delegate are sent to the chat stream. Any errors returned by the
// delegate are packaged as chaincode error messages.
func (h *Handler) HandleTransaction(msg *pb.ChaincodeMessage, delegate handleFunc) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[27], 1);
	chaincodeLogger.Debugf("[%s] handling %s from chaincode", shorttxid(msg.Txid), msg.Type.String())
	if !h.registerTxid(msg) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[32], 1);
		return
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[28], 1);startTime := time.Now()
	var txContext *TransactionContext
	var err error
	if msg.Type == pb.ChaincodeMessage_INVOKE_CHAINCODE {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[33], 1);
		txContext, err = h.getTxContextForInvoke(msg.ChannelId, msg.Txid, msg.Payload, "")
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[34], 1);{
		txContext, err = h.isValidTxSim(msg.ChannelId, msg.Txid, "no ledger context")
	}}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[29], 1);chaincodeName := h.chaincodeID.Name + ":" + h.chaincodeID.Version
	meterLabels := []string{
		"type", msg.Type.String(),
		"channel", msg.ChannelId,
		"chaincode", chaincodeName,
	}
	h.Metrics.ShimRequestsReceived.With(meterLabels...).Add(1)

	var resp *pb.ChaincodeMessage
	if err == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[35], 1);
		resp, err = delegate(msg, txContext)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[30], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[36], 1);
		err = errors.Wrapf(err, "%s failed: transaction ID: %s", msg.Type, msg.Txid)
		chaincodeLogger.Errorf("[%s] Failed to handle %s. error: %+v", shorttxid(msg.Txid), msg.Type, err)
		resp = &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_ERROR, Payload: []byte(err.Error()), Txid: msg.Txid, ChannelId: msg.ChannelId}
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[31], 1);chaincodeLogger.Debugf("[%s] Completed %s. Sending %s", shorttxid(msg.Txid), msg.Type, resp.Type)
	h.ActiveTransactions.Remove(msg.ChannelId, msg.Txid)
	h.serialSendAsync(resp)

	meterLabels = append(meterLabels, "success", strconv.FormatBool(resp.Type != pb.ChaincodeMessage_ERROR))
	h.Metrics.ShimRequestDuration.With(meterLabels...).Observe(time.Since(startTime).Seconds())
	h.Metrics.ShimRequestsCompleted.With(meterLabels...).Add(1)
}

func shorttxid(txid string) string {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[37], 1);
	if len(txid) < 8 {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[39], 1);
		return txid
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[38], 1);return txid[0:8]
}

// ParseName parses a chaincode name into a ChaincodeInstance. The name should
// be of the form "chaincode-name:version/channel-name" with optional elements.
func ParseName(ccName string) *sysccprovider.ChaincodeInstance {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[40], 1);
	ci := &sysccprovider.ChaincodeInstance{}

	z := strings.SplitN(ccName, "/", 2)
	if len(z) == 2 {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[43], 1);
		ci.ChainID = z[1]
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[41], 1);z = strings.SplitN(z[0], ":", 2)
	if len(z) == 2 {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[44], 1);
		ci.ChaincodeVersion = z[1]
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[42], 1);ci.ChaincodeName = z[0]

	return ci
}

func (h *Handler) ChaincodeName() string {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[45], 1);
	if h.ccInstance == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[47], 1);
		return ""
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[46], 1);return h.ccInstance.ChaincodeName
}

// serialSend serializes msgs so gRPC will be happy
func (h *Handler) serialSend(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[48], 1);
	h.serialLock.Lock()
	defer h.serialLock.Unlock()

	if err := h.chatStream.Send(msg); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[50], 1);
		err = errors.WithMessage(err, fmt.Sprintf("[%s] error sending %s", shorttxid(msg.Txid), msg.Type))
		chaincodeLogger.Errorf("%+v", err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[49], 1);return nil
}

// serialSendAsync serves the same purpose as serialSend (serialize msgs so gRPC will
// be happy). In addition, it is also asynchronous so send-remoterecv--localrecv loop
// can be nonblocking. Only errors need to be handled and these are handled by
// communication on supplied error channel. A typical use will be a non-blocking or
// nil channel
func (h *Handler) serialSendAsync(msg *pb.ChaincodeMessage) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[51], 1);
	go func() {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[52], 1);
		if err := h.serialSend(msg); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[53], 1);
			// provide an error response to the caller
			resp := &pb.ChaincodeMessage{
				Type:      pb.ChaincodeMessage_ERROR,
				Payload:   []byte(err.Error()),
				Txid:      msg.Txid,
				ChannelId: msg.ChannelId,
			}
			h.Notify(resp)

			// surface send error to stream processing
			h.errChan <- err
		}
	}()
}

// Check if the transactor is allow to call this chaincode on this channel
func (h *Handler) checkACL(signedProp *pb.SignedProposal, proposal *pb.Proposal, ccIns *sysccprovider.ChaincodeInstance) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[54], 1);
	// ensure that we don't invoke a system chaincode
	// that is not invokable through a cc2cc invocation
	if h.SystemCCProvider.IsSysCCAndNotInvokableCC2CC(ccIns.ChaincodeName) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[58], 1);
		return errors.Errorf("system chaincode %s cannot be invoked with a cc2cc invocation", ccIns.ChaincodeName)
	}

	// if we are here, all we know is that the invoked chaincode is either
	// - a system chaincode that *is* invokable through a cc2cc
	//   (but we may still have to determine whether the invoker can perform this invocation)
	// - an application chaincode
	//   (and we still need to determine whether the invoker can invoke it)

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[55], 1);if h.SystemCCProvider.IsSysCC(ccIns.ChaincodeName) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[59], 1);
		// Allow this call
		return nil
	}

	// A Nil signedProp will be rejected for non-system chaincodes
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[56], 1);if signedProp == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[60], 1);
		return errors.Errorf("signed proposal must not be nil from caller [%s]", ccIns.String())
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[57], 1);return h.ACLProvider.CheckACL(resources.Peer_ChaincodeToChaincode, ccIns.ChainID, signedProp)
}

func (h *Handler) deregister() {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[61], 1);
	if h.chaincodeID != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[62], 1);
		h.Registry.Deregister(h.chaincodeID.Name)
	}
}

func (h *Handler) ProcessStream(stream ccintf.ChaincodeStream) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[63], 1);
	defer h.deregister()

	h.chatStream = stream
	h.errChan = make(chan error, 1)

	var keepaliveCh <-chan time.Time
	if h.Keepalive != 0 {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[66], 1);
		ticker := time.NewTicker(h.Keepalive)
		defer ticker.Stop()
		keepaliveCh = ticker.C
	}

	// holds return values from gRPC Recv below
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[64], 1);type recvMsg struct {
		msg *pb.ChaincodeMessage
		err error
	}
	msgAvail := make(chan *recvMsg, 1)

	receiveMessage := func() {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[67], 1);
		in, err := h.chatStream.Recv()
		msgAvail <- &recvMsg{in, err}
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[65], 1);go receiveMessage()
	for {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[68], 1);
		select {
		case rmsg := <-msgAvail:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[69], 1);
			switch {
			// Defer the deregistering of the this handler.
			case rmsg.err == io.EOF:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[72], 1);
				chaincodeLogger.Debugf("received EOF, ending chaincode support stream: %s", rmsg.err)
				return rmsg.err
			case rmsg.err != nil:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[73], 1);
				err := errors.Wrap(rmsg.err, "receive failed")
				chaincodeLogger.Errorf("handling chaincode support stream: %+v", err)
				return err
			case rmsg.msg == nil:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[74], 1);
				err := errors.New("received nil message, ending chaincode support stream")
				chaincodeLogger.Debugf("%+v", err)
				return err
			default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[75], 1);
				err := h.handleMessage(rmsg.msg)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[77], 1);
					err = errors.WithMessage(err, "error handling message, ending stream")
					chaincodeLogger.Errorf("[%s] %+v", shorttxid(rmsg.msg.Txid), err)
					return err
				}

				_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[76], 1);go receiveMessage()
			}

		case sendErr := <-h.errChan:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[70], 1);
			err := errors.Wrapf(sendErr, "received error while sending message, ending chaincode support stream")
			chaincodeLogger.Errorf("%s", err)
			return err
		case <-keepaliveCh:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[71], 1);
			// if no error message from serialSend, KEEPALIVE happy, and don't care about error
			// (maybe it'll work later)
			h.serialSendAsync(&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_KEEPALIVE})
			continue
		}
	}
}

// sendReady sends READY to chaincode serially (just like REGISTER)
func (h *Handler) sendReady() error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[78], 1);
	chaincodeLogger.Debugf("sending READY for chaincode %+v", h.chaincodeID)
	ccMsg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_READY}

	// if error in sending tear down the h
	if err := h.serialSend(ccMsg); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[80], 1);
		chaincodeLogger.Errorf("error sending READY (%s) for chaincode %+v", err, h.chaincodeID)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[79], 1);h.state = Ready

	chaincodeLogger.Debugf("Changed to state ready for chaincode %+v", h.chaincodeID)

	return nil
}

// notifyRegistry will send ready on registration success and
// update the launch state of the chaincode in the handler registry.
func (h *Handler) notifyRegistry(err error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[81], 1);
	if err == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[84], 1);
		err = h.sendReady()
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[82], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[85], 1);
		h.Registry.Failed(h.chaincodeID.Name, err)
		chaincodeLogger.Errorf("failed to start %s", h.chaincodeID)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[83], 1);h.Registry.Ready(h.chaincodeID.Name)
}

// handleRegister is invoked when chaincode tries to register.
func (h *Handler) HandleRegister(msg *pb.ChaincodeMessage) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[86], 1);
	chaincodeLogger.Debugf("Received %s in state %s", msg.Type, h.state)
	chaincodeID := &pb.ChaincodeID{}
	err := proto.Unmarshal(msg.Payload, chaincodeID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[90], 1);
		chaincodeLogger.Errorf("Error in received %s, could NOT unmarshal registration info: %s", pb.ChaincodeMessage_REGISTER, err)
		return
	}

	// Now register with the chaincodeSupport
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[87], 1);h.chaincodeID = chaincodeID
	err = h.Registry.Register(h)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[91], 1);
		h.notifyRegistry(err)
		return
	}

	// get the component parts so we can use the root chaincode
	// name in keys
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[88], 1);h.ccInstance = ParseName(h.chaincodeID.Name)

	chaincodeLogger.Debugf("Got %s for chaincodeID = %s, sending back %s", pb.ChaincodeMessage_REGISTER, chaincodeID, pb.ChaincodeMessage_REGISTERED)
	if err := h.serialSend(&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_REGISTERED}); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[92], 1);
		chaincodeLogger.Errorf("error sending %s: %s", pb.ChaincodeMessage_REGISTERED, err)
		h.notifyRegistry(err)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[89], 1);h.state = Established

	chaincodeLogger.Debugf("Changed state to established for %+v", h.chaincodeID)

	// for dev mode this will also move to ready automatically
	h.notifyRegistry(nil)
}

func (h *Handler) Notify(msg *pb.ChaincodeMessage) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[93], 1);
	tctx := h.TXContexts.Get(msg.ChannelId, msg.Txid)
	if tctx == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[95], 1);
		chaincodeLogger.Debugf("notifier Txid:%s, channelID:%s does not exist for handling message %s", msg.Txid, msg.ChannelId, msg.Type)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[94], 1);chaincodeLogger.Debugf("[%s] notifying Txid:%s, channelID:%s", shorttxid(msg.Txid), msg.Txid, msg.ChannelId)
	tctx.ResponseNotifier <- msg
	tctx.CloseQueryIterators()
}

// is this a txid for which there is a valid txsim
func (h *Handler) isValidTxSim(channelID string, txid string, fmtStr string, args ...interface{}) (*TransactionContext, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[96], 1);
	txContext := h.TXContexts.Get(channelID, txid)
	if txContext == nil || txContext.TXSimulator == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[98], 1);
		err := errors.Errorf(fmtStr, args...)
		chaincodeLogger.Errorf("no ledger context: %s %s\n\n %+v", channelID, txid, err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[97], 1);return txContext, nil
}

// register Txid to prevent overlapping handle messages from chaincode
func (h *Handler) registerTxid(msg *pb.ChaincodeMessage) bool {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[99], 1);
	// Check if this is the unique state request from this chaincode txid
	if h.ActiveTransactions.Add(msg.ChannelId, msg.Txid) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[102], 1);
		return true
	}

	// Log the issue and drop the request
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[100], 1);chaincodeName := "unknown"
	if h.chaincodeID != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[103], 1);
		chaincodeName = h.chaincodeID.Name
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[101], 1);chaincodeLogger.Errorf("[%s] Another request pending for this CC: %s, Txid: %s, ChannelID: %s. Cannot process.", shorttxid(msg.Txid), chaincodeName, msg.Txid, msg.ChannelId)
	return false
}

func (h *Handler) checkMetadataCap(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[104], 1);
	ac, exists := h.AppConfig.GetApplicationConfig(msg.ChannelId)
	if !exists {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[107], 1);
		return errors.Errorf("application config does not exist for %s", msg.ChannelId)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[105], 1);if !ac.Capabilities().KeyLevelEndorsement() {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[108], 1);
		return errors.New("key level endorsement is not enabled")
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[106], 1);return nil
}

func errorIfCreatorHasNoReadAccess(chaincodeName, collection string, txContext *TransactionContext) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[109], 1);
	accessAllowed, err := hasReadAccess(chaincodeName, collection, txContext)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[112], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[110], 1);if !accessAllowed {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[113], 1);
		return errors.Errorf("tx creator does not have read access permission on privatedata in chaincodeName:%s collectionName: %s",
			chaincodeName, collection)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[111], 1);return nil
}

func hasReadAccess(chaincodeName, collection string, txContext *TransactionContext) (bool, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[114], 1);
	// check to see if read access has already been checked in the scope of this chaincode simulation
	if txContext.AllowedCollectionAccess[collection] {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[118], 1);
		return true, nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[115], 1);cc := common.CollectionCriteria{
		Channel:    txContext.ChainID,
		Namespace:  chaincodeName,
		Collection: collection,
	}

	accessAllowed, err := txContext.CollectionStore.HasReadAccess(cc, txContext.SignedProp, txContext.TXSimulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[119], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[116], 1);if accessAllowed {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[120], 1);
		txContext.AllowedCollectionAccess[collection] = accessAllowed
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[117], 1);return accessAllowed, err
}

// Handles query to ledger to get state
func (h *Handler) HandleGetState(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[121], 1);
	getState := &pb.GetState{}
	err := proto.Unmarshal(msg.Payload, getState)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[126], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[122], 1);var res []byte
	chaincodeName := h.ChaincodeName()
	collection := getState.Collection
	chaincodeLogger.Debugf("[%s] getting state for chaincode %s, key %s, channel %s", shorttxid(msg.Txid), chaincodeName, getState.Key, txContext.ChainID)

	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[127], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[130], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[128], 1);if err := errorIfCreatorHasNoReadAccess(chaincodeName, collection, txContext); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[131], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[129], 1);res, err = txContext.TXSimulator.GetPrivateData(chaincodeName, collection, getState.Key)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[132], 1);{
		res, err = txContext.TXSimulator.GetState(chaincodeName, getState.Key)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[123], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[133], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[124], 1);if res == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[134], 1);
		chaincodeLogger.Debugf("[%s] No state associated with key: %s. Sending %s with an empty payload", shorttxid(msg.Txid), getState.Key, pb.ChaincodeMessage_RESPONSE)
	}

	// Send response msg back to chaincode. GetState will not trigger event
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[125], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: res, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles query to ledger to get state metadata
func (h *Handler) HandleGetStateMetadata(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[135], 1);
	err := h.checkMetadataCap(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[142], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[136], 1);getStateMetadata := &pb.GetStateMetadata{}
	err = proto.Unmarshal(msg.Payload, getStateMetadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[143], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[137], 1);chaincodeName := h.ChaincodeName()
	collection := getStateMetadata.Collection
	chaincodeLogger.Debugf("[%s] getting state metadata for chaincode %s, key %s, channel %s", shorttxid(msg.Txid), chaincodeName, getStateMetadata.Key, txContext.ChainID)

	var metadata map[string][]byte
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[144], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[147], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[145], 1);if err := errorIfCreatorHasNoReadAccess(chaincodeName, collection, txContext); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[148], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[146], 1);metadata, err = txContext.TXSimulator.GetPrivateDataMetadata(chaincodeName, collection, getStateMetadata.Key)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[149], 1);{
		metadata, err = txContext.TXSimulator.GetStateMetadata(chaincodeName, getStateMetadata.Key)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[138], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[150], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[139], 1);var metadataResult pb.StateMetadataResult
	for metakey := range metadata {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[151], 1);
		md := &pb.StateMetadata{Metakey: metakey, Value: metadata[metakey]}
		metadataResult.Entries = append(metadataResult.Entries, md)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[140], 1);res, err := proto.Marshal(&metadataResult)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[152], 1);
		return nil, errors.WithStack(err)
	}

	// Send response msg back to chaincode. GetState will not trigger event
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[141], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: res, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles query to ledger to rage query state
func (h *Handler) HandleGetStateByRange(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[153], 1);
	getStateByRange := &pb.GetStateByRange{}
	err := proto.Unmarshal(msg.Payload, getStateByRange)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[160], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[154], 1);metadata, err := getQueryMetadataFromBytes(getStateByRange.Metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[161], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[155], 1);totalReturnLimit := calculateTotalReturnLimit(metadata)

	iterID := h.UUIDGenerator.New()

	var rangeIter commonledger.ResultsIterator
	var paginationInfo map[string]interface{}

	isPaginated := false

	chaincodeName := h.ChaincodeName()
	collection := getStateByRange.Collection
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[162], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[165], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[163], 1);if err := errorIfCreatorHasNoReadAccess(chaincodeName, collection, txContext); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[166], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[164], 1);rangeIter, err = txContext.TXSimulator.GetPrivateDataRangeScanIterator(chaincodeName, collection,
			getStateByRange.StartKey, getStateByRange.EndKey)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[167], 1);if isMetadataSetForPagination(metadata) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[168], 1);
		paginationInfo, err = createPaginationInfoFromMetadata(metadata, totalReturnLimit, pb.ChaincodeMessage_GET_STATE_BY_RANGE)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[171], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[169], 1);isPaginated = true

		startKey := getStateByRange.StartKey

		if isMetadataSetForPagination(metadata) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[172], 1);
			if metadata.Bookmark != "" {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[173], 1);
				startKey = metadata.Bookmark
			}
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[170], 1);rangeIter, err = txContext.TXSimulator.GetStateRangeScanIteratorWithMetadata(chaincodeName,
			startKey, getStateByRange.EndKey, paginationInfo)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[174], 1);{
		rangeIter, err = txContext.TXSimulator.GetStateRangeScanIterator(chaincodeName, getStateByRange.StartKey, getStateByRange.EndKey)
	}}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[156], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[175], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[157], 1);txContext.InitializeQueryContext(iterID, rangeIter)

	payload, err := h.QueryResponseBuilder.BuildQueryResponse(txContext, rangeIter, iterID, isPaginated, totalReturnLimit)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[176], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[158], 1);payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[177], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[159], 1);chaincodeLogger.Debugf("Got keys and values. Sending %s", pb.ChaincodeMessage_RESPONSE)
	return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: payloadBytes, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles query to ledger for query state next
func (h *Handler) HandleQueryStateNext(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[178], 1);
	queryStateNext := &pb.QueryStateNext{}
	err := proto.Unmarshal(msg.Payload, queryStateNext)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[183], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[179], 1);queryIter := txContext.GetQueryIterator(queryStateNext.Id)
	if queryIter == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[184], 1);
		return nil, errors.New("query iterator not found")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[180], 1);totalReturnLimit := calculateTotalReturnLimit(nil)

	payload, err := h.QueryResponseBuilder.BuildQueryResponse(txContext, queryIter, queryStateNext.Id, false, totalReturnLimit)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[185], 1);
		txContext.CleanupQueryContext(queryStateNext.Id)
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[181], 1);payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[186], 1);
		txContext.CleanupQueryContext(queryStateNext.Id)
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[182], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: payloadBytes, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles the closing of a state iterator
func (h *Handler) HandleQueryStateClose(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[187], 1);
	queryStateClose := &pb.QueryStateClose{}
	err := proto.Unmarshal(msg.Payload, queryStateClose)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[191], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[188], 1);iter := txContext.GetQueryIterator(queryStateClose.Id)
	if iter != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[192], 1);
		txContext.CleanupQueryContext(queryStateClose.Id)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[189], 1);payload := &pb.QueryResponse{HasMore: false, Id: queryStateClose.Id}
	payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[193], 1);
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[190], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: payloadBytes, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles query to ledger to execute query state
func (h *Handler) HandleGetQueryResult(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[194], 1);
	iterID := h.UUIDGenerator.New()

	getQueryResult := &pb.GetQueryResult{}
	err := proto.Unmarshal(msg.Payload, getQueryResult)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[201], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[195], 1);metadata, err := getQueryMetadataFromBytes(getQueryResult.Metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[202], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[196], 1);totalReturnLimit := calculateTotalReturnLimit(metadata)
	isPaginated := false

	var executeIter commonledger.ResultsIterator
	var paginationInfo map[string]interface{}

	chaincodeName := h.ChaincodeName()
	collection := getQueryResult.Collection
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[203], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[206], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[204], 1);if err := errorIfCreatorHasNoReadAccess(chaincodeName, collection, txContext); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[207], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[205], 1);executeIter, err = txContext.TXSimulator.ExecuteQueryOnPrivateData(chaincodeName, collection, getQueryResult.Query)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[208], 1);if isMetadataSetForPagination(metadata) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[209], 1);
		paginationInfo, err = createPaginationInfoFromMetadata(metadata, totalReturnLimit, pb.ChaincodeMessage_GET_QUERY_RESULT)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[211], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[210], 1);isPaginated = true
		executeIter, err = txContext.TXSimulator.ExecuteQueryWithMetadata(chaincodeName,
			getQueryResult.Query, paginationInfo)

	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[212], 1);{
		executeIter, err = txContext.TXSimulator.ExecuteQuery(chaincodeName, getQueryResult.Query)
	}}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[197], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[213], 1);
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[198], 1);txContext.InitializeQueryContext(iterID, executeIter)

	payload, err := h.QueryResponseBuilder.BuildQueryResponse(txContext, executeIter, iterID, isPaginated, totalReturnLimit)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[214], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[199], 1);payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[215], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[200], 1);chaincodeLogger.Debugf("Got keys and values. Sending %s", pb.ChaincodeMessage_RESPONSE)
	return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: payloadBytes, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles query to ledger history db
func (h *Handler) HandleGetHistoryForKey(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[216], 1);
	iterID := h.UUIDGenerator.New()
	chaincodeName := h.ChaincodeName()

	getHistoryForKey := &pb.GetHistoryForKey{}
	err := proto.Unmarshal(msg.Payload, getHistoryForKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[221], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[217], 1);historyIter, err := txContext.HistoryQueryExecutor.GetHistoryForKey(chaincodeName, getHistoryForKey.Key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[222], 1);
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[218], 1);totalReturnLimit := calculateTotalReturnLimit(nil)

	txContext.InitializeQueryContext(iterID, historyIter)
	payload, err := h.QueryResponseBuilder.BuildQueryResponse(txContext, historyIter, iterID, false, totalReturnLimit)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[223], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[219], 1);payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[224], 1);
		txContext.CleanupQueryContext(iterID)
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[220], 1);chaincodeLogger.Debugf("Got keys and values. Sending %s", pb.ChaincodeMessage_RESPONSE)
	return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: payloadBytes, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

func isCollectionSet(collection string) bool {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[225], 1);
	return collection != ""
}

func isMetadataSetForPagination(metadata *pb.QueryMetadata) bool {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[226], 1);
	if metadata == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[229], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[227], 1);if metadata.PageSize == 0 && metadata.Bookmark == "" {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[230], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[228], 1);return true
}

func getQueryMetadataFromBytes(metadataBytes []byte) (*pb.QueryMetadata, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[231], 1);
	if metadataBytes != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[233], 1);
		metadata := &pb.QueryMetadata{}
		err := proto.Unmarshal(metadataBytes, metadata)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[235], 1);
			return nil, errors.Wrap(err, "unmarshal failed")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[234], 1);return metadata, nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[232], 1);return nil, nil
}

func createPaginationInfoFromMetadata(metadata *pb.QueryMetadata, totalReturnLimit int32, queryType pb.ChaincodeMessage_Type) (map[string]interface{}, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[236], 1);
	paginationInfoMap := make(map[string]interface{})

	switch queryType {
	case pb.ChaincodeMessage_GET_QUERY_RESULT:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[238], 1);
		paginationInfoMap["bookmark"] = metadata.Bookmark
	case pb.ChaincodeMessage_GET_STATE_BY_RANGE:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[239], 1);
		// this is a no-op for range query
	default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[240], 1);
		return nil, errors.New("query type must be either GetQueryResult or GetStateByRange")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[237], 1);paginationInfoMap["limit"] = totalReturnLimit
	return paginationInfoMap, nil
}

func calculateTotalReturnLimit(metadata *pb.QueryMetadata) int32 {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[241], 1);
	totalReturnLimit := int32(ledgerconfig.GetTotalQueryLimit())
	if metadata != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[243], 1);
		pageSize := int32(metadata.PageSize)
		if pageSize > 0 && pageSize < totalReturnLimit {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[244], 1);
			totalReturnLimit = pageSize
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[242], 1);return totalReturnLimit
}

func (h *Handler) getTxContextForInvoke(channelID string, txid string, payload []byte, format string, args ...interface{}) (*TransactionContext, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[245], 1);
	// if we have a channelID, just get the txsim from isValidTxSim
	if channelID != "" {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[250], 1);
		return h.isValidTxSim(channelID, txid, "could not get valid transaction")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[246], 1);chaincodeSpec := &pb.ChaincodeSpec{}
	err := proto.Unmarshal(payload, chaincodeSpec)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[251], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	// Get the chaincodeID to invoke. The chaincodeID to be called may
	// contain composite info like "chaincode-name:version/channel-name"
	// We are not using version now but default to the latest
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[247], 1);targetInstance := ParseName(chaincodeSpec.ChaincodeId.Name)

	// If targetInstance is not an SCC, isValidTxSim should be called which will return an err.
	// We do not want to propagate calls to user CCs when the original call was to a SCC
	// without a channel context (ie, no ledger context).
	if !h.SystemCCProvider.IsSysCC(targetInstance.ChaincodeName) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[252], 1);
		// normal path - UCC invocation with an empty ("") channel: isValidTxSim will return an error
		return h.isValidTxSim("", txid, "could not get valid transaction")
	}

	// Calling SCC without a ChainID, then the assumption this is an external SCC called by the client (special case) and no UCC involved,
	// so no Transaction Simulator validation needed as there are no commits to the ledger, get the txContext directly if it is not nil
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[248], 1);txContext := h.TXContexts.Get(channelID, txid)
	if txContext == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[253], 1);
		return nil, errors.New("failed to get transaction context")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[249], 1);return txContext, nil
}

func (h *Handler) HandlePutState(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[254], 1);
	putState := &pb.PutState{}
	err := proto.Unmarshal(msg.Payload, putState)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[258], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[255], 1);chaincodeName := h.ChaincodeName()
	collection := putState.Collection
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[259], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[261], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[260], 1);err = txContext.TXSimulator.SetPrivateData(chaincodeName, collection, putState.Key, putState.Value)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[262], 1);{
		err = txContext.TXSimulator.SetState(chaincodeName, putState.Key, putState.Value)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[256], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[263], 1);
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[257], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

func (h *Handler) HandlePutStateMetadata(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[264], 1);
	err := h.checkMetadataCap(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[269], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[265], 1);putStateMetadata := &pb.PutStateMetadata{}
	err = proto.Unmarshal(msg.Payload, putStateMetadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[270], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[266], 1);metadata := make(map[string][]byte)
	metadata[putStateMetadata.Metadata.Metakey] = putStateMetadata.Metadata.Value

	chaincodeName := h.ChaincodeName()
	collection := putStateMetadata.Collection
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[271], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[273], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[272], 1);err = txContext.TXSimulator.SetPrivateDataMetadata(chaincodeName, collection, putStateMetadata.Key, metadata)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[274], 1);{
		err = txContext.TXSimulator.SetStateMetadata(chaincodeName, putStateMetadata.Key, metadata)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[267], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[275], 1);
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[268], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

func (h *Handler) HandleDelState(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[276], 1);
	delState := &pb.DelState{}
	err := proto.Unmarshal(msg.Payload, delState)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[280], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[277], 1);chaincodeName := h.ChaincodeName()
	collection := delState.Collection
	if isCollectionSet(collection) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[281], 1);
		if txContext.IsInitTransaction {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[283], 1);
			return nil, errors.New("private data APIs are not allowed in chaincode Init()")
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[282], 1);err = txContext.TXSimulator.DeletePrivateData(chaincodeName, collection, delState.Key)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[284], 1);{
		err = txContext.TXSimulator.DeleteState(chaincodeName, delState.Key)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[278], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[285], 1);
		return nil, errors.WithStack(err)
	}

	// Send response msg back to chaincode.
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[279], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

// Handles requests that modify ledger state
func (h *Handler) HandleInvokeChaincode(msg *pb.ChaincodeMessage, txContext *TransactionContext) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[286], 1);
	chaincodeLogger.Debugf("[%s] C-call-C", shorttxid(msg.Txid))

	chaincodeSpec := &pb.ChaincodeSpec{}
	err := proto.Unmarshal(msg.Payload, chaincodeSpec)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[294], 1);
		return nil, errors.Wrap(err, "unmarshal failed")
	}

	// Get the chaincodeID to invoke. The chaincodeID to be called may
	// contain composite info like "chaincode-name:version/channel-name".
	// We are not using version now but default to the latest.
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[287], 1);targetInstance := ParseName(chaincodeSpec.ChaincodeId.Name)
	chaincodeSpec.ChaincodeId.Name = targetInstance.ChaincodeName
	if targetInstance.ChainID == "" {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[295], 1);
		// use caller's channel as the called chaincode is in the same channel
		targetInstance.ChainID = txContext.ChainID
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[288], 1);chaincodeLogger.Debugf("[%s] C-call-C %s on channel %s", shorttxid(msg.Txid), targetInstance.ChaincodeName, targetInstance.ChainID)

	err = h.checkACL(txContext.SignedProp, txContext.Proposal, targetInstance)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[296], 1);
		chaincodeLogger.Errorf(
			"[%s] C-call-C %s on channel %s failed check ACL [%v]: [%s]",
			shorttxid(msg.Txid),
			targetInstance.ChaincodeName,
			targetInstance.ChainID,
			txContext.SignedProp,
			err,
		)
		return nil, errors.WithStack(err)
	}

	// Set up a new context for the called chaincode if on a different channel
	// We grab the called channel's ledger simulator to hold the new state
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[289], 1);txParams := &ccprovider.TransactionParams{
		TxID:                 msg.Txid,
		ChannelID:            targetInstance.ChainID,
		SignedProp:           txContext.SignedProp,
		Proposal:             txContext.Proposal,
		TXSimulator:          txContext.TXSimulator,
		HistoryQueryExecutor: txContext.HistoryQueryExecutor,
	}

	if targetInstance.ChainID != txContext.ChainID {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[297], 1);
		lgr := h.LedgerGetter.GetLedger(targetInstance.ChainID)
		if lgr == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[301], 1);
			return nil, errors.Errorf("failed to find ledger for channel: %s", targetInstance.ChainID)
		}

		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[298], 1);sim, err := lgr.NewTxSimulator(msg.Txid)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[302], 1);
			return nil, errors.WithStack(err)
		}
		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[299], 1);defer sim.Done()

		hqe, err := lgr.NewHistoryQueryExecutor()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[303], 1);
			return nil, errors.WithStack(err)
		}

		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[300], 1);txParams.TXSimulator = sim
		txParams.HistoryQueryExecutor = hqe
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[290], 1);chaincodeLogger.Debugf("[%s] getting chaincode data for %s on channel %s", shorttxid(msg.Txid), targetInstance.ChaincodeName, targetInstance.ChainID)

	version := h.SystemCCVersion
	if !h.SystemCCProvider.IsSysCC(targetInstance.ChaincodeName) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[304], 1);
		// if its a user chaincode, get the details
		cd, err := h.DefinitionGetter.ChaincodeDefinition(targetInstance.ChaincodeName, txParams.TXSimulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[306], 1);
			return nil, errors.WithStack(err)
		}

		_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[305], 1);version = cd.CCVersion()

		err = h.InstantiationPolicyChecker.CheckInstantiationPolicy(targetInstance.ChaincodeName, version, cd.(*ccprovider.ChaincodeData))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[307], 1);
			return nil, errors.WithStack(err)
		}
	}

	// Launch the new chaincode if not already running
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[291], 1);chaincodeLogger.Debugf("[%s] launching chaincode %s on channel %s", shorttxid(msg.Txid), targetInstance.ChaincodeName, targetInstance.ChainID)

	cccid := &ccprovider.CCContext{
		Name:    targetInstance.ChaincodeName,
		Version: version,
	}

	// Execute the chaincode... this CANNOT be an init at least for now
	responseMessage, err := h.Invoker.Invoke(txParams, cccid, chaincodeSpec.Input)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[308], 1);
		return nil, errors.Wrap(err, "execute failed")
	}

	// payload is marshalled and sent to the calling chaincode's shim which unmarshals and
	// sends it to chaincode
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[292], 1);res, err := proto.Marshal(responseMessage)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[309], 1);
		return nil, errors.Wrap(err, "marshal failed")
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[293], 1);return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE, Payload: res, Txid: msg.Txid, ChannelId: msg.ChannelId}, nil
}

func (h *Handler) Execute(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration) (*pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[310], 1);
	chaincodeLogger.Debugf("Entry")
	defer chaincodeLogger.Debugf("Exit")

	txParams.CollectionStore = h.getCollectionStore(msg.ChannelId)
	txParams.IsInitTransaction = (msg.Type == pb.ChaincodeMessage_INIT)

	txctx, err := h.TXContexts.Create(txParams)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[314], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[311], 1);defer h.TXContexts.Delete(msg.ChannelId, msg.Txid)

	if err := h.setChaincodeProposal(txParams.SignedProp, txParams.Proposal, msg); err != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[315], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[312], 1);h.serialSendAsync(msg)

	var ccresp *pb.ChaincodeMessage
	select {
	case ccresp = <-txctx.ResponseNotifier:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[316], 1);
		// response is sent to user or calling chaincode. ChaincodeMessage_ERROR
		// are typically treated as error
	case <-time.After(timeout):_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[317], 1);
		err = errors.New("timeout expired while executing transaction")
		ccName := cccid.Name + ":" + cccid.Version
		h.Metrics.ExecuteTimeouts.With(
			"chaincode", ccName,
		).Add(1)
	}

	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[313], 1);return ccresp, err
}

func (h *Handler) setChaincodeProposal(signedProp *pb.SignedProposal, prop *pb.Proposal, msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[318], 1);
	if prop != nil && signedProp == nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[321], 1);
		return errors.New("failed getting proposal context. Signed proposal is nil")
	}
	// TODO: This doesn't make a lot of sense. Feels like both are required or
	// neither should be set. Check with a knowledgeable expert.
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[319], 1);if prop != nil {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[322], 1);
		msg.Proposal = signedProp
	}
	_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[320], 1);return nil
}

func (h *Handler) getCollectionStore(channelID string) privdata.CollectionStore {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[323], 1);
	csStoreSupport := &peer.CollectionSupport{
		PeerLedger: h.LedgerGetter.GetLedger(channelID),
	}
	return privdata.NewSimpleCollectionStore(csStoreSupport)

}

func (h *Handler) State() State {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[324], 1); return h.state }
func (h *Handler) Close()       {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[325], 1); h.TXContexts.Close() }

type State int

const (
	Created State = iota
	Established
	Ready
)

func (s State) String() string {_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[326], 1);
	switch s {
	case Created:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[327], 1);
		return "created"
	case Established:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[328], 1);
		return "established"
	case Ready:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[329], 1);
		return "ready"
	default:_cover_atomic_.AddUint32(&GoCover_5_323839383963343337363361.Count[330], 1);
		return "UNKNOWN"
	}
}

var GoCover_5_323839383963343337363361 = struct {
	Count     [331]uint32
	Pos       [3 * 331]uint32
	NumStmt   [331]uint16
} {
	Pos: [3 * 331]uint32{
		83, 85, 0x2007a, // [0]
		111, 111, 0x370029, // [1]
		174, 177, 0x2f0041, // [2]
		181, 181, 0x110002, // [3]
		177, 179, 0x3002f, // [4]
		182, 183, 0x2a000f, // [5]
		184, 185, 0x28000d, // [6]
		186, 187, 0x61000a, // [7]
		191, 192, 0x12004d, // [8]
		198, 198, 0xc0002, // [9]
		193, 194, 0x180024, // [10]
		195, 196, 0x76000a, // [11]
		201, 202, 0x12004b, // [12]
		234, 234, 0xc0002, // [13]
		203, 204, 0x100040, // [14]
		206, 207, 0x300025, // [15]
		208, 209, 0x300025, // [16]
		210, 211, 0x37002c, // [17]
		213, 214, 0x300025, // [18]
		215, 216, 0x37002e, // [19]
		217, 218, 0x36002c, // [20]
		219, 220, 0x38002f, // [21]
		221, 222, 0x36002c, // [22]
		223, 224, 0x37002d, // [23]
		226, 227, 0x38002e, // [24]
		228, 229, 0x38002e, // [25]
		230, 231, 0x74000a, // [26]
		247, 249, 0x1a0054, // [27]
		253, 256, 0x360002, // [28]
		262, 271, 0x100002, // [29]
		275, 275, 0x100002, // [30]
		281, 287, 0x3d0002, // [31]
		249, 251, 0x3001a, // [32]
		256, 258, 0x30036, // [33]
		258, 260, 0x30008, // [34]
		271, 273, 0x30010, // [35]
		275, 279, 0x30010, // [36]
		290, 291, 0x130024, // [37]
		294, 294, 0x120002, // [38]
		291, 293, 0x30013, // [39]
		299, 303, 0x110040, // [40]
		306, 307, 0x110002, // [41]
		310, 312, 0xb0002, // [42]
		303, 305, 0x30011, // [43]
		307, 309, 0x30011, // [44]
		315, 316, 0x19002a, // [45]
		319, 319, 0x230002, // [46]
		316, 318, 0x30019, // [47]
		323, 327, 0x2f003e, // [48]
		333, 333, 0xc0002, // [49]
		327, 331, 0x3002f, // [50]
		341, 342, 0xc003d, // [51]
		342, 343, 0x2b000c, // [52]
		343, 355, 0x4002b, // [53]
		360, 363, 0x490080, // [54]
		373, 373, 0x350002, // [55]
		379, 379, 0x170002, // [56]
		383, 383, 0x5f0002, // [57]
		363, 365, 0x30049, // [58]
		373, 376, 0x30035, // [59]
		379, 381, 0x30017, // [60]
		386, 387, 0x1a0020, // [61]
		387, 389, 0x3001a, // [62]
		392, 399, 0x160046, // [63]
		406, 412, 0x1b0002, // [64]
		417, 418, 0x60002, // [65]
		399, 403, 0x30016, // [66]
		412, 415, 0x3001b, // [67]
		418, 419, 0xa0006, // [68]
		420, 421, 0xb001b, // [69]
		445, 448, 0xe001f, // [70]
		449, 453, 0xc0016, // [71]
		423, 425, 0x14001c, // [72]
		426, 429, 0xf0019, // [73]
		430, 433, 0xf0019, // [74]
		434, 436, 0x13000c, // [75]
		442, 442, 0x180005, // [76]
		436, 440, 0x60013, // [77]
		459, 464, 0x2c0025, // [78]
		469, 473, 0xc0002, // [79]
		464, 467, 0x3002c, // [80]
		478, 479, 0x10002d, // [81]
		483, 483, 0x100002, // [82]
		489, 489, 0x260002, // [83]
		479, 481, 0x30010, // [84]
		483, 487, 0x30010, // [85]
		493, 497, 0x10003c, // [86]
		503, 505, 0x100002, // [87]
		512, 515, 0x610002, // [88]
		521, 526, 0x170002, // [89]
		497, 500, 0x30010, // [90]
		505, 508, 0x30010, // [91]
		515, 519, 0x30061, // [92]
		529, 531, 0x110034, // [93]
		536, 538, 0x1c0002, // [94]
		531, 534, 0x30011, // [95]
		542, 544, 0x360080, // [96]
		549, 549, 0x170002, // [97]
		544, 548, 0x30036, // [98]
		553, 555, 0x37003f, // [99]
		560, 561, 0x1a0002, // [100]
		564, 565, 0xe0002, // [101]
		555, 557, 0x30037, // [102]
		561, 563, 0x3001a, // [103]
		568, 570, 0xd0044, // [104]
		574, 574, 0x2e0002, // [105]
		577, 577, 0xc0002, // [106]
		570, 572, 0x3000d, // [107]
		574, 576, 0x3002e, // [108]
		580, 582, 0x10006b, // [109]
		585, 585, 0x140002, // [110]
		589, 589, 0xc0002, // [111]
		582, 584, 0x30010, // [112]
		585, 588, 0x30014, // [113]
		592, 594, 0x330063, // [114]
		598, 605, 0x100002, // [115]
		608, 608, 0x130002, // [116]
		612, 612, 0x1b0002, // [117]
		594, 596, 0x30033, // [118]
		605, 607, 0x30010, // [119]
		608, 610, 0x30013, // [120]
		616, 619, 0x100079, // [121]
		623, 628, 0x210002, // [122]
		639, 639, 0x100002, // [123]
		642, 642, 0x100002, // [124]
		647, 647, 0x7e0002, // [125]
		619, 621, 0x30010, // [126]
		628, 629, 0x220021, // [127]
		632, 632, 0x5d0003, // [128]
		635, 635, 0x5b0003, // [129]
		629, 631, 0x40022, // [130]
		632, 634, 0x4005d, // [131]
		636, 638, 0x30008, // [132]
		639, 641, 0x30010, // [133]
		642, 644, 0x30010, // [134]
		651, 653, 0x100081, // [135]
		657, 659, 0x100002, // [136]
		663, 668, 0x210002, // [137]
		679, 679, 0x100002, // [138]
		682, 683, 0x200002, // [139]
		687, 688, 0x100002, // [140]
		693, 693, 0x7e0002, // [141]
		653, 655, 0x30010, // [142]
		659, 661, 0x30010, // [143]
		668, 669, 0x220021, // [144]
		672, 672, 0x5d0003, // [145]
		675, 675, 0x700003, // [146]
		669, 671, 0x40022, // [147]
		672, 674, 0x4005d, // [148]
		676, 678, 0x30008, // [149]
		679, 681, 0x30010, // [150]
		683, 686, 0x30020, // [151]
		688, 690, 0x30010, // [152]
		697, 700, 0x100080, // [153]
		704, 705, 0x100002, // [154]
		709, 720, 0x210002, // [155]
		748, 748, 0x100002, // [156]
		751, 754, 0x100002, // [157]
		759, 760, 0x100002, // [158]
		765, 766, 0x870002, // [159]
		700, 702, 0x30010, // [160]
		705, 707, 0x30010, // [161]
		720, 721, 0x220021, // [162]
		724, 724, 0x5d0003, // [163]
		727, 728, 0x350003, // [164]
		721, 723, 0x40022, // [165]
		724, 726, 0x4005d, // [166]
		729, 729, 0x310008, // [167]
		729, 731, 0x110031, // [168]
		734, 738, 0x2b0003, // [169]
		743, 744, 0x350003, // [170]
		731, 733, 0x40011, // [171]
		738, 739, 0x1f002b, // [172]
		739, 741, 0x5001f, // [173]
		745, 747, 0x30008, // [174]
		748, 750, 0x30010, // [175]
		754, 757, 0x30010, // [176]
		760, 763, 0x30010, // [177]
		770, 773, 0x10007f, // [178]
		777, 778, 0x160002, // [179]
		782, 785, 0x100002, // [180]
		790, 791, 0x100002, // [181]
		796, 796, 0x870002, // [182]
		773, 775, 0x30010, // [183]
		778, 780, 0x30016, // [184]
		785, 788, 0x30010, // [185]
		791, 794, 0x30010, // [186]
		800, 803, 0x100080, // [187]
		807, 808, 0x110002, // [188]
		812, 814, 0x100002, // [189]
		818, 818, 0x870002, // [190]
		803, 805, 0x30010, // [191]
		808, 810, 0x30011, // [192]
		814, 816, 0x30010, // [193]
		822, 827, 0x10007f, // [194]
		831, 832, 0x100002, // [195]
		836, 844, 0x210002, // [196]
		864, 864, 0x100002, // [197]
		868, 871, 0x100002, // [198]
		876, 877, 0x100002, // [199]
		882, 883, 0x870002, // [200]
		827, 829, 0x30010, // [201]
		832, 834, 0x30010, // [202]
		844, 845, 0x220021, // [203]
		848, 848, 0x5d0003, // [204]
		851, 851, 0x760003, // [205]
		845, 847, 0x40022, // [206]
		848, 850, 0x4005d, // [207]
		852, 852, 0x310008, // [208]
		852, 854, 0x110031, // [209]
		857, 859, 0x290003, // [210]
		854, 856, 0x40011, // [211]
		861, 863, 0x30008, // [212]
		864, 866, 0x30010, // [213]
		871, 874, 0x30010, // [214]
		877, 880, 0x30010, // [215]
		887, 893, 0x100081, // [216]
		897, 898, 0x100002, // [217]
		902, 906, 0x100002, // [218]
		911, 912, 0x100002, // [219]
		917, 918, 0x870002, // [220]
		893, 895, 0x30010, // [221]
		898, 900, 0x30010, // [222]
		906, 909, 0x30010, // [223]
		912, 915, 0x30010, // [224]
		921, 923, 0x2002e, // [225]
		925, 926, 0x150042, // [226]
		930, 930, 0x370002, // [227]
		934, 934, 0xd0002, // [228]
		926, 928, 0x30015, // [229]
		930, 932, 0x30037, // [230]
		937, 938, 0x1a0051, // [231]
		946, 946, 0x110002, // [232]
		938, 941, 0x11001a, // [233]
		944, 944, 0x170003, // [234]
		941, 943, 0x40011, // [235]
		949, 952, 0x13009f, // [236]
		961, 962, 0x1f0002, // [237]
		953, 954, 0x34002c, // [238]
		955, 955, 0x2e002e, // [239]
		957, 958, 0x58000a, // [240]
		965, 967, 0x150042, // [241]
		973, 973, 0x190002, // [242]
		967, 969, 0x320015, // [243]
		969, 971, 0x40032, // [244]
		976, 978, 0x150099, // [245]
		982, 984, 0x100002, // [246]
		991, 996, 0x3f0002, // [247]
		1003, 1004, 0x160002, // [248]
		1008, 1008, 0x170002, // [249]
		978, 980, 0x30015, // [250]
		984, 986, 0x30010, // [251]
		996, 999, 0x3003f, // [252]
		1004, 1006, 0x30016, // [253]
		1011, 1014, 0x100079, // [254]
		1018, 1020, 0x210002, // [255]
		1028, 1028, 0x100002, // [256]
		1032, 1032, 0x700002, // [257]
		1014, 1016, 0x30010, // [258]
		1020, 1021, 0x220021, // [259]
		1024, 1024, 0x660003, // [260]
		1021, 1023, 0x40022, // [261]
		1025, 1027, 0x30008, // [262]
		1028, 1030, 0x30010, // [263]
		1035, 1037, 0x100081, // [264]
		1041, 1043, 0x100002, // [265]
		1047, 1052, 0x210002, // [266]
		1060, 1060, 0x100002, // [267]
		1064, 1064, 0x700002, // [268]
		1037, 1039, 0x30010, // [269]
		1043, 1045, 0x30010, // [270]
		1052, 1053, 0x220021, // [271]
		1056, 1056, 0x700003, // [272]
		1053, 1055, 0x40022, // [273]
		1057, 1059, 0x30008, // [274]
		1060, 1062, 0x30010, // [275]
		1067, 1070, 0x100079, // [276]
		1074, 1076, 0x210002, // [277]
		1084, 1084, 0x100002, // [278]
		1089, 1089, 0x700002, // [279]
		1070, 1072, 0x30010, // [280]
		1076, 1077, 0x220021, // [281]
		1080, 1080, 0x590003, // [282]
		1077, 1079, 0x40022, // [283]
		1081, 1083, 0x30008, // [284]
		1084, 1086, 0x30010, // [285]
		1093, 1098, 0x100080, // [286]
		1105, 1107, 0x220002, // [287]
		1111, 1114, 0x100002, // [288]
		1128, 1137, 0x310002, // [289]
		1158, 1161, 0x3f0002, // [290]
		1177, 1186, 0x100002, // [291]
		1192, 1193, 0x100002, // [292]
		1197, 1197, 0x7e0002, // [293]
		1098, 1100, 0x30010, // [294]
		1107, 1110, 0x30022, // [295]
		1114, 1124, 0x30010, // [296]
		1137, 1139, 0x110031, // [297]
		1143, 1144, 0x110003, // [298]
		1147, 1150, 0x110003, // [299]
		1154, 1155, 0x260003, // [300]
		1139, 1141, 0x40011, // [301]
		1144, 1146, 0x40011, // [302]
		1150, 1152, 0x40011, // [303]
		1161, 1164, 0x11003f, // [304]
		1168, 1171, 0x110003, // [305]
		1164, 1166, 0x40011, // [306]
		1171, 1173, 0x40011, // [307]
		1186, 1188, 0x30010, // [308]
		1193, 1195, 0x30010, // [309]
		1200, 1208, 0x1000af, // [310]
		1211, 1213, 0x5c0002, // [311]
		1217, 1220, 0x90002, // [312]
		1232, 1232, 0x140002, // [313]
		1208, 1210, 0x30010, // [314]
		1213, 1215, 0x3005c, // [315]
		1221, 1221, 0x290029, // [316]
		1224, 1229, 0xb001d, // [317]
		1235, 1236, 0x26007a, // [318]
		1241, 1241, 0x110002, // [319]
		1244, 1244, 0xc0002, // [320]
		1236, 1238, 0x30026, // [321]
		1241, 1243, 0x30011, // [322]
		1247, 1253, 0x20051, // [323]
		1255, 1255, 0x330021, // [324]
		1256, 1256, 0x390021, // [325]
		1266, 1267, 0xb0020, // [326]
		1268, 1269, 0x13000f, // [327]
		1270, 1271, 0x170013, // [328]
		1272, 1273, 0x11000d, // [329]
		1274, 1275, 0x13000a, // [330]
	},
	NumStmt: [331]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		4, // 28
		5, // 29
		1, // 30
		6, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		3, // 36
		1, // 37
		1, // 38
		1, // 39
		3, // 40
		2, // 41
		2, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		3, // 48
		1, // 49
		3, // 50
		1, // 51
		1, // 52
		3, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		5, // 63
		3, // 64
		2, // 65
		3, // 66
		2, // 67
		1, // 68
		1, // 69
		3, // 70
		2, // 71
		2, // 72
		3, // 73
		3, // 74
		2, // 75
		1, // 76
		3, // 77
		3, // 78
		3, // 79
		2, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		3, // 85
		4, // 86
		3, // 87
		3, // 88
		3, // 89
		2, // 90
		2, // 91
		3, // 92
		2, // 93
		3, // 94
		2, // 95
		2, // 96
		1, // 97
		3, // 98
		1, // 99
		2, // 100
		2, // 101
		1, // 102
		1, // 103
		2, // 104
		1, // 105
		1, // 106
		1, // 107
		1, // 108
		2, // 109
		1, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		3, // 115
		1, // 116
		1, // 117
		1, // 118
		1, // 119
		1, // 120
		3, // 121
		5, // 122
		1, // 123
		1, // 124
		1, // 125
		1, // 126
		1, // 127
		1, // 128
		1, // 129
		1, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		2, // 135
		3, // 136
		5, // 137
		1, // 138
		2, // 139
		2, // 140
		1, // 141
		1, // 142
		1, // 143
		1, // 144
		1, // 145
		1, // 146
		1, // 147
		1, // 148
		1, // 149
		1, // 150
		2, // 151
		1, // 152
		3, // 153
		2, // 154
		8, // 155
		1, // 156
		3, // 157
		2, // 158
		2, // 159
		1, // 160
		1, // 161
		1, // 162
		1, // 163
		1, // 164
		1, // 165
		1, // 166
		1, // 167
		2, // 168
		3, // 169
		1, // 170
		1, // 171
		1, // 172
		1, // 173
		1, // 174
		1, // 175
		2, // 176
		2, // 177
		3, // 178
		2, // 179
		3, // 180
		2, // 181
		1, // 182
		1, // 183
		1, // 184
		2, // 185
		2, // 186
		3, // 187
		2, // 188
		3, // 189
		1, // 190
		1, // 191
		1, // 192
		1, // 193
		4, // 194
		2, // 195
		7, // 196
		1, // 197
		3, // 198
		2, // 199
		2, // 200
		1, // 201
		1, // 202
		1, // 203
		1, // 204
		1, // 205
		1, // 206
		1, // 207
		1, // 208
		2, // 209
		2, // 210
		1, // 211
		1, // 212
		1, // 213
		2, // 214
		2, // 215
		5, // 216
		2, // 217
		4, // 218
		2, // 219
		2, // 220
		1, // 221
		1, // 222
		2, // 223
		2, // 224
		1, // 225
		1, // 226
		1, // 227
		1, // 228
		1, // 229
		1, // 230
		1, // 231
		1, // 232
		3, // 233
		1, // 234
		1, // 235
		2, // 236
		2, // 237
		1, // 238
		0, // 239
		1, // 240
		2, // 241
		1, // 242
		2, // 243
		1, // 244
		1, // 245
		3, // 246
		2, // 247
		2, // 248
		1, // 249
		1, // 250
		1, // 251
		1, // 252
		1, // 253
		3, // 254
		3, // 255
		1, // 256
		1, // 257
		1, // 258
		1, // 259
		1, // 260
		1, // 261
		1, // 262
		1, // 263
		2, // 264
		3, // 265
		5, // 266
		1, // 267
		1, // 268
		1, // 269
		1, // 270
		1, // 271
		1, // 272
		1, // 273
		1, // 274
		1, // 275
		3, // 276
		3, // 277
		1, // 278
		1, // 279
		1, // 280
		1, // 281
		1, // 282
		1, // 283
		1, // 284
		1, // 285
		4, // 286
		3, // 287
		3, // 288
		2, // 289
		3, // 290
		4, // 291
		2, // 292
		1, // 293
		1, // 294
		1, // 295
		2, // 296
		2, // 297
		2, // 298
		3, // 299
		2, // 300
		1, // 301
		1, // 302
		1, // 303
		2, // 304
		3, // 305
		1, // 306
		1, // 307
		1, // 308
		1, // 309
		6, // 310
		2, // 311
		3, // 312
		1, // 313
		1, // 314
		1, // 315
		0, // 316
		3, // 317
		1, // 318
		1, // 319
		1, // 320
		1, // 321
		1, // 322
		2, // 323
		1, // 324
		1, // 325
		1, // 326
		1, // 327
		1, // 328
		1, // 329
		1, // 330
	},
}
var _ = _cover_atomic_.LoadUint32
