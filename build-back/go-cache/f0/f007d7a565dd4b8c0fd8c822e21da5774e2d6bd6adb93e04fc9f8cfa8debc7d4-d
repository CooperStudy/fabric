//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/cceventmgmt/mgr.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cceventmgmt; import _cover_atomic_ "sync/atomic"

import (
	"sync"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger"
)

var logger = flogging.MustGetLogger("cceventmgmt")

var mgr *Mgr

// Initialize initializes event mgmt
func Initialize(ccInfoProvider ChaincodeInfoProvider) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[0], 1);
	initialize(ccInfoProvider)
}

func initialize(ccInfoProvider ChaincodeInfoProvider) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[1], 1);
	mgr = newMgr(ccInfoProvider)
}

// GetMgr returns the reference to singleton event manager
func GetMgr() *Mgr {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[2], 1);
	return mgr
}

// Mgr encapsulate important interactions for events related to the interest of ledger
type Mgr struct {
	// rwlock is mainly used to synchronize across deploy transaction, chaincode install, and channel creation
	// Ideally, different services in the peer should be designed such that they expose locks for different important
	// events so that a code on top can synchronize across if needs to. However, in the lack of any such system-wide design,
	// we use this lock for contextual use
	rwlock               sync.RWMutex
	infoProvider         ChaincodeInfoProvider
	ccLifecycleListeners map[string][]ChaincodeLifecycleEventListener
	callbackStatus       *callbackStatus
}

func newMgr(chaincodeInfoProvider ChaincodeInfoProvider) *Mgr {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[3], 1);
	return &Mgr{
		infoProvider:         chaincodeInfoProvider,
		ccLifecycleListeners: make(map[string][]ChaincodeLifecycleEventListener),
		callbackStatus:       newCallbackStatus()}
}

// Register registers a ChaincodeLifecycleEventListener for given ledgerid
// Since, `Register` is expected to be invoked when creating/opening a ledger instance
func (m *Mgr) Register(ledgerid string, l ChaincodeLifecycleEventListener) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[4], 1);
	// write lock to synchronize concurrent 'chaincode install' operations with ledger creation/open
	m.rwlock.Lock()
	defer m.rwlock.Unlock()
	m.ccLifecycleListeners[ledgerid] = append(m.ccLifecycleListeners[ledgerid], l)
}

// HandleChaincodeDeploy is expected to be invoked when a chaincode is deployed via a deploy transaction
// The `chaincodeDefinitions` parameter contains all the chaincodes deployed in a block
// We need to store the last received `chaincodeDefinitions` because this function is expected to be invoked
// after the deploy transactions validation is performed but not committed yet to the ledger. Further, we
// release the read lock after this function. This leaves a small window when a `chaincode install` can happen
// before the deploy transaction is committed and hence the function `HandleChaincodeInstall` may miss finding
// the deployed chaincode. So, in function `HandleChaincodeInstall`, we explicitly check for chaincode deployed
// in this stored `chaincodeDefinitions`
func (m *Mgr) HandleChaincodeDeploy(chainid string, chaincodeDefinitions []*ChaincodeDefinition) error {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[5], 1);
	logger.Debugf("Channel [%s]: Handling chaincode deploy event for chaincode [%s]", chainid, chaincodeDefinitions)
	// Read lock to allow concurrent deploy on multiple channels but to synchronize concurrent `chaincode install` operation
	m.rwlock.RLock()
	for _, chaincodeDefinition := range chaincodeDefinitions {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[7], 1);
		installed, dbArtifacts, err := m.infoProvider.RetrieveChaincodeArtifacts(chaincodeDefinition)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[11], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[8], 1);if !installed {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[12], 1);
			logger.Infof("Channel [%s]: Chaincode [%s] is not installed hence no need to create chaincode artifacts for endorsement",
				chainid, chaincodeDefinition)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[9], 1);m.callbackStatus.setDeployPending(chainid)
		if err := m.invokeHandler(chainid, chaincodeDefinition, dbArtifacts); err != nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[13], 1);
			logger.Warningf("Channel [%s]: Error while invoking a listener for handling chaincode install event: %s", chainid, err)
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[10], 1);logger.Debugf("Channel [%s]: Handled chaincode deploy event for chaincode [%s]", chainid, chaincodeDefinitions)
	}
	_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[6], 1);return nil
}

// ChaincodeDeployDone is expected to be called when the deploy transaction state is committed
func (m *Mgr) ChaincodeDeployDone(chainid string) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[14], 1);
	// release the lock aquired in function `HandleChaincodeDeploy`
	defer m.rwlock.RUnlock()
	if m.callbackStatus.isDeployPending(chainid) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[15], 1);
		m.invokeDoneOnHandlers(chainid, true)
		m.callbackStatus.unsetDeployPending(chainid)
	}
}

// HandleChaincodeInstall is expected to get invoked during installation of a chaincode package
func (m *Mgr) HandleChaincodeInstall(chaincodeDefinition *ChaincodeDefinition, dbArtifacts []byte) error {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[16], 1);
	logger.Debugf("HandleChaincodeInstall() - chaincodeDefinition=%#v", chaincodeDefinition)
	// Write lock prevents concurrent deploy operations
	m.rwlock.Lock()
	for chainid := range m.ccLifecycleListeners {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[18], 1);
		logger.Debugf("Channel [%s]: Handling chaincode install event for chaincode [%s]", chainid, chaincodeDefinition)
		var deployedCCInfo *ledger.DeployedChaincodeInfo
		var err error
		if deployedCCInfo, err = m.infoProvider.GetDeployedChaincodeInfo(chainid, chaincodeDefinition); err != nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[22], 1);
			logger.Warningf("Channel [%s]: Error while getting the deployment status of chaincode: %s", chainid, err)
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[19], 1);if deployedCCInfo == nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[23], 1);
			logger.Debugf("Channel [%s]: Chaincode [%s] is not deployed on channel hence not creating chaincode artifacts.",
				chainid, chaincodeDefinition)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[20], 1);m.callbackStatus.setInstallPending(chainid)
		chaincodeDefinition.CollectionConfigs = deployedCCInfo.CollectionConfigPkg
		if err := m.invokeHandler(chainid, chaincodeDefinition, dbArtifacts); err != nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[24], 1);
			logger.Warningf("Channel [%s]: Error while invoking a listener for handling chaincode install event: %s", chainid, err)
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[21], 1);logger.Debugf("Channel [%s]: Handled chaincode install event for chaincode [%s]", chainid, chaincodeDefinition)
	}
	_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[17], 1);return nil
}

// ChaincodeInstallDone is expected to get invoked when chaincode install finishes
func (m *Mgr) ChaincodeInstallDone(succeeded bool) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[25], 1);
	// release the lock acquired in function `HandleChaincodeInstall`
	defer m.rwlock.Unlock()
	for chainid := range m.callbackStatus.installPending {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[26], 1);
		m.invokeDoneOnHandlers(chainid, succeeded)
		m.callbackStatus.unsetInstallPending(chainid)
	}
}

func (m *Mgr) invokeHandler(chainid string, chaincodeDefinition *ChaincodeDefinition, dbArtifactsTar []byte) error {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[27], 1);
	listeners := m.ccLifecycleListeners[chainid]
	for _, listener := range listeners {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[29], 1);
		if err := listener.HandleChaincodeDeploy(chaincodeDefinition, dbArtifactsTar); err != nil {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[30], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[28], 1);return nil
}

func (m *Mgr) invokeDoneOnHandlers(chainid string, succeeded bool) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[31], 1);
	listeners := m.ccLifecycleListeners[chainid]
	for _, listener := range listeners {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[32], 1);
		listener.ChaincodeDeployDone(succeeded)
	}
}

type callbackStatus struct {
	l              sync.Mutex
	deployPending  map[string]bool
	installPending map[string]bool
}

func newCallbackStatus() *callbackStatus {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[33], 1);
	return &callbackStatus{
		deployPending:  make(map[string]bool),
		installPending: make(map[string]bool)}
}

func (s *callbackStatus) setDeployPending(channelID string) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[34], 1);
	s.l.Lock()
	defer s.l.Unlock()
	s.deployPending[channelID] = true
}

func (s *callbackStatus) unsetDeployPending(channelID string) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[35], 1);
	s.l.Lock()
	defer s.l.Unlock()
	delete(s.deployPending, channelID)
}

func (s *callbackStatus) isDeployPending(channelID string) bool {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[36], 1);
	s.l.Lock()
	defer s.l.Unlock()
	return s.deployPending[channelID]
}

func (s *callbackStatus) setInstallPending(channelID string) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[37], 1);
	s.l.Lock()
	defer s.l.Unlock()
	s.installPending[channelID] = true
}

func (s *callbackStatus) unsetInstallPending(channelID string) {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[38], 1);
	s.l.Lock()
	defer s.l.Unlock()
	delete(s.installPending, channelID)
}

func (s *callbackStatus) isInstallPending(channelID string) bool {_cover_atomic_.AddUint32(&GoCover_2_313036666535393137343839.Count[39], 1);
	s.l.Lock()
	defer s.l.Unlock()
	return s.installPending[channelID]
}

var GoCover_2_313036666535393137343839 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		21, 23, 0x20037, // [0]
		25, 27, 0x20037, // [1]
		30, 32, 0x20014, // [2]
		46, 51, 0x2003f, // [3]
		55, 60, 0x2004c, // [4]
		70, 74, 0x3b0068, // [5]
		91, 91, 0xc0002, // [6]
		74, 76, 0x11003b, // [7]
		79, 79, 0x110003, // [8]
		84, 85, 0x540003, // [9]
		89, 89, 0x720003, // [10]
		76, 78, 0x40011, // [11]
		79, 82, 0xc0011, // [12]
		85, 88, 0x40054, // [13]
		95, 98, 0x2f0033, // [14]
		98, 101, 0x3002f, // [15]
		105, 109, 0x2e006a, // [16]
		130, 130, 0xc0002, // [17]
		109, 113, 0x6e002e, // [18]
		117, 117, 0x1c0003, // [19]
		122, 124, 0x540003, // [20]
		128, 128, 0x720003, // [21]
		113, 116, 0x4006e, // [22]
		117, 120, 0xc001c, // [23]
		124, 127, 0x40054, // [24]
		134, 137, 0x370034, // [25]
		137, 140, 0x30037, // [26]
		143, 145, 0x250074, // [27]
		150, 150, 0xc0002, // [28]
		145, 146, 0x5d0025, // [29]
		146, 148, 0x4005d, // [30]
		153, 155, 0x250044, // [31]
		155, 157, 0x30025, // [32]
		166, 170, 0x2002a, // [33]
		172, 176, 0x2003d, // [34]
		178, 182, 0x2003f, // [35]
		184, 188, 0x20041, // [36]
		190, 194, 0x2003e, // [37]
		196, 200, 0x20040, // [38]
		202, 206, 0x20042, // [39]
	},
	NumStmt: [40]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		3, // 4
		3, // 5
		1, // 6
		2, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		2, // 12
		2, // 13
		2, // 14
		2, // 15
		3, // 16
		1, // 17
		4, // 18
		1, // 19
		3, // 20
		1, // 21
		2, // 22
		2, // 23
		2, // 24
		2, // 25
		2, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		2, // 31
		1, // 32
		1, // 33
		3, // 34
		3, // 35
		3, // 36
		3, // 37
		3, // 38
		3, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
