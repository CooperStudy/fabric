//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/platforms/platforms.go:1
/*
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
*/

package platforms; import _cover_atomic_ "sync/atomic"

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"strings"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/metadata"
	cutil "github.com/hyperledger/fabric/core/container/util"
)

//MetadataProvider is implemented by each platform in a platform specific manner.
//It can process metadata stored in ChaincodeDeploymentSpec in different formats.
//The common format is targz. Currently users expect the metadata to be presented
//as tar file entries (directly extracted from chaincode stored in targz format).
//In future, we would like provide better abstraction by extending the interface
type MetadataProvider interface {
	GetMetadataAsTarEntries() ([]byte, error)
}

// Interface for validating the specification and and writing the package for
// the given platform
type Platform interface {
	Name() string
	ValidatePath(path string) error
	ValidateCodePackage(code []byte) error
	GetDeploymentPayload(path string) ([]byte, error)
	GenerateDockerfile() (string, error)
	GenerateDockerBuild(path string, code []byte, tw *tar.Writer) error
	GetMetadataProvider(code []byte) MetadataProvider
}

type PackageWriter interface {
	Write(name string, payload []byte, tw *tar.Writer) error
}

type PackageWriterWrapper func(name string, payload []byte, tw *tar.Writer) error

func (pw PackageWriterWrapper) Write(name string, payload []byte, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[0], 1);
	return pw(name, payload, tw)
}

type Registry struct {
	Platforms     map[string]Platform
	PackageWriter PackageWriter
}

var logger = flogging.MustGetLogger("chaincode.platform")

func NewRegistry(platformTypes ...Platform) *Registry {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[1], 1);
	platforms := make(map[string]Platform)
	for _, platform := range platformTypes {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[3], 1);
		if _, ok := platforms[platform.Name()]; ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[5], 1);
			logger.Panicf("Multiple platforms of the same name specified: %s", platform.Name())
		}
		_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[4], 1);platforms[platform.Name()] = platform
	}
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[2], 1);return &Registry{
		Platforms:     platforms,
		PackageWriter: PackageWriterWrapper(cutil.WriteBytesToPackage),
	}
}

func (r *Registry) ValidateSpec(ccType, path string) error {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[6], 1);
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[8], 1);
		return fmt.Errorf("Unknown chaincodeType: %s", ccType)
	}
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[7], 1);return platform.ValidatePath(path)
}

func (r *Registry) ValidateDeploymentSpec(ccType string, codePackage []byte) error {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[9], 1);
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[11], 1);
		return fmt.Errorf("Unknown chaincodeType: %s", ccType)
	}
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[10], 1);return platform.ValidateCodePackage(codePackage)
}

func (r *Registry) GetMetadataProvider(ccType string, codePackage []byte) (MetadataProvider, error) {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[12], 1);
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[14], 1);
		return nil, fmt.Errorf("Unknown chaincodeType: %s", ccType)
	}
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[13], 1);return platform.GetMetadataProvider(codePackage), nil
}

func (r *Registry) GetDeploymentPayload(ccType, path string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[15], 1);
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[17], 1);
		return nil, fmt.Errorf("Unknown chaincodeType: %s", ccType)
	}

	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[16], 1);return platform.GetDeploymentPayload(path)
}

func (r *Registry) GenerateDockerfile(ccType, name, version string) (string, error) {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[18], 1);
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[21], 1);
		return "", fmt.Errorf("Unknown chaincodeType: %s", ccType)
	}

	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[19], 1);var buf []string

	// ----------------------------------------------------------------------------------------------------
	// Let the platform define the base Dockerfile
	// ----------------------------------------------------------------------------------------------------
	base, err := platform.GenerateDockerfile()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[22], 1);
		return "", fmt.Errorf("Failed to generate platform-specific Dockerfile: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[20], 1);buf = append(buf, base)

	// ----------------------------------------------------------------------------------------------------
	// Add some handy labels
	// ----------------------------------------------------------------------------------------------------
	buf = append(buf, fmt.Sprintf(`LABEL %s.chaincode.id.name="%s" \`, metadata.BaseDockerLabel, name))
	buf = append(buf, fmt.Sprintf(`      %s.chaincode.id.version="%s" \`, metadata.BaseDockerLabel, version))
	buf = append(buf, fmt.Sprintf(`      %s.chaincode.type="%s" \`, metadata.BaseDockerLabel, ccType))
	buf = append(buf, fmt.Sprintf(`      %s.version="%s" \`, metadata.BaseDockerLabel, metadata.Version))
	buf = append(buf, fmt.Sprintf(`      %s.base.version="%s"`, metadata.BaseDockerLabel, metadata.BaseVersion))
	// ----------------------------------------------------------------------------------------------------
	// Then augment it with any general options
	// ----------------------------------------------------------------------------------------------------
	//append version so chaincode build version can be compared against peer build version
	buf = append(buf, fmt.Sprintf("ENV CORE_CHAINCODE_BUILDLEVEL=%s", metadata.Version))

	// ----------------------------------------------------------------------------------------------------
	// Finalize it
	// ----------------------------------------------------------------------------------------------------
	contents := strings.Join(buf, "\n")
	logger.Debugf("\n%s", contents)

	return contents, nil
}

func (r *Registry) StreamDockerBuild(ccType, path string, codePackage []byte, inputFiles map[string][]byte, tw *tar.Writer) error {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[23], 1);
	var err error

	// ----------------------------------------------------------------------------------------------------
	// Determine our platform driver from the spec
	// ----------------------------------------------------------------------------------------------------
	platform, ok := r.Platforms[ccType]
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[27], 1);
		return fmt.Errorf("could not find platform of type: %s", ccType)
	}

	// ----------------------------------------------------------------------------------------------------
	// First stream out our static inputFiles
	// ----------------------------------------------------------------------------------------------------
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[24], 1);for name, data := range inputFiles {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[28], 1);
		err = r.PackageWriter.Write(name, data, tw)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[29], 1);
			return fmt.Errorf(`Failed to inject "%s": %s`, name, err)
		}
	}

	// ----------------------------------------------------------------------------------------------------
	// Now give the platform an opportunity to contribute its own context to the build
	// ----------------------------------------------------------------------------------------------------
	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[25], 1);err = platform.GenerateDockerBuild(path, codePackage, tw)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[30], 1);
		return fmt.Errorf("Failed to generate platform-specific docker build: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[26], 1);return nil
}

func (r *Registry) GenerateDockerBuild(ccType, path, name, version string, codePackage []byte) (io.Reader, error) {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[31], 1);

	inputFiles := make(map[string][]byte)

	// ----------------------------------------------------------------------------------------------------
	// Generate the Dockerfile specific to our context
	// ----------------------------------------------------------------------------------------------------
	dockerFile, err := r.GenerateDockerfile(ccType, name, version)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[34], 1);
		return nil, fmt.Errorf("Failed to generate a Dockerfile: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[32], 1);inputFiles["Dockerfile"] = []byte(dockerFile)

	// ----------------------------------------------------------------------------------------------------
	// Finally, launch an asynchronous process to stream all of the above into a docker build context
	// ----------------------------------------------------------------------------------------------------
	input, output := io.Pipe()

	go func() {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[35], 1);
		gw := gzip.NewWriter(output)
		tw := tar.NewWriter(gw)
		err := r.StreamDockerBuild(ccType, path, codePackage, inputFiles, tw)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[37], 1);
			logger.Error(err)
		}

		_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[36], 1);tw.Close()
		gw.Close()
		output.CloseWithError(err)
	}()

	_cover_atomic_.AddUint32(&GoCover_0_666232303835636534626563.Count[33], 1);return input, nil
}

var GoCover_0_666232303835636534626563 = struct {
	Count     [38]uint32
	Pos       [3 * 38]uint32
	NumStmt   [38]uint16
} {
	Pos: [3 * 38]uint32{
		48, 50, 0x20059, // [0]
		59, 61, 0x290037, // [1]
		67, 70, 0x30002, // [2]
		61, 62, 0x2e0029, // [3]
		65, 65, 0x280003, // [4]
		62, 64, 0x4002e, // [5]
		73, 75, 0x9003c, // [6]
		78, 78, 0x240002, // [7]
		75, 77, 0x30009, // [8]
		81, 83, 0x90054, // [9]
		86, 86, 0x320002, // [10]
		83, 85, 0x30009, // [11]
		89, 91, 0x90065, // [12]
		94, 94, 0x370002, // [13]
		91, 93, 0x30009, // [14]
		97, 99, 0x9004e, // [15]
		103, 103, 0x2c0002, // [16]
		99, 101, 0x30009, // [17]
		106, 108, 0x90055, // [18]
		112, 118, 0x100002, // [19]
		121, 143, 0x160002, // [20]
		108, 110, 0x30009, // [21]
		118, 120, 0x30010, // [22]
		146, 153, 0x90083, // [23]
		160, 160, 0x250002, // [24]
		170, 171, 0x100002, // [25]
		175, 175, 0xc0002, // [26]
		153, 155, 0x30009, // [27]
		160, 162, 0x110025, // [28]
		162, 164, 0x40011, // [29]
		171, 173, 0x30010, // [30]
		178, 186, 0x100073, // [31]
		190, 197, 0xc0002, // [32]
		210, 210, 0x130002, // [33]
		186, 188, 0x30010, // [34]
		197, 201, 0x11000c, // [35]
		205, 207, 0x1d0003, // [36]
		201, 203, 0x40011, // [37]
	},
	NumStmt: [38]uint16{
		1, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		1, // 17
		2, // 18
		3, // 19
		10, // 20
		1, // 21
		1, // 22
		3, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		3, // 31
		3, // 32
		1, // 33
		1, // 34
		4, // 35
		3, // 36
		1, // 37
	},
}
var _ = _cover_atomic_.LoadUint32
