//line /home/cooper/go/src/github.com/hyperledger/fabric/common/grpclogging/server.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package grpclogging; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"strings"
	"time"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/peer"
)

// Leveler returns a zap level to use when logging from a grpc interceptor.
type Leveler interface {
	Level(ctx context.Context, fullMethod string) zapcore.Level
}

// PayloadLeveler gets the level to use when logging grpc message payloads.
type PayloadLeveler interface {
	PayloadLevel(ctx context.Context, fullMethod string) zapcore.Level
}

//go:generate counterfeiter -o fakes/leveler.go --fake-name Leveler . LevelerFunc

type LevelerFunc func(ctx context.Context, fullMethod string) zapcore.Level

func (l LevelerFunc) Level(ctx context.Context, fullMethod string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[0], 1);
	return l(ctx, fullMethod)
}

func (l LevelerFunc) PayloadLevel(ctx context.Context, fullMethod string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[1], 1);
	return l(ctx, fullMethod)
}

// DefaultPayloadLevel is default level to use when logging payloads
const DefaultPayloadLevel = zapcore.Level(zapcore.DebugLevel - 1)

type options struct {
	Leveler
	PayloadLeveler
}

type Option func(o *options)

func WithLeveler(l Leveler) Option {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[2], 1);
	return func(o *options) {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[3], 1); o.Leveler = l }
}

func WithPayloadLeveler(l PayloadLeveler) Option {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[4], 1);
	return func(o *options) {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[5], 1); o.PayloadLeveler = l }
}

func applyOptions(opts ...Option) *options {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[6], 1);
	o := &options{
		Leveler:        LevelerFunc(func(context.Context, string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[9], 1); return zapcore.InfoLevel }),
		PayloadLeveler: LevelerFunc(func(context.Context, string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[10], 1); return DefaultPayloadLevel }),
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[7], 1);for _, opt := range opts {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[11], 1);
		opt(o)
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[8], 1);return o
}

// Levelers will be required and should be provided with the full method info

func UnaryServerInterceptor(logger *zap.Logger, opts ...Option) grpc.UnaryServerInterceptor {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[12], 1);
	o := applyOptions(opts...)

	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[13], 1);
		logger := logger
		startTime := time.Now()

		fields := getFields(ctx, startTime, info.FullMethod)
		logger = logger.With(fields...)
		ctx = WithFields(ctx, fields)

		payloadLogger := logger.Named("payload")
		payloadLevel := o.PayloadLevel(ctx, info.FullMethod)
		if ce := payloadLogger.Check(payloadLevel, "received unary request"); ce != nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[17], 1);
			ce.Write(ProtoMessage("message", req))
		}

		_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[14], 1);resp, err := handler(ctx, req)

		if ce := payloadLogger.Check(payloadLevel, "sending unary response"); ce != nil && err == nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[18], 1);
			ce.Write(ProtoMessage("message", resp))
		}

		_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[15], 1);if ce := logger.Check(o.Level(ctx, info.FullMethod), "unary call completed"); ce != nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[19], 1);
			ce.Write(
				Error(err),
				zap.Stringer("grpc.code", grpc.Code(err)),
				zap.Duration("grpc.call_duration", time.Since(startTime)),
			)
		}

		_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[16], 1);return resp, err
	}
}

func StreamServerInterceptor(logger *zap.Logger, opts ...Option) grpc.StreamServerInterceptor {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[20], 1);
	o := applyOptions(opts...)

	return func(service interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[21], 1);
		logger := logger
		ctx := stream.Context()
		startTime := time.Now()

		fields := getFields(ctx, startTime, info.FullMethod)
		logger = logger.With(fields...)
		ctx = WithFields(ctx, fields)

		wrappedStream := &serverStream{
			ServerStream:  stream,
			context:       ctx,
			payloadLogger: logger.Named("payload"),
			payloadLevel:  o.PayloadLevel(ctx, info.FullMethod),
		}

		err := handler(service, wrappedStream)
		if ce := logger.Check(o.Level(ctx, info.FullMethod), "streaming call completed"); ce != nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[23], 1);
			ce.Write(
				Error(err),
				zap.Stringer("grpc.code", grpc.Code(err)),
				zap.Duration("grpc.call_duration", time.Since(startTime)),
			)
		}
		_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[22], 1);return err
	}
}

func getFields(ctx context.Context, startTime time.Time, method string) []zapcore.Field {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[24], 1);
	fields := []zap.Field{zap.Time("grpc.start_time", startTime)}
	if parts := strings.Split(method, "/"); len(parts) == 3 {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[28], 1);
		fields = append(fields, zap.String("grpc.service", parts[1]), zap.String("grpc.method", parts[2]))
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[25], 1);if deadline, ok := ctx.Deadline(); ok {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[29], 1);
		fields = append(fields, zap.Time("grpc.request_deadline", deadline))
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[26], 1);if p, ok := peer.FromContext(ctx); ok {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[30], 1);
		fields = append(fields, zap.String("grpc.peer_address", p.Addr.String()))
		if ti, ok := p.AuthInfo.(credentials.TLSInfo); ok {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[31], 1);
			if len(ti.State.PeerCertificates) > 0 {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[32], 1);
				cert := ti.State.PeerCertificates[0]
				fields = append(fields, zap.String("grpc.peer_subject", cert.Subject.String()))
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[27], 1);return fields
}

type serverStream struct {
	grpc.ServerStream
	context       context.Context
	payloadLogger *zap.Logger
	payloadLevel  zapcore.Level
}

func (ss *serverStream) Context() context.Context {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[33], 1);
	return ss.context
}

func (ss *serverStream) SendMsg(msg interface{}) error {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[34], 1);
	if ce := ss.payloadLogger.Check(ss.payloadLevel, "sending stream message"); ce != nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[36], 1);
		ce.Write(ProtoMessage("message", msg))
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[35], 1);return ss.ServerStream.SendMsg(msg)
}

func (ss *serverStream) RecvMsg(msg interface{}) error {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[37], 1);
	err := ss.ServerStream.RecvMsg(msg)
	if ce := ss.payloadLogger.Check(ss.payloadLevel, "received stream message"); ce != nil {_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[39], 1);
		ce.Write(ProtoMessage("message", msg))
	}
	_cover_atomic_.AddUint32(&GoCover_2_643665343532316435366565.Count[38], 1);return err
}

var GoCover_2_643665343532316435366565 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		35, 37, 0x20052, // [0]
		39, 41, 0x20059, // [1]
		53, 54, 0x1a0024, // [2]
		54, 54, 0x2b001a, // [3]
		57, 58, 0x1a0032, // [4]
		58, 58, 0x32001a, // [5]
		61, 63, 0x4b002c, // [6]
		66, 66, 0x1b0002, // [7]
		69, 69, 0xa0002, // [8]
		63, 63, 0x67004b, // [9]
		64, 64, 0x69004b, // [10]
		66, 68, 0x3001b, // [11]
		74, 77, 0x80005d, // [12]
		77, 87, 0x530080, // [13]
		91, 93, 0x610003, // [14]
		97, 97, 0x5b0003, // [15]
		105, 105, 0x130003, // [16]
		87, 89, 0x40053, // [17]
		93, 95, 0x40061, // [18]
		97, 103, 0x4005b, // [19]
		109, 112, 0x7c005f, // [20]
		112, 129, 0x5f007c, // [21]
		136, 136, 0xd0003, // [22]
		129, 135, 0x4005f, // [23]
		140, 142, 0x3a0059, // [24]
		145, 145, 0x280002, // [25]
		148, 148, 0x280002, // [26]
		157, 157, 0xf0002, // [27]
		142, 144, 0x3003a, // [28]
		145, 147, 0x30028, // [29]
		148, 150, 0x350028, // [30]
		150, 151, 0x2a0035, // [31]
		151, 154, 0x5002a, // [32]
		167, 169, 0x20033, // [33]
		171, 172, 0x580038, // [34]
		175, 175, 0x250002, // [35]
		172, 174, 0x30058, // [36]
		178, 180, 0x590038, // [37]
		183, 183, 0xc0002, // [38]
		180, 182, 0x30059, // [39]
	},
	NumStmt: [40]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		2, // 12
		8, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		2, // 20
		9, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		2, // 37
		1, // 38
		1, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
