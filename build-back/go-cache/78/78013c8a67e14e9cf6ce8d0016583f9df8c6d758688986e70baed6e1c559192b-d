//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate/db.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package privacyenabledstate; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
)

// DBProvider provides handle to a PvtVersionedDB
type DBProvider interface {
	// GetDBHandle returns a handle to a PvtVersionedDB
	GetDBHandle(id string) (DB, error)
	// Close closes all the PvtVersionedDB instances and releases any resources held by VersionedDBProvider
	Close()
}

// DB extends VersionedDB interface. This interface provides additional functions for managing private data state
type DB interface {
	statedb.VersionedDB
	IsBulkOptimizable() bool
	LoadCommittedVersionsOfPubAndHashedKeys(pubKeys []*statedb.CompositeKey, hashedKeys []*HashedCompositeKey) error
	GetCachedKeyHashVersion(namespace, collection string, keyHash []byte) (*version.Height, bool)
	ClearCachedVersions()
	GetChaincodeEventListener() cceventmgmt.ChaincodeLifecycleEventListener
	GetPrivateData(namespace, collection, key string) (*statedb.VersionedValue, error)
	GetValueHash(namespace, collection string, keyHash []byte) (*statedb.VersionedValue, error)
	GetKeyHashVersion(namespace, collection string, keyHash []byte) (*version.Height, error)
	GetPrivateDataMultipleKeys(namespace, collection string, keys []string) ([]*statedb.VersionedValue, error)
	GetPrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (statedb.ResultsIterator, error)
	GetStateMetadata(namespace, key string) ([]byte, error)
	GetPrivateDataMetadataByHash(namespace, collection string, keyHash []byte) ([]byte, error)
	ExecuteQueryOnPrivateData(namespace, collection, query string) (statedb.ResultsIterator, error)
	ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) error
}

// PvtdataCompositeKey encloses Namespace, CollectionName and Key components
type PvtdataCompositeKey struct {
	Namespace      string
	CollectionName string
	Key            string
}

// HashedCompositeKey encloses Namespace, CollectionName and KeyHash components
type HashedCompositeKey struct {
	Namespace      string
	CollectionName string
	KeyHash        string
}

// PvtKVWrite encloses Key, IsDelete, Value, and Version components
type PvtKVWrite struct {
	Key      string
	IsDelete bool
	Value    []byte
	Version  *version.Height
}

// UpdateBatch encapsulates the updates to Public, Private, and Hashed data.
// This is expected to contain a consistent set of updates
type UpdateBatch struct {
	PubUpdates  *PubUpdateBatch
	HashUpdates *HashedUpdateBatch
	PvtUpdates  *PvtUpdateBatch
}

// PubUpdateBatch contains update for the public data
type PubUpdateBatch struct {
	*statedb.UpdateBatch
}

// HashedUpdateBatch contains updates for the hashes of the private data
type HashedUpdateBatch struct {
	UpdateMap
}

// PvtUpdateBatch contains updates for the private data
type PvtUpdateBatch struct {
	UpdateMap
}

// UpdateMap maintains entries of tuple <Namespace, UpdatesForNamespace>
type UpdateMap map[string]nsBatch

// nsBatch contains updates related to one namespace
type nsBatch struct {
	*statedb.UpdateBatch
}

// NewUpdateBatch creates and empty UpdateBatch
func NewUpdateBatch() *UpdateBatch {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[0], 1);
	return &UpdateBatch{NewPubUpdateBatch(), NewHashedUpdateBatch(), NewPvtUpdateBatch()}
}

// NewPubUpdateBatch creates an empty PubUpdateBatch
func NewPubUpdateBatch() *PubUpdateBatch {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[1], 1);
	return &PubUpdateBatch{statedb.NewUpdateBatch()}
}

// NewHashedUpdateBatch creates an empty HashedUpdateBatch
func NewHashedUpdateBatch() *HashedUpdateBatch {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[2], 1);
	return &HashedUpdateBatch{make(map[string]nsBatch)}
}

// NewPvtUpdateBatch creates an empty PvtUpdateBatch
func NewPvtUpdateBatch() *PvtUpdateBatch {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[3], 1);
	return &PvtUpdateBatch{make(map[string]nsBatch)}
}

// IsEmpty returns true if there exists any updates
func (b UpdateMap) IsEmpty() bool {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[4], 1);
	return len(b) == 0
}

// Put sets the value in the batch for a given combination of namespace and collection name
func (b UpdateMap) Put(ns, coll, key string, value []byte, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[5], 1);
	b.PutValAndMetadata(ns, coll, key, value, nil, version)
}

// PutValAndMetadata adds a key with value and metadata
func (b UpdateMap) PutValAndMetadata(ns, coll, key string, value []byte, metadata []byte, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[6], 1);
	b.getOrCreateNsBatch(ns).PutValAndMetadata(coll, key, value, metadata, version)
}

// Delete adds a delete marker in the batch for a given combination of namespace and collection name
func (b UpdateMap) Delete(ns, coll, key string, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[7], 1);
	b.getOrCreateNsBatch(ns).Delete(coll, key, version)
}

// Get retrieves the value from the batch for a given combination of namespace and collection name
func (b UpdateMap) Get(ns, coll, key string) *statedb.VersionedValue {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[8], 1);
	nsPvtBatch, ok := b[ns]
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[10], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[9], 1);return nsPvtBatch.Get(coll, key)
}

// Contains returns true if the given <ns,coll,key> tuple is present in the batch
func (b UpdateMap) Contains(ns, coll, key string) bool {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[11], 1);
	nsBatch, ok := b[ns]
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[13], 1);
		return false
	}
	_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[12], 1);return nsBatch.Exists(coll, key)
}

func (nsb nsBatch) GetCollectionNames() []string {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[14], 1);
	return nsb.GetUpdatedNamespaces()
}

func (b UpdateMap) getOrCreateNsBatch(ns string) nsBatch {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[15], 1);
	batch, ok := b[ns]
	if !ok {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[17], 1);
		batch = nsBatch{statedb.NewUpdateBatch()}
		b[ns] = batch
	}
	_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[16], 1);return batch
}

// Contains returns true if the given <ns,coll,keyHash> tuple is present in the batch
func (h HashedUpdateBatch) Contains(ns, coll string, keyHash []byte) bool {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[18], 1);
	return h.UpdateMap.Contains(ns, coll, string(keyHash))
}

// Put overrides the function in UpdateMap for allowing the key to be a []byte instead of a string
func (h HashedUpdateBatch) Put(ns, coll string, key []byte, value []byte, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[19], 1);
	h.PutValHashAndMetadata(ns, coll, key, value, nil, version)
}

// PutValHashAndMetadata adds a key with value and metadata
// TODO introducing a new function to limit the refactoring. Later in a separate CR, the 'Put' function above should be removed
func (h HashedUpdateBatch) PutValHashAndMetadata(ns, coll string, key []byte, value []byte, metadata []byte, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[20], 1);
	h.UpdateMap.PutValAndMetadata(ns, coll, string(key), value, metadata, version)
}

// Delete overrides the function in UpdateMap for allowing the key to be a []byte instead of a string
func (h HashedUpdateBatch) Delete(ns, coll string, key []byte, version *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[21], 1);
	h.UpdateMap.Delete(ns, coll, string(key), version)
}

// ToCompositeKeyMap rearranges the update batch data in the form of a single map
func (h HashedUpdateBatch) ToCompositeKeyMap() map[HashedCompositeKey]*statedb.VersionedValue {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[22], 1);
	m := make(map[HashedCompositeKey]*statedb.VersionedValue)
	for ns, nsBatch := range h.UpdateMap {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[24], 1);
		for _, coll := range nsBatch.GetCollectionNames() {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[25], 1);
			for key, vv := range nsBatch.GetUpdates(coll) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[26], 1);
				m[HashedCompositeKey{ns, coll, key}] = vv
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[23], 1);return m
}

// PvtdataCompositeKeyMap is a map of PvtdataCompositeKey to VersionedValue
type PvtdataCompositeKeyMap map[PvtdataCompositeKey]*statedb.VersionedValue

// ToCompositeKeyMap rearranges the update batch data in the form of a single map
func (p PvtUpdateBatch) ToCompositeKeyMap() PvtdataCompositeKeyMap {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[27], 1);
	m := make(PvtdataCompositeKeyMap)
	for ns, nsBatch := range p.UpdateMap {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[29], 1);
		for _, coll := range nsBatch.GetCollectionNames() {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[30], 1);
			for key, vv := range nsBatch.GetUpdates(coll) {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[31], 1);
				m[PvtdataCompositeKey{ns, coll, key}] = vv
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[28], 1);return m
}

// String returns a print friendly form of HashedCompositeKey
func (hck *HashedCompositeKey) String() string {_cover_atomic_.AddUint32(&GoCover_1_626362383230316436633863.Count[32], 1);
	return fmt.Sprintf("ns=%s, collection=%s, keyHash=%x", hck.Namespace, hck.CollectionName, hck.KeyHash)
}

var GoCover_1_626362383230316436633863 = struct {
	Count     [33]uint32
	Pos       [3 * 33]uint32
	NumStmt   [33]uint16
} {
	Pos: [3 * 33]uint32{
		98, 100, 0x20024, // [0]
		103, 105, 0x2002a, // [1]
		108, 110, 0x20030, // [2]
		113, 115, 0x2002a, // [3]
		118, 120, 0x20023, // [4]
		123, 125, 0x20055, // [5]
		128, 130, 0x20074, // [6]
		133, 135, 0x2004a, // [7]
		138, 140, 0x90046, // [8]
		143, 143, 0x220002, // [9]
		140, 142, 0x30009, // [10]
		147, 149, 0x90038, // [11]
		152, 152, 0x220002, // [12]
		149, 151, 0x30009, // [13]
		155, 157, 0x20032, // [14]
		159, 161, 0x9003a, // [15]
		165, 165, 0xe0002, // [16]
		161, 164, 0x30009, // [17]
		169, 171, 0x2004b, // [18]
		174, 176, 0x20064, // [19]
		180, 182, 0x20087, // [20]
		185, 187, 0x20059, // [21]
		190, 192, 0x27005f, // [22]
		199, 199, 0xa0002, // [23]
		192, 193, 0x350027, // [24]
		193, 194, 0x320035, // [25]
		194, 196, 0x50032, // [26]
		206, 208, 0x270044, // [27]
		215, 215, 0xa0002, // [28]
		208, 209, 0x350027, // [29]
		209, 210, 0x320035, // [30]
		210, 212, 0x50032, // [31]
		219, 221, 0x20030, // [32]
	},
	NumStmt: [33]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		2, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
	},
}
var _ = _cover_atomic_.LoadUint32
