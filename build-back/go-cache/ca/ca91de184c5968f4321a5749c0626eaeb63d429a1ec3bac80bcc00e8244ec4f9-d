//line /home/cooper/go/src/github.com/hyperledger/fabric/core/scc/lscc/lscc.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package lscc; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"regexp"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/cauthdsl"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/aclmgmt"
	"github.com/hyperledger/fabric/core/aclmgmt/resources"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/chaincode/platforms/ccmetadata"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
	"github.com/hyperledger/fabric/core/peer"
	"github.com/hyperledger/fabric/core/policy"
	"github.com/hyperledger/fabric/core/policyprovider"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/msp/mgmt"
	"github.com/hyperledger/fabric/protos/common"
	mb "github.com/hyperledger/fabric/protos/msp"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

//The life cycle system chaincode manages chaincodes deployed
//on this peer. It manages chaincodes via Invoke proposals.
//     "Args":["deploy",<ChaincodeDeploymentSpec>]
//     "Args":["upgrade",<ChaincodeDeploymentSpec>]
//     "Args":["stop",<ChaincodeInvocationSpec>]
//     "Args":["start",<ChaincodeInvocationSpec>]

var logger = flogging.MustGetLogger("lscc")

const (
	// chaincode lifecycle commands

	// INSTALL install command
	INSTALL = "install"

	// DEPLOY deploy command
	DEPLOY = "deploy"

	// UPGRADE upgrade chaincode
	UPGRADE = "upgrade"

	// CCEXISTS get chaincode
	CCEXISTS = "getid"

	// CHAINCODEEXISTS get chaincode alias
	CHAINCODEEXISTS = "ChaincodeExists"

	// GETDEPSPEC get ChaincodeDeploymentSpec
	GETDEPSPEC = "getdepspec"

	// GETDEPLOYMENTSPEC get ChaincodeDeploymentSpec alias
	GETDEPLOYMENTSPEC = "GetDeploymentSpec"

	// GETCCDATA get ChaincodeData
	GETCCDATA = "getccdata"

	// GETCHAINCODEDATA get ChaincodeData alias
	GETCHAINCODEDATA = "GetChaincodeData"

	// GETCHAINCODES gets the instantiated chaincodes on a channel
	GETCHAINCODES = "getchaincodes"

	// GETCHAINCODESALIAS gets the instantiated chaincodes on a channel
	GETCHAINCODESALIAS = "GetChaincodes"

	// GETINSTALLEDCHAINCODES gets the installed chaincodes on a peer
	GETINSTALLEDCHAINCODES = "getinstalledchaincodes"

	// GETINSTALLEDCHAINCODESALIAS gets the installed chaincodes on a peer
	GETINSTALLEDCHAINCODESALIAS = "GetInstalledChaincodes"

	// GETCOLLECTIONSCONFIG gets the collections config for a chaincode
	GETCOLLECTIONSCONFIG = "GetCollectionsConfig"

	// GETCOLLECTIONSCONFIGALIAS gets the collections config for a chaincode
	GETCOLLECTIONSCONFIGALIAS = "getcollectionsconfig"

	allowedChaincodeName = "^[a-zA-Z0-9]+([-_][a-zA-Z0-9]+)*$"
	allowedCharsVersion  = "[A-Za-z0-9_.+-]+"
)

// FilesystemSupport contains functions that LSCC requires to execute its tasks
type FilesystemSupport interface {
	// PutChaincodeToLocalStorage stores the supplied chaincode
	// package to local storage (i.e. the file system)
	PutChaincodeToLocalStorage(ccprovider.CCPackage) error

	// GetChaincodeFromLocalStorage retrieves the chaincode package
	// for the requested chaincode, specified by name and version
	GetChaincodeFromLocalStorage(ccname string, ccversion string) (ccprovider.CCPackage, error)

	// GetChaincodesFromLocalStorage returns an array of all chaincode
	// data that have previously been persisted to local storage
	GetChaincodesFromLocalStorage() (*pb.ChaincodeQueryResponse, error)

	// GetInstantiationPolicy returns the instantiation policy for the
	// supplied chaincode (or the channel's default if none was specified)
	GetInstantiationPolicy(channel string, ccpack ccprovider.CCPackage) ([]byte, error)

	// CheckInstantiationPolicy checks whether the supplied signed proposal
	// complies with the supplied instantiation policy
	CheckInstantiationPolicy(signedProposal *pb.SignedProposal, chainName string, instantiationPolicy []byte) error
}

//---------- the LSCC -----------------

// LifeCycleSysCC implements chaincode lifecycle and policies around it
type LifeCycleSysCC struct {
	// aclProvider is responsible for access control evaluation
	ACLProvider aclmgmt.ACLProvider

	// SCCProvider is the interface which is passed into system chaincodes
	// to access other parts of the system
	SCCProvider sysccprovider.SystemChaincodeProvider

	// PolicyChecker is the interface used to perform
	// access control
	PolicyChecker policy.PolicyChecker

	// Support provides the implementation of several
	// static functions
	Support FilesystemSupport

	PlatformRegistry *platforms.Registry
}

// New creates a new instance of the LSCC
// Typically there is only one of these per peer
func New(sccp sysccprovider.SystemChaincodeProvider, ACLProvider aclmgmt.ACLProvider, platformRegistry *platforms.Registry) *LifeCycleSysCC {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[0], 1);
	return &LifeCycleSysCC{
		Support:          &supportImpl{},
		PolicyChecker:    policyprovider.GetPolicyChecker(),
		SCCProvider:      sccp,
		ACLProvider:      ACLProvider,
		PlatformRegistry: platformRegistry,
	}
}

func (lscc *LifeCycleSysCC) Name() string              {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[1], 1); return "lscc" }
func (lscc *LifeCycleSysCC) Path() string              {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[2], 1); return "github.com/hyperledger/fabric/core/scc/lscc" }
func (lscc *LifeCycleSysCC) InitArgs() [][]byte        {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[3], 1); return nil }
func (lscc *LifeCycleSysCC) Chaincode() shim.Chaincode {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[4], 1); return lscc }
func (lscc *LifeCycleSysCC) InvokableExternal() bool   {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[5], 1); return true }
func (lscc *LifeCycleSysCC) InvokableCC2CC() bool      {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[6], 1); return true }
func (lscc *LifeCycleSysCC) Enabled() bool             {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[7], 1); return true }

func (lscc *LifeCycleSysCC) ChaincodeContainerInfo(chaincodeName string, qe ledger.QueryExecutor) (*ccprovider.ChaincodeContainerInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[8], 1);
	chaincodeDataBytes, err := qe.GetState("lscc", chaincodeName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[12], 1);
		return nil, errors.Wrapf(err, "could not retrieve state for chaincode %s", chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[9], 1);if chaincodeDataBytes == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[13], 1);
		return nil, errors.Errorf("chaincode %s not found", chaincodeName)
	}

	// Note, although it looks very tempting to replace the bulk of this function with
	// the below 'ChaincodeDefinition' call, the 'getCCCode' call provides us security
	// by side-effect, so we must leave it as is for now.
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[10], 1);cds, _, err := lscc.getCCCode(chaincodeName, chaincodeDataBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[14], 1);
		return nil, errors.Wrapf(err, "could not get chaincode code")
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[11], 1);return ccprovider.DeploymentSpecToChaincodeContainerInfo(cds), nil
}

func (lscc *LifeCycleSysCC) ChaincodeDefinition(chaincodeName string, qe ledger.QueryExecutor) (ccprovider.ChaincodeDefinition, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[15], 1);
	chaincodeDataBytes, err := qe.GetState("lscc", chaincodeName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[19], 1);
		return nil, errors.Wrapf(err, "could not retrieve state for chaincode %s", chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[16], 1);if chaincodeDataBytes == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[20], 1);
		return nil, errors.Errorf("chaincode %s not found", chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[17], 1);chaincodeData := &ccprovider.ChaincodeData{}
	err = proto.Unmarshal(chaincodeDataBytes, chaincodeData)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[21], 1);
		return nil, errors.Wrapf(err, "chaincode %s has bad definition", chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[18], 1);return chaincodeData, nil
}

//create the chaincode on the given chain
func (lscc *LifeCycleSysCC) putChaincodeData(stub shim.ChaincodeStubInterface, cd *ccprovider.ChaincodeData) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[22], 1);
	cdbytes, err := proto.Marshal(cd)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[25], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[23], 1);if cdbytes == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[26], 1);
		return MarshallErr(cd.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[24], 1);err = stub.PutState(cd.Name, cdbytes)

	return err
}

// checkCollectionMemberPolicy checks whether the supplied collection configuration
// complies to the given msp configuration
func checkCollectionMemberPolicy(collectionConfig *common.CollectionConfig, mspmgr msp.MSPManager) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[27], 1);
	if mspmgr == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[35], 1);
		return fmt.Errorf("msp manager not set")
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[28], 1);msps, err := mspmgr.GetMSPs()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[36], 1);
		return errors.Wrapf(err, "error getting channel msp")
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[29], 1);if collectionConfig == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[37], 1);
		return fmt.Errorf("collection configuration is not set")
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[30], 1);coll := collectionConfig.GetStaticCollectionConfig()
	if coll == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[38], 1);
		return fmt.Errorf("collection configuration is empty")
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[31], 1);if coll.MemberOrgsPolicy == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[39], 1);
		return fmt.Errorf("collection member policy is not set")
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[32], 1);if coll.MemberOrgsPolicy.GetSignaturePolicy() == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[40], 1);
		return fmt.Errorf("collection member org policy is empty")
	}
	// make sure that the orgs listed are actually part of the channel
	// check all principals in the signature policy
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[33], 1);for _, principal := range coll.MemberOrgsPolicy.GetSignaturePolicy().Identities {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[41], 1);
		found := false
		var orgID string
		// the member org policy only supports certain principal types
		switch principal.PrincipalClassification {

		case mb.MSPPrincipal_ROLE:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[43], 1);
			msprole := &mb.MSPRole{}
			err := proto.Unmarshal(principal.Principal, msprole)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[49], 1);
				return errors.Wrapf(err, "collection-name: %s -- cannot unmarshal identities", coll.GetName())
			}
			_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[44], 1);orgID = msprole.MspIdentifier
			// the msp map is indexed using msp IDs - this behavior is implementation specific, making the following check a bit of a hack
			for mspid := range msps {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[50], 1);
				if mspid == orgID {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[51], 1);
					found = true
					break
				}
			}

		case mb.MSPPrincipal_ORGANIZATION_UNIT:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[45], 1);
			mspou := &mb.OrganizationUnit{}
			err := proto.Unmarshal(principal.Principal, mspou)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[52], 1);
				return errors.Wrapf(err, "collection-name: %s -- cannot unmarshal identities", coll.GetName())
			}
			_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[46], 1);orgID = mspou.MspIdentifier
			// the msp map is indexed using msp IDs - this behavior is implementation specific, making the following check a bit of a hack
			for mspid := range msps {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[53], 1);
				if mspid == orgID {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[54], 1);
					found = true
					break
				}
			}

		case mb.MSPPrincipal_IDENTITY:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[47], 1);
			orgID = "identity principal"
			for _, msp := range msps {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[55], 1);
				_, err := msp.DeserializeIdentity(principal.Principal)
				if err == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[56], 1);
					found = true
					break
				}
			}
		default:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[48], 1);
			return fmt.Errorf("collection-name: %s -- principal type %v is not supported", coll.GetName(), principal.PrincipalClassification)
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[42], 1);if !found {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[57], 1);
			logger.Warningf("collection-name: %s collection member %s is not part of the channel", coll.GetName(), orgID)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[34], 1);return nil
}

// putChaincodeCollectionData adds collection data for the chaincode
func (lscc *LifeCycleSysCC) putChaincodeCollectionData(stub shim.ChaincodeStubInterface, cd *ccprovider.ChaincodeData, collectionConfigBytes []byte) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[58], 1);
	if cd == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[65], 1);
		return errors.New("nil ChaincodeData")
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[59], 1);if len(collectionConfigBytes) == 0 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[66], 1);
		logger.Debug("No collection configuration specified")
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[60], 1);collections := &common.CollectionConfigPackage{}
	err := proto.Unmarshal(collectionConfigBytes, collections)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[67], 1);
		return errors.Errorf("invalid collection configuration supplied for chaincode %s:%s", cd.Name, cd.Version)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[61], 1);mspmgr := mgmt.GetManagerForChain(stub.GetChannelID())
	if mspmgr == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[68], 1);
		return fmt.Errorf("could not get MSP manager for channel %s", stub.GetChannelID())
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[62], 1);for _, collectionConfig := range collections.Config {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[69], 1);
		err = checkCollectionMemberPolicy(collectionConfig, mspmgr)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[70], 1);
			return errors.Wrapf(err, "collection member policy check failed")
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[63], 1);key := privdata.BuildCollectionKVSKey(cd.Name)

	err = stub.PutState(key, collectionConfigBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[71], 1);
		return errors.WithMessage(err, fmt.Sprintf("error putting collection for chaincode %s:%s", cd.Name, cd.Version))
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[64], 1);return nil
}

// getChaincodeCollectionData retrieve collections config.
func (lscc *LifeCycleSysCC) getChaincodeCollectionData(stub shim.ChaincodeStubInterface, chaincodeName string) pb.Response {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[72], 1);
	key := privdata.BuildCollectionKVSKey(chaincodeName)
	collectionsConfigBytes, err := stub.GetState(key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[75], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[73], 1);if len(collectionsConfigBytes) == 0 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[76], 1);
		return shim.Error(fmt.Sprintf("collections config not defined for chaincode %s", chaincodeName))
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[74], 1);return shim.Success(collectionsConfigBytes)
}

//checks for existence of chaincode on the given channel
func (lscc *LifeCycleSysCC) getCCInstance(stub shim.ChaincodeStubInterface, ccname string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[77], 1);
	cdbytes, err := stub.GetState(ccname)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[80], 1);
		return nil, TXNotFoundErr(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[78], 1);if cdbytes == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[81], 1);
		return nil, NotFoundErr(ccname)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[79], 1);return cdbytes, nil
}

//gets the cd out of the bytes
func (lscc *LifeCycleSysCC) getChaincodeData(ccname string, cdbytes []byte) (*ccprovider.ChaincodeData, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[82], 1);
	cd := &ccprovider.ChaincodeData{}
	err := proto.Unmarshal(cdbytes, cd)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[85], 1);
		return nil, MarshallErr(ccname)
	}

	//this should not happen but still a sanity check is not a bad thing
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[83], 1);if cd.Name != ccname {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[86], 1);
		return nil, ChaincodeMismatchErr(fmt.Sprintf("%s!=%s", ccname, cd.Name))
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[84], 1);return cd, nil
}

//checks for existence of chaincode on the given chain
func (lscc *LifeCycleSysCC) getCCCode(ccname string, cdbytes []byte) (*pb.ChaincodeDeploymentSpec, []byte, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[87], 1);
	cd, err := lscc.getChaincodeData(ccname, cdbytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[91], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[88], 1);ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(ccname, cd.Version)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[92], 1);
		return nil, nil, InvalidDeploymentSpecErr(err.Error())
	}

	//this is the big test and the reason every launch should go through
	//getChaincode call. We validate the chaincode entry against the
	//the chaincode in FS
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[89], 1);if err = ccpack.ValidateCC(cd); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[93], 1);
		return nil, nil, InvalidCCOnFSError(err.Error())
	}

	//these are guaranteed to be non-nil because we got a valid ccpack
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[90], 1);depspec := ccpack.GetDepSpec()
	depspecbytes := ccpack.GetDepSpecBytes()

	return depspec, depspecbytes, nil
}

// getChaincodes returns all chaincodes instantiated on this LSCC's channel
func (lscc *LifeCycleSysCC) getChaincodes(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[94], 1);
	// get all rows from LSCC
	itr, err := stub.GetStateByRange("", "")

	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[98], 1);
		return shim.Error(err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[95], 1);defer itr.Close()

	// array to store metadata for all chaincode entries from LSCC
	var ccInfoArray []*pb.ChaincodeInfo

	for itr.HasNext() {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[99], 1);
		response, err := itr.Next()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[104], 1);
			return shim.Error(err.Error())
		}

		// CollectionConfig isn't ChaincodeData
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[100], 1);if privdata.IsCollectionConfigKey(response.Key) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[105], 1);
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[101], 1);ccdata := &ccprovider.ChaincodeData{}
		if err = proto.Unmarshal(response.Value, ccdata); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[106], 1);
			return shim.Error(err.Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[102], 1);var path string
		var input string

		// if chaincode is not installed on the system we won't have
		// data beyond name and version
		ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(ccdata.Name, ccdata.Version)
		if err == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[107], 1);
			path = ccpack.GetDepSpec().GetChaincodeSpec().ChaincodeId.Path
			input = ccpack.GetDepSpec().GetChaincodeSpec().Input.String()
		}

		// add this specific chaincode's metadata to the array of all chaincodes
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[103], 1);ccInfo := &pb.ChaincodeInfo{Name: ccdata.Name, Version: ccdata.Version, Path: path, Input: input, Escc: ccdata.Escc, Vscc: ccdata.Vscc}
		ccInfoArray = append(ccInfoArray, ccInfo)
	}
	// add array with info about all instantiated chaincodes to the query
	// response proto
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[96], 1);cqr := &pb.ChaincodeQueryResponse{Chaincodes: ccInfoArray}

	cqrbytes, err := proto.Marshal(cqr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[108], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[97], 1);return shim.Success(cqrbytes)
}

// getInstalledChaincodes returns all chaincodes installed on the peer
func (lscc *LifeCycleSysCC) getInstalledChaincodes() pb.Response {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[109], 1);
	// get chaincode query response proto which contains information about all
	// installed chaincodes
	cqr, err := lscc.Support.GetChaincodesFromLocalStorage()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[112], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[110], 1);cqrbytes, err := proto.Marshal(cqr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[113], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[111], 1);return shim.Success(cqrbytes)
}

// check validity of channel name
func (lscc *LifeCycleSysCC) isValidChannelName(channel string) bool {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[114], 1);
	// TODO we probably need more checks
	if channel == "" {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[116], 1);
		return false
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[115], 1);return true
}

// isValidChaincodeName checks the validity of chaincode name. Chaincode names
// should never be blank and should only consist of alphanumerics, '_', and '-'
func (lscc *LifeCycleSysCC) isValidChaincodeName(chaincodeName string) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[117], 1);
	if chaincodeName == "" {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[120], 1);
		return EmptyChaincodeNameErr("")
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[118], 1);if !isValidCCNameOrVersion(chaincodeName, allowedChaincodeName) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[121], 1);
		return InvalidChaincodeNameErr(chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[119], 1);return nil
}

// isValidChaincodeVersion checks the validity of chaincode version. Versions
// should never be blank and should only consist of alphanumerics, '_',  '-',
// '+', and '.'
func (lscc *LifeCycleSysCC) isValidChaincodeVersion(chaincodeName string, version string) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[122], 1);
	if version == "" {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[125], 1);
		return EmptyVersionErr(chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[123], 1);if !isValidCCNameOrVersion(version, allowedCharsVersion) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[126], 1);
		return InvalidVersionErr(version)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[124], 1);return nil
}

func isValidCCNameOrVersion(ccNameOrVersion string, regExp string) bool {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[127], 1);
	re, _ := regexp.Compile(regExp)

	matched := re.FindString(ccNameOrVersion)
	if len(matched) != len(ccNameOrVersion) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[129], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[128], 1);return true
}

func isValidStatedbArtifactsTar(statedbArtifactsTar []byte) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[130], 1);
	// Extract the metadata files from the archive
	// Passing an empty string for the databaseType will validate all artifacts in
	// the archive
	archiveFiles, err := ccprovider.ExtractFileEntries(statedbArtifactsTar, "")
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[133], 1);
		return err
	}
	// iterate through the files and validate
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[131], 1);for _, archiveDirectoryFiles := range archiveFiles {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[134], 1);
		for _, fileEntry := range archiveDirectoryFiles {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[135], 1);
			indexData := fileEntry.FileContent
			// Validation is based on the passed file name, e.g. META-INF/statedb/couchdb/indexes/indexname.json
			err = ccmetadata.ValidateMetadataFile(fileEntry.FileHeader.Name, indexData)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[136], 1);
				return err
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[132], 1);return nil
}

// executeInstall implements the "install" Invoke transaction
func (lscc *LifeCycleSysCC) executeInstall(stub shim.ChaincodeStubInterface, ccbytes []byte) error {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[137], 1);
	ccpack, err := ccprovider.GetCCPackage(ccbytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[148], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[138], 1);cds := ccpack.GetDepSpec()

	if cds == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[149], 1);
		return fmt.Errorf("nil deployment spec from from the CC package")
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[139], 1);if err = lscc.isValidChaincodeName(cds.ChaincodeSpec.ChaincodeId.Name); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[150], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[140], 1);if err = lscc.isValidChaincodeVersion(cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[151], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[141], 1);if lscc.SCCProvider.IsSysCC(cds.ChaincodeSpec.ChaincodeId.Name) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[152], 1);
		return errors.Errorf("cannot install: %s is the name of a system chaincode", cds.ChaincodeSpec.ChaincodeId.Name)
	}

	// Get any statedb artifacts from the chaincode package, e.g. couchdb index definitions
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[142], 1);statedbArtifactsTar, err := ccprovider.ExtractStatedbArtifactsFromCCPackage(ccpack, lscc.PlatformRegistry)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[153], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[143], 1);if err = isValidStatedbArtifactsTar(statedbArtifactsTar); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[154], 1);
		return InvalidStatedbArtifactsErr(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[144], 1);chaincodeDefinition := &cceventmgmt.ChaincodeDefinition{
		Name:    ccpack.GetChaincodeData().Name,
		Version: ccpack.GetChaincodeData().Version,
		Hash:    ccpack.GetId()} // Note - The chaincode 'id' is the hash of chaincode's (CodeHash || MetaDataHash), aka fingerprint

	// HandleChaincodeInstall will apply any statedb artifacts (e.g. couchdb indexes) to
	// any channel's statedb where the chaincode is already instantiated
	// Note - this step is done prior to PutChaincodeToLocalStorage() since this step is idempotent and harmless until endorsements start,
	// that is, if there are errors deploying the indexes the chaincode install can safely be re-attempted later.
	err = cceventmgmt.GetMgr().HandleChaincodeInstall(chaincodeDefinition, statedbArtifactsTar)
	defer func() {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[155], 1);
		cceventmgmt.GetMgr().ChaincodeInstallDone(err == nil)
	}()
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[145], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[156], 1);
		return err
	}

	// Finally, if everything is good above, install the chaincode to local peer file system so that endorsements can start
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[146], 1);if err = lscc.Support.PutChaincodeToLocalStorage(ccpack); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[157], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[147], 1);logger.Infof("Installed Chaincode [%s] Version [%s] to peer", ccpack.GetChaincodeData().Name, ccpack.GetChaincodeData().Version)

	return nil
}

// executeDeployOrUpgrade routes the code path either to executeDeploy or executeUpgrade
// depending on its function argument
func (lscc *LifeCycleSysCC) executeDeployOrUpgrade(
	stub shim.ChaincodeStubInterface,
	chainname string,
	cds *pb.ChaincodeDeploymentSpec,
	policy, escc, vscc, collectionConfigBytes []byte,
	function string,
) (*ccprovider.ChaincodeData, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[158], 1);

	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name
	chaincodeVersion := cds.ChaincodeSpec.ChaincodeId.Version

	if err := lscc.isValidChaincodeName(chaincodeName); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[162], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[159], 1);if err := lscc.isValidChaincodeVersion(chaincodeName, chaincodeVersion); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[163], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[160], 1);ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[164], 1);
		retErrMsg := fmt.Sprintf("cannot get package for chaincode (%s:%s)", chaincodeName, chaincodeVersion)
		logger.Errorf("%s-err:%s", retErrMsg, err)
		return nil, fmt.Errorf("%s", retErrMsg)
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[161], 1);cd := ccpack.GetChaincodeData()

	switch function {
	case DEPLOY:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[165], 1);
		return lscc.executeDeploy(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)
	case UPGRADE:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[166], 1);
		return lscc.executeUpgrade(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)
	default:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[167], 1);
		logger.Panicf("Programming error, unexpected function '%s'", function)
		panic("") // unreachable code
	}
}

// executeDeploy implements the "instantiate" Invoke transaction
func (lscc *LifeCycleSysCC) executeDeploy(
	stub shim.ChaincodeStubInterface,
	chainname string,
	cds *pb.ChaincodeDeploymentSpec,
	policy []byte,
	escc []byte,
	vscc []byte,
	cdfs *ccprovider.ChaincodeData,
	ccpackfs ccprovider.CCPackage,
	collectionConfigBytes []byte,
) (*ccprovider.ChaincodeData, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[168], 1);
	//just test for existence of the chaincode in the LSCC
	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name
	_, err := lscc.getCCInstance(stub, chaincodeName)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[175], 1);
		return nil, ExistsErr(chaincodeName)
	}

	//retain chaincode specific data and fill channel specific ones
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[169], 1);cdfs.Escc = string(escc)
	cdfs.Vscc = string(vscc)
	cdfs.Policy = policy

	// retrieve and evaluate instantiation policy
	cdfs.InstantiationPolicy, err = lscc.Support.GetInstantiationPolicy(chainname, ccpackfs)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[176], 1);
		return nil, err
	}
	// get the signed instantiation proposal
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[170], 1);signedProp, err := stub.GetSignedProposal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[177], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[171], 1);err = lscc.Support.CheckInstantiationPolicy(signedProp, chainname, cdfs.InstantiationPolicy)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[178], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[172], 1);err = lscc.putChaincodeData(stub, cdfs)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[179], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[173], 1);err = lscc.putChaincodeCollectionData(stub, cdfs, collectionConfigBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[180], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[174], 1);return cdfs, nil
}

// executeUpgrade implements the "upgrade" Invoke transaction.
func (lscc *LifeCycleSysCC) executeUpgrade(stub shim.ChaincodeStubInterface, chainName string, cds *pb.ChaincodeDeploymentSpec, policy []byte, escc []byte, vscc []byte, cdfs *ccprovider.ChaincodeData, ccpackfs ccprovider.CCPackage, collectionConfigBytes []byte) (*ccprovider.ChaincodeData, error) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[181], 1);

	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name

	// check for existence of chaincode instance only (it has to exist on the channel)
	// we dont care about the old chaincode on the FS. In particular, user may even
	// have deleted it
	cdbytes, _ := lscc.getCCInstance(stub, chaincodeName)
	if cdbytes == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[193], 1);
		return nil, NotFoundErr(chaincodeName)
	}

	//we need the cd to compare the version
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[182], 1);cdLedger, err := lscc.getChaincodeData(chaincodeName, cdbytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[194], 1);
		return nil, err
	}

	//do not upgrade if same version
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[183], 1);if cdLedger.Version == cds.ChaincodeSpec.ChaincodeId.Version {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[195], 1);
		return nil, IdenticalVersionErr(chaincodeName)
	}

	//do not upgrade if instantiation policy is violated
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[184], 1);if cdLedger.InstantiationPolicy == nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[196], 1);
		return nil, InstantiationPolicyMissing("")
	}
	// get the signed instantiation proposal
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[185], 1);signedProp, err := stub.GetSignedProposal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[197], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[186], 1);err = lscc.Support.CheckInstantiationPolicy(signedProp, chainName, cdLedger.InstantiationPolicy)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[198], 1);
		return nil, err
	}

	//retain chaincode specific data and fill channel specific ones
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[187], 1);cdfs.Escc = string(escc)
	cdfs.Vscc = string(vscc)
	cdfs.Policy = policy

	// retrieve and evaluate new instantiation policy
	cdfs.InstantiationPolicy, err = lscc.Support.GetInstantiationPolicy(chainName, ccpackfs)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[199], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[188], 1);err = lscc.Support.CheckInstantiationPolicy(signedProp, chainName, cdfs.InstantiationPolicy)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[200], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[189], 1);err = lscc.putChaincodeData(stub, cdfs)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[201], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[190], 1);ac, exists := lscc.SCCProvider.GetApplicationConfig(chainName)
	if !exists {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[202], 1);
		logger.Panicf("programming error, non-existent appplication config for channel '%s'", chainName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[191], 1);if ac.Capabilities().CollectionUpgrade() {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[203], 1);
		err = lscc.putChaincodeCollectionData(stub, cdfs, collectionConfigBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[204], 1);
			return nil, err
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[205], 1);{
		if collectionConfigBytes != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[206], 1);
			return nil, errors.New(CollectionsConfigUpgradesNotAllowed("").Error())
		}
	}}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[192], 1);lifecycleEvent := &pb.LifecycleEvent{ChaincodeName: chaincodeName}
	lifecycleEventBytes := utils.MarshalOrPanic(lifecycleEvent)
	stub.SetEvent(UPGRADE, lifecycleEventBytes)
	return cdfs, nil
}

//-------------- the chaincode stub interface implementation ----------

//Init is mostly useless for SCC
func (lscc *LifeCycleSysCC) Init(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[207], 1);
	return shim.Success(nil)
}

// Invoke implements lifecycle functions "deploy", "start", "stop", "upgrade".
// Deploy's arguments -  {[]byte("deploy"), []byte(<chainname>), <unmarshalled pb.ChaincodeDeploymentSpec>}
//
// Invoke also implements some query-like functions
// Get chaincode arguments -  {[]byte("getid"), []byte(<chainname>), []byte(<chaincodename>)}
func (lscc *LifeCycleSysCC) Invoke(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[208], 1);
	args := stub.GetArgs()
	if len(args) < 1 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[212], 1);
		return shim.Error(InvalidArgsLenErr(len(args)).Error())
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[209], 1);function := string(args[0])

	// Handle ACL:
	// 1. get the signed proposal
	sp, err := stub.GetSignedProposal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[213], 1);
		return shim.Error(fmt.Sprintf("Failed retrieving signed proposal on executing %s with error %s", function, err))
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[210], 1);switch function {
	case INSTALL:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[214], 1);
		if len(args) < 2 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[245], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		// 2. check local MSP Admins policy
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[215], 1);if err = lscc.PolicyChecker.CheckPolicyNoChannel(mgmt.Admins, sp); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[246], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s]: %s", function, err))
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[216], 1);depSpec := args[1]

		err := lscc.executeInstall(stub, depSpec)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[247], 1);
			return shim.Error(err.Error())
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[217], 1);return shim.Success([]byte("OK"))
	case DEPLOY, UPGRADE:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[218], 1);
		// we expect a minimum of 3 arguments, the function
		// name, the chain name and deployment spec
		if len(args) < 3 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[248], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		// channel the chaincode should be associated with. It
		// should be created with a register call
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[219], 1);channel := string(args[1])

		if !lscc.isValidChannelName(channel) {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[249], 1);
			return shim.Error(InvalidChannelNameErr(channel).Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[220], 1);ac, exists := lscc.SCCProvider.GetApplicationConfig(channel)
		if !exists {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[250], 1);
			logger.Panicf("programming error, non-existent appplication config for channel '%s'", channel)
		}

		// the maximum number of arguments depends on the capability of the channel
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[221], 1);if !ac.Capabilities().PrivateChannelData() && len(args) > 6 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[251], 1);
			return shim.Error(PrivateChannelDataNotAvailable("").Error())
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[222], 1);if ac.Capabilities().PrivateChannelData() && len(args) > 7 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[252], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[223], 1);depSpec := args[2]
		cds := &pb.ChaincodeDeploymentSpec{}
		err := proto.Unmarshal(depSpec, cds)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[253], 1);
			return shim.Error(fmt.Sprintf("error unmarshaling ChaincodeDeploymentSpec: %s", err))
		}

		// optional arguments here (they can each be nil and may or may not be present)
		// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy
		// args[4] is the name of escc
		// args[5] is the name of vscc
		// args[6] is a marshalled CollectionConfigPackage struct
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[224], 1);var EP []byte
		if len(args) > 3 && len(args[3]) > 0 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[254], 1);
			EP = args[3]
		} else{ _cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[255], 1);{
			p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))
			EP, err = utils.Marshal(p)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[256], 1);
				return shim.Error(err.Error())
			}
		}}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[225], 1);var escc []byte
		if len(args) > 4 && len(args[4]) > 0 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[257], 1);
			escc = args[4]
		} else{ _cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[258], 1);{
			escc = []byte("escc")
		}}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[226], 1);var vscc []byte
		if len(args) > 5 && len(args[5]) > 0 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[259], 1);
			vscc = args[5]
		} else{ _cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[260], 1);{
			vscc = []byte("vscc")
		}}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[227], 1);var collectionsConfig []byte
		// we proceed with a non-nil collection configuration only if
		// we Support the PrivateChannelData capability
		if ac.Capabilities().PrivateChannelData() && len(args) > 6 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[261], 1);
			collectionsConfig = args[6]
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[228], 1);cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[262], 1);
			return shim.Error(err.Error())
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[229], 1);cdbytes, err := proto.Marshal(cd)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[263], 1);
			return shim.Error(err.Error())
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[230], 1);return shim.Success(cdbytes)
	case CCEXISTS, CHAINCODEEXISTS, GETDEPSPEC, GETDEPLOYMENTSPEC, GETCCDATA, GETCHAINCODEDATA:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[231], 1);
		if len(args) != 3 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[264], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[232], 1);channel := string(args[1])
		ccname := string(args[2])

		// 2. check policy for ACL resource
		var resource string
		switch function {
		case CCEXISTS, CHAINCODEEXISTS:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[265], 1);
			resource = resources.Lscc_ChaincodeExists
		case GETDEPSPEC, GETDEPLOYMENTSPEC:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[266], 1);
			resource = resources.Lscc_GetDeploymentSpec
		case GETCCDATA, GETCHAINCODEDATA:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[267], 1);
			resource = resources.Lscc_GetChaincodeData
		}
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[233], 1);if err = lscc.ACLProvider.CheckACL(resource, channel, sp); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[268], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: %s", function, channel, err))
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[234], 1);cdbytes, err := lscc.getCCInstance(stub, ccname)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[269], 1);
			logger.Errorf("error getting chaincode %s on channel [%s]: %s", ccname, channel, err)
			return shim.Error(err.Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[235], 1);switch function {
		case CCEXISTS, CHAINCODEEXISTS:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[270], 1);
			cd, err := lscc.getChaincodeData(ccname, cdbytes)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[276], 1);
				return shim.Error(err.Error())
			}
			_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[271], 1);return shim.Success([]byte(cd.Name))
		case GETCCDATA, GETCHAINCODEDATA:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[272], 1);
			return shim.Success(cdbytes)
		case GETDEPSPEC, GETDEPLOYMENTSPEC:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[273], 1);
			_, depspecbytes, err := lscc.getCCCode(ccname, cdbytes)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[277], 1);
				return shim.Error(err.Error())
			}
			_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[274], 1);return shim.Success(depspecbytes)
		default:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[275], 1);
			panic("unreachable")
		}
	case GETCHAINCODES, GETCHAINCODESALIAS:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[236], 1);
		if len(args) != 1 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[278], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[237], 1);if err = lscc.ACLProvider.CheckACL(resources.Lscc_GetInstantiatedChaincodes, stub.GetChannelID(), sp); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[279], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s][%s]: %s", function, stub.GetChannelID(), err))
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[238], 1);return lscc.getChaincodes(stub)
	case GETINSTALLEDCHAINCODES, GETINSTALLEDCHAINCODESALIAS:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[239], 1);
		if len(args) != 1 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[280], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		// 2. check local MSP Admins policy
		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[240], 1);if err = lscc.PolicyChecker.CheckPolicyNoChannel(mgmt.Admins, sp); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[281], 1);
			return shim.Error(fmt.Sprintf("access denied for [%s]: %s", function, err))
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[241], 1);return lscc.getInstalledChaincodes()
	case GETCOLLECTIONSCONFIG, GETCOLLECTIONSCONFIGALIAS:_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[242], 1);
		if len(args) != 2 {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[282], 1);
			return shim.Error(InvalidArgsLenErr(len(args)).Error())
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[243], 1);chaincodeName := string(args[1])

		logger.Debugf("GetCollectionsConfig, chaincodeName:%s, start to check ACL for current identity policy", chaincodeName)
		if err = lscc.ACLProvider.CheckACL(resources.Lscc_GetCollectionsConfig, stub.GetChannelID(), sp); err != nil {_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[283], 1);
			logger.Debugf("ACL Check Failed for channel:%s, chaincode:%s", stub.GetChannelID(), chaincodeName)
			return shim.Error(fmt.Sprintf("access denied for [%s]: %s", function, err))
		}

		_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[244], 1);return lscc.getChaincodeCollectionData(stub, chaincodeName)
	}

	_cover_atomic_.AddUint32(&GoCover_2_386331393235373732613932.Count[211], 1);return shim.Error(InvalidFunctionErr(function).Error())
}

var GoCover_2_386331393235373732613932 = struct {
	Count     [284]uint32
	Pos       [3 * 284]uint32
	NumStmt   [284]uint16
} {
	Pos: [3 * 284]uint32{
		146, 154, 0x2008d, // [0]
		156, 156, 0x490038, // [1]
		157, 157, 0x700038, // [2]
		158, 158, 0x460038, // [3]
		159, 159, 0x470038, // [4]
		160, 160, 0x470038, // [5]
		161, 161, 0x470038, // [6]
		162, 162, 0x470038, // [7]
		164, 166, 0x10008f, // [8]
		170, 170, 0x1f0002, // [9]
		177, 178, 0x100002, // [10]
		182, 182, 0x440002, // [11]
		166, 168, 0x30010, // [12]
		170, 172, 0x3001f, // [13]
		178, 180, 0x30010, // [14]
		185, 187, 0x100088, // [15]
		191, 191, 0x1f0002, // [16]
		195, 197, 0x100002, // [17]
		201, 201, 0x1b0002, // [18]
		187, 189, 0x30010, // [19]
		191, 193, 0x3001f, // [20]
		197, 199, 0x30010, // [21]
		205, 207, 0x100074, // [22]
		211, 211, 0x140002, // [23]
		215, 217, 0xc0002, // [24]
		207, 209, 0x30010, // [25]
		211, 213, 0x30014, // [26]
		222, 223, 0x13006a, // [27]
		226, 227, 0x100002, // [28]
		230, 230, 0x1d0002, // [29]
		233, 234, 0x110002, // [30]
		237, 237, 0x220002, // [31]
		240, 240, 0x370002, // [32]
		245, 245, 0x520002, // [33]
		298, 298, 0xc0002, // [34]
		223, 225, 0x30013, // [35]
		227, 229, 0x30010, // [36]
		230, 232, 0x3001d, // [37]
		234, 236, 0x30011, // [38]
		237, 239, 0x30022, // [39]
		240, 242, 0x30037, // [40]
		245, 249, 0x2c0052, // [41]
		293, 293, 0xd0003, // [42]
		251, 254, 0x12001d, // [43]
		257, 259, 0x1c0004, // [44]
		266, 269, 0x12002a, // [45]
		272, 274, 0x1c0004, // [46]
		281, 283, 0x1d0021, // [47]
		290, 291, 0x85000b, // [48]
		254, 256, 0x50012, // [49]
		259, 260, 0x17001c, // [50]
		260, 262, 0xb0017, // [51]
		269, 271, 0x50012, // [52]
		274, 275, 0x17001c, // [53]
		275, 277, 0xb0017, // [54]
		283, 285, 0x13001d, // [55]
		285, 287, 0xb0013, // [56]
		293, 295, 0x4000d, // [57]
		302, 303, 0xf009c, // [58]
		307, 307, 0x250002, // [59]
		312, 314, 0x100002, // [60]
		318, 319, 0x130002, // [61]
		322, 322, 0x360002, // [62]
		329, 332, 0x100002, // [63]
		336, 336, 0xc0002, // [64]
		303, 305, 0x3000f, // [65]
		307, 310, 0x30025, // [66]
		314, 316, 0x30010, // [67]
		319, 321, 0x30013, // [68]
		322, 324, 0x110036, // [69]
		324, 326, 0x40011, // [70]
		332, 334, 0x30010, // [71]
		340, 343, 0x10007c, // [72]
		346, 346, 0x260002, // [73]
		349, 349, 0x2d0002, // [74]
		343, 345, 0x30010, // [75]
		346, 348, 0x30026, // [76]
		353, 355, 0x10006c, // [77]
		358, 358, 0x140002, // [78]
		362, 362, 0x150002, // [79]
		355, 357, 0x30010, // [80]
		358, 360, 0x30014, // [81]
		366, 369, 0x100070, // [82]
		374, 374, 0x170002, // [83]
		378, 378, 0x100002, // [84]
		369, 371, 0x30010, // [85]
		374, 376, 0x30017, // [86]
		382, 384, 0x100073, // [87]
		388, 389, 0x100002, // [88]
		396, 396, 0x2d0002, // [89]
		401, 404, 0x230002, // [90]
		384, 386, 0x30010, // [91]
		389, 391, 0x30010, // [92]
		396, 398, 0x3002d, // [93]
		408, 412, 0x100059, // [94]
		415, 420, 0x140002, // [95]
		453, 456, 0x100002, // [96]
		460, 460, 0x1f0002, // [97]
		412, 414, 0x30010, // [98]
		420, 422, 0x110014, // [99]
		427, 427, 0x330003, // [100]
		431, 432, 0x400003, // [101]
		436, 442, 0x110003, // [102]
		448, 449, 0x2c0003, // [103]
		422, 424, 0x40011, // [104]
		427, 428, 0xc0033, // [105]
		432, 434, 0x40040, // [106]
		442, 445, 0x40011, // [107]
		456, 458, 0x30010, // [108]
		464, 468, 0x100042, // [109]
		472, 473, 0x100002, // [110]
		477, 477, 0x1f0002, // [111]
		468, 470, 0x30010, // [112]
		473, 475, 0x30010, // [113]
		481, 483, 0x130045, // [114]
		486, 486, 0xd0002, // [115]
		483, 485, 0x30013, // [116]
		491, 492, 0x19004e, // [117]
		496, 496, 0x420002, // [118]
		500, 500, 0xc0002, // [119]
		492, 494, 0x30019, // [120]
		496, 498, 0x30042, // [121]
		506, 507, 0x130061, // [122]
		511, 511, 0x3b0002, // [123]
		515, 515, 0xc0002, // [124]
		507, 509, 0x30013, // [125]
		511, 513, 0x3003b, // [126]
		518, 522, 0x2a0049, // [127]
		526, 526, 0xd0002, // [128]
		522, 524, 0x3002a, // [129]
		529, 534, 0x100043, // [130]
		538, 538, 0x350002, // [131]
		549, 549, 0xc0002, // [132]
		534, 536, 0x30010, // [133]
		538, 539, 0x330035, // [134]
		539, 543, 0x120033, // [135]
		543, 545, 0x50012, // [136]
		553, 555, 0x100064, // [137]
		559, 561, 0x100002, // [138]
		565, 565, 0x550002, // [139]
		569, 569, 0x7f0002, // [140]
		573, 573, 0x420002, // [141]
		578, 579, 0x100002, // [142]
		583, 583, 0x470002, // [143]
		587, 597, 0xf0002, // [144]
		600, 600, 0x100002, // [145]
		605, 605, 0x470002, // [146]
		609, 611, 0xc0002, // [147]
		555, 557, 0x30010, // [148]
		561, 563, 0x30010, // [149]
		565, 567, 0x30055, // [150]
		569, 571, 0x3007f, // [151]
		573, 575, 0x30042, // [152]
		579, 581, 0x30010, // [153]
		583, 585, 0x30047, // [154]
		597, 599, 0x3000f, // [155]
		600, 602, 0x30010, // [156]
		605, 607, 0x30047, // [157]
		622, 627, 0x410026, // [158]
		631, 631, 0x560002, // [159]
		635, 636, 0x100002, // [160]
		641, 643, 0x120002, // [161]
		627, 629, 0x30041, // [162]
		631, 633, 0x30056, // [163]
		636, 640, 0x30010, // [164]
		644, 645, 0x69000e, // [165]
		646, 647, 0x6a000f, // [166]
		648, 650, 0xc000a, // [167]
		665, 669, 0x100026, // [168]
		674, 680, 0x100002, // [169]
		684, 685, 0x100002, // [170]
		688, 689, 0x100002, // [171]
		693, 694, 0x100002, // [172]
		698, 699, 0x100002, // [173]
		703, 703, 0x120002, // [174]
		669, 671, 0x30010, // [175]
		680, 682, 0x30010, // [176]
		685, 687, 0x30010, // [177]
		689, 691, 0x30010, // [178]
		694, 696, 0x30010, // [179]
		699, 701, 0x30010, // [180]
		707, 715, 0x14012a, // [181]
		720, 721, 0x100002, // [182]
		726, 726, 0x3f0002, // [183]
		731, 731, 0x290002, // [184]
		735, 736, 0x100002, // [185]
		739, 740, 0x100002, // [186]
		745, 751, 0x100002, // [187]
		754, 755, 0x100002, // [188]
		759, 760, 0x100002, // [189]
		764, 765, 0xd0002, // [190]
		769, 769, 0x2b0002, // [191]
		780, 783, 0x120002, // [192]
		715, 717, 0x30014, // [193]
		721, 723, 0x30010, // [194]
		726, 728, 0x3003f, // [195]
		731, 733, 0x30029, // [196]
		736, 738, 0x30010, // [197]
		740, 742, 0x30010, // [198]
		751, 753, 0x30010, // [199]
		755, 757, 0x30010, // [200]
		760, 762, 0x30010, // [201]
		765, 767, 0x3000d, // [202]
		769, 771, 0x11002b, // [203]
		771, 773, 0x40011, // [204]
		774, 775, 0x230008, // [205]
		775, 777, 0x40023, // [206]
		789, 791, 0x20050, // [207]
		798, 800, 0x130052, // [208]
		804, 809, 0x100002, // [209]
		813, 813, 0x120002, // [210]
		995, 995, 0x390002, // [211]
		800, 802, 0x30013, // [212]
		809, 811, 0x30010, // [213]
		814, 815, 0x14000f, // [214]
		820, 820, 0x510003, // [215]
		824, 827, 0x110003, // [216]
		830, 830, 0x240003, // [217]
		831, 834, 0x140017, // [218]
		840, 842, 0x280003, // [219]
		846, 847, 0xe0003, // [220]
		852, 852, 0x3f0003, // [221]
		855, 855, 0x3e0003, // [222]
		859, 862, 0x110003, // [223]
		871, 872, 0x280003, // [224]
		882, 883, 0x280003, // [225]
		889, 890, 0x280003, // [226]
		896, 899, 0x3e0003, // [227]
		903, 904, 0x110003, // [228]
		907, 908, 0x110003, // [229]
		911, 911, 0x1f0003, // [230]
		912, 913, 0x15005d, // [231]
		917, 922, 0x130003, // [232]
		930, 930, 0x490003, // [233]
		934, 935, 0x110003, // [234]
		940, 940, 0x130003, // [235]
		958, 959, 0x150029, // [236]
		963, 963, 0x750003, // [237]
		967, 967, 0x220003, // [238]
		968, 969, 0x15003b, // [239]
		974, 974, 0x510003, // [240]
		978, 978, 0x270003, // [241]
		979, 980, 0x150037, // [242]
		984, 987, 0x700003, // [243]
		992, 992, 0x3e0003, // [244]
		815, 817, 0x40014, // [245]
		820, 822, 0x40051, // [246]
		827, 829, 0x40011, // [247]
		834, 836, 0x40014, // [248]
		842, 844, 0x40028, // [249]
		847, 849, 0x4000e, // [250]
		852, 854, 0x4003f, // [251]
		855, 857, 0x4003e, // [252]
		862, 864, 0x40011, // [253]
		872, 874, 0x40028, // [254]
		874, 877, 0x120009, // [255]
		877, 879, 0x50012, // [256]
		883, 885, 0x40028, // [257]
		885, 887, 0x40009, // [258]
		890, 892, 0x40028, // [259]
		892, 894, 0x40009, // [260]
		899, 901, 0x4003e, // [261]
		904, 906, 0x40011, // [262]
		908, 910, 0x40011, // [263]
		913, 915, 0x40015, // [264]
		923, 924, 0x2d0022, // [265]
		925, 926, 0x2f0026, // [266]
		927, 928, 0x2e0024, // [267]
		930, 932, 0x40049, // [268]
		935, 938, 0x40011, // [269]
		941, 943, 0x120022, // [270]
		946, 946, 0x280004, // [271]
		947, 948, 0x200024, // [272]
		949, 951, 0x120026, // [273]
		954, 954, 0x250004, // [274]
		955, 956, 0x18000b, // [275]
		943, 945, 0x50012, // [276]
		951, 953, 0x50012, // [277]
		959, 961, 0x40015, // [278]
		963, 965, 0x40075, // [279]
		969, 971, 0x40015, // [280]
		974, 976, 0x40051, // [281]
		980, 982, 0x40015, // [282]
		987, 990, 0x40070, // [283]
	},
	NumStmt: [284]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		3, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		2, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		2, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		3, // 41
		1, // 42
		3, // 43
		2, // 44
		3, // 45
		2, // 46
		2, // 47
		1, // 48
		1, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		2, // 54
		2, // 55
		2, // 56
		1, // 57
		1, // 58
		1, // 59
		3, // 60
		2, // 61
		1, // 62
		3, // 63
		1, // 64
		1, // 65
		2, // 66
		1, // 67
		1, // 68
		2, // 69
		1, // 70
		1, // 71
		3, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		2, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		3, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		2, // 87
		2, // 88
		1, // 89
		3, // 90
		1, // 91
		1, // 92
		1, // 93
		2, // 94
		3, // 95
		3, // 96
		1, // 97
		1, // 98
		2, // 99
		1, // 100
		2, // 101
		4, // 102
		2, // 103
		1, // 104
		1, // 105
		1, // 106
		2, // 107
		1, // 108
		2, // 109
		2, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		1, // 119
		1, // 120
		1, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		1, // 126
		3, // 127
		1, // 128
		1, // 129
		2, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		3, // 135
		1, // 136
		2, // 137
		2, // 138
		1, // 139
		1, // 140
		1, // 141
		2, // 142
		1, // 143
		3, // 144
		1, // 145
		1, // 146
		2, // 147
		1, // 148
		1, // 149
		1, // 150
		1, // 151
		1, // 152
		1, // 153
		1, // 154
		1, // 155
		1, // 156
		1, // 157
		3, // 158
		1, // 159
		2, // 160
		2, // 161
		1, // 162
		1, // 163
		3, // 164
		1, // 165
		1, // 166
		2, // 167
		3, // 168
		5, // 169
		2, // 170
		2, // 171
		2, // 172
		2, // 173
		1, // 174
		1, // 175
		1, // 176
		1, // 177
		1, // 178
		1, // 179
		1, // 180
		3, // 181
		2, // 182
		1, // 183
		1, // 184
		2, // 185
		2, // 186
		5, // 187
		2, // 188
		2, // 189
		2, // 190
		1, // 191
		4, // 192
		1, // 193
		1, // 194
		1, // 195
		1, // 196
		1, // 197
		1, // 198
		1, // 199
		1, // 200
		1, // 201
		1, // 202
		2, // 203
		1, // 204
		1, // 205
		1, // 206
		1, // 207
		2, // 208
		3, // 209
		1, // 210
		1, // 211
		1, // 212
		1, // 213
		1, // 214
		1, // 215
		3, // 216
		1, // 217
		1, // 218
		2, // 219
		2, // 220
		1, // 221
		1, // 222
		4, // 223
		2, // 224
		2, // 225
		2, // 226
		2, // 227
		2, // 228
		2, // 229
		1, // 230
		1, // 231
		4, // 232
		1, // 233
		2, // 234
		1, // 235
		1, // 236
		1, // 237
		1, // 238
		1, // 239
		1, // 240
		1, // 241
		1, // 242
		3, // 243
		1, // 244
		1, // 245
		1, // 246
		1, // 247
		1, // 248
		1, // 249
		1, // 250
		1, // 251
		1, // 252
		1, // 253
		1, // 254
		3, // 255
		1, // 256
		1, // 257
		1, // 258
		1, // 259
		1, // 260
		1, // 261
		1, // 262
		1, // 263
		1, // 264
		1, // 265
		1, // 266
		1, // 267
		1, // 268
		2, // 269
		2, // 270
		1, // 271
		1, // 272
		2, // 273
		1, // 274
		1, // 275
		1, // 276
		1, // 277
		1, // 278
		1, // 279
		1, // 280
		1, // 281
		1, // 282
		2, // 283
	},
}
var _ = _cover_atomic_.LoadUint32
