//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecouchdb/version_field_encoding.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package statecouchdb; import _cover_atomic_ "sync/atomic"

import (
	"encoding/base64"
	"fmt"
	"strconv"
	"strings"

	proto "github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb/statecouchdb/msgs"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
)

func encodeVersionAndMetadata(version *version.Height, metadata []byte) (string, error) {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[0], 1);
	msg := &msgs.VersionFieldProto{
		VersionBytes: version.ToBytes(),
		Metadata:     metadata,
	}
	msgBytes, err := proto.Marshal(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[2], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[1], 1);msgBase64 := base64.StdEncoding.EncodeToString(msgBytes)
	encodedVersionField := append([]byte{byte(0)}, []byte(msgBase64)...)
	return string(encodedVersionField), nil
}

func decodeVersionAndMetadata(encodedstr string) (*version.Height, []byte, error) {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[3], 1);
	if oldFormatEncoding(encodedstr) {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[7], 1);
		return decodeVersionOldFormat(encodedstr), nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[4], 1);versionFieldBytes, err := base64.StdEncoding.DecodeString(encodedstr[1:])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[8], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[5], 1);versionFieldMsg := &msgs.VersionFieldProto{}
	if err = proto.Unmarshal(versionFieldBytes, versionFieldMsg); err != nil {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[9], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[6], 1);ver, _ := version.NewHeightFromBytes(versionFieldMsg.VersionBytes)
	return ver, versionFieldMsg.Metadata, nil
}

// encodeVersionOldFormat return string representation of version
// With the intorduction of metadata feature, we change the encoding (see function below). However, we retain
// this funtion for test so as to make sure that we can decode old format and support mixed formats present
// in a statedb. This function should be used only in tests to generate the encoding in old format
func encodeVersionOldFormat(version *version.Height) string {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[10], 1);
	return fmt.Sprintf("%v:%v", version.BlockNum, version.TxNum)
}

// decodeVersionOldFormat separates the version and value from encoded string
// See comments in the function `encodeVersionOldFormat`. We retain this function as is
// to use this for decoding the old format data present in the statedb. This function
// should not be used directly or in a tests. The function 'decodeVersionAndMetadata' should be used
// for all decodings - which is expected to detect the encoded format and direct the call
// to this function for decoding the versions encoded in the old format
func decodeVersionOldFormat(encodedVersion string) *version.Height {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[11], 1);
	versionArray := strings.Split(fmt.Sprintf("%s", encodedVersion), ":")
	// convert the blockNum from String to unsigned int
	blockNum, _ := strconv.ParseUint(versionArray[0], 10, 64)
	// convert the txNum from String to unsigned int
	txNum, _ := strconv.ParseUint(versionArray[1], 10, 64)
	return version.NewHeight(blockNum, txNum)
}

func oldFormatEncoding(encodedstr string) bool {_cover_atomic_.AddUint32(&GoCover_7_613461656536306435636636.Count[12], 1);
	return []byte(encodedstr)[0] != byte(0)
}

var GoCover_7_613461656536306435636636 = struct {
	Count     [13]uint32
	Pos       [3 * 13]uint32
	NumStmt   [13]uint16
} {
	Pos: [3 * 13]uint32{
		19, 25, 0x100059, // [0]
		28, 30, 0x290002, // [1]
		25, 27, 0x30010, // [2]
		33, 34, 0x230053, // [3]
		37, 38, 0x100002, // [4]
		41, 42, 0x4b0002, // [5]
		45, 46, 0x2b0002, // [6]
		34, 36, 0x30023, // [7]
		38, 40, 0x30010, // [8]
		42, 44, 0x3004b, // [9]
		53, 55, 0x2003d, // [10]
		63, 70, 0x20044, // [11]
		72, 74, 0x20030, // [12]
	},
	NumStmt: [13]uint16{
		3, // 0
		3, // 1
		1, // 2
		1, // 3
		2, // 4
		2, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		4, // 11
		1, // 12
	},
}
var _ = _cover_atomic_.LoadUint32
