//line /home/cooper/go/src/github.com/hyperledger/fabric/core/committer/committer_impl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package committer; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("committer")

//--------!!!IMPORTANT!!-!!IMPORTANT!!-!!IMPORTANT!!---------
// This is used merely to complete the loop for the "skeleton"
// path so we can reason about and  modify committer component
// more effectively using code.

// PeerLedgerSupport abstract out the API's of ledger.PeerLedger interface
// required to implement LedgerCommitter
type PeerLedgerSupport interface {
	GetPvtDataAndBlockByNum(blockNum uint64, filter ledger.PvtNsCollFilter) (*ledger.BlockAndPvtData, error)

	GetPvtDataByNum(blockNum uint64, filter ledger.PvtNsCollFilter) ([]*ledger.TxPvtData, error)

	CommitWithPvtData(blockAndPvtdata *ledger.BlockAndPvtData) error

	CommitPvtDataOfOldBlocks(blockPvtData []*ledger.BlockPvtData) ([]*ledger.PvtdataHashMismatch, error)

	GetBlockchainInfo() (*common.BlockchainInfo, error)

	GetBlockByNumber(blockNumber uint64) (*common.Block, error)

	GetConfigHistoryRetriever() (ledger.ConfigHistoryRetriever, error)

	GetMissingPvtDataTracker() (ledger.MissingPvtDataTracker, error)

	Close()
}

// LedgerCommitter is the implementation of  Committer interface
// it keeps the reference to the ledger to commit blocks and retrieve
// chain information
type LedgerCommitter struct {
	PeerLedgerSupport
	eventer ConfigBlockEventer
}

// ConfigBlockEventer callback function proto type to define action
// upon arrival on new configuaration update block
type ConfigBlockEventer func(block *common.Block) error

// NewLedgerCommitter is a factory function to create an instance of the committer
// which passes incoming blocks via validation and commits them into the ledger.
func NewLedgerCommitter(ledger PeerLedgerSupport) *LedgerCommitter {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[0], 1);
	return NewLedgerCommitterReactive(ledger, func(_ *common.Block) error {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[1], 1); return nil })
}

// NewLedgerCommitterReactive is a factory function to create an instance of the committer
// same as way as NewLedgerCommitter, while also provides an option to specify callback to
// be called upon new configuration block arrival and commit event
func NewLedgerCommitterReactive(ledger PeerLedgerSupport, eventer ConfigBlockEventer) *LedgerCommitter {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[2], 1);
	return &LedgerCommitter{PeerLedgerSupport: ledger, eventer: eventer}
}

// preCommit takes care to validate the block and update based on its
// content
func (lc *LedgerCommitter) preCommit(block *common.Block) error {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[3], 1);
	// Updating CSCC with new configuration block
	if utils.IsConfigBlock(block) {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[5], 1);
		logger.Debug("Received configuration update, calling CSCC ConfigUpdate")
		if err := lc.eventer(block); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[6], 1);
			return errors.WithMessage(err, "could not update CSCC with new configuration update")
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[4], 1);return nil
}

// CommitWithPvtData commits blocks atomically with private data
func (lc *LedgerCommitter) CommitWithPvtData(blockAndPvtData *ledger.BlockAndPvtData) error {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[7], 1);
	// Do validation and whatever needed before
	// committing new block
	if err := lc.preCommit(blockAndPvtData.Block); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[10], 1);
		return err
	}

	// Committing new block
	_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[8], 1);if err := lc.PeerLedgerSupport.CommitWithPvtData(blockAndPvtData); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[11], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[9], 1);return nil
}

// GetPvtDataAndBlockByNum retrieves private data and block for given sequence number
func (lc *LedgerCommitter) GetPvtDataAndBlockByNum(seqNum uint64) (*ledger.BlockAndPvtData, error) {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[12], 1);
	return lc.PeerLedgerSupport.GetPvtDataAndBlockByNum(seqNum, nil)
}

// LedgerHeight returns recently committed block sequence number
func (lc *LedgerCommitter) LedgerHeight() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[13], 1);
	var info *common.BlockchainInfo
	var err error
	if info, err = lc.GetBlockchainInfo(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[15], 1);
		logger.Errorf("Cannot get blockchain info, %s", info)
		return uint64(0), err
	}

	_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[14], 1);return info.Height, nil
}

// GetBlocks used to retrieve blocks with sequence numbers provided in the slice
func (lc *LedgerCommitter) GetBlocks(blockSeqs []uint64) []*common.Block {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[16], 1);
	var blocks []*common.Block

	for _, seqNum := range blockSeqs {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[18], 1);
		if blck, err := lc.GetBlockByNumber(seqNum); err != nil {_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[19], 1);
			logger.Errorf("Not able to acquire block num %d, from the ledger skipping...", seqNum)
			continue
		} else{ _cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[20], 1);{
			logger.Debug("Appending next block with seqNum = ", seqNum, " to the resulting set")
			blocks = append(blocks, blck)
		}}
	}

	_cover_atomic_.AddUint32(&GoCover_1_633030346339666532326335.Count[17], 1);return blocks
}

var GoCover_1_633030346339666532326335 = struct {
	Count     [21]uint32
	Pos       [3 * 21]uint32
	NumStmt   [21]uint16
} {
	Pos: [3 * 21]uint32{
		60, 61, 0x480044, // [0]
		61, 61, 0x560048, // [1]
		67, 69, 0x20068, // [2]
		73, 75, 0x200041, // [3]
		81, 81, 0xc0002, // [4]
		75, 77, 0x2b0020, // [5]
		77, 79, 0x4002b, // [6]
		85, 88, 0x3c005d, // [7]
		93, 93, 0x500002, // [8]
		97, 97, 0xc0002, // [9]
		88, 90, 0x3003c, // [10]
		93, 95, 0x30050, // [11]
		101, 103, 0x20064, // [12]
		106, 109, 0x34003b, // [13]
		114, 114, 0x190002, // [14]
		109, 112, 0x30034, // [15]
		118, 121, 0x23004a, // [16]
		131, 131, 0xf0002, // [17]
		121, 122, 0x3b0023, // [18]
		122, 124, 0xc003b, // [19]
		125, 128, 0x40009, // [20]
	},
	NumStmt: [21]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		3, // 13
		1, // 14
		2, // 15
		2, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
	},
}
var _ = _cover_atomic_.LoadUint32
