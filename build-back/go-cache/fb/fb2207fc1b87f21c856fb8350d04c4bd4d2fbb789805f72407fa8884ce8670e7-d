//line /home/cooper/go/src/github.com/hyperledger/fabric/common/configtx/validator.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package configtx; import _cover_atomic_ "sync/atomic"

import (
	"regexp"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/policies"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("common.configtx")

// Constraints for valid channel and config IDs
var (
	channelAllowedChars = "[a-z][a-z0-9.-]*"
	configAllowedChars  = "[a-zA-Z0-9.-]+"
	maxLength           = 249
	illegalNames        = map[string]struct{}{
		".":  {},
		"..": {},
	}
)

// ValidatorImpl implements the Validator interface
type ValidatorImpl struct {
	channelID   string
	sequence    uint64
	configMap   map[string]comparable
	configProto *cb.Config
	namespace   string
	pm          policies.Manager
}

// validateConfigID makes sure that the config element names (ie map key of
// ConfigGroup) comply with the following restrictions
//      1. Contain only ASCII alphanumerics, dots '.', dashes '-'
//      2. Are shorter than 250 characters.
//      3. Are not the strings "." or "..".
func validateConfigID(configID string) error {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[0], 1);
	re, _ := regexp.Compile(configAllowedChars)
	// Length
	if len(configID) <= 0 {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[5], 1);
		return errors.New("config ID illegal, cannot be empty")
	}
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[1], 1);if len(configID) > maxLength {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[6], 1);
		return errors.Errorf("config ID illegal, cannot be longer than %d", maxLength)
	}
	// Illegal name
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[2], 1);if _, ok := illegalNames[configID]; ok {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[7], 1);
		return errors.Errorf("name '%s' for config ID is not allowed", configID)
	}
	// Illegal characters
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[3], 1);matched := re.FindString(configID)
	if len(matched) != len(configID) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[8], 1);
		return errors.Errorf("config ID '%s' contains illegal characters", configID)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[4], 1);return nil
}

// validateChannelID makes sure that proposed channel IDs comply with the
// following restrictions:
//      1. Contain only lower case ASCII alphanumerics, dots '.', and dashes '-'
//      2. Are shorter than 250 characters.
//      3. Start with a letter
//
// This is the intersection of the Kafka restrictions and CouchDB restrictions
// with the following exception: '.' is converted to '_' in the CouchDB naming
// This is to accomodate existing channel names with '.', especially in the
// behave tests which rely on the dot notation for their sluggification.
func validateChannelID(channelID string) error {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[9], 1);
	re, _ := regexp.Compile(channelAllowedChars)
	// Length
	if len(channelID) <= 0 {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[13], 1);
		return errors.Errorf("channel ID illegal, cannot be empty")
	}
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[10], 1);if len(channelID) > maxLength {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[14], 1);
		return errors.Errorf("channel ID illegal, cannot be longer than %d", maxLength)
	}

	// Illegal characters
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[11], 1);matched := re.FindString(channelID)
	if len(matched) != len(channelID) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[15], 1);
		return errors.Errorf("channel ID '%s' contains illegal characters", channelID)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[12], 1);return nil
}

// NewValidatorImpl constructs a new implementation of the Validator interface.
func NewValidatorImpl(channelID string, config *cb.Config, namespace string, pm policies.Manager) (*ValidatorImpl, error) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[16], 1);
	if config == nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[21], 1);
		return nil, errors.Errorf("nil config parameter")
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[17], 1);if config.ChannelGroup == nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[22], 1);
		return nil, errors.Errorf("nil channel group")
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[18], 1);if err := validateChannelID(channelID); err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[23], 1);
		return nil, errors.Errorf("bad channel ID: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[19], 1);configMap, err := mapConfig(config.ChannelGroup, namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[24], 1);
		return nil, errors.Errorf("error converting config to map: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[20], 1);return &ValidatorImpl{
		namespace:   namespace,
		pm:          pm,
		sequence:    config.Sequence,
		configMap:   configMap,
		channelID:   channelID,
		configProto: config,
	}, nil
}

// ProposeConfigUpdate takes in an Envelope of type CONFIG_UPDATE and produces a
// ConfigEnvelope to be used as the Envelope Payload Data of a CONFIG message
func (vi *ValidatorImpl) ProposeConfigUpdate(configtx *cb.Envelope) (*cb.ConfigEnvelope, error) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[25], 1);
	return vi.proposeConfigUpdate(configtx)
}

func (vi *ValidatorImpl) proposeConfigUpdate(configtx *cb.Envelope) (*cb.ConfigEnvelope, error) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[26], 1);
	configUpdateEnv, err := utils.EnvelopeToConfigUpdate(configtx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[30], 1);
		return nil, errors.Errorf("error converting envelope to config update: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[27], 1);configMap, err := vi.authorizeUpdate(configUpdateEnv)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[31], 1);
		return nil, errors.Errorf("error authorizing update: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[28], 1);channelGroup, err := configMapToConfig(configMap, vi.namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[32], 1);
		return nil, errors.Errorf("could not turn configMap back to channelGroup: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[29], 1);return &cb.ConfigEnvelope{
		Config: &cb.Config{
			Sequence:     vi.sequence + 1,
			ChannelGroup: channelGroup,
		},
		LastUpdate: configtx,
	}, nil
}

// Validate simulates applying a ConfigEnvelope to become the new config
func (vi *ValidatorImpl) Validate(configEnv *cb.ConfigEnvelope) error {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[33], 1);
	if configEnv == nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[41], 1);
		return errors.Errorf("config envelope is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[34], 1);if configEnv.Config == nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[42], 1);
		return errors.Errorf("config envelope has nil config")
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[35], 1);if configEnv.Config.Sequence != vi.sequence+1 {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[43], 1);
		return errors.Errorf("config currently at sequence %d, cannot validate config at sequence %d", vi.sequence, configEnv.Config.Sequence)
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[36], 1);configUpdateEnv, err := utils.EnvelopeToConfigUpdate(configEnv.LastUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[44], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[37], 1);configMap, err := vi.authorizeUpdate(configUpdateEnv)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[45], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[38], 1);channelGroup, err := configMapToConfig(configMap, vi.namespace)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[46], 1);
		return errors.Errorf("could not turn configMap back to channelGroup: %s", err)
	}

	// reflect.Equal will not work here, because it considers nil and empty maps as different
	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[39], 1);if !proto.Equal(channelGroup, configEnv.Config.ChannelGroup) {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[47], 1);
		return errors.Errorf("ConfigEnvelope LastUpdate did not produce the supplied config result")
	}

	_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[40], 1);return nil
}

// ChainID retrieves the chain ID associated with this manager
func (vi *ValidatorImpl) ChainID() string {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[48], 1);
	return vi.channelID
}

// Sequence returns the sequence number of the config
func (vi *ValidatorImpl) Sequence() uint64 {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[49], 1);
	return vi.sequence
}

// ConfigProto returns the config proto which initialized this Validator
func (vi *ValidatorImpl) ConfigProto() *cb.Config {_cover_atomic_.AddUint32(&GoCover_5_346532363364653032376334.Count[50], 1);
	return vi.configProto
}

var GoCover_5_346532363364653032376334 = struct {
	Count     [51]uint32
	Pos       [3 * 51]uint32
	NumStmt   [51]uint16
} {
	Pos: [3 * 51]uint32{
		48, 51, 0x18002e, // [0]
		54, 54, 0x1f0002, // [1]
		58, 58, 0x290002, // [2]
		62, 63, 0x230002, // [3]
		67, 67, 0xc0002, // [4]
		51, 53, 0x30018, // [5]
		54, 56, 0x3001f, // [6]
		58, 60, 0x30029, // [7]
		63, 65, 0x30023, // [8]
		80, 83, 0x190030, // [9]
		86, 86, 0x200002, // [10]
		91, 92, 0x240002, // [11]
		96, 96, 0xc0002, // [12]
		83, 85, 0x30019, // [13]
		86, 88, 0x30020, // [14]
		92, 94, 0x30024, // [15]
		100, 101, 0x13007b, // [16]
		105, 105, 0x200002, // [17]
		109, 109, 0x350002, // [18]
		113, 114, 0x100002, // [19]
		118, 125, 0x80002, // [20]
		101, 103, 0x30013, // [21]
		105, 107, 0x30020, // [22]
		109, 111, 0x30035, // [23]
		114, 116, 0x30010, // [24]
		130, 132, 0x20061, // [25]
		134, 136, 0x100061, // [26]
		140, 141, 0x100002, // [27]
		145, 146, 0x100002, // [28]
		150, 156, 0x80002, // [29]
		136, 138, 0x30010, // [30]
		141, 143, 0x30010, // [31]
		146, 148, 0x30010, // [32]
		160, 161, 0x160047, // [33]
		165, 165, 0x1d0002, // [34]
		169, 169, 0x300002, // [35]
		173, 174, 0x100002, // [36]
		178, 179, 0x100002, // [37]
		183, 184, 0x100002, // [38]
		189, 189, 0x3f0002, // [39]
		193, 193, 0xc0002, // [40]
		161, 163, 0x30016, // [41]
		165, 167, 0x3001d, // [42]
		169, 171, 0x30030, // [43]
		174, 176, 0x30010, // [44]
		179, 181, 0x30010, // [45]
		184, 186, 0x30010, // [46]
		189, 191, 0x3003f, // [47]
		197, 199, 0x2002b, // [48]
		202, 204, 0x2002c, // [49]
		207, 209, 0x20033, // [50]
	},
	NumStmt: [51]uint16{
		2, // 0
		1, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		2, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		2, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
	},
}
var _ = _cover_atomic_.LoadUint32
