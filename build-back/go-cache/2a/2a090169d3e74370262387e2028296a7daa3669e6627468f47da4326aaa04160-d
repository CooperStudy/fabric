//line /home/cooper/go/src/github.com/hyperledger/fabric/core/transientstore/store_helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package transientstore; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"errors"
	"path/filepath"

	"github.com/hyperledger/fabric/common/ledger/util"
	"github.com/hyperledger/fabric/core/config"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
)

var (
	prwsetPrefix             = []byte("P")[0] // key prefix for storing private write set in transient store.
	purgeIndexByHeightPrefix = []byte("H")[0] // key prefix for storing index on private write set using received at block height.
	purgeIndexByTxidPrefix   = []byte("T")[0] // key prefix for storing index on private write set using txid
	compositeKeySep          = byte(0x00)
)

// createCompositeKeyForPvtRWSet creates a key for storing private write set
// in the transient store. The structure of the key is <prwsetPrefix>~txid~uuid~blockHeight.
func createCompositeKeyForPvtRWSet(txid string, uuid string, blockHeight uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[0], 1);
	var compositeKey []byte
	compositeKey = append(compositeKey, prwsetPrefix)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, createCompositeKeyWithoutPrefixForTxid(txid, uuid, blockHeight)...)

	return compositeKey
}

// createCompositeKeyForPurgeIndexByTxid creates a key to index private write set based on
// txid such that purge based on txid can be achieved. The structure
// of the key is <purgeIndexByTxidPrefix>~txid~uuid~blockHeight.
func createCompositeKeyForPurgeIndexByTxid(txid string, uuid string, blockHeight uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[1], 1);
	var compositeKey []byte
	compositeKey = append(compositeKey, purgeIndexByTxidPrefix)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, createCompositeKeyWithoutPrefixForTxid(txid, uuid, blockHeight)...)

	return compositeKey
}

// createCompositeKeyWithoutPrefixForTxid creates a composite key of structure txid~uuid~blockHeight.
func createCompositeKeyWithoutPrefixForTxid(txid string, uuid string, blockHeight uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[2], 1);
	var compositeKey []byte
	compositeKey = append(compositeKey, []byte(txid)...)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, []byte(uuid)...)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, util.EncodeOrderPreservingVarUint64(blockHeight)...)

	return compositeKey
}

// createCompositeKeyForPurgeIndexByHeight creates a key to index private write set based on
// received at block height such that purge based on block height can be achieved. The structure
// of the key is <purgeIndexByHeightPrefix>~blockHeight~txid~uuid.
func createCompositeKeyForPurgeIndexByHeight(blockHeight uint64, txid string, uuid string) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[3], 1);
	var compositeKey []byte
	compositeKey = append(compositeKey, purgeIndexByHeightPrefix)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, util.EncodeOrderPreservingVarUint64(blockHeight)...)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, []byte(txid)...)
	compositeKey = append(compositeKey, compositeKeySep)
	compositeKey = append(compositeKey, []byte(uuid)...)

	return compositeKey
}

// splitCompositeKeyOfPvtRWSet splits the compositeKey (<prwsetPrefix>~txid~uuid~blockHeight)
// into uuid and blockHeight.
func splitCompositeKeyOfPvtRWSet(compositeKey []byte) (uuid string, blockHeight uint64) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[4], 1);
	return splitCompositeKeyWithoutPrefixForTxid(compositeKey[2:])
}

// splitCompositeKeyOfPurgeIndexByTxid splits the compositeKey (<purgeIndexByTxidPrefix>~txid~uuid~blockHeight)
// into uuid and blockHeight.
func splitCompositeKeyOfPurgeIndexByTxid(compositeKey []byte) (uuid string, blockHeight uint64) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[5], 1);
	return splitCompositeKeyWithoutPrefixForTxid(compositeKey[2:])
}

// splitCompositeKeyOfPurgeIndexByHeight splits the compositeKey (<purgeIndexByHeightPrefix>~blockHeight~txid~uuid)
// into txid, uuid and blockHeight.
func splitCompositeKeyOfPurgeIndexByHeight(compositeKey []byte) (txid string, uuid string, blockHeight uint64) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[6], 1);
	var n int
	blockHeight, n = util.DecodeOrderPreservingVarUint64(compositeKey[2:])
	splits := bytes.Split(compositeKey[n+3:], []byte{compositeKeySep})
	txid = string(splits[0])
	uuid = string(splits[1])
	return
}

// splitCompositeKeyWithoutPrefixForTxid splits the composite key txid~uuid~blockHeight into
// uuid and blockHeight
func splitCompositeKeyWithoutPrefixForTxid(compositeKey []byte) (uuid string, blockHeight uint64) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[7], 1);
	// skip txid as all functions which requires split of composite key already has it
	firstSepIndex := bytes.IndexByte(compositeKey, compositeKeySep)
	secondSepIndex := firstSepIndex + bytes.IndexByte(compositeKey[firstSepIndex+1:], compositeKeySep) + 1
	uuid = string(compositeKey[firstSepIndex+1 : secondSepIndex])
	blockHeight, _ = util.DecodeOrderPreservingVarUint64(compositeKey[secondSepIndex+1:])
	return
}

// createTxidRangeStartKey returns a startKey to do a range query on transient store using txid
func createTxidRangeStartKey(txid string) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[8], 1);
	var startKey []byte
	startKey = append(startKey, prwsetPrefix)
	startKey = append(startKey, compositeKeySep)
	startKey = append(startKey, []byte(txid)...)
	startKey = append(startKey, compositeKeySep)
	return startKey
}

// createTxidRangeEndKey returns a endKey to do a range query on transient store using txid
func createTxidRangeEndKey(txid string) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[9], 1);
	var endKey []byte
	endKey = append(endKey, prwsetPrefix)
	endKey = append(endKey, compositeKeySep)
	endKey = append(endKey, []byte(txid)...)
	// As txid is a fixed length string (i.e., 128 bits long UUID), 0xff can be used as a stopper.
	// Otherwise a super-string of a given txid would also fall under the end key of range query.
	endKey = append(endKey, byte(0xff))
	return endKey
}

// createPurgeIndexByHeightRangeStartKey returns a startKey to do a range query on index stored in transient store
// using blockHeight
func createPurgeIndexByHeightRangeStartKey(blockHeight uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[10], 1);
	var startKey []byte
	startKey = append(startKey, purgeIndexByHeightPrefix)
	startKey = append(startKey, compositeKeySep)
	startKey = append(startKey, util.EncodeOrderPreservingVarUint64(blockHeight)...)
	startKey = append(startKey, compositeKeySep)
	return startKey
}

// createPurgeIndexByHeightRangeEndKey returns a endKey to do a range query on index stored in transient store
// using blockHeight
func createPurgeIndexByHeightRangeEndKey(blockHeight uint64) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[11], 1);
	var endKey []byte
	endKey = append(endKey, purgeIndexByHeightPrefix)
	endKey = append(endKey, compositeKeySep)
	endKey = append(endKey, util.EncodeOrderPreservingVarUint64(blockHeight)...)
	endKey = append(endKey, byte(0xff))
	return endKey
}

// createPurgeIndexByTxidRangeStartKey returns a startKey to do a range query on index stored in transient store
// using txid
func createPurgeIndexByTxidRangeStartKey(txid string) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[12], 1);
	var startKey []byte
	startKey = append(startKey, purgeIndexByTxidPrefix)
	startKey = append(startKey, compositeKeySep)
	startKey = append(startKey, []byte(txid)...)
	startKey = append(startKey, compositeKeySep)
	return startKey
}

// createPurgeIndexByTxidRangeEndKey returns a endKey to do a range query on index stored in transient store
// using txid
func createPurgeIndexByTxidRangeEndKey(txid string) []byte {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[13], 1);
	var endKey []byte
	endKey = append(endKey, purgeIndexByTxidPrefix)
	endKey = append(endKey, compositeKeySep)
	endKey = append(endKey, []byte(txid)...)
	// As txid is a fixed length string (i.e., 128 bits long UUID), 0xff can be used as a stopper.
	// Otherwise a super-string of a given txid would also fall under the end key of range query.
	endKey = append(endKey, byte(0xff))
	return endKey
}

// GetTransientStorePath returns the filesystem path for temporarily storing the private rwset
func GetTransientStorePath() string {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[14], 1);
	sysPath := config.GetPath("peer.fileSystemPath")
	return filepath.Join(sysPath, "transientStore")
}

// trimPvtWSet returns a `TxPvtReadWriteSet` that retains only list of 'ns/collections' supplied in the filter
// A nil filter does not filter any results and returns the original `pvtWSet` as is
func trimPvtWSet(pvtWSet *rwset.TxPvtReadWriteSet, filter ledger.PvtNsCollFilter) *rwset.TxPvtReadWriteSet {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[15], 1);
	if filter == nil {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[19], 1);
		return pvtWSet
	}

	_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[16], 1);var filteredNsRwSet []*rwset.NsPvtReadWriteSet
	for _, ns := range pvtWSet.NsPvtRwset {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[20], 1);
		var filteredCollRwSet []*rwset.CollectionPvtReadWriteSet
		for _, coll := range ns.CollectionPvtRwset {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[22], 1);
			if filter.Has(ns.Namespace, coll.CollectionName) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[23], 1);
				filteredCollRwSet = append(filteredCollRwSet, coll)
			}
		}
		_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[21], 1);if filteredCollRwSet != nil {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[24], 1);
			filteredNsRwSet = append(filteredNsRwSet,
				&rwset.NsPvtReadWriteSet{
					Namespace:          ns.Namespace,
					CollectionPvtRwset: filteredCollRwSet,
				},
			)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[17], 1);var filteredTxPvtRwSet *rwset.TxPvtReadWriteSet
	if filteredNsRwSet != nil {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[25], 1);
		filteredTxPvtRwSet = &rwset.TxPvtReadWriteSet{
			DataModel:  pvtWSet.GetDataModel(),
			NsPvtRwset: filteredNsRwSet,
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[18], 1);return filteredTxPvtRwSet
}

func trimPvtCollectionConfigs(configs map[string]*common.CollectionConfigPackage,
	filter ledger.PvtNsCollFilter) (map[string]*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[26], 1);
	if filter == nil {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[29], 1);
		return configs, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[27], 1);result := make(map[string]*common.CollectionConfigPackage)

	for ns, pkg := range configs {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[30], 1);
		result[ns] = &common.CollectionConfigPackage{}
		for _, colConf := range pkg.GetConfig() {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[31], 1);
			switch cconf := colConf.Payload.(type) {
			case *common.CollectionConfig_StaticCollectionConfig:_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[32], 1);
				if filter.Has(ns, cconf.StaticCollectionConfig.Name) {_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[34], 1);
					result[ns].Config = append(result[ns].Config, colConf)
				}
			default:_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[33], 1);
				return nil, errors.New("unexpected collection type")
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_646462646366376465656666.Count[28], 1);return result, nil
}

var GoCover_1_646462646366376465656666 = struct {
	Count     [35]uint32
	Pos       [3 * 35]uint32
	NumStmt   [35]uint16
} {
	Pos: [3 * 35]uint32{
		30, 37, 0x20059, // [0]
		42, 49, 0x20061, // [1]
		52, 61, 0x20062, // [2]
		66, 77, 0x20063, // [3]
		81, 83, 0x20059, // [4]
		87, 89, 0x20061, // [5]
		93, 100, 0x20070, // [6]
		104, 111, 0x20063, // [7]
		114, 121, 0x20032, // [8]
		124, 133, 0x20030, // [9]
		137, 144, 0x20047, // [10]
		148, 155, 0x20045, // [11]
		159, 166, 0x2003e, // [12]
		170, 179, 0x2003c, // [13]
		182, 185, 0x20025, // [14]
		189, 190, 0x13006c, // [15]
		194, 195, 0x280002, // [16]
		211, 212, 0x1c0002, // [17]
		218, 218, 0x1b0002, // [18]
		190, 192, 0x30013, // [19]
		195, 197, 0x2e0028, // [20]
		202, 202, 0x1f0003, // [21]
		197, 198, 0x35002e, // [22]
		198, 200, 0x50035, // [23]
		202, 209, 0x4001f, // [24]
		212, 217, 0x3001c, // [25]
		222, 223, 0x130055, // [26]
		226, 228, 0x1f0002, // [27]
		241, 241, 0x140002, // [28]
		223, 225, 0x30013, // [29]
		228, 230, 0x2b001f, // [30]
		230, 231, 0x2b002b, // [31]
		232, 233, 0x3a0039, // [32]
		236, 237, 0x39000c, // [33]
		233, 235, 0x6003a, // [34]
	},
	NumStmt: [35]uint16{
		5, // 0
		5, // 1
		7, // 2
		9, // 3
		1, // 4
		1, // 5
		6, // 6
		5, // 7
		6, // 8
		6, // 9
		6, // 10
		6, // 11
		6, // 12
		6, // 13
		2, // 14
		1, // 15
		2, // 16
		2, // 17
		1, // 18
		1, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
	},
}
var _ = _cover_atomic_.LoadUint32
