//line /home/cooper/go/src/github.com/hyperledger/fabric/core/common/privdata/store.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package privdata; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

// Support is an interface used to inject dependencies
type Support interface {
	// GetQueryExecutorForLedger returns a query executor for the specified channel
	GetQueryExecutorForLedger(cid string) (ledger.QueryExecutor, error)

	// GetIdentityDeserializer returns an IdentityDeserializer
	// instance for the specified chain
	GetIdentityDeserializer(chainID string) msp.IdentityDeserializer
}

// StateGetter retrieves data from the state
type State interface {
	// GetState retrieves the value for the given key in the given namespace
	GetState(namespace string, key string) ([]byte, error)
}

type NoSuchCollectionError common.CollectionCriteria

func (f NoSuchCollectionError) Error() string {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[0], 1);
	return fmt.Sprintf("collection %s/%s/%s could not be found", f.Channel, f.Namespace, f.Collection)
}

type simpleCollectionStore struct {
	s Support
}

// NewSimpleCollectionStore returns a collection stored backed
// by a ledger supplied by the specified ledgerGetter with
// an internal name formed as specified by the supplied
// collectionNamer function
func NewSimpleCollectionStore(s Support) CollectionStore {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[1], 1);
	return &simpleCollectionStore{s}
}

func (c *simpleCollectionStore) retrieveCollectionConfigPackage(cc common.CollectionCriteria, qe ledger.QueryExecutor) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[2], 1);
	if qe != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[5], 1);
		return RetrieveCollectionConfigPackageFromState(cc, qe)
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[3], 1);qe, err := c.s.GetQueryExecutorForLedger(cc.Channel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[6], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("could not retrieve query executor for collection criteria %#v", cc))
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[4], 1);defer qe.Done()
	return RetrieveCollectionConfigPackageFromState(cc, qe)
}

// RetrieveCollectionConfigPackageFromState retrieves the collection config package from the given key from the given state
func RetrieveCollectionConfigPackageFromState(cc common.CollectionCriteria, state State) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[7], 1);
	cb, err := state.GetState("lscc", BuildCollectionKVSKey(cc.Namespace))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[11], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error while retrieving collection for collection criteria %#v", cc))
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[8], 1);if cb == nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[12], 1);
		return nil, NoSuchCollectionError(cc)
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[9], 1);conf, err := ParseCollectionConfig(cb)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[13], 1);
		return nil, errors.Wrapf(err, "invalid configuration for collection criteria %#v", cc)
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[10], 1);return conf, nil
}

// ParseCollectionConfig parses the collection configuration from the given serialized representation
func ParseCollectionConfig(colBytes []byte) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[14], 1);
	collections := &common.CollectionConfigPackage{}
	err := proto.Unmarshal(colBytes, collections)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[16], 1);
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[15], 1);return collections, nil
}

func (c *simpleCollectionStore) retrieveCollectionConfig(cc common.CollectionCriteria, qe ledger.QueryExecutor) (*common.StaticCollectionConfig, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[17], 1);
	collections, err := c.retrieveCollectionConfigPackage(cc, qe)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[21], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[18], 1);if collections == nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[22], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[19], 1);for _, cconf := range collections.Config {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[23], 1);
		switch cconf := cconf.Payload.(type) {
		case *common.CollectionConfig_StaticCollectionConfig:_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[24], 1);
			if cconf.StaticCollectionConfig.Name == cc.Collection {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[26], 1);
				return cconf.StaticCollectionConfig, nil
			}
		default:_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[25], 1);
			return nil, errors.New("unexpected collection type")
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[20], 1);return nil, NoSuchCollectionError(cc)
}

func (c *simpleCollectionStore) retrieveSimpleCollection(cc common.CollectionCriteria, qe ledger.QueryExecutor) (*SimpleCollection, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[27], 1);
	staticCollectionConfig, err := c.retrieveCollectionConfig(cc, qe)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[30], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[28], 1);sc := &SimpleCollection{}
	err = sc.Setup(staticCollectionConfig, c.s.GetIdentityDeserializer(cc.Channel))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[31], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("error setting up collection for collection criteria %#v", cc))
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[29], 1);return sc, nil
}

func (c *simpleCollectionStore) AccessFilter(channelName string, collectionPolicyConfig *common.CollectionPolicyConfig) (Filter, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[32], 1);
	sc := &SimpleCollection{}
	err := sc.setupAccessPolicy(collectionPolicyConfig, c.s.GetIdentityDeserializer(channelName))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[34], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[33], 1);return sc.AccessFilter(), nil
}

func (c *simpleCollectionStore) RetrieveCollection(cc common.CollectionCriteria) (Collection, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[35], 1);
	return c.retrieveSimpleCollection(cc, nil)
}

func (c *simpleCollectionStore) RetrieveCollectionAccessPolicy(cc common.CollectionCriteria) (CollectionAccessPolicy, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[36], 1);
	return c.retrieveSimpleCollection(cc, nil)
}

func (c *simpleCollectionStore) RetrieveCollectionConfigPackage(cc common.CollectionCriteria) (*common.CollectionConfigPackage, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[37], 1);
	return c.retrieveCollectionConfigPackage(cc, nil)
}

// RetrieveCollectionPersistenceConfigs retrieves the collection's persistence related configurations
func (c *simpleCollectionStore) RetrieveCollectionPersistenceConfigs(cc common.CollectionCriteria) (CollectionPersistenceConfigs, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[38], 1);
	staticCollectionConfig, err := c.retrieveCollectionConfig(cc, nil)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[40], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[39], 1);return &SimpleCollectionPersistenceConfigs{staticCollectionConfig.BlockToLive}, nil
}

func (c *simpleCollectionStore) HasReadAccess(cc common.CollectionCriteria, signedProposal *pb.SignedProposal, qe ledger.QueryExecutor) (bool, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[41], 1);
	accessPolicy, err := c.retrieveSimpleCollection(cc, qe)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[45], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[42], 1);if !accessPolicy.IsMemberOnlyRead() {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[46], 1);
		return true, nil
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[43], 1);signedData, err := getSignedData(signedProposal)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[47], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[44], 1);hasReadAccess := accessPolicy.AccessFilter()
	return hasReadAccess(signedData), nil
}

func getSignedData(signedProposal *pb.SignedProposal) (common.SignedData, error) {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[48], 1);
	proposal, err := utils.GetProposal(signedProposal.ProposalBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[51], 1);
		return common.SignedData{}, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[49], 1);creator, _, err := utils.GetChaincodeProposalContext(proposal)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[52], 1);
		return common.SignedData{}, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_666632313434393663303335.Count[50], 1);return common.SignedData{
		Data:      signedProposal.ProposalBytes,
		Identity:  creator,
		Signature: signedProposal.Signature,
	}, nil
}

var GoCover_3_666632313434393663303335 = struct {
	Count     [53]uint32
	Pos       [3 * 53]uint32
	NumStmt   [53]uint16
} {
	Pos: [3 * 53]uint32{
		39, 41, 0x2002f, // [0]
		51, 53, 0x2003a, // [1]
		55, 56, 0xf00a1, // [2]
		60, 61, 0x100002, // [3]
		64, 65, 0x390002, // [4]
		56, 58, 0x3000f, // [5]
		61, 63, 0x30010, // [6]
		69, 71, 0x100083, // [7]
		74, 74, 0xf0002, // [8]
		77, 78, 0x100002, // [9]
		81, 81, 0x120002, // [10]
		71, 73, 0x30010, // [11]
		74, 76, 0x3000f, // [12]
		78, 80, 0x30010, // [13]
		85, 88, 0x100056, // [14]
		92, 92, 0x190002, // [15]
		88, 90, 0x30010, // [16]
		95, 97, 0x100099, // [17]
		100, 100, 0x180002, // [18]
		103, 103, 0x2b0002, // [19]
		113, 113, 0x270002, // [20]
		97, 99, 0x30010, // [21]
		100, 102, 0x30018, // [22]
		103, 104, 0x28002b, // [23]
		105, 106, 0x3a0038, // [24]
		109, 110, 0x38000b, // [25]
		106, 108, 0x5003a, // [26]
		116, 118, 0x10008c, // [27]
		121, 123, 0x100002, // [28]
		126, 126, 0x100002, // [29]
		118, 120, 0x30010, // [30]
		123, 125, 0x30010, // [31]
		129, 132, 0x100089, // [32]
		135, 135, 0x1f0002, // [33]
		132, 134, 0x30010, // [34]
		138, 140, 0x20066, // [35]
		142, 144, 0x2007e, // [36]
		146, 148, 0x20088, // [37]
		151, 153, 0x10008a, // [38]
		156, 156, 0x550002, // [39]
		153, 155, 0x30010, // [40]
		159, 161, 0x100097, // [41]
		165, 165, 0x260002, // [42]
		169, 170, 0x100002, // [43]
		174, 175, 0x270002, // [44]
		161, 163, 0x30010, // [45]
		165, 167, 0x30026, // [46]
		170, 172, 0x30010, // [47]
		178, 180, 0x100052, // [48]
		184, 185, 0x100002, // [49]
		189, 193, 0x80002, // [50]
		180, 182, 0x30010, // [51]
		185, 187, 0x30010, // [52]
	},
	NumStmt: [53]uint16{
		1, // 0
		1, // 1
		1, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		3, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		3, // 28
		1, // 29
		1, // 30
		1, // 31
		3, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		2, // 43
		2, // 44
		1, // 45
		1, // 46
		1, // 47
		2, // 48
		2, // 49
		1, // 50
		1, // 51
		1, // 52
	},
}
var _ = _cover_atomic_.LoadUint32
