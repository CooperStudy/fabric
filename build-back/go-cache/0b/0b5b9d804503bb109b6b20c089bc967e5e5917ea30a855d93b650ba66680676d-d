//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/msgprocessor/systemchannel.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msgprocessor; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/configtx"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/policies"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
)

// ChannelConfigTemplator can be used to generate config templates.
type ChannelConfigTemplator interface {
	// NewChannelConfig creates a new template configuration manager.
	NewChannelConfig(env *cb.Envelope) (channelconfig.Resources, error)
}

// SystemChannel implements the Processor interface for the system channel.
type SystemChannel struct {
	*StandardChannel
	templator ChannelConfigTemplator
}

// NewSystemChannel creates a new system channel message processor.
func NewSystemChannel(support StandardChannelSupport, templator ChannelConfigTemplator, filters *RuleSet) *SystemChannel {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[0], 1);
	logger.Debugf("Creating system channel msg processor for channel %s", support.ChainID())
	return &SystemChannel{
		StandardChannel: NewStandardChannel(support, filters),
		templator:       templator,
	}
}

// CreateSystemChannelFilters creates the set of filters for the ordering system chain.
func CreateSystemChannelFilters(chainCreator ChainCreator, ledgerResources channelconfig.Resources) *RuleSet {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[1], 1);
	ordererConfig, ok := ledgerResources.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[3], 1);
		logger.Panicf("Cannot create system channel filters without orderer config")
	}
	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[2], 1);return NewRuleSet([]Rule{
		EmptyRejectRule,
		NewExpirationRejectRule(ledgerResources),
		NewSizeFilter(ordererConfig),
		NewSigFilter(policies.ChannelWriters, ledgerResources),
		NewSystemChannelFilter(ledgerResources, chainCreator),
	})
}

// ProcessNormalMsg handles normal messages, rejecting them if they are not bound for the system channel ID
// with ErrChannelDoesNotExist.
func (s *SystemChannel) ProcessNormalMsg(msg *cb.Envelope) (configSeq uint64, err error) {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[4], 1);
	channelID, err := utils.ChannelID(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[7], 1);
		return 0, err
	}

	// For the StandardChannel message processing, we would not check the channel ID,
	// because the message processor is looked up by channel ID.
	// However, the system channel message processor is the catch all for messages
	// which do not correspond to an extant channel, so we must check it here.
	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[5], 1);if channelID != s.support.ChainID() {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[8], 1);
		return 0, ErrChannelDoesNotExist
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[6], 1);return s.StandardChannel.ProcessNormalMsg(msg)
}

// ProcessConfigUpdateMsg handles messages of type CONFIG_UPDATE either for the system channel itself
// or, for channel creation.  In the channel creation case, the CONFIG_UPDATE is wrapped into a resulting
// ORDERER_TRANSACTION, and in the standard CONFIG_UPDATE case, a resulting CONFIG message
func (s *SystemChannel) ProcessConfigUpdateMsg(envConfigUpdate *cb.Envelope) (config *cb.Envelope, configSeq uint64, err error) {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[9], 1);
	channelID, err := utils.ChannelID(envConfigUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[17], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[10], 1);logger.Debugf("Processing config update tx with system channel message processor for channel ID %s", channelID)

	if channelID == s.support.ChainID() {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[18], 1);
		return s.StandardChannel.ProcessConfigUpdateMsg(envConfigUpdate)
	}

	// XXX we should check that the signature on the outer envelope is at least valid for some MSP in the system channel

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[11], 1);logger.Debugf("Processing channel create tx for channel %s on system channel %s", channelID, s.support.ChainID())

	// If the channel ID does not match the system channel, then this must be a channel creation transaction

	bundle, err := s.templator.NewChannelConfig(envConfigUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[19], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[12], 1);newChannelConfigEnv, err := bundle.ConfigtxValidator().ProposeConfigUpdate(envConfigUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[20], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[13], 1);newChannelEnvConfig, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID, s.support.Signer(), newChannelConfigEnv, msgVersion, epoch)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[21], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[14], 1);wrappedOrdererTransaction, err := utils.CreateSignedEnvelope(cb.HeaderType_ORDERER_TRANSACTION, s.support.ChainID(), s.support.Signer(), newChannelEnvConfig, msgVersion, epoch)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[22], 1);
		return nil, 0, err
	}

	// We re-apply the filters here, especially for the size filter, to ensure that the transaction we
	// just constructed is not too large for our consenter.  It additionally reapplies the signature
	// check, which although not strictly necessary, is a good sanity check, in case the orderer
	// has not been configured with the right cert material.  The additional overhead of the signature
	// check is negligable, as this is the channel creation path and not the normal path.
	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[15], 1);err = s.StandardChannel.filters.Apply(wrappedOrdererTransaction)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[23], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[16], 1);return wrappedOrdererTransaction, s.support.Sequence(), nil
}

// ProcessConfigMsg takes envelope of following two types:
//   - `HeaderType_CONFIG`: system channel itself is the target of config, we simply unpack `ConfigUpdate`
//     envelope from `LastUpdate` field and call `ProcessConfigUpdateMsg` on the underlying standard channel
//   - `HeaderType_ORDERER_TRANSACTION`: it's a channel creation message, we unpack `ConfigUpdate` envelope
//     and run `ProcessConfigUpdateMsg` on it
func (s *SystemChannel) ProcessConfigMsg(env *cb.Envelope) (*cb.Envelope, uint64, error) {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[24], 1);
	payload, err := utils.UnmarshalPayload(env.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[29], 1);
		return nil, 0, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[25], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[30], 1);
		return nil, 0, fmt.Errorf("Abort processing config msg because no head was set")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[26], 1);if payload.Header.ChannelHeader == nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[31], 1);
		return nil, 0, fmt.Errorf("Abort processing config msg because no channel header was set")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[27], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[32], 1);
		return nil, 0, fmt.Errorf("Abort processing config msg because channel header unmarshalling error: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[28], 1);switch chdr.Type {
	case int32(cb.HeaderType_CONFIG):_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[33], 1);
		configEnvelope := &cb.ConfigEnvelope{}
		if err = proto.Unmarshal(payload.Data, configEnvelope); err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[39], 1);
			return nil, 0, err
		}

		_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[34], 1);return s.StandardChannel.ProcessConfigUpdateMsg(configEnvelope.LastUpdate)

	case int32(cb.HeaderType_ORDERER_TRANSACTION):_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[35], 1);
		env, err := utils.UnmarshalEnvelope(payload.Data)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[40], 1);
			return nil, 0, fmt.Errorf("Abort processing config msg because payload data unmarshalling error: %s", err)
		}

		_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[36], 1);configEnvelope := &cb.ConfigEnvelope{}
		_, err = utils.UnmarshalEnvelopeOfType(env, cb.HeaderType_CONFIG, configEnvelope)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[41], 1);
			return nil, 0, fmt.Errorf("Abort processing config msg because payload data unmarshalling error: %s", err)
		}

		_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[37], 1);return s.ProcessConfigUpdateMsg(configEnvelope.LastUpdate)

	default:_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[38], 1);
		return nil, 0, fmt.Errorf("Panic processing config msg due to unexpected envelope type %s", cb.HeaderType_name[chdr.Type])
	}
}

// DefaultTemplatorSupport is the subset of the channel config required by the DefaultTemplator.
type DefaultTemplatorSupport interface {
	// ConsortiumsConfig returns the ordering system channel's Consortiums config.
	ConsortiumsConfig() (channelconfig.Consortiums, bool)

	// OrdererConfig returns the ordering configuration and whether the configuration exists
	OrdererConfig() (channelconfig.Orderer, bool)

	// ConfigtxValidator returns the configtx manager corresponding to the system channel's current config.
	ConfigtxValidator() configtx.Validator

	// Signer returns the local signer suitable for signing forwarded messages.
	Signer() crypto.LocalSigner
}

// DefaultTemplator implements the ChannelConfigTemplator interface and is the one used in production deployments.
type DefaultTemplator struct {
	support DefaultTemplatorSupport
}

// NewDefaultTemplator returns an instance of the DefaultTemplator.
func NewDefaultTemplator(support DefaultTemplatorSupport) *DefaultTemplator {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[42], 1);
	return &DefaultTemplator{
		support: support,
	}
}

// NewChannelConfig creates a new template channel configuration based on the current config in the ordering system channel.
func (dt *DefaultTemplator) NewChannelConfig(envConfigUpdate *cb.Envelope) (channelconfig.Resources, error) {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[43], 1);
	configUpdatePayload, err := utils.UnmarshalPayload(envConfigUpdate.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[63], 1);
		return nil, fmt.Errorf("Failing initial channel config creation because of payload unmarshaling error: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[44], 1);configUpdateEnv, err := configtx.UnmarshalConfigUpdateEnvelope(configUpdatePayload.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[64], 1);
		return nil, fmt.Errorf("Failing initial channel config creation because of config update envelope unmarshaling error: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[45], 1);if configUpdatePayload.Header == nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[65], 1);
		return nil, fmt.Errorf("Failed initial channel config creation because config update header was missing")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[46], 1);channelHeader, err := utils.UnmarshalChannelHeader(configUpdatePayload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[66], 1);
		return nil, fmt.Errorf("Failed initial channel config creation because channel header was malformed: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[47], 1);configUpdate, err := configtx.UnmarshalConfigUpdate(configUpdateEnv.ConfigUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[67], 1);
		return nil, fmt.Errorf("Failing initial channel config creation because of config update unmarshaling error: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[48], 1);if configUpdate.ChannelId != channelHeader.ChannelId {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[68], 1);
		return nil, fmt.Errorf("Failing initial channel config creation: mismatched channel IDs: '%s' != '%s'", configUpdate.ChannelId, channelHeader.ChannelId)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[49], 1);if configUpdate.WriteSet == nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[69], 1);
		return nil, fmt.Errorf("Config update has an empty writeset")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[50], 1);if configUpdate.WriteSet.Groups == nil || configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey] == nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[70], 1);
		return nil, fmt.Errorf("Config update has missing application group")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[51], 1);if uv := configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Version; uv != 1 {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[71], 1);
		return nil, fmt.Errorf("Config update for channel creation does not set application group version to 1, was %d", uv)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[52], 1);consortiumConfigValue, ok := configUpdate.WriteSet.Values[channelconfig.ConsortiumKey]
	if !ok {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[72], 1);
		return nil, fmt.Errorf("Consortium config value missing")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[53], 1);consortium := &cb.Consortium{}
	err = proto.Unmarshal(consortiumConfigValue.Value, consortium)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[73], 1);
		return nil, fmt.Errorf("Error reading unmarshaling consortium name: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[54], 1);applicationGroup := cb.NewConfigGroup()
	consortiumsConfig, ok := dt.support.ConsortiumsConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[74], 1);
		return nil, fmt.Errorf("The ordering system channel does not appear to support creating channels")
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[55], 1);consortiumConf, ok := consortiumsConfig.Consortiums()[consortium.Name]
	if !ok {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[75], 1);
		return nil, fmt.Errorf("Unknown consortium name: %s", consortium.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[56], 1);applicationGroup.Policies[channelconfig.ChannelCreationPolicyKey] = &cb.ConfigPolicy{
		Policy: consortiumConf.ChannelCreationPolicy(),
	}
	applicationGroup.ModPolicy = channelconfig.ChannelCreationPolicyKey

	// Get the current system channel config
	systemChannelGroup := dt.support.ConfigtxValidator().ConfigProto().ChannelGroup

	// If the consortium group has no members, allow the source request to have no members.  However,
	// if the consortium group has any members, there must be at least one member in the source request
	if len(systemChannelGroup.Groups[channelconfig.ConsortiumsGroupKey].Groups[consortium.Name].Groups) > 0 &&
		len(configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups) == 0 {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[76], 1);
		return nil, fmt.Errorf("Proposed configuration has no application group members, but consortium contains members")
	}

	// If the consortium has no members, allow the source request to contain arbitrary members
	// Otherwise, require that the supplied members are a subset of the consortium members
	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[57], 1);if len(systemChannelGroup.Groups[channelconfig.ConsortiumsGroupKey].Groups[consortium.Name].Groups) > 0 {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[77], 1);
		for orgName := range configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[78], 1);
			consortiumGroup, ok := systemChannelGroup.Groups[channelconfig.ConsortiumsGroupKey].Groups[consortium.Name].Groups[orgName]
			if !ok {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[80], 1);
				return nil, fmt.Errorf("Attempted to include a member which is not in the consortium")
			}
			_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[79], 1);applicationGroup.Groups[orgName] = proto.Clone(consortiumGroup).(*cb.ConfigGroup)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[58], 1);channelGroup := cb.NewConfigGroup()

	// Copy the system channel Channel level config to the new config
	for key, value := range systemChannelGroup.Values {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[81], 1);
		channelGroup.Values[key] = proto.Clone(value).(*cb.ConfigValue)
		if key == channelconfig.ConsortiumKey {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[82], 1);
			// Do not set the consortium name, we do this later
			continue
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[59], 1);for key, policy := range systemChannelGroup.Policies {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[83], 1);
		channelGroup.Policies[key] = proto.Clone(policy).(*cb.ConfigPolicy)
	}

	// Set the new config orderer group to the system channel orderer group and the application group to the new application group
	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[60], 1);channelGroup.Groups[channelconfig.OrdererGroupKey] = proto.Clone(systemChannelGroup.Groups[channelconfig.OrdererGroupKey]).(*cb.ConfigGroup)
	channelGroup.Groups[channelconfig.ApplicationGroupKey] = applicationGroup
	channelGroup.Values[channelconfig.ConsortiumKey] = &cb.ConfigValue{
		Value:     utils.MarshalOrPanic(channelconfig.ConsortiumValue(consortium.Name).Value()),
		ModPolicy: channelconfig.AdminsPolicyKey,
	}

	// Non-backwards compatible bugfix introduced in v1.1
	// The capability check should be removed once v1.0 is deprecated
	if oc, ok := dt.support.OrdererConfig(); ok && oc.Capabilities().PredictableChannelTemplate() {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[84], 1);
		channelGroup.ModPolicy = systemChannelGroup.ModPolicy
		zeroVersions(channelGroup)
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[61], 1);bundle, err := channelconfig.NewBundle(channelHeader.ChannelId, &cb.Config{
		ChannelGroup: channelGroup,
	})

	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[85], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[62], 1);return bundle, nil
}

// zeroVersions recursively iterates over a config tree, setting all versions to zero
func zeroVersions(cg *cb.ConfigGroup) {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[86], 1);
	cg.Version = 0

	for _, value := range cg.Values {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[89], 1);
		value.Version = 0
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[87], 1);for _, policy := range cg.Policies {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[90], 1);
		policy.Version = 0
	}

	_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[88], 1);for _, group := range cg.Groups {_cover_atomic_.AddUint32(&GoCover_6_646330373837303238396264.Count[91], 1);
		zeroVersions(group)
	}
}

var GoCover_6_646330373837303238396264 = struct {
	Count     [92]uint32
	Pos       [3 * 92]uint32
	NumStmt   [92]uint16
} {
	Pos: [3 * 92]uint32{
		34, 40, 0x2007a, // [0]
		43, 45, 0x9006e, // [1]
		48, 54, 0x40002, // [2]
		45, 47, 0x30009, // [3]
		59, 61, 0x10005a, // [4]
		69, 69, 0x260002, // [5]
		73, 73, 0x300002, // [6]
		61, 63, 0x30010, // [7]
		69, 71, 0x30026, // [8]
		79, 81, 0x100081, // [9]
		85, 87, 0x260002, // [10]
		93, 98, 0x100002, // [11]
		102, 103, 0x100002, // [12]
		107, 108, 0x100002, // [13]
		112, 113, 0x100002, // [14]
		122, 123, 0x100002, // [15]
		127, 127, 0x3d0002, // [16]
		81, 83, 0x30010, // [17]
		87, 89, 0x30026, // [18]
		98, 100, 0x30010, // [19]
		103, 105, 0x30010, // [20]
		108, 110, 0x30010, // [21]
		113, 115, 0x30010, // [22]
		123, 125, 0x30010, // [23]
		135, 137, 0x10005a, // [24]
		141, 141, 0x1b0002, // [25]
		145, 145, 0x290002, // [26]
		149, 150, 0x100002, // [27]
		154, 154, 0x130002, // [28]
		137, 139, 0x30010, // [29]
		141, 143, 0x3001b, // [30]
		145, 147, 0x30029, // [31]
		150, 152, 0x30010, // [32]
		155, 157, 0x460023, // [33]
		161, 161, 0x4d0003, // [34]
		163, 165, 0x110030, // [35]
		169, 171, 0x110003, // [36]
		175, 175, 0x3d0003, // [37]
		177, 178, 0x7d000a, // [38]
		157, 159, 0x40046, // [39]
		165, 167, 0x40011, // [40]
		171, 173, 0x40011, // [41]
		203, 207, 0x2004d, // [42]
		210, 212, 0x10006d, // [43]
		216, 217, 0x100002, // [44]
		221, 221, 0x270002, // [45]
		225, 226, 0x100002, // [46]
		230, 231, 0x100002, // [47]
		235, 235, 0x370002, // [48]
		239, 239, 0x220002, // [49]
		243, 243, 0x730002, // [50]
		247, 247, 0x5c0002, // [51]
		251, 252, 0x90002, // [52]
		256, 258, 0x100002, // [53]
		262, 264, 0x90002, // [54]
		268, 269, 0x90002, // [55]
		273, 284, 0x540002, // [56]
		290, 290, 0x6a0002, // [57]
		300, 303, 0x340002, // [58]
		311, 311, 0x370002, // [59]
		316, 325, 0x600002, // [60]
		330, 334, 0x100002, // [61]
		338, 338, 0x140002, // [62]
		212, 214, 0x30010, // [63]
		217, 219, 0x30010, // [64]
		221, 223, 0x30027, // [65]
		226, 228, 0x30010, // [66]
		231, 233, 0x30010, // [67]
		235, 237, 0x30037, // [68]
		239, 241, 0x30022, // [69]
		243, 245, 0x30073, // [70]
		247, 249, 0x3005c, // [71]
		252, 254, 0x30009, // [72]
		258, 260, 0x30010, // [73]
		264, 266, 0x30009, // [74]
		269, 271, 0x30009, // [75]
		284, 286, 0x30054, // [76]
		290, 291, 0x5f006a, // [77]
		291, 293, 0xb005f, // [78]
		296, 296, 0x550004, // [79]
		293, 295, 0x5000b, // [80]
		303, 305, 0x290034, // [81]
		305, 307, 0xc0029, // [82]
		311, 313, 0x30037, // [83]
		325, 328, 0x30060, // [84]
		334, 336, 0x30010, // [85]
		342, 345, 0x220027, // [86]
		349, 349, 0x250002, // [87]
		353, 353, 0x220002, // [88]
		345, 347, 0x30022, // [89]
		349, 351, 0x30025, // [90]
		353, 355, 0x30022, // [91]
	},
	NumStmt: [92]uint16{
		2, // 0
		2, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		3, // 11
		2, // 12
		2, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		2, // 33
		1, // 34
		2, // 35
		3, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		2, // 43
		2, // 44
		1, // 45
		2, // 46
		2, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		2, // 52
		3, // 53
		3, // 54
		2, // 55
		4, // 56
		1, // 57
		2, // 58
		1, // 59
		4, // 60
		2, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		2, // 78
		1, // 79
		1, // 80
		2, // 81
		1, // 82
		1, // 83
		2, // 84
		1, // 85
		2, // 86
		1, // 87
		1, // 88
		1, // 89
		1, // 90
		1, // 91
	},
}
var _ = _cover_atomic_.LoadUint32
