//line /home/cooper/go/src/github.com/hyperledger/fabric/cmd/common/cli.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package common; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/hyperledger/fabric/cmd/common/comm"
	"github.com/hyperledger/fabric/cmd/common/signer"
	"gopkg.in/alecthomas/kingpin.v2"
)

const (
	saveConfigCommand = "saveConfig"
)

var (
	// Function used to terminate the CLI
	terminate = os.Exit
	// Function used to redirect output to
	outWriter io.Writer = os.Stderr

	// CLI arguments
	mspID                                     *string
	tlsCA, tlsCert, tlsKey, userKey, userCert **os.File
	configFile                                *string
)

// CLICommand defines a command that is added to the CLI
// via an external consumer.
type CLICommand func(Config) error

// CLI defines a command line interpreter
type CLI struct {
	app         *kingpin.Application
	dispatchers map[string]CLICommand
}

// NewCLI creates a new CLI with the given name and help message
func NewCLI(name, help string) *CLI {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[0], 1);
	return &CLI{
		app:         kingpin.New(name, help),
		dispatchers: make(map[string]CLICommand),
	}
}

// Command adds a new top-level command to the CLI
func (cli *CLI) Command(name, help string, onCommand CLICommand) *kingpin.CmdClause {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[1], 1);
	cmd := cli.app.Command(name, help)
	cli.dispatchers[name] = onCommand
	return cmd
}

// Run makes the CLI process the arguments and executes the command(s) with the flag(s)
func (cli *CLI) Run(args []string) {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[2], 1);
	configFile = cli.app.Flag("configFile", "Specifies the config file to load the configuration from").String()
	persist := cli.app.Command(saveConfigCommand, fmt.Sprintf("Save the config passed by flags into the file specified by --configFile"))
	configureFlags(cli.app)

	command := kingpin.MustParse(cli.app.Parse(args))
	if command == persist.FullCommand() {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[6], 1);
		if *configFile == "" {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[8], 1);
			out("--configFile must be used to specify the configuration file")
			return
		}
		_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[7], 1);persistConfig(parseFlagsToConfig(), *configFile)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[3], 1);var conf Config
	if *configFile == "" {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[9], 1);
		conf = parseFlagsToConfig()
	} else{ _cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[10], 1);{
		conf = loadConfig(*configFile)
	}}

	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[4], 1);f, exists := cli.dispatchers[command]
	if !exists {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[11], 1);
		out("Unknown command:", command)
		terminate(1)
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[5], 1);err := f(conf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[12], 1);
		out(err)
		terminate(1)
		return
	}
}

func configureFlags(persistCommand *kingpin.Application) {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[13], 1);
	// TLS flags
	tlsCA = persistCommand.Flag("peerTLSCA", "Sets the TLS CA certificate file path that verifies the TLS peer's certificate").File()
	tlsCert = persistCommand.Flag("tlsCert", "(Optional) Sets the client TLS certificate file path that is used when the peer enforces client authentication").File()
	tlsKey = persistCommand.Flag("tlsKey", "(Optional) Sets the client TLS key file path that is used when the peer enforces client authentication").File()
	// Enrollment flags
	userKey = persistCommand.Flag("userKey", "Sets the user's key file path that is used to sign messages sent to the peer").File()
	userCert = persistCommand.Flag("userCert", "Sets the user's certificate file path that is used to authenticate the messages sent to the peer").File()
	mspID = persistCommand.Flag("MSP", "Sets the MSP ID of the user, which represents the CA(s) that issued its user certificate").String()
}

func persistConfig(conf Config, file string) {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[14], 1);
	if err := conf.ToFile(file); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[15], 1);
		out("Failed persisting configuration:", err)
		terminate(1)
	}
}

func loadConfig(file string) Config {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[16], 1);
	conf, err := ConfigFromFile(file)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[18], 1);
		out("Failed loading config", err)
		terminate(1)
		return Config{}
	}
	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[17], 1);return conf
}

func parseFlagsToConfig() Config {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[19], 1);
	conf := Config{
		SignerConfig: signer.Config{
			MSPID:        *mspID,
			IdentityPath: evaluateFileFlag(userCert),
			KeyPath:      evaluateFileFlag(userKey),
		},
		TLSConfig: comm.Config{
			KeyPath:        evaluateFileFlag(tlsKey),
			CertPath:       evaluateFileFlag(tlsCert),
			PeerCACertPath: evaluateFileFlag(tlsCA),
		},
	}
	return conf
}

func evaluateFileFlag(f **os.File) string {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[20], 1);
	if f == nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[24], 1);
		return ""
	}
	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[21], 1);if *f == nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[25], 1);
		return ""
	}
	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[22], 1);path, err := filepath.Abs((*f).Name())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[26], 1);
		out("Failed listing", (*f).Name(), ":", err)
		terminate(1)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[23], 1);return path
}
func out(a ...interface{}) {_cover_atomic_.AddUint32(&GoCover_0_623737633338616638356566.Count[27], 1);
	fmt.Fprintln(outWriter, a...)
}

var GoCover_0_623737633338616638356566 = struct {
	Count     [28]uint32
	Pos       [3 * 28]uint32
	NumStmt   [28]uint16
} {
	Pos: [3 * 28]uint32{
		47, 52, 0x20025, // [0]
		55, 59, 0x20055, // [1]
		62, 68, 0x260024, // [2]
		77, 78, 0x170002, // [3]
		84, 85, 0xd0002, // [4]
		90, 91, 0x100002, // [5]
		68, 69, 0x180026, // [6]
		73, 74, 0x90003, // [7]
		69, 72, 0x40018, // [8]
		78, 80, 0x30017, // [9]
		80, 82, 0x30008, // [10]
		85, 89, 0x3000d, // [11]
		91, 95, 0x30010, // [12]
		98, 107, 0x2003a, // [13]
		109, 110, 0x2a002e, // [14]
		110, 113, 0x3002a, // [15]
		116, 118, 0x100025, // [16]
		123, 123, 0xd0002, // [17]
		118, 122, 0x30010, // [18]
		126, 140, 0x20022, // [19]
		142, 143, 0xe002b, // [20]
		146, 146, 0xf0002, // [21]
		149, 150, 0x100002, // [22]
		154, 154, 0xd0002, // [23]
		143, 145, 0x3000e, // [24]
		146, 148, 0x3000f, // [25]
		150, 153, 0x30010, // [26]
		156, 158, 0x2001c, // [27]
	},
	NumStmt: [28]uint16{
		1, // 0
		3, // 1
		5, // 2
		2, // 3
		2, // 4
		2, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		3, // 11
		3, // 12
		6, // 13
		1, // 14
		2, // 15
		2, // 16
		1, // 17
		3, // 18
		2, // 19
		1, // 20
		1, // 21
		2, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		1, // 27
	},
}
var _ = _cover_atomic_.LoadUint32
