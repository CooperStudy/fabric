//line /home/cooper/go/src/github.com/hyperledger/fabric/common/tools/configtxlator/sanitycheck/sanitycheck.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package sanitycheck; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	newchannelconfig "github.com/hyperledger/fabric/common/channelconfig"
	cb "github.com/hyperledger/fabric/protos/common"
	mspprotos "github.com/hyperledger/fabric/protos/msp"
)

type Messages struct {
	GeneralErrors   []string          `json:"general_errors"`
	ElementWarnings []*ElementMessage `json:"element_warnings"`
	ElementErrors   []*ElementMessage `json:"element_errors"`
}

type ElementMessage struct {
	Path    string `json:"path"`
	Message string `json:"message"`
}

func Check(config *cb.Config) (*Messages, error) {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[0], 1);
	result := &Messages{}

	bundle, err := newchannelconfig.NewBundle("sanitycheck", config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[4], 1);
		result.GeneralErrors = []string{err.Error()}
		return result, nil
	}

	// This should come from the MSP manager, but, for some reason
	// the MSP manager is not intialized if there are no orgs, so,
	// we collect this manually.
	_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[1], 1);mspMap := make(map[string]struct{})

	if ac, ok := bundle.ApplicationConfig(); ok {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[5], 1);
		for _, org := range ac.Organizations() {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[6], 1);
			mspMap[org.MSPID()] = struct{}{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[2], 1);if oc, ok := bundle.OrdererConfig(); ok {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[7], 1);
		for _, org := range oc.Organizations() {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[8], 1);
			mspMap[org.MSPID()] = struct{}{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[3], 1);policyWarnings, policyErrors := checkPolicyPrincipals(config.ChannelGroup, "", mspMap)

	result.ElementWarnings = policyWarnings
	result.ElementErrors = policyErrors

	return result, nil
}

func checkPolicyPrincipals(group *cb.ConfigGroup, basePath string, mspMap map[string]struct{}) (warnings []*ElementMessage, errors []*ElementMessage) {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[9], 1);
	for policyName, configPolicy := range group.Policies {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[12], 1);
		appendError := func(err string) {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[18], 1);
			errors = append(errors, &ElementMessage{
				Path:    basePath + ".policies." + policyName,
				Message: err,
			})
		}

		_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[13], 1);appendWarning := func(err string) {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[19], 1);
			warnings = append(errors, &ElementMessage{
				Path:    basePath + ".policies." + policyName,
				Message: err,
			})
		}

		_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[14], 1);if configPolicy.Policy == nil {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[20], 1);
			appendError(fmt.Sprintf("no policy value set for %s", policyName))
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[15], 1);if configPolicy.Policy.Type != int32(cb.Policy_SIGNATURE) {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[21], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[16], 1);spe := &cb.SignaturePolicyEnvelope{}
		err := proto.Unmarshal(configPolicy.Policy.Value, spe)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[22], 1);
			appendError(fmt.Sprintf("error unmarshaling policy value to SignaturePolicyEnvelope: %s", err))
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[17], 1);for i, identity := range spe.Identities {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[23], 1);
			var mspID string
			switch identity.PrincipalClassification {
			case mspprotos.MSPPrincipal_ROLE:_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[25], 1);
				role := &mspprotos.MSPRole{}
				err = proto.Unmarshal(identity.Principal, role)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[30], 1);
					appendError(fmt.Sprintf("value of identities array at index %d is of type ROLE, but could not be unmarshaled to msp.MSPRole: %s", i, err))
					continue
				}
				_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[26], 1);mspID = role.MspIdentifier
			case mspprotos.MSPPrincipal_ORGANIZATION_UNIT:_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[27], 1);
				ou := &mspprotos.OrganizationUnit{}
				err = proto.Unmarshal(identity.Principal, ou)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[31], 1);
					appendError(fmt.Sprintf("value of identities array at index %d is of type ORGANIZATION_UNIT, but could not be unmarshaled to msp.OrganizationUnit: %s", i, err))
					continue
				}
				_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[28], 1);mspID = ou.MspIdentifier
			default:_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[29], 1);
				continue
			}

			_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[24], 1);_, ok := mspMap[mspID]
			if !ok {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[32], 1);
				appendWarning(fmt.Sprintf("identity principal at index %d refers to MSP ID '%s', which is not an MSP in the network", i, mspID))
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[10], 1);for subGroupName, subGroup := range group.Groups {_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[33], 1);
		subWarnings, subErrors := checkPolicyPrincipals(subGroup, basePath+".groups."+subGroupName, mspMap)
		warnings = append(warnings, subWarnings...)
		errors = append(errors, subErrors...)
	}
	_cover_atomic_.AddUint32(&GoCover_0_366139303463343033343564.Count[11], 1);return
}

var GoCover_0_366139303463343033343564 = struct {
	Count     [34]uint32
	Pos       [3 * 34]uint32
	NumStmt   [34]uint16
} {
	Pos: [3 * 34]uint32{
		29, 33, 0x100032, // [0]
		41, 43, 0x2e0002, // [1]
		49, 49, 0x2a0002, // [2]
		55, 60, 0x140002, // [3]
		33, 36, 0x30010, // [4]
		43, 44, 0x2a002e, // [5]
		44, 46, 0x4002a, // [6]
		49, 50, 0x2a002a, // [7]
		50, 52, 0x4002a, // [8]
		63, 64, 0x370097, // [9]
		124, 124, 0x330002, // [10]
		129, 129, 0x80002, // [11]
		64, 65, 0x230037, // [12]
		72, 72, 0x250003, // [13]
		79, 79, 0x210003, // [14]
		84, 84, 0x3d0003, // [15]
		87, 89, 0x110003, // [16]
		94, 94, 0x2b0003, // [17]
		65, 70, 0x40023, // [18]
		72, 77, 0x40025, // [19]
		79, 81, 0xc0021, // [20]
		84, 85, 0xc003d, // [21]
		89, 91, 0xc0011, // [22]
		94, 96, 0x2c002b, // [23]
		117, 118, 0xb0004, // [24]
		97, 100, 0x130025, // [25]
		104, 104, 0x1f0005, // [26]
		105, 108, 0x130032, // [27]
		112, 112, 0x1d0005, // [28]
		113, 114, 0xd000c, // [29]
		100, 102, 0xe0013, // [30]
		108, 110, 0xe0013, // [31]
		118, 120, 0x5000b, // [32]
		124, 128, 0x30033, // [33]
	},
	NumStmt: [34]uint16{
		3, // 0
		2, // 1
		1, // 2
		4, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		1, // 18
		1, // 19
		2, // 20
		1, // 21
		2, // 22
		2, // 23
		2, // 24
		3, // 25
		1, // 26
		3, // 27
		1, // 28
		1, // 29
		2, // 30
		2, // 31
		1, // 32
		3, // 33
	},
}
var _ = _cover_atomic_.LoadUint32
