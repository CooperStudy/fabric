//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/standardvalues.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"reflect"

	"github.com/golang/protobuf/proto"
	cb "github.com/hyperledger/fabric/protos/common"
)

// DeserializeGroup deserializes the value for all values in a config group
func DeserializeProtoValuesFromGroup(group *cb.ConfigGroup, protosStructs ...interface{}) error {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[0], 1);
	sv, err := NewStandardValues(protosStructs...)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[3], 1);
		logger.Panicf("This is a compile time bug only, the proto structures are somehow invalid: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[1], 1);for key, value := range group.Values {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[4], 1);
		if _, err := sv.Deserialize(key, value.Value); err != nil {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[5], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[2], 1);return nil
}

type StandardValues struct {
	lookup map[string]proto.Message
}

// NewStandardValues accepts a structure which must contain only protobuf message
// types.  The structure may embed other (non-pointer) structures which satisfy
// the same condition.  NewStandard values will instantiate memory for all the proto
// messages and build a lookup map from structure field name to proto message instance
// This is a useful way to easily implement the Values interface
func NewStandardValues(protosStructs ...interface{}) (*StandardValues, error) {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[6], 1);
	sv := &StandardValues{
		lookup: make(map[string]proto.Message),
	}

	for _, protosStruct := range protosStructs {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[8], 1);
		logger.Debugf("Initializing protos for %T\n", protosStruct)
		if err := sv.initializeProtosStruct(reflect.ValueOf(protosStruct)); err != nil {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[9], 1);
			return nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[7], 1);return sv, nil
}

// Deserialize looks up the backing Values proto of the given name, unmarshals the given bytes
// to populate the backing message structure, and returns a referenced to the retained deserialized
// message (or an error, either because the key did not exist, or there was an an error unmarshaling
func (sv *StandardValues) Deserialize(key string, value []byte) (proto.Message, error) {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[10], 1);
	msg, ok := sv.lookup[key]
	if !ok {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[13], 1);
		return nil, fmt.Errorf("Unexpected key %s", key)
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[11], 1);err := proto.Unmarshal(value, msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[14], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[12], 1);return msg, nil
}

func (sv *StandardValues) initializeProtosStruct(objValue reflect.Value) error {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[15], 1);
	objType := objValue.Type()
	if objType.Kind() != reflect.Ptr {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[19], 1);
		return fmt.Errorf("Non pointer type")
	}
	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[16], 1);if objType.Elem().Kind() != reflect.Struct {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[20], 1);
		return fmt.Errorf("Non struct type")
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[17], 1);numFields := objValue.Elem().NumField()
	for i := 0; i < numFields; i++ {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[21], 1);
		structField := objType.Elem().Field(i)
		logger.Debugf("Processing field: %s\n", structField.Name)
		switch structField.Type.Kind() {
		case reflect.Ptr:_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[25], 1);
			fieldPtr := objValue.Elem().Field(i)
			if !fieldPtr.CanSet() {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[28], 1);
				return fmt.Errorf("Cannot set structure field %s (unexported?)", structField.Name)
			}
			_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[26], 1);fieldPtr.Set(reflect.New(structField.Type.Elem()))
		default:_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[27], 1);
			return fmt.Errorf("Bad type supplied: %s", structField.Type.Kind())
		}

		_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[22], 1);proto, ok := objValue.Elem().Field(i).Interface().(proto.Message)
		if !ok {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[29], 1);
			return fmt.Errorf("Field type %T does not implement proto.Message", objValue.Elem().Field(i))
		}

		_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[23], 1);_, ok = sv.lookup[structField.Name]
		if ok {_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[30], 1);
			return fmt.Errorf("Ambiguous field name specified, multiple occurrences of %s", structField.Name)
		}

		_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[24], 1);sv.lookup[structField.Name] = proto
	}

	_cover_atomic_.AddUint32(&GoCover_13_373339383034363064316135.Count[18], 1);return nil
}

var GoCover_13_373339383034363064316135 = struct {
	Count     [31]uint32
	Pos       [3 * 31]uint32
	NumStmt   [31]uint16
} {
	Pos: [3 * 31]uint32{
		18, 20, 0x100061, // [0]
		24, 24, 0x270002, // [1]
		29, 29, 0xc0002, // [2]
		20, 22, 0x30010, // [3]
		24, 25, 0x3d0027, // [4]
		25, 27, 0x4003d, // [5]
		41, 46, 0x2d004f, // [6]
		53, 53, 0x100002, // [7]
		46, 48, 0x52002d, // [8]
		48, 50, 0x40052, // [9]
		59, 61, 0x90058, // [10]
		65, 66, 0x100002, // [11]
		70, 70, 0x110002, // [12]
		61, 63, 0x30009, // [13]
		66, 68, 0x30010, // [14]
		73, 75, 0x230050, // [15]
		78, 78, 0x2d0002, // [16]
		82, 83, 0x210002, // [17]
		110, 110, 0xc0002, // [18]
		75, 77, 0x30023, // [19]
		78, 80, 0x3002d, // [20]
		83, 86, 0x220021, // [21]
		97, 98, 0xa0003, // [22]
		102, 103, 0x90003, // [23]
		107, 107, 0x260003, // [24]
		87, 89, 0x1a0014, // [25]
		92, 92, 0x360004, // [26]
		93, 94, 0x47000b, // [27]
		89, 91, 0x5001a, // [28]
		98, 100, 0x4000a, // [29]
		103, 105, 0x40009, // [30]
	},
	NumStmt: [31]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		1, // 9
		2, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		3, // 21
		2, // 22
		2, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
	},
}
var _ = _cover_atomic_.LoadUint32
