//line /home/cooper/go/src/github.com/hyperledger/fabric/core/endorser/plugin_endorser.go:1
/*
Copyright IBM Corp. 2018 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package endorser; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/handlers/endorsement/api"
	endorsement3 "github.com/hyperledger/fabric/core/handlers/endorsement/api/identities"
	"github.com/hyperledger/fabric/core/transientstore"
	pb "github.com/hyperledger/fabric/protos/peer"
	putils "github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

//go:generate mockery -dir . -name TransientStoreRetriever -case underscore -output mocks/
//go:generate mockery -dir ../transientstore/ -name Store -case underscore -output mocks/

// TransientStoreRetriever retrieves transient stores
type TransientStoreRetriever interface {
	// StoreForChannel returns the transient store for the given channel
	StoreForChannel(channel string) transientstore.Store
}

//go:generate mockery -dir . -name ChannelStateRetriever -case underscore -output mocks/

// ChannelStateRetriever retrieves Channel state
type ChannelStateRetriever interface {
	// ChannelState returns a QueryCreator for the given Channel
	NewQueryCreator(channel string) (QueryCreator, error)
}

//go:generate mockery -dir . -name PluginMapper -case underscore -output mocks/

// PluginMapper maps plugin names to their corresponding factories
type PluginMapper interface {
	PluginFactoryByName(name PluginName) endorsement.PluginFactory
}

// MapBasedPluginMapper maps plugin names to their corresponding factories
type MapBasedPluginMapper map[string]endorsement.PluginFactory

// PluginFactoryByName returns a plugin factory for the given plugin name, or nil if not found
func (m MapBasedPluginMapper) PluginFactoryByName(name PluginName) endorsement.PluginFactory {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[0], 1);
	return m[string(name)]
}

// Context defines the data that is related to an in-flight endorsement
type Context struct {
	PluginName     string
	Channel        string
	TxID           string
	Proposal       *pb.Proposal
	SignedProposal *pb.SignedProposal
	Visibility     []byte
	Response       *pb.Response
	Event          []byte
	ChaincodeID    *pb.ChaincodeID
	SimRes         []byte
}

// String returns a text representation of this context
func (c Context) String() string {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[1], 1);
	return fmt.Sprintf("{plugin: %s, channel: %s, tx: %s, chaincode: %s}", c.PluginName, c.Channel, c.TxID, c.ChaincodeID.Name)
}

// PluginSupport aggregates the support interfaces
// needed for the operation of the plugin endorser
type PluginSupport struct {
	ChannelStateRetriever
	endorsement3.SigningIdentityFetcher
	PluginMapper
	TransientStoreRetriever
}

// NewPluginEndorser endorses with using a plugin
func NewPluginEndorser(ps *PluginSupport) *PluginEndorser {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[2], 1);
	return &PluginEndorser{
		SigningIdentityFetcher:  ps.SigningIdentityFetcher,
		PluginMapper:            ps.PluginMapper,
		pluginChannelMapping:    make(map[PluginName]*pluginsByChannel),
		ChannelStateRetriever:   ps.ChannelStateRetriever,
		TransientStoreRetriever: ps.TransientStoreRetriever,
	}
}

// PluginName defines the name of the plugin as it appears in the configuration
type PluginName string

type pluginsByChannel struct {
	sync.RWMutex
	pluginFactory    endorsement.PluginFactory
	channels2Plugins map[string]endorsement.Plugin
	pe               *PluginEndorser
}

func (pbc *pluginsByChannel) createPluginIfAbsent(channel string) (endorsement.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[3], 1);
	pbc.RLock()
	plugin, exists := pbc.channels2Plugins[channel]
	pbc.RUnlock()
	if exists {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[7], 1);
		return plugin, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[4], 1);pbc.Lock()
	defer pbc.Unlock()
	plugin, exists = pbc.channels2Plugins[channel]
	if exists {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[8], 1);
		return plugin, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[5], 1);pluginInstance := pbc.pluginFactory.New()
	plugin, err := pbc.initPlugin(pluginInstance, channel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[9], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[6], 1);pbc.channels2Plugins[channel] = plugin
	return plugin, nil
}

func (pbc *pluginsByChannel) initPlugin(plugin endorsement.Plugin, channel string) (endorsement.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[10], 1);
	var dependencies []endorsement.Dependency
	var err error
	// If this is a channel endorsement, add the channel state as a dependency
	if channel != "" {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[13], 1);
		query, err := pbc.pe.NewQueryCreator(channel)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[16], 1);
			return nil, errors.Wrap(err, "failed obtaining channel state")
		}
		_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[14], 1);store := pbc.pe.TransientStoreRetriever.StoreForChannel(channel)
		if store == nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[17], 1);
			return nil, errors.Errorf("transient store for channel %s was not initialized", channel)
		}
		_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[15], 1);dependencies = append(dependencies, &ChannelState{QueryCreator: query, Store: store})
	}
	// Add the SigningIdentityFetcher as a dependency
	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[11], 1);dependencies = append(dependencies, pbc.pe.SigningIdentityFetcher)
	err = plugin.Init(dependencies...)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[18], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[12], 1);return plugin, nil
}

// PluginEndorser endorsers proposal responses using plugins
type PluginEndorser struct {
	sync.Mutex
	PluginMapper
	pluginChannelMapping map[PluginName]*pluginsByChannel
	ChannelStateRetriever
	endorsement3.SigningIdentityFetcher
	TransientStoreRetriever
}

// EndorseWithPlugin endorses the response with a plugin
func (pe *PluginEndorser) EndorseWithPlugin(ctx Context) (*pb.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[19], 1);
	endorserLogger.Debug("Entering endorsement for", ctx)

	if ctx.Response == nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[25], 1);
		return nil, errors.New("response is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[20], 1);if ctx.Response.Status >= shim.ERRORTHRESHOLD {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[26], 1);
		return &pb.ProposalResponse{Response: ctx.Response}, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[21], 1);plugin, err := pe.getOrCreatePlugin(PluginName(ctx.PluginName), ctx.Channel)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[27], 1);
		endorserLogger.Warning("Endorsement with plugin for", ctx, " failed:", err)
		return nil, errors.Errorf("plugin with name %s could not be used: %v", ctx.PluginName, err)
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[22], 1);prpBytes, err := proposalResponsePayloadFromContext(ctx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[28], 1);
		endorserLogger.Warning("Endorsement with plugin for", ctx, " failed:", err)
		return nil, errors.Wrap(err, "failed assembling proposal response payload")
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[23], 1);endorsement, prpBytes, err := plugin.Endorse(prpBytes, ctx.SignedProposal)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[29], 1);
		endorserLogger.Warning("Endorsement with plugin for", ctx, " failed:", err)
		return nil, errors.WithStack(err)
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[24], 1);resp := &pb.ProposalResponse{
		Version:     1,
		Endorsement: endorsement,
		Payload:     prpBytes,
		Response:    ctx.Response,
	}
	endorserLogger.Debug("Exiting", ctx)
	return resp, nil
}

// getAndStorePlugin returns a plugin instance for the given plugin name and channel
func (pe *PluginEndorser) getOrCreatePlugin(plugin PluginName, channel string) (endorsement.Plugin, error) {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[30], 1);
	pluginFactory := pe.PluginFactoryByName(plugin)
	if pluginFactory == nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[32], 1);
		return nil, errors.Errorf("plugin with name %s wasn't found", plugin)
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[31], 1);pluginsByChannel := pe.getOrCreatePluginChannelMapping(PluginName(plugin), pluginFactory)
	return pluginsByChannel.createPluginIfAbsent(channel)
}

func (pe *PluginEndorser) getOrCreatePluginChannelMapping(plugin PluginName, pf endorsement.PluginFactory) *pluginsByChannel {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[33], 1);
	pe.Lock()
	defer pe.Unlock()
	endorserChannelMapping, exists := pe.pluginChannelMapping[PluginName(plugin)]
	if !exists {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[35], 1);
		endorserChannelMapping = &pluginsByChannel{
			pluginFactory:    pf,
			channels2Plugins: make(map[string]endorsement.Plugin),
			pe:               pe,
		}
		pe.pluginChannelMapping[PluginName(plugin)] = endorserChannelMapping
	}
	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[34], 1);return endorserChannelMapping
}

func proposalResponsePayloadFromContext(ctx Context) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[36], 1);
	hdr, err := putils.GetHeader(ctx.Proposal.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[40], 1);
		endorserLogger.Warning("Failed parsing header", err)
		return nil, errors.Wrap(err, "failed parsing header")
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[37], 1);pHashBytes, err := putils.GetProposalHash1(hdr, ctx.Proposal.Payload, ctx.Visibility)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[41], 1);
		endorserLogger.Warning("Failed computing proposal hash", err)
		return nil, errors.Wrap(err, "could not compute proposal hash")
	}

	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[38], 1);prpBytes, err := putils.GetBytesProposalResponsePayload(pHashBytes, ctx.Response, ctx.SimRes, ctx.Event, ctx.ChaincodeID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[42], 1);
		endorserLogger.Warning("Failed marshaling the proposal response payload to bytes", err)
		return nil, errors.New("failure while marshaling the ProposalResponsePayload")
	}
	_cover_atomic_.AddUint32(&GoCover_1_306432633236306362313365.Count[39], 1);return prpBytes, nil
}

var GoCover_1_306432633236306362313365 = struct {
	Count     [43]uint32
	Pos       [3 * 43]uint32
	NumStmt   [43]uint16
} {
	Pos: [3 * 43]uint32{
		50, 52, 0x2005e, // [0]
		69, 71, 0x20022, // [1]
		83, 91, 0x2003b, // [2]
		103, 107, 0xc005f, // [3]
		111, 114, 0xc0002, // [4]
		118, 120, 0x100002, // [5]
		123, 124, 0x140002, // [6]
		107, 109, 0x3000c, // [7]
		114, 116, 0x3000c, // [8]
		120, 122, 0x30010, // [9]
		127, 131, 0x130070, // [10]
		143, 145, 0x100002, // [11]
		148, 148, 0x140002, // [12]
		131, 133, 0x110013, // [13]
		136, 137, 0x130003, // [14]
		140, 140, 0x580003, // [15]
		133, 135, 0x40011, // [16]
		137, 139, 0x40013, // [17]
		145, 147, 0x30010, // [18]
		162, 165, 0x190058, // [19]
		169, 169, 0x300002, // [20]
		173, 174, 0x100002, // [21]
		179, 180, 0x100002, // [22]
		185, 186, 0x100002, // [23]
		191, 198, 0x120002, // [24]
		165, 167, 0x30019, // [25]
		169, 171, 0x30030, // [26]
		174, 177, 0x30010, // [27]
		180, 183, 0x30010, // [28]
		186, 189, 0x30010, // [29]
		202, 204, 0x1a006c, // [30]
		208, 209, 0x370002, // [31]
		204, 206, 0x3001a, // [32]
		212, 216, 0xd007e, // [33]
		224, 224, 0x1f0002, // [34]
		216, 223, 0x3000d, // [35]
		227, 229, 0x100046, // [36]
		234, 235, 0x100002, // [37]
		240, 241, 0x100002, // [38]
		245, 245, 0x160002, // [39]
		229, 232, 0x30010, // [40]
		235, 238, 0x30010, // [41]
		241, 244, 0x30010, // [42]
	},
	NumStmt: [43]uint16{
		1, // 0
		1, // 1
		1, // 2
		4, // 3
		4, // 4
		3, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		3, // 10
		3, // 11
		1, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		2, // 21
		2, // 22
		2, // 23
		3, // 24
		1, // 25
		1, // 26
		2, // 27
		2, // 28
		2, // 29
		2, // 30
		2, // 31
		1, // 32
		4, // 33
		1, // 34
		2, // 35
		2, // 36
		2, // 37
		2, // 38
		1, // 39
		2, // 40
		2, // 41
		2, // 42
	},
}
var _ = _cover_atomic_.LoadUint32
