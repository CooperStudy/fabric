//line /home/cooper/go/src/github.com/hyperledger/fabric/core/common/validation/statebased/validator_keylevel.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package statebased; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	commonerrors "github.com/hyperledger/fabric/common/errors"
	"github.com/hyperledger/fabric/core/handlers/validation/api/policies"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

/**********************************************************************************************************/
/**********************************************************************************************************/

type policyChecker struct {
	someEPChecked bool
	ccEPChecked   bool
	vpmgr         KeyLevelValidationParameterManager
	policySupport validation.PolicyEvaluator
	ccEP          []byte
	signatureSet  []*common.SignedData
}

func (p *policyChecker) checkCCEPIfCondition(cc string, blockNum, txNum uint64, condition bool) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[0], 1);
	if condition {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[3], 1);
		return nil
	}

	// validate against cc ep
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[1], 1);err := p.policySupport.Evaluate(p.ccEP, p.signatureSet)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[4], 1);
		return policyErr(errors.Wrapf(err, "validation of endorsement policy for chaincode %s in tx %d:%d failed", cc, blockNum, txNum))
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[2], 1);p.ccEPChecked = true
	p.someEPChecked = true
	return nil
}

func (p *policyChecker) checkCCEPIfNotChecked(cc string, blockNum, txNum uint64) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[5], 1);
	return p.checkCCEPIfCondition(cc, blockNum, txNum, p.ccEPChecked)
}

func (p *policyChecker) checkCCEPIfNoEPChecked(cc string, blockNum, txNum uint64) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[6], 1);
	return p.checkCCEPIfCondition(cc, blockNum, txNum, p.someEPChecked)
}

func (p *policyChecker) checkSBAndCCEP(cc, coll, key string, blockNum, txNum uint64) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[7], 1);
	// see if there is a key-level validation parameter for this key
	vp, err := p.vpmgr.GetValidationParameterForKey(cc, coll, key, blockNum, txNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[11], 1);
		// error handling for GetValidationParameterForKey follows this rationale:
		switch err := errors.Cause(err).(type) {
		// 1) if there is a conflict because validation params have been updated
		//    by another transaction in this block, we will get ValidationParameterUpdatedError.
		//    This should lead to invalidating the transaction by calling policyErr
		case *ValidationParameterUpdatedError:_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[12], 1);
			return policyErr(err)
		// 2) if the ledger returns "determinstic" errors, that is, errors that
		//    every peer in the channel will also return (such as errors linked to
		//    an attempt to retrieve metadata from a non-defined collection) should be
		//    logged and ignored. The ledger will take the most appropriate action
		//    when performing its side of the validation.
		case *ledger.CollConfigNotDefinedError, *ledger.InvalidCollNameError:_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[13], 1);
			logger.Warningf(errors.WithMessage(err, "skipping key-level validation").Error())
			err = nil
		// 3) any other type of error should return an execution failure which will
		//    lead to halting the processing on this channel. Note that any non-categorized
		//    deterministic error would be caught by the default and would lead to
		//    a processing halt. This would certainly be a bug, but - in the absence of a
		//    single, well-defined deterministic error returned by the ledger, it is
		//    best to err on the side of caution and rather halt processing (because a
		//    deterministic error is treated like an I/O one) rather than risking a fork
		//    (in case an I/O error is treated as a deterministic one).
		default:_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[14], 1);
			return &commonerrors.VSCCExecutionFailureError{
				Err: err,
			}
		}
	}

	// if no key-level validation parameter has been specified, the regular cc endorsement policy needs to hold
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[8], 1);if len(vp) == 0 {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[15], 1);
		return p.checkCCEPIfNotChecked(cc, blockNum, txNum)
	}

	// validate against key-level vp
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[9], 1);err = p.policySupport.Evaluate(vp, p.signatureSet)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[16], 1);
		return policyErr(errors.Wrapf(err, "validation of key %s (coll'%s':ns'%s') in tx %d:%d failed", key, coll, cc, blockNum, txNum))
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[10], 1);p.someEPChecked = true

	return nil
}

/**********************************************************************************************************/
/**********************************************************************************************************/

type blockDependency struct {
	mutex     sync.Mutex
	blockNum  uint64
	txDepOnce []sync.Once
}

// KeyLevelValidator implements per-key level ep validation
type KeyLevelValidator struct {
	vpmgr         KeyLevelValidationParameterManager
	policySupport validation.PolicyEvaluator
	blockDep      blockDependency
}

func NewKeyLevelValidator(policySupport validation.PolicyEvaluator, vpmgr KeyLevelValidationParameterManager) *KeyLevelValidator {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[17], 1);
	return &KeyLevelValidator{
		vpmgr:         vpmgr,
		policySupport: policySupport,
		blockDep:      blockDependency{},
	}
}

func (klv *KeyLevelValidator) invokeOnce(block *common.Block, txnum uint64) *sync.Once {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[18], 1);
	klv.blockDep.mutex.Lock()
	defer klv.blockDep.mutex.Unlock()

	if klv.blockDep.blockNum != block.Header.Number {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[20], 1);
		klv.blockDep.blockNum = block.Header.Number
		klv.blockDep.txDepOnce = make([]sync.Once, len(block.Data.Data))
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[19], 1);return &klv.blockDep.txDepOnce[txnum]
}

func (klv *KeyLevelValidator) extractDependenciesForTx(blockNum, txNum uint64, envelopeBytes []byte) {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[21], 1);
	env, err := utils.GetEnvelopeFromBlock(envelopeBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[28], 1);
		logger.Warningf("while executing GetEnvelopeFromBlock got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[22], 1);payl, err := utils.GetPayload(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[29], 1);
		logger.Warningf("while executing GetPayload got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[23], 1);tx, err := utils.GetTransaction(payl.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[30], 1);
		logger.Warningf("while executing GetTransaction got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[24], 1);cap, err := utils.GetChaincodeActionPayload(tx.Actions[0].Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[31], 1);
		logger.Warningf("while executing GetChaincodeActionPayload got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[25], 1);pRespPayload, err := utils.GetProposalResponsePayload(cap.Action.ProposalResponsePayload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[32], 1);
		logger.Warningf("while executing GetProposalResponsePayload got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[26], 1);respPayload, err := utils.GetChaincodeAction(pRespPayload.Extension)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[33], 1);
		logger.Warningf("while executing GetChaincodeAction got error '%s', skipping tx at height (%d,%d)", err, blockNum, txNum)
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[27], 1);klv.vpmgr.ExtractValidationParameterDependency(blockNum, txNum, respPayload.Results)
}

// PreValidate implements the function of the StateBasedValidator interface
func (klv *KeyLevelValidator) PreValidate(txNum uint64, block *common.Block) {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[34], 1);
	for i := int64(txNum); i >= 0; i-- {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[35], 1);
		txPosition := uint64(i)

		klv.invokeOnce(block, txPosition).Do(
			func() {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[36], 1);
				klv.extractDependenciesForTx(block.Header.Number, txPosition, block.Data.Data[txPosition])
			})
	}
}

// Validate implements the function of the StateBasedValidator interface
func (klv *KeyLevelValidator) Validate(cc string, blockNum, txNum uint64, rwsetBytes, prp, ccEP []byte, endorsements []*peer.Endorsement) commonerrors.TxValidationError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[37], 1);
	// construct signature set
	signatureSet := []*common.SignedData{}
	for _, endorsement := range endorsements {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[41], 1);
		data := make([]byte, len(prp)+len(endorsement.Endorser))
		copy(data, prp)
		copy(data[len(prp):], endorsement.Endorser)

		signatureSet = append(signatureSet, &common.SignedData{
			// set the data that is signed; concatenation of proposal response bytes and endorser ID
			Data: data,
			// set the identity that signs the message: it's the endorser
			Identity: endorsement.Endorser,
			// set the signature
			Signature: endorsement.Signature})
	}

	// construct the policy checker object
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[38], 1);policyChecker := policyChecker{
		ccEP:          ccEP,
		policySupport: klv.policySupport,
		signatureSet:  signatureSet,
		vpmgr:         klv.vpmgr,
	}

	// unpack the rwset
	rwset := &rwsetutil.TxRwSet{}
	if err := rwset.FromProtoBytes(rwsetBytes); err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[42], 1);
		return policyErr(errors.WithMessage(err, fmt.Sprintf("txRWSet.FromProtoBytes failed on tx (%d,%d)", blockNum, txNum)))
	}

	// iterate over all writes in the rwset
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[39], 1);for _, nsRWSet := range rwset.NsRwSets {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[43], 1);
		// skip other namespaces
		if nsRWSet.NameSpace != cc {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[48], 1);
			continue
		}

		// public writes
		// we validate writes against key-level validation parameters
		// if any are present or the chaincode-wide endorsement policy
		_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[44], 1);for _, pubWrite := range nsRWSet.KvRwSet.Writes {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[49], 1);
			err := policyChecker.checkSBAndCCEP(cc, "", pubWrite.Key, blockNum, txNum)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[50], 1);
				return err
			}
		}
		// public metadata writes
		// we validate writes against key-level validation parameters
		// if any are present or the chaincode-wide endorsement policy
		_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[45], 1);for _, pubMdWrite := range nsRWSet.KvRwSet.MetadataWrites {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[51], 1);
			err := policyChecker.checkSBAndCCEP(cc, "", pubMdWrite.Key, blockNum, txNum)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[52], 1);
				return err
			}
		}
		// writes in collections
		// we validate writes against key-level validation parameters
		// if any are present or the chaincode-wide endorsement policy
		_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[46], 1);for _, collRWSet := range nsRWSet.CollHashedRwSets {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[53], 1);
			coll := collRWSet.CollectionName
			for _, hashedWrite := range collRWSet.HashedRwSet.HashedWrites {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[54], 1);
				key := string(hashedWrite.KeyHash)
				err := policyChecker.checkSBAndCCEP(cc, coll, key, blockNum, txNum)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[55], 1);
					return err
				}
			}
		}
		// metadata writes in collections
		// we validate writes against key-level validation parameters
		// if any are present or the chaincode-wide endorsement policy
		_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[47], 1);for _, collRWSet := range nsRWSet.CollHashedRwSets {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[56], 1);
			coll := collRWSet.CollectionName
			for _, hashedMdWrite := range collRWSet.HashedRwSet.MetadataWrites {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[57], 1);
				key := string(hashedMdWrite.KeyHash)
				err := policyChecker.checkSBAndCCEP(cc, coll, key, blockNum, txNum)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[58], 1);
					return err
				}
			}
		}
	}

	// we make sure that we check at least the CCEP to honour FAB-9473
	_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[40], 1);return policyChecker.checkCCEPIfNoEPChecked(cc, blockNum, txNum)
}

// PostValidate implements the function of the StateBasedValidator interface
func (klv *KeyLevelValidator) PostValidate(cc string, blockNum, txNum uint64, err error) {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[59], 1);
	klv.vpmgr.SetTxValidationResult(cc, blockNum, txNum, err)
}

func policyErr(err error) *commonerrors.VSCCEndorsementPolicyError {_cover_atomic_.AddUint32(&GoCover_0_616264363130383339383531.Count[60], 1);
	return &commonerrors.VSCCEndorsementPolicyError{
		Err: err,
	}
}

var GoCover_0_616264363130383339383531 = struct {
	Count     [61]uint32
	Pos       [3 * 61]uint32
	NumStmt   [61]uint16
} {
	Pos: [3 * 61]uint32{
		35, 36, 0xf0080, // [0]
		41, 42, 0x100002, // [1]
		46, 48, 0xc0002, // [2]
		36, 38, 0x3000f, // [3]
		42, 44, 0x30010, // [4]
		51, 53, 0x20071, // [5]
		55, 57, 0x20072, // [6]
		59, 62, 0x100075, // [7]
		94, 94, 0x120002, // [8]
		99, 100, 0x100002, // [9]
		104, 106, 0xc0002, // [10]
		62, 64, 0x2a0010, // [11]
		68, 69, 0x190029, // [12]
		75, 77, 0xd0048, // [13]
		86, 89, 0x5000b, // [14]
		94, 96, 0x30012, // [15]
		100, 102, 0x30010, // [16]
		125, 131, 0x20082, // [17]
		133, 137, 0x320058, // [18]
		142, 142, 0x270002, // [19]
		137, 140, 0x30032, // [20]
		145, 147, 0x100066, // [21]
		152, 153, 0x100002, // [22]
		158, 159, 0x100002, // [23]
		164, 165, 0x100002, // [24]
		170, 171, 0x100002, // [25]
		176, 177, 0x100002, // [26]
		182, 182, 0x560002, // [27]
		147, 150, 0x30010, // [28]
		153, 156, 0x30010, // [29]
		159, 162, 0x30010, // [30]
		165, 168, 0x30010, // [31]
		171, 174, 0x30010, // [32]
		177, 180, 0x30010, // [33]
		186, 187, 0x25004e, // [34]
		187, 191, 0xb0025, // [35]
		191, 193, 0x5000b, // [36]
		198, 201, 0x2b00aa, // [37]
		216, 225, 0x390002, // [38]
		230, 230, 0x290002, // [39]
		283, 283, 0x420002, // [40]
		201, 213, 0x3002b, // [41]
		225, 227, 0x30039, // [42]
		230, 232, 0x1e0029, // [43]
		239, 239, 0x330003, // [44]
		248, 248, 0x3d0003, // [45]
		257, 257, 0x360003, // [46]
		270, 270, 0x360003, // [47]
		232, 233, 0xc001e, // [48]
		239, 241, 0x120033, // [49]
		241, 243, 0x50012, // [50]
		248, 250, 0x12003d, // [51]
		250, 252, 0x50012, // [52]
		257, 259, 0x430036, // [53]
		259, 262, 0x130043, // [54]
		262, 264, 0x60013, // [55]
		270, 272, 0x470036, // [56]
		272, 275, 0x130047, // [57]
		275, 277, 0x60013, // [58]
		287, 289, 0x2005a, // [59]
		291, 295, 0x20044, // [60]
	},
	NumStmt: [61]uint16{
		1, // 0
		2, // 1
		3, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		3, // 18
		1, // 19
		2, // 20
		2, // 21
		2, // 22
		2, // 23
		2, // 24
		2, // 25
		2, // 26
		1, // 27
		2, // 28
		2, // 29
		2, // 30
		2, // 31
		2, // 32
		2, // 33
		1, // 34
		2, // 35
		1, // 36
		2, // 37
		3, // 38
		1, // 39
		1, // 40
		4, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		1, // 50
		2, // 51
		1, // 52
		2, // 53
		3, // 54
		1, // 55
		2, // 56
		3, // 57
		1, // 58
		1, // 59
		1, // 60
	},
}
var _ = _cover_atomic_.LoadUint32
