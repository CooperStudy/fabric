//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/platforms/ccmetadata/validators.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package ccmetadata; import _cover_atomic_ "sync/atomic"

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
)

// fileValidators are used as handlers to validate specific metadata directories
type fileValidator func(fileName string, fileBytes []byte) error

// AllowedCharsCollectionName captures the regex pattern for a valid collection name
const AllowedCharsCollectionName = "[A-Za-z0-9_-]+"

// Currently, the only metadata expected and allowed is for META-INF/statedb/couchdb/indexes.
var fileValidators = map[*regexp.Regexp]fileValidator{
	regexp.MustCompile("^META-INF/statedb/couchdb/indexes/.*[.]json"):                                                couchdbIndexFileValidator,
	regexp.MustCompile("^META-INF/statedb/couchdb/collections/" + AllowedCharsCollectionName + "/indexes/.*[.]json"): couchdbIndexFileValidator,
}

var collectionNameValid = regexp.MustCompile("^" + AllowedCharsCollectionName)

var fileNameValid = regexp.MustCompile("^.*[.]json")

var validDatabases = []string{"couchdb"}

// UnhandledDirectoryError is returned for metadata files in unhandled directories
type UnhandledDirectoryError struct {
	err string
}

func (e *UnhandledDirectoryError) Error() string {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[0], 1);
	return e.err
}

// InvalidIndexContentError is returned for metadata files with invalid content
type InvalidIndexContentError struct {
	err string
}

func (e *InvalidIndexContentError) Error() string {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[1], 1);
	return e.err
}

// ValidateMetadataFile checks that metadata files are valid
// according to the validation rules of the file's directory
func ValidateMetadataFile(filePathName string, fileBytes []byte) error {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[2], 1);
	// Get the validator handler for the metadata directory
	fileValidator := selectFileValidator(filePathName)

	// If there is no validator handler for metadata directory, return UnhandledDirectoryError
	if fileValidator == nil {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[5], 1);
		return &UnhandledDirectoryError{buildMetadataFileErrorMessage(filePathName)}
	}

	// If the file is not valid for the given directory-based validator, return the corresponding error
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[3], 1);err := fileValidator(filePathName, fileBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[6], 1);
		return err
	}

	// file is valid, return nil error
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[4], 1);return nil
}

func buildMetadataFileErrorMessage(filePathName string) string {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[7], 1);

	dir, filename := filepath.Split(filePathName)

	if !strings.HasPrefix(filePathName, "META-INF/statedb") {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[16], 1);
		return fmt.Sprintf("metadata file path must begin with META-INF/statedb, found: %s", dir)
	}
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[8], 1);directoryArray := strings.Split(filepath.Clean(dir), "/")
	// verify the minimum directory depth
	if len(directoryArray) < 4 {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[17], 1);
		return fmt.Sprintf("metadata file path must include a database and index directory: %s", dir)
	}
	// validate the database type
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[9], 1);if !contains(validDatabases, directoryArray[2]) {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[18], 1);
		return fmt.Sprintf("database name [%s] is not supported, valid options: %s", directoryArray[2], validDatabases)
	}
	// verify "indexes" is under the database name
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[10], 1);if len(directoryArray) == 4 && directoryArray[3] != "indexes" {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[19], 1);
		return fmt.Sprintf("metadata file path does not have an indexes directory: %s", dir)
	}
	// if this is for collections, check the path length
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[11], 1);if len(directoryArray) != 6 {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[20], 1);
		return fmt.Sprintf("metadata file path for collections must include a collections and index directory: %s", dir)
	}
	// verify "indexes" is under the collections and collection directories
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[12], 1);if directoryArray[3] != "collections" || directoryArray[5] != "indexes" {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[21], 1);
		return fmt.Sprintf("metadata file path for collections must have a collections and indexes directory: %s", dir)
	}
	// validate the collection name
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[13], 1);if !collectionNameValid.MatchString(directoryArray[4]) {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[22], 1);
		return fmt.Sprintf("collection name is not valid: %s", directoryArray[4])
	}

	// validate the file name
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[14], 1);if !fileNameValid.MatchString(filename) {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[23], 1);
		return fmt.Sprintf("artifact file name is not valid: %s", filename)
	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[15], 1);return fmt.Sprintf("metadata file path or name is not supported: %s", dir)

}

func contains(validStrings []string, target string) bool {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[24], 1);
	for _, str := range validStrings {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[26], 1);
		if str == target {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[27], 1);
			return true
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[25], 1);return false
}

func selectFileValidator(filePathName string) fileValidator {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[28], 1);
	for validateExp, fileValidator := range fileValidators {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[30], 1);
		isValid := validateExp.MatchString(filePathName)
		if isValid {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[31], 1);
			return fileValidator
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[29], 1);return nil
}

// couchdbIndexFileValidator implements fileValidator
func couchdbIndexFileValidator(fileName string, fileBytes []byte) error {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[32], 1);

	// if the content does not validate as JSON, return err to invalidate the file
	boolIsJSON, indexDefinition := isJSON(fileBytes)
	if !boolIsJSON {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[35], 1);
		return &InvalidIndexContentError{fmt.Sprintf("Index metadata file [%s] is not a valid JSON", fileName)}
	}

	// validate the index definition
	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[33], 1);err := validateIndexJSON(indexDefinition)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[36], 1);
		return &InvalidIndexContentError{fmt.Sprintf("Index metadata file [%s] is not a valid index definition: %s", fileName, err)}
	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[34], 1);return nil

}

// isJSON tests a string to determine if it can be parsed as valid JSON
func isJSON(s []byte) (bool, map[string]interface{}) {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[37], 1);
	var js map[string]interface{}
	return json.Unmarshal([]byte(s), &js) == nil, js
}

func validateIndexJSON(indexDefinition map[string]interface{}) error {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[38], 1);

	//flag to track if the "index" key is included
	indexIncluded := false

	//iterate through the JSON index definition
	for jsonKey, jsonValue := range indexDefinition {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[41], 1);

		//create a case for the top level entries
		switch jsonKey {

		case "index":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[42], 1);

			if reflect.TypeOf(jsonValue).Kind() != reflect.Map {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[52], 1);
				return fmt.Errorf("Invalid entry, \"index\" must be a JSON")
			}

			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[43], 1);err := processIndexMap(jsonValue.(map[string]interface{}))
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[53], 1);
				return err
			}

			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[44], 1);indexIncluded = true

		case "ddoc":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[45], 1);

			//Verify the design doc is a string
			if reflect.TypeOf(jsonValue).Kind() != reflect.String {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[54], 1);
				return fmt.Errorf("Invalid entry, \"ddoc\" must be a string")
			}

			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[46], 1);logger.Debugf("Found index object: \"%s\":\"%s\"", jsonKey, jsonValue)

		case "name":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[47], 1);

			//Verify the name is a string
			if reflect.TypeOf(jsonValue).Kind() != reflect.String {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[55], 1);
				return fmt.Errorf("Invalid entry, \"name\" must be a string")
			}

			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[48], 1);logger.Debugf("Found index object: \"%s\":\"%s\"", jsonKey, jsonValue)

		case "type":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[49], 1);

			if jsonValue != "json" {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[56], 1);
				return fmt.Errorf("Index type must be json")
			}

			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[50], 1);logger.Debugf("Found index object: \"%s\":\"%s\"", jsonKey, jsonValue)

		default:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[51], 1);

			return fmt.Errorf("Invalid Entry.  Entry %s", jsonKey)

		}

	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[39], 1);if !indexIncluded {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[57], 1);
		return fmt.Errorf("Index definition must include a \"fields\" definition")
	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[40], 1);return nil

}

//processIndexMap processes an interface map and wraps field names or traverses
//the next level of the json query
func processIndexMap(jsonFragment map[string]interface{}) error {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[58], 1);

	//iterate the item in the map
	for jsonKey, jsonValue := range jsonFragment {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[60], 1);

		switch jsonKey {

		case "fields":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[61], 1);

			switch jsonValueType := jsonValue.(type) {

			case []interface{}:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[64], 1);

				//iterate the index field objects
				for _, itemValue := range jsonValueType {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[66], 1);

					switch reflect.TypeOf(itemValue).Kind() {

					case reflect.String:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[67], 1);
						//String is a valid field descriptor  ex: "color", "size"
						logger.Debugf("Found index field name: \"%s\"", itemValue)

					case reflect.Map:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[68], 1);
						//Handle the case where a sort is included  ex: {"size":"asc"}, {"color":"desc"}
						err := validateFieldMap(itemValue.(map[string]interface{}))
						if err != nil {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[69], 1);
							return err
						}

					}
				}

			default:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[65], 1);
				return fmt.Errorf("Expecting a JSON array of fields")
			}

		case "partial_filter_selector":_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[62], 1);

			//TODO - add support for partial filter selector, for now return nil
			//Take no other action, will be considered valid for now

		default:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[63], 1);

			//if anything other than "fields" or "partial_filter_selector" was found,
			//return an error
			return fmt.Errorf("Invalid Entry.  Entry %s", jsonKey)

		}

	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[59], 1);return nil

}

//validateFieldMap validates the list of field objects
func validateFieldMap(jsonFragment map[string]interface{}) error {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[70], 1);

	//iterate the fields to validate the sort criteria
	for jsonKey, jsonValue := range jsonFragment {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[72], 1);

		switch jsonValue.(type) {

		case string:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[73], 1);
			//Ensure the sort is either "asc" or "desc"
			if !(strings.ToLower(jsonValue.(string)) == "asc" || strings.ToLower(jsonValue.(string)) == "desc") {_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[76], 1);
				return fmt.Errorf("Sort must be either \"asc\" or \"desc\".  \"%s\" was found.", jsonValue)
			}
			_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[74], 1);logger.Debugf("Found index field name: \"%s\":\"%s\"", jsonKey, jsonValue)

		default:_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[75], 1);
			return fmt.Errorf("Invalid field definition, fields must be in the form \"fieldname\":\"sort\"")

		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_653463396433393233376434.Count[71], 1);return nil

}

var GoCover_2_653463396433393233376434 = struct {
	Count     [77]uint32
	Pos       [3 * 77]uint32
	NumStmt   [77]uint16
} {
	Pos: [3 * 77]uint32{
		41, 43, 0x20032, // [0]
		50, 52, 0x20033, // [1]
		56, 61, 0x1a0048, // [2]
		66, 67, 0x100002, // [3]
		72, 72, 0xc0002, // [4]
		61, 63, 0x3001a, // [5]
		67, 69, 0x30010, // [6]
		75, 79, 0x3a0040, // [7]
		82, 84, 0x1d0002, // [8]
		88, 88, 0x320002, // [9]
		92, 92, 0x400002, // [10]
		96, 96, 0x1e0002, // [11]
		100, 100, 0x4a0002, // [12]
		104, 104, 0x390002, // [13]
		109, 109, 0x2a0002, // [14]
		113, 113, 0x4c0002, // [15]
		79, 81, 0x3003a, // [16]
		84, 86, 0x3001d, // [17]
		88, 90, 0x30032, // [18]
		92, 94, 0x30040, // [19]
		96, 98, 0x3001e, // [20]
		100, 102, 0x3004a, // [21]
		104, 106, 0x30039, // [22]
		109, 111, 0x3002a, // [23]
		117, 118, 0x23003a, // [24]
		123, 123, 0xe0002, // [25]
		118, 119, 0x140023, // [26]
		119, 121, 0x40014, // [27]
		126, 127, 0x39003d, // [28]
		133, 133, 0xc0002, // [29]
		127, 129, 0xe0039, // [30]
		129, 131, 0x4000e, // [31]
		137, 141, 0x110049, // [32]
		146, 147, 0x100002, // [33]
		151, 151, 0xc0002, // [34]
		141, 143, 0x30011, // [35]
		147, 149, 0x30010, // [36]
		156, 159, 0x20036, // [37]
		161, 167, 0x320046, // [38]
		219, 219, 0x140002, // [39]
		223, 223, 0xc0002, // [40]
		167, 170, 0x120032, // [41]
		172, 174, 0x370010, // [42]
		178, 179, 0x120004, // [43]
		183, 183, 0x180004, // [44]
		185, 188, 0x3a000f, // [45]
		192, 192, 0x4a0004, // [46]
		194, 197, 0x3a000f, // [47]
		201, 201, 0x4a0004, // [48]
		203, 205, 0x1b000f, // [49]
		209, 209, 0x4a0004, // [50]
		211, 213, 0x3a000b, // [51]
		174, 176, 0x50037, // [52]
		179, 181, 0x50012, // [53]
		188, 190, 0x5003a, // [54]
		197, 199, 0x5003a, // [55]
		205, 207, 0x5001b, // [56]
		219, 221, 0x30014, // [57]
		229, 232, 0x2f0041, // [58]
		280, 280, 0xc0002, // [59]
		232, 234, 0x12002f, // [60]
		236, 238, 0x2d0011, // [61]
		265, 265, 0x220022, // [62]
		270, 274, 0x3a000b, // [63]
		240, 243, 0x2d0017, // [64]
		261, 262, 0x3a000c, // [65]
		243, 245, 0x2e002d, // [66]
		247, 249, 0x41001a, // [67]
		251, 254, 0x150017, // [68]
		254, 256, 0x80015, // [69]
		285, 288, 0x2f0042, // [70]
		305, 305, 0xc0002, // [71]
		288, 290, 0x1b002f, // [72]
		292, 294, 0x68000f, // [73]
		297, 297, 0x4e0004, // [74]
		299, 300, 0x64000b, // [75]
		294, 296, 0x50068, // [76]
	},
	NumStmt: [77]uint16{
		1, // 0
		1, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		2, // 32
		2, // 33
		1, // 34
		1, // 35
		1, // 36
		2, // 37
		2, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		2, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		0, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		2, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
	},
}
var _ = _cover_atomic_.LoadUint32
