//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/block_stream.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fsblkstorage; import _cover_atomic_ "sync/atomic"

import (
	"bufio"
	"fmt"
	"io"
	"os"

	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
)

// ErrUnexpectedEndOfBlockfile error used to indicate an unexpected end of a file segment
// this can happen mainly if a crash occurs during appening a block and partial block contents
// get written towards the end of the file
var ErrUnexpectedEndOfBlockfile = errors.New("unexpected end of blockfile")

// blockfileStream reads blocks sequentially from a single file.
// It starts from the given offset and can traverse till the end of the file
type blockfileStream struct {
	fileNum       int
	file          *os.File
	reader        *bufio.Reader
	currentOffset int64
}

// blockStream reads blocks sequentially from multiple files.
// it starts from a given file offset and continues with the next
// file segment until the end of the last segment (`endFileNum`)
type blockStream struct {
	rootDir           string
	currentFileNum    int
	endFileNum        int
	currentFileStream *blockfileStream
}

// blockPlacementInfo captures the information related
// to block's placement in the file.
type blockPlacementInfo struct {
	fileNum          int
	blockStartOffset int64
	blockBytesOffset int64
}

///////////////////////////////////
// blockfileStream functions
////////////////////////////////////
func newBlockfileStream(rootDir string, fileNum int, startOffset int64) (*blockfileStream, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[0], 1);
	filePath := deriveBlockfilePath(rootDir, fileNum)
	logger.Debugf("newBlockfileStream(): filePath=[%s], startOffset=[%d]", filePath, startOffset)
	var file *os.File
	var err error
	if file, err = os.OpenFile(filePath, os.O_RDONLY, 0600); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[4], 1);
		return nil, errors.Wrapf(err, "error opening block file %s", filePath)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[1], 1);var newPosition int64
	if newPosition, err = file.Seek(startOffset, 0); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[5], 1);
		return nil, errors.Wrapf(err, "error seeking block file [%s] to startOffset [%d]", filePath, startOffset)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[2], 1);if newPosition != startOffset {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[6], 1);
		panic(fmt.Sprintf("Could not seek block file [%s] to startOffset [%d]. New position = [%d]",
			filePath, startOffset, newPosition))
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[3], 1);s := &blockfileStream{fileNum, file, bufio.NewReader(file), startOffset}
	return s, nil
}

func (s *blockfileStream) nextBlockBytes() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[7], 1);
	blockBytes, _, err := s.nextBlockBytesAndPlacementInfo()
	return blockBytes, err
}

// nextBlockBytesAndPlacementInfo returns bytes for the next block
// along with the offset information in the block file.
// An error `ErrUnexpectedEndOfBlockfile` is returned if a partial written data is detected
// which is possible towards the tail of the file if a crash had taken place during appending of a block
func (s *blockfileStream) nextBlockBytesAndPlacementInfo() ([]byte, *blockPlacementInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[8], 1);
	var lenBytes []byte
	var err error
	var fileInfo os.FileInfo
	moreContentAvailable := true

	if fileInfo, err = s.file.Stat(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[17], 1);
		return nil, nil, errors.Wrapf(err, "error getting block file stat")
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[9], 1);if s.currentOffset == fileInfo.Size() {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[18], 1);
		logger.Debugf("Finished reading file number [%d]", s.fileNum)
		return nil, nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[10], 1);remainingBytes := fileInfo.Size() - s.currentOffset
	// Peek 8 or smaller number of bytes (if remaining bytes are less than 8)
	// Assumption is that a block size would be small enough to be represented in 8 bytes varint
	peekBytes := 8
	if remainingBytes < int64(peekBytes) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[19], 1);
		peekBytes = int(remainingBytes)
		moreContentAvailable = false
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[11], 1);logger.Debugf("Remaining bytes=[%d], Going to peek [%d] bytes", remainingBytes, peekBytes)
	if lenBytes, err = s.reader.Peek(peekBytes); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[20], 1);
		return nil, nil, errors.Wrapf(err, "error peeking [%d] bytes from block file", peekBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[12], 1);length, n := proto.DecodeVarint(lenBytes)
	if n == 0 {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[21], 1);
		// proto.DecodeVarint did not consume any byte at all which means that the bytes
		// representing the size of the block are partial bytes
		if !moreContentAvailable {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[23], 1);
			return nil, nil, ErrUnexpectedEndOfBlockfile
		}
		_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[22], 1);panic(errors.Errorf("Error in decoding varint bytes [%#v]", lenBytes))
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[13], 1);bytesExpected := int64(n) + int64(length)
	if bytesExpected > remainingBytes {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[24], 1);
		logger.Debugf("At least [%d] bytes expected. Remaining bytes = [%d]. Returning with error [%s]",
			bytesExpected, remainingBytes, ErrUnexpectedEndOfBlockfile)
		return nil, nil, ErrUnexpectedEndOfBlockfile
	}
	// skip the bytes representing the block size
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[14], 1);if _, err = s.reader.Discard(n); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[25], 1);
		return nil, nil, errors.Wrapf(err, "error discarding [%d] bytes", n)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[15], 1);blockBytes := make([]byte, length)
	if _, err = io.ReadAtLeast(s.reader, blockBytes, int(length)); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[26], 1);
		logger.Errorf("Error reading [%d] bytes from file number [%d], error: %s", length, s.fileNum, err)
		return nil, nil, errors.Wrapf(err, "error reading [%d] bytes from file number [%d]", length, s.fileNum)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[16], 1);blockPlacementInfo := &blockPlacementInfo{
		fileNum:          s.fileNum,
		blockStartOffset: s.currentOffset,
		blockBytesOffset: s.currentOffset + int64(n)}
	s.currentOffset += int64(n) + int64(length)
	logger.Debugf("Returning blockbytes - length=[%d], placementInfo={%s}", len(blockBytes), blockPlacementInfo)
	return blockBytes, blockPlacementInfo, nil
}

func (s *blockfileStream) close() error {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[27], 1);
	return errors.WithStack(s.file.Close())
}

///////////////////////////////////
// blockStream functions
////////////////////////////////////
func newBlockStream(rootDir string, startFileNum int, startOffset int64, endFileNum int) (*blockStream, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[28], 1);
	startFileStream, err := newBlockfileStream(rootDir, startFileNum, startOffset)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[30], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[29], 1);return &blockStream{rootDir, startFileNum, endFileNum, startFileStream}, nil
}

func (s *blockStream) moveToNextBlockfileStream() error {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[31], 1);
	var err error
	if err = s.currentFileStream.close(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[34], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[32], 1);s.currentFileNum++
	if s.currentFileStream, err = newBlockfileStream(s.rootDir, s.currentFileNum, 0); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[35], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[33], 1);return nil
}

func (s *blockStream) nextBlockBytes() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[36], 1);
	blockBytes, _, err := s.nextBlockBytesAndPlacementInfo()
	return blockBytes, err
}

func (s *blockStream) nextBlockBytesAndPlacementInfo() ([]byte, *blockPlacementInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[37], 1);
	var blockBytes []byte
	var blockPlacementInfo *blockPlacementInfo
	var err error
	if blockBytes, blockPlacementInfo, err = s.currentFileStream.nextBlockBytesAndPlacementInfo(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[40], 1);
		logger.Errorf("Error reading next block bytes from file number [%d]: %s", s.currentFileNum, err)
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[38], 1);logger.Debugf("blockbytes [%d] read from file [%d]", len(blockBytes), s.currentFileNum)
	if blockBytes == nil && (s.currentFileNum < s.endFileNum || s.endFileNum < 0) {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[41], 1);
		logger.Debugf("current file [%d] exhausted. Moving to next file", s.currentFileNum)
		if err = s.moveToNextBlockfileStream(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[43], 1);
			return nil, nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[42], 1);return s.nextBlockBytesAndPlacementInfo()
	}
	_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[39], 1);return blockBytes, blockPlacementInfo, nil
}

func (s *blockStream) close() error {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[44], 1);
	return s.currentFileStream.close()
}

func (i *blockPlacementInfo) String() string {_cover_atomic_.AddUint32(&GoCover_1_386431356532613230373239.Count[45], 1);
	return fmt.Sprintf("fileNum=[%d], startOffset=[%d], bytesOffset=[%d]",
		i.fileNum, i.blockStartOffset, i.blockBytesOffset)
}

var GoCover_1_386431356532613230373239 = struct {
	Count     [46]uint32
	Pos       [3 * 46]uint32
	NumStmt   [46]uint16
} {
	Pos: [3 * 46]uint32{
		54, 59, 0x460063, // [0]
		62, 63, 0x3e0002, // [1]
		66, 66, 0x200002, // [2]
		70, 71, 0xf0002, // [3]
		59, 61, 0x30046, // [4]
		63, 65, 0x3003e, // [5]
		66, 68, 0x280020, // [6]
		74, 77, 0x2003c, // [7]
		83, 89, 0x2f0061, // [8]
		92, 92, 0x280002, // [9]
		96, 100, 0x270002, // [10]
		104, 105, 0x3a0002, // [11]
		108, 109, 0xc0002, // [12]
		117, 118, 0x240002, // [13]
		124, 124, 0x2e0002, // [14]
		127, 128, 0x4c0002, // [15]
		132, 138, 0x2c0002, // [16]
		89, 91, 0x3002f, // [17]
		92, 95, 0x30028, // [18]
		100, 103, 0x30027, // [19]
		105, 107, 0x3003a, // [20]
		109, 112, 0x1c000c, // [21]
		115, 115, 0x490003, // [22]
		112, 114, 0x4001c, // [23]
		118, 122, 0x30024, // [24]
		124, 126, 0x3002e, // [25]
		128, 131, 0x3004c, // [26]
		141, 143, 0x20029, // [27]
		148, 150, 0x100070, // [28]
		153, 153, 0x4e0002, // [29]
		150, 152, 0x30010, // [30]
		156, 158, 0x330039, // [31]
		161, 162, 0x5f0002, // [32]
		165, 165, 0xc0002, // [33]
		158, 160, 0x30033, // [34]
		162, 164, 0x3005f, // [35]
		168, 171, 0x20038, // [36]
		173, 177, 0x6c005d, // [37]
		181, 182, 0x500002, // [38]
		189, 189, 0x2c0002, // [39]
		177, 180, 0x3006c, // [40]
		182, 184, 0x360050, // [41]
		187, 187, 0x2c0003, // [42]
		184, 186, 0x40036, // [43]
		192, 194, 0x20025, // [44]
		196, 199, 0x2002e, // [45]
	},
	NumStmt: [46]uint16{
		5, // 0
		2, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		5, // 8
		1, // 9
		3, // 10
		2, // 11
		2, // 12
		2, // 13
		1, // 14
		2, // 15
		4, // 16
		1, // 17
		2, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		2, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		4, // 37
		2, // 38
		1, // 39
		2, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
	},
}
var _ = _cover_atomic_.LoadUint32
