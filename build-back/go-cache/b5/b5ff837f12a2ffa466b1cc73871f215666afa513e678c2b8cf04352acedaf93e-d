//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/utils/proputils.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package utils; import _cover_atomic_ "sync/atomic"

import (
	"encoding/binary"
	"encoding/hex"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

// GetChaincodeInvocationSpec get the ChaincodeInvocationSpec from the proposal
func GetChaincodeInvocationSpec(prop *peer.Proposal) (*peer.ChaincodeInvocationSpec, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[0], 1);
	if prop == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[4], 1);
		return nil, errors.New("proposal is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[1], 1);_, err := GetHeader(prop.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[5], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[2], 1);ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[6], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[3], 1);cis := &peer.ChaincodeInvocationSpec{}
	err = proto.Unmarshal(ccPropPayload.Input, cis)
	return cis, errors.Wrap(err, "error unmarshaling ChaincodeInvocationSpec")
}

// GetChaincodeProposalContext returns creator and transient
func GetChaincodeProposalContext(prop *peer.Proposal) ([]byte, map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[7], 1);
	if prop == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[17], 1);
		return nil, nil, errors.New("proposal is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[8], 1);if len(prop.Header) == 0 {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[18], 1);
		return nil, nil, errors.New("proposal's header is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[9], 1);if len(prop.Payload) == 0 {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[19], 1);
		return nil, nil, errors.New("proposal's payload is nil")
	}
	// get back the header
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[10], 1);hdr, err := GetHeader(prop.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[20], 1);
		return nil, nil, errors.WithMessage(err, "error extracting header from proposal")
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[11], 1);if hdr == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[21], 1);
		return nil, nil, errors.New("unmarshaled header is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[12], 1);chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[22], 1);
		return nil, nil, errors.WithMessage(err, "error extracting channel header from proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[13], 1);if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[23], 1);
		return nil, nil, errors.WithMessage(err, "invalid proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[14], 1);shdr, err := GetSignatureHeader(hdr.SignatureHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[24], 1);
		return nil, nil, errors.WithMessage(err, "error extracting signature header from proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[15], 1);ccPropPayload, err := GetChaincodeProposalPayload(prop.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[25], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[16], 1);return shdr.Creator, ccPropPayload.TransientMap, nil
}

func validateChannelHeaderType(chdr *common.ChannelHeader, expectedTypes []common.HeaderType) error {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[26], 1);
	for _, t := range expectedTypes {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[28], 1);
		if common.HeaderType(chdr.Type) == t {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[29], 1);
			return nil
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[27], 1);return errors.Errorf("invalid channel header type. expected one of %s, received %s", expectedTypes, common.HeaderType(chdr.Type))
}

// GetHeader Get Header from bytes
func GetHeader(bytes []byte) (*common.Header, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[30], 1);
	hdr := &common.Header{}
	err := proto.Unmarshal(bytes, hdr)
	return hdr, errors.Wrap(err, "error unmarshaling Header")
}

// GetNonce returns the nonce used in Proposal
func GetNonce(prop *peer.Proposal) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[31], 1);
	if prop == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[38], 1);
		return nil, errors.New("proposal is nil")
	}

	// get back the header
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[32], 1);hdr, err := GetHeader(prop.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[39], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[33], 1);chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[40], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[34], 1);if err = validateChannelHeaderType(chdr, []common.HeaderType{common.HeaderType_ENDORSER_TRANSACTION, common.HeaderType_CONFIG}); err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[41], 1);
		return nil, errors.WithMessage(err, "invalid proposal")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[35], 1);shdr, err := GetSignatureHeader(hdr.SignatureHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[42], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[36], 1);if hdr.SignatureHeader == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[43], 1);
		return nil, errors.New("invalid signature header. cannot be nil")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[37], 1);return shdr.Nonce, nil
}

// GetChaincodeHeaderExtension get chaincode header extension given header
func GetChaincodeHeaderExtension(hdr *common.Header) (*peer.ChaincodeHeaderExtension, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[44], 1);
	chdr, err := UnmarshalChannelHeader(hdr.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[46], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[45], 1);chaincodeHdrExt := &peer.ChaincodeHeaderExtension{}
	err = proto.Unmarshal(chdr.Extension, chaincodeHdrExt)
	return chaincodeHdrExt, errors.Wrap(err, "error unmarshaling ChaincodeHeaderExtension")
}

// GetProposalResponse given proposal in bytes
func GetProposalResponse(prBytes []byte) (*peer.ProposalResponse, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[47], 1);
	proposalResponse := &peer.ProposalResponse{}
	err := proto.Unmarshal(prBytes, proposalResponse)
	return proposalResponse, errors.Wrap(err, "error unmarshaling ProposalResponse")
}

// GetChaincodeDeploymentSpec returns a ChaincodeDeploymentSpec given args
func GetChaincodeDeploymentSpec(code []byte, pr *platforms.Registry) (*peer.ChaincodeDeploymentSpec, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[48], 1);
	cds := &peer.ChaincodeDeploymentSpec{}
	err := proto.Unmarshal(code, cds)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[50], 1);
		return nil, errors.Wrap(err, "error unmarshaling ChaincodeDeploymentSpec")
	}

	// FAB-2122: Validate the CDS according to platform specific requirements
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[49], 1);return cds, pr.ValidateDeploymentSpec(cds.CCType(), cds.Bytes())
}

// GetChaincodeAction gets the ChaincodeAction given chaicnode action bytes
func GetChaincodeAction(caBytes []byte) (*peer.ChaincodeAction, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[51], 1);
	chaincodeAction := &peer.ChaincodeAction{}
	err := proto.Unmarshal(caBytes, chaincodeAction)
	return chaincodeAction, errors.Wrap(err, "error unmarshaling ChaincodeAction")
}

// GetResponse gets the Response given response bytes
func GetResponse(resBytes []byte) (*peer.Response, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[52], 1);
	response := &peer.Response{}
	err := proto.Unmarshal(resBytes, response)
	return response, errors.Wrap(err, "error unmarshaling Response")
}

// GetChaincodeEvents gets the ChaincodeEvents given chaincode event bytes
func GetChaincodeEvents(eBytes []byte) (*peer.ChaincodeEvent, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[53], 1);
	chaincodeEvent := &peer.ChaincodeEvent{}
	err := proto.Unmarshal(eBytes, chaincodeEvent)
	return chaincodeEvent, errors.Wrap(err, "error unmarshaling ChaicnodeEvent")
}

// GetProposalResponsePayload gets the proposal response payload
func GetProposalResponsePayload(prpBytes []byte) (*peer.ProposalResponsePayload, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[54], 1);
	prp := &peer.ProposalResponsePayload{}
	err := proto.Unmarshal(prpBytes, prp)
	return prp, errors.Wrap(err, "error unmarshaling ProposalResponsePayload")
}

// GetProposal returns a Proposal message from its bytes
func GetProposal(propBytes []byte) (*peer.Proposal, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[55], 1);
	prop := &peer.Proposal{}
	err := proto.Unmarshal(propBytes, prop)
	return prop, errors.Wrap(err, "error unmarshaling Proposal")
}

// GetPayload Get Payload from Envelope message
func GetPayload(e *common.Envelope) (*common.Payload, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[56], 1);
	payload := &common.Payload{}
	err := proto.Unmarshal(e.Payload, payload)
	return payload, errors.Wrap(err, "error unmarshaling Payload")
}

// GetTransaction Get Transaction from bytes
func GetTransaction(txBytes []byte) (*peer.Transaction, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[57], 1);
	tx := &peer.Transaction{}
	err := proto.Unmarshal(txBytes, tx)
	return tx, errors.Wrap(err, "error unmarshaling Transaction")

}

// GetChaincodeActionPayload Get ChaincodeActionPayload from bytes
func GetChaincodeActionPayload(capBytes []byte) (*peer.ChaincodeActionPayload, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[58], 1);
	cap := &peer.ChaincodeActionPayload{}
	err := proto.Unmarshal(capBytes, cap)
	return cap, errors.Wrap(err, "error unmarshaling ChaincodeActionPayload")
}

// GetChaincodeProposalPayload Get ChaincodeProposalPayload from bytes
func GetChaincodeProposalPayload(bytes []byte) (*peer.ChaincodeProposalPayload, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[59], 1);
	cpp := &peer.ChaincodeProposalPayload{}
	err := proto.Unmarshal(bytes, cpp)
	return cpp, errors.Wrap(err, "error unmarshaling ChaincodeProposalPayload")
}

// GetSignatureHeader Get SignatureHeader from bytes
func GetSignatureHeader(bytes []byte) (*common.SignatureHeader, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[60], 1);
	sh := &common.SignatureHeader{}
	err := proto.Unmarshal(bytes, sh)
	return sh, errors.Wrap(err, "error unmarshaling SignatureHeader")
}

// CreateChaincodeProposal creates a proposal from given input.
// It returns the proposal and the transaction id associated to the proposal
func CreateChaincodeProposal(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[61], 1);
	return CreateChaincodeProposalWithTransient(typ, chainID, cis, creator, nil)
}

// CreateChaincodeProposalWithTransient creates a proposal from given input
// It returns the proposal and the transaction id associated to the proposal
func CreateChaincodeProposalWithTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[62], 1);
	// generate a random nonce
	nonce, err := crypto.GetRandomNonce()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[65], 1);
		return nil, "", err
	}

	// compute txid
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[63], 1);txid, err := ComputeTxID(nonce, creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[66], 1);
		return nil, "", err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[64], 1);return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
}

// CreateChaincodeProposalWithTxIDAndTransient creates a proposal from given
// input. It returns the proposal and the transaction id associated with the
// proposal
func CreateChaincodeProposalWithTxIDAndTransient(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte, txid string, transientMap map[string][]byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[67], 1);
	// generate a random nonce
	nonce, err := crypto.GetRandomNonce()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[70], 1);
		return nil, "", err
	}

	// compute txid unless provided by tests
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[68], 1);if txid == "" {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[71], 1);
		txid, err = ComputeTxID(nonce, creator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[72], 1);
			return nil, "", err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[69], 1);return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, transientMap)
}

// CreateChaincodeProposalWithTxIDNonceAndTransient creates a proposal from
// given input
func CreateChaincodeProposalWithTxIDNonceAndTransient(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, nonce, creator []byte, transientMap map[string][]byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[73], 1);
	ccHdrExt := &peer.ChaincodeHeaderExtension{ChaincodeId: cis.ChaincodeSpec.ChaincodeId}
	ccHdrExtBytes, err := proto.Marshal(ccHdrExt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[78], 1);
		return nil, "", errors.Wrap(err, "error marshaling ChaincodeHeaderExtension")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[74], 1);cisBytes, err := proto.Marshal(cis)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[79], 1);
		return nil, "", errors.Wrap(err, "error marshaling ChaincodeInvocationSpec")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[75], 1);ccPropPayload := &peer.ChaincodeProposalPayload{Input: cisBytes, TransientMap: transientMap}
	ccPropPayloadBytes, err := proto.Marshal(ccPropPayload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[80], 1);
		return nil, "", errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
	}

	// TODO: epoch is now set to zero. This must be changed once we
	// get a more appropriate mechanism to handle it in.
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[76], 1);var epoch uint64

	timestamp := util.CreateUtcTimestamp()

	hdr := &common.Header{
		ChannelHeader: MarshalOrPanic(
			&common.ChannelHeader{
				Type:      int32(typ),
				TxId:      txid,
				Timestamp: timestamp,
				ChannelId: chainID,
				Extension: ccHdrExtBytes,
				Epoch:     epoch,
			},
		),
		SignatureHeader: MarshalOrPanic(
			&common.SignatureHeader{
				Nonce:   nonce,
				Creator: creator,
			},
		),
	}

	hdrBytes, err := proto.Marshal(hdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[81], 1);
		return nil, "", err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[77], 1);prop := &peer.Proposal{
		Header:  hdrBytes,
		Payload: ccPropPayloadBytes,
	}
	return prop, txid, nil
}

// GetBytesProposalResponsePayload gets proposal response payload
func GetBytesProposalResponsePayload(hash []byte, response *peer.Response, result []byte, event []byte, ccid *peer.ChaincodeID) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[82], 1);
	cAct := &peer.ChaincodeAction{
		Events: event, Results: result,
		Response:    response,
		ChaincodeId: ccid,
	}
	cActBytes, err := proto.Marshal(cAct)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[84], 1);
		return nil, errors.Wrap(err, "error marshaling ChaincodeAction")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[83], 1);prp := &peer.ProposalResponsePayload{
		Extension:    cActBytes,
		ProposalHash: hash,
	}
	prpBytes, err := proto.Marshal(prp)
	return prpBytes, errors.Wrap(err, "error marshaling ProposalResponsePayload")
}

// GetBytesChaincodeProposalPayload gets the chaincode proposal payload
func GetBytesChaincodeProposalPayload(cpp *peer.ChaincodeProposalPayload) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[85], 1);
	cppBytes, err := proto.Marshal(cpp)
	return cppBytes, errors.Wrap(err, "error marshaling ChaincodeProposalPayload")
}

// GetBytesResponse gets the bytes of Response
func GetBytesResponse(res *peer.Response) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[86], 1);
	resBytes, err := proto.Marshal(res)
	return resBytes, errors.Wrap(err, "error marshaling Response")
}

// GetBytesChaincodeEvent gets the bytes of ChaincodeEvent
func GetBytesChaincodeEvent(event *peer.ChaincodeEvent) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[87], 1);
	eventBytes, err := proto.Marshal(event)
	return eventBytes, errors.Wrap(err, "error marshaling ChaincodeEvent")
}

// GetBytesChaincodeActionPayload get the bytes of ChaincodeActionPayload from
// the message
func GetBytesChaincodeActionPayload(cap *peer.ChaincodeActionPayload) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[88], 1);
	capBytes, err := proto.Marshal(cap)
	return capBytes, errors.Wrap(err, "error marshaling ChaincodeActionPayload")
}

// GetBytesProposalResponse gets proposal bytes response
func GetBytesProposalResponse(pr *peer.ProposalResponse) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[89], 1);
	respBytes, err := proto.Marshal(pr)
	return respBytes, errors.Wrap(err, "error marshaling ProposalResponse")
}

// GetBytesProposal returns the bytes of a proposal message
func GetBytesProposal(prop *peer.Proposal) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[90], 1);
	propBytes, err := proto.Marshal(prop)
	return propBytes, errors.Wrap(err, "error marshaling Proposal")
}

// GetBytesHeader get the bytes of Header from the message
func GetBytesHeader(hdr *common.Header) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[91], 1);
	bytes, err := proto.Marshal(hdr)
	return bytes, errors.Wrap(err, "error marshaling Header")
}

// GetBytesSignatureHeader get the bytes of SignatureHeader from the message
func GetBytesSignatureHeader(hdr *common.SignatureHeader) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[92], 1);
	bytes, err := proto.Marshal(hdr)
	return bytes, errors.Wrap(err, "error marshaling SignatureHeader")
}

// GetBytesTransaction get the bytes of Transaction from the message
func GetBytesTransaction(tx *peer.Transaction) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[93], 1);
	bytes, err := proto.Marshal(tx)
	return bytes, errors.Wrap(err, "error unmarshaling Transaction")
}

// GetBytesPayload get the bytes of Payload from the message
func GetBytesPayload(payl *common.Payload) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[94], 1);
	bytes, err := proto.Marshal(payl)
	return bytes, errors.Wrap(err, "error marshaling Payload")
}

// GetBytesEnvelope get the bytes of Envelope from the message
func GetBytesEnvelope(env *common.Envelope) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[95], 1);
	bytes, err := proto.Marshal(env)
	return bytes, errors.Wrap(err, "error marshaling Envelope")
}

// GetActionFromEnvelope extracts a ChaincodeAction message from a
// serialized Envelope
// TODO: fix function name as per FAB-11831
func GetActionFromEnvelope(envBytes []byte) (*peer.ChaincodeAction, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[96], 1);
	env, err := GetEnvelopeFromBlock(envBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[98], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[97], 1);return GetActionFromEnvelopeMsg(env)
}

func GetActionFromEnvelopeMsg(env *common.Envelope) (*peer.ChaincodeAction, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[99], 1);
	payl, err := GetPayload(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[103], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[100], 1);tx, err := GetTransaction(payl.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[104], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[101], 1);if len(tx.Actions) == 0 {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[105], 1);
		return nil, errors.New("at least one TransactionAction required")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[102], 1);_, respPayload, err := GetPayloads(tx.Actions[0])
	return respPayload, err
}

// CreateProposalFromCISAndTxid returns a proposal given a serialized identity
// and a ChaincodeInvocationSpec
func CreateProposalFromCISAndTxid(txid string, typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[106], 1);
	nonce, err := crypto.GetRandomNonce()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[108], 1);
		return nil, "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[107], 1);return CreateChaincodeProposalWithTxIDNonceAndTransient(txid, typ, chainID, cis, nonce, creator, nil)
}

// CreateProposalFromCIS returns a proposal given a serialized identity and a
// ChaincodeInvocationSpec
func CreateProposalFromCIS(typ common.HeaderType, chainID string, cis *peer.ChaincodeInvocationSpec, creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[109], 1);
	return CreateChaincodeProposal(typ, chainID, cis, creator)
}

// CreateGetChaincodesProposal returns a GETCHAINCODES proposal given a
// serialized identity
func CreateGetChaincodesProposal(chainID string, creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[110], 1);
	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getchaincodes")}}
	lsccSpec := &peer.ChaincodeInvocationSpec{
		ChaincodeSpec: &peer.ChaincodeSpec{
			Type:        peer.ChaincodeSpec_GOLANG,
			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
			Input:       ccinp,
		},
	}
	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
}

// CreateGetInstalledChaincodesProposal returns a GETINSTALLEDCHAINCODES
// proposal given a serialized identity
func CreateGetInstalledChaincodesProposal(creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[111], 1);
	ccinp := &peer.ChaincodeInput{Args: [][]byte{[]byte("getinstalledchaincodes")}}
	lsccSpec := &peer.ChaincodeInvocationSpec{
		ChaincodeSpec: &peer.ChaincodeSpec{
			Type:        peer.ChaincodeSpec_GOLANG,
			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
			Input:       ccinp,
		},
	}
	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, "", lsccSpec, creator)
}

// CreateInstallProposalFromCDS returns a install proposal given a serialized
// identity and a ChaincodeDeploymentSpec
func CreateInstallProposalFromCDS(ccpack proto.Message, creator []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[112], 1);
	return createProposalFromCDS("", ccpack, creator, "install")
}

// CreateDeployProposalFromCDS returns a deploy proposal given a serialized
// identity and a ChaincodeDeploymentSpec
func CreateDeployProposalFromCDS(
	chainID string,
	cds *peer.ChaincodeDeploymentSpec,
	creator []byte,
	policy []byte,
	escc []byte,
	vscc []byte,
	collectionConfig []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[113], 1);
	if collectionConfig == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[115], 1);
		return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc)
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[114], 1);return createProposalFromCDS(chainID, cds, creator, "deploy", policy, escc, vscc, collectionConfig)
}

// CreateUpgradeProposalFromCDS returns a upgrade proposal given a serialized
// identity and a ChaincodeDeploymentSpec
func CreateUpgradeProposalFromCDS(
	chainID string,
	cds *peer.ChaincodeDeploymentSpec,
	creator []byte,
	policy []byte,
	escc []byte,
	vscc []byte,
	collectionConfig []byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[116], 1);
	if collectionConfig == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[118], 1);
		return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc)
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[117], 1);return createProposalFromCDS(chainID, cds, creator, "upgrade", policy, escc, vscc, collectionConfig)
}

// createProposalFromCDS returns a deploy or upgrade proposal given a
// serialized identity and a ChaincodeDeploymentSpec
func createProposalFromCDS(chainID string, msg proto.Message, creator []byte, propType string, args ...[]byte) (*peer.Proposal, string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[119], 1);
	// in the new mode, cds will be nil, "deploy" and "upgrade" are instantiates.
	var ccinp *peer.ChaincodeInput
	var b []byte
	var err error
	if msg != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[122], 1);
		b, err = proto.Marshal(msg)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[123], 1);
			return nil, "", err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[120], 1);switch propType {
	case "deploy":_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[124], 1);
		fallthrough
	case "upgrade":_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[125], 1);
		cds, ok := msg.(*peer.ChaincodeDeploymentSpec)
		if !ok || cds == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[128], 1);
			return nil, "", errors.New("invalid message for creating lifecycle chaincode proposal")
		}
		_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[126], 1);Args := [][]byte{[]byte(propType), []byte(chainID), b}
		Args = append(Args, args...)

		ccinp = &peer.ChaincodeInput{Args: Args}
	case "install":_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[127], 1);
		ccinp = &peer.ChaincodeInput{Args: [][]byte{[]byte(propType), b}}
	}

	// wrap the deployment in an invocation spec to lscc...
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[121], 1);lsccSpec := &peer.ChaincodeInvocationSpec{
		ChaincodeSpec: &peer.ChaincodeSpec{
			Type:        peer.ChaincodeSpec_GOLANG,
			ChaincodeId: &peer.ChaincodeID{Name: "lscc"},
			Input:       ccinp,
		},
	}

	// ...and get the proposal for it
	return CreateProposalFromCIS(common.HeaderType_ENDORSER_TRANSACTION, chainID, lsccSpec, creator)
}

// ComputeTxID computes TxID as the Hash computed
// over the concatenation of nonce and creator.
func ComputeTxID(nonce, creator []byte) (string, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[129], 1);
	// TODO: Get the Hash function to be used from
	// channel configuration
	digest, err := factory.GetDefault().Hash(
		append(nonce, creator...),
		&bccsp.SHA256Opts{})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[131], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[130], 1);return hex.EncodeToString(digest), nil
}

// CheckTxID checks that txid is equal to the Hash computed
// over the concatenation of nonce and creator.
func CheckTxID(txid string, nonce, creator []byte) error {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[132], 1);
	computedTxID, err := ComputeTxID(nonce, creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[135], 1);
		return errors.WithMessage(err, "error computing target txid")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[133], 1);if txid != computedTxID {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[136], 1);
		return errors.Errorf("invalid txid. got [%s], expected [%s]", txid, computedTxID)
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[134], 1);return nil
}

// ComputeProposalBinding computes the binding of a proposal
func ComputeProposalBinding(proposal *peer.Proposal) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[137], 1);
	if proposal == nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[143], 1);
		return nil, errors.New("proposal is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[138], 1);if len(proposal.Header) == 0 {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[144], 1);
		return nil, errors.New("proposal's header is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[139], 1);h, err := GetHeader(proposal.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[145], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[140], 1);chdr, err := UnmarshalChannelHeader(h.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[146], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[141], 1);shdr, err := GetSignatureHeader(h.SignatureHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[147], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[142], 1);return computeProposalBindingInternal(shdr.Nonce, shdr.Creator, chdr.Epoch)
}

func computeProposalBindingInternal(nonce, creator []byte, epoch uint64) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_333834643165316261363934.Count[148], 1);
	epochBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(epochBytes, epoch)

	// TODO: add to genesis block the hash function used for
	// the binding computation
	return factory.GetDefault().Hash(
		append(append(nonce, creator...), epochBytes...),
		&bccsp.SHA256Opts{})
}

var GoCover_3_333834643165316261363934 = struct {
	Count     [149]uint32
	Pos       [3 * 149]uint32
	NumStmt   [149]uint16
} {
	Pos: [3 * 149]uint32{
		25, 26, 0x11005d, // [0]
		29, 30, 0x100002, // [1]
		33, 34, 0x100002, // [2]
		37, 39, 0x4c0002, // [3]
		26, 28, 0x30011, // [4]
		30, 32, 0x30010, // [5]
		34, 36, 0x30010, // [6]
		43, 44, 0x11005a, // [7]
		47, 47, 0x1b0002, // [8]
		50, 50, 0x1c0002, // [9]
		54, 55, 0x100002, // [10]
		58, 58, 0x100002, // [11]
		62, 63, 0x100002, // [12]
		67, 67, 0x8e0002, // [13]
		71, 72, 0x100002, // [14]
		76, 77, 0x100002, // [15]
		81, 81, 0x360002, // [16]
		44, 46, 0x30011, // [17]
		47, 49, 0x3001b, // [18]
		50, 52, 0x3001c, // [19]
		55, 57, 0x30010, // [20]
		58, 60, 0x30010, // [21]
		63, 65, 0x30010, // [22]
		67, 69, 0x3008e, // [23]
		72, 74, 0x30010, // [24]
		77, 79, 0x30010, // [25]
		84, 85, 0x220065, // [26]
		90, 90, 0x830002, // [27]
		85, 86, 0x280022, // [28]
		86, 88, 0x40028, // [29]
		94, 98, 0x20036, // [30]
		101, 102, 0x110034, // [31]
		107, 108, 0x100002, // [32]
		112, 113, 0x100002, // [33]
		117, 117, 0x8e0002, // [34]
		121, 122, 0x100002, // [35]
		126, 126, 0x200002, // [36]
		130, 130, 0x180002, // [37]
		102, 104, 0x30011, // [38]
		108, 110, 0x30010, // [39]
		113, 115, 0x30010, // [40]
		117, 119, 0x3008e, // [41]
		122, 124, 0x30010, // [42]
		126, 128, 0x30020, // [43]
		134, 136, 0x10005e, // [44]
		140, 142, 0x590002, // [45]
		136, 138, 0x30010, // [46]
		146, 150, 0x2004a, // [47]
		153, 156, 0x10006d, // [48]
		161, 161, 0x420002, // [49]
		156, 158, 0x30010, // [50]
		165, 169, 0x20048, // [51]
		172, 176, 0x2003b, // [52]
		179, 183, 0x20046, // [53]
		186, 190, 0x20059, // [54]
		193, 197, 0x2003c, // [55]
		200, 204, 0x2003e, // [56]
		207, 212, 0x20040, // [57]
		215, 219, 0x20057, // [58]
		222, 226, 0x20058, // [59]
		229, 233, 0x20048, // [60]
		237, 239, 0x20098, // [61]
		243, 246, 0x1000c5, // [62]
		251, 252, 0x100002, // [63]
		256, 256, 0x700002, // [64]
		246, 248, 0x30010, // [65]
		252, 254, 0x30010, // [66]
		262, 265, 0x1000d9, // [67]
		270, 270, 0x100002, // [68]
		277, 277, 0x700002, // [69]
		265, 267, 0x30010, // [70]
		270, 272, 0x110010, // [71]
		272, 274, 0x40011, // [72]
		282, 285, 0x1000e5, // [73]
		289, 290, 0x100002, // [74]
		294, 296, 0x100002, // [75]
		302, 326, 0x100002, // [76]
		330, 334, 0x180002, // [77]
		285, 287, 0x30010, // [78]
		290, 292, 0x30010, // [79]
		296, 298, 0x30010, // [80]
		326, 328, 0x30010, // [81]
		338, 345, 0x100091, // [82]
		349, 354, 0x4f0002, // [83]
		345, 347, 0x30010, // [84]
		358, 361, 0x2005b, // [85]
		364, 367, 0x2003b, // [86]
		370, 373, 0x20049, // [87]
		377, 380, 0x20057, // [88]
		383, 386, 0x2004a, // [89]
		389, 392, 0x2003c, // [90]
		395, 398, 0x20039, // [91]
		401, 404, 0x2004b, // [92]
		407, 410, 0x20040, // [93]
		413, 416, 0x2003c, // [94]
		419, 422, 0x2003d, // [95]
		427, 429, 0x10004c, // [96]
		432, 432, 0x260002, // [97]
		429, 431, 0x30010, // [98]
		435, 437, 0x100054, // [99]
		441, 442, 0x100002, // [100]
		446, 446, 0x1a0002, // [101]
		450, 451, 0x190002, // [102]
		437, 439, 0x30010, // [103]
		442, 444, 0x30010, // [104]
		446, 448, 0x3001a, // [105]
		456, 458, 0x1000aa, // [106]
		461, 461, 0x670002, // [107]
		458, 460, 0x30010, // [108]
		466, 468, 0x20096, // [109]
		472, 482, 0x20062, // [110]
		486, 496, 0x2005b, // [111]
		500, 502, 0x20069, // [112]
		513, 514, 0x1d003b, // [113]
		517, 517, 0x650002, // [114]
		514, 516, 0x3001d, // [115]
		529, 530, 0x1d003b, // [116]
		533, 533, 0x660002, // [117]
		530, 532, 0x3001d, // [118]
		538, 543, 0x100090, // [119]
		549, 549, 0x120002, // [120]
		566, 575, 0x620002, // [121]
		543, 545, 0x110010, // [122]
		545, 547, 0x40011, // [123]
		550, 551, 0xe0010, // [124]
		552, 554, 0x180011, // [125]
		557, 560, 0x2b0003, // [126]
		561, 562, 0x440011, // [127]
		554, 556, 0x40018, // [128]
		580, 586, 0x100039, // [129]
		589, 589, 0x280002, // [130]
		586, 588, 0x30010, // [131]
		594, 596, 0x10003a, // [132]
		600, 600, 0x1a0002, // [133]
		604, 604, 0xc0002, // [134]
		596, 598, 0x30010, // [135]
		600, 602, 0x3001a, // [136]
		608, 609, 0x150046, // [137]
		612, 612, 0x1f0002, // [138]
		616, 617, 0x100002, // [139]
		621, 622, 0x100002, // [140]
		625, 626, 0x100002, // [141]
		630, 630, 0x4d0002, // [142]
		609, 611, 0x30015, // [143]
		612, 614, 0x3001f, // [144]
		617, 619, 0x30010, // [145]
		622, 624, 0x30010, // [146]
		626, 628, 0x30010, // [147]
		633, 642, 0x2005a, // [148]
	},
	NumStmt: [149]uint16{
		1, // 0
		2, // 1
		2, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		2, // 12
		1, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		3, // 30
		1, // 31
		2, // 32
		2, // 33
		1, // 34
		2, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		2, // 44
		3, // 45
		1, // 46
		3, // 47
		3, // 48
		1, // 49
		1, // 50
		3, // 51
		3, // 52
		3, // 53
		3, // 54
		3, // 55
		3, // 56
		3, // 57
		3, // 58
		3, // 59
		3, // 60
		1, // 61
		2, // 62
		2, // 63
		1, // 64
		1, // 65
		1, // 66
		2, // 67
		1, // 68
		1, // 69
		1, // 70
		2, // 71
		1, // 72
		3, // 73
		2, // 74
		3, // 75
		5, // 76
		2, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		3, // 82
		3, // 83
		1, // 84
		2, // 85
		2, // 86
		2, // 87
		2, // 88
		2, // 89
		2, // 90
		2, // 91
		2, // 92
		2, // 93
		2, // 94
		2, // 95
		2, // 96
		1, // 97
		1, // 98
		2, // 99
		2, // 100
		1, // 101
		2, // 102
		1, // 103
		1, // 104
		1, // 105
		2, // 106
		1, // 107
		1, // 108
		1, // 109
		3, // 110
		3, // 111
		1, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		4, // 119
		1, // 120
		2, // 121
		2, // 122
		1, // 123
		1, // 124
		2, // 125
		3, // 126
		1, // 127
		1, // 128
		2, // 129
		1, // 130
		1, // 131
		2, // 132
		1, // 133
		1, // 134
		1, // 135
		1, // 136
		1, // 137
		1, // 138
		2, // 139
		2, // 140
		2, // 141
		1, // 142
		1, // 143
		1, // 144
		1, // 145
		1, // 146
		1, // 147
		3, // 148
	},
}
var _ = _cover_atomic_.LoadUint32
