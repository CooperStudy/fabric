//line /home/cooper/go/src/github.com/hyperledger/fabric/msp/idemixmsp.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msp; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/bccsp"
	idemixbccsp "github.com/hyperledger/fabric/bccsp/idemix"
	"github.com/hyperledger/fabric/bccsp/sw"
	m "github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
	"go.uber.org/zap/zapcore"
)

const (
	// AttributeIndexOU contains the index of the OU attribute in the idemix credential attributes
	AttributeIndexOU = iota

	// AttributeIndexRole contains the index of the Role attribute in the idemix credential attributes
	AttributeIndexRole

	// AttributeIndexEnrollmentId contains the index of the Enrollment ID attribute in the idemix credential attributes
	AttributeIndexEnrollmentId

	// AttributeIndexRevocationHandle contains the index of the Revocation Handle attribute in the idemix credential attributes
	AttributeIndexRevocationHandle
)

const (
	// AttributeNameOU is the attribute name of the Organization Unit attribute
	AttributeNameOU = "OU"

	// AttributeNameRole is the attribute name of the Role attribute
	AttributeNameRole = "Role"

	// AttributeNameEnrollmentId is the attribute name of the Enrollment ID attribute
	AttributeNameEnrollmentId = "EnrollmentID"

	// AttributeNameRevocationHandle is the attribute name of the revocation handle attribute
	AttributeNameRevocationHandle = "RevocationHandle"
)

// index of the revocation handle attribute in the credential
const rhIndex = 3

// discloseFlags will be passed to the idemix signing and verification routines.
// It informs idemix to disclose both attributes (OU and Role) when signing,
// while hiding attributes EnrollmentID and RevocationHandle.
var discloseFlags = []byte{1, 1, 0, 0}

type idemixmsp struct {
	csp          bccsp.BCCSP
	version      MSPVersion
	ipk          bccsp.Key
	signer       *idemixSigningIdentity
	name         string
	revocationPK bccsp.Key
	epoch        int
}

// newIdemixMsp creates a new instance of idemixmsp
func newIdemixMsp(version MSPVersion) (MSP, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[0], 1);
	mspLogger.Debugf("Creating Idemix-based MSP instance")

	csp, err := idemixbccsp.New(sw.NewDummyKeyStore())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[2], 1);
		panic(fmt.Sprintf("unexpected condition, error received [%s]", err))
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[1], 1);msp := idemixmsp{csp: csp}
	msp.version = version
	return &msp, nil
}

func (msp *idemixmsp) Setup(conf1 *m.MSPConfig) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[3], 1);
	mspLogger.Debugf("Setting up Idemix-based MSP instance")

	if conf1 == nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[16], 1);
		return errors.Errorf("setup error: nil conf reference")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[4], 1);if conf1.Type != int32(IDEMIX) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[17], 1);
		return errors.Errorf("setup error: config is not of type IDEMIX")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[5], 1);var conf m.IdemixMSPConfig
	err := proto.Unmarshal(conf1.Config, &conf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[18], 1);
		return errors.Wrap(err, "failed unmarshalling idemix msp config")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[6], 1);msp.name = conf.Name
	mspLogger.Debugf("Setting up Idemix MSP instance %s", msp.name)

	// Import Issuer Public Key
	IssuerPublicKey, err := msp.csp.KeyImport(
		conf.Ipk,
		&bccsp.IdemixIssuerPublicKeyImportOpts{
			Temporary: true,
			AttributeNames: []string{
				AttributeNameOU,
				AttributeNameRole,
				AttributeNameEnrollmentId,
				AttributeNameRevocationHandle,
			},
		})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[19], 1);
		importErr, ok := errors.Cause(err).(*bccsp.IdemixIssuerPublicKeyImporterError)
		if !ok {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[21], 1);
			panic("unexpected condition, BCCSP did not return the expected *bccsp.IdemixIssuerPublicKeyImporterError")
		}
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[20], 1);switch importErr.Type {
		case bccsp.IdemixIssuerPublicKeyImporterUnmarshallingError:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[22], 1);
			return errors.WithMessage(err, "failed to unmarshal ipk from idemix msp config")
		case bccsp.IdemixIssuerPublicKeyImporterHashError:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[23], 1);
			return errors.WithMessage(err, "setting the hash of the issuer public key failed")
		case bccsp.IdemixIssuerPublicKeyImporterValidationError:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[24], 1);
			return errors.WithMessage(err, "cannot setup idemix msp with invalid public key")
		case bccsp.IdemixIssuerPublicKeyImporterNumAttributesError:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[25], 1);
			fallthrough
		case bccsp.IdemixIssuerPublicKeyImporterAttributeNameError:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[26], 1);
			return errors.Errorf("issuer public key must have have attributes OU, Role, EnrollmentId, and RevocationHandle")
		default:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[27], 1);
			panic(fmt.Sprintf("unexpected condtion, issuer public key import error not valid, got [%d]", importErr.Type))
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[7], 1);msp.ipk = IssuerPublicKey

	// Import revocation public key
	RevocationPublicKey, err := msp.csp.KeyImport(
		conf.RevocationPk,
		&bccsp.IdemixRevocationPublicKeyImportOpts{Temporary: true},
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[28], 1);
		return errors.WithMessage(err, "failed to import revocation public key")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[8], 1);msp.revocationPK = RevocationPublicKey

	if conf.Signer == nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[29], 1);
		// No credential in config, so we don't setup a default signer
		mspLogger.Debug("idemix msp setup as verification only msp (no key material found)")
		return nil
	}

	// A credential is present in the config, so we setup a default signer

	// Import User secret key
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[9], 1);UserKey, err := msp.csp.KeyImport(conf.Signer.Sk, &bccsp.IdemixUserSecretKeyImportOpts{Temporary: true})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[30], 1);
		return errors.WithMessage(err, "failed importing signer secret key")
	}

	// Derive NymPublicKey
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[10], 1);NymKey, err := msp.csp.KeyDeriv(UserKey, &bccsp.IdemixNymKeyDerivationOpts{Temporary: true, IssuerPK: IssuerPublicKey})
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[31], 1);
		return errors.WithMessage(err, "failed deriving nym")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[11], 1);NymPublicKey, err := NymKey.PublicKey()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[32], 1);
		return errors.Wrapf(err, "failed getting public nym key")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[12], 1);role := &m.MSPRole{
		MspIdentifier: msp.name,
		Role:          m.MSPRole_MEMBER,
	}
	if checkRole(int(conf.Signer.Role), ADMIN) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[33], 1);
		role.Role = m.MSPRole_ADMIN
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[13], 1);ou := &m.OrganizationUnit{
		MspIdentifier:                msp.name,
		OrganizationalUnitIdentifier: conf.Signer.OrganizationalUnitIdentifier,
		CertifiersIdentifier:         IssuerPublicKey.SKI(),
	}

	enrollmentId := conf.Signer.EnrollmentId

	// Verify credential
	valid, err := msp.csp.Verify(
		UserKey,
		conf.Signer.Cred,
		nil,
		&bccsp.IdemixCredentialSignerOpts{
			IssuerPK: IssuerPublicKey,
			Attributes: []bccsp.IdemixAttribute{
				{Type: bccsp.IdemixBytesAttribute, Value: []byte(conf.Signer.OrganizationalUnitIdentifier)},
				{Type: bccsp.IdemixIntAttribute, Value: getIdemixRoleFromMSPRole(role)},
				{Type: bccsp.IdemixBytesAttribute, Value: []byte(enrollmentId)},
				{Type: bccsp.IdemixHiddenAttribute},
			},
		},
	)
	if err != nil || !valid {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[34], 1);
		return errors.WithMessage(err, "Credential is not cryptographically valid")
	}

	// Create the cryptographic evidence that this identity is valid
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[14], 1);proof, err := msp.csp.Sign(
		UserKey,
		nil,
		&bccsp.IdemixSignerOpts{
			Credential: conf.Signer.Cred,
			Nym:        NymKey,
			IssuerPK:   IssuerPublicKey,
			Attributes: []bccsp.IdemixAttribute{
				{Type: bccsp.IdemixBytesAttribute},
				{Type: bccsp.IdemixIntAttribute},
				{Type: bccsp.IdemixHiddenAttribute},
				{Type: bccsp.IdemixHiddenAttribute},
			},
			RhIndex: rhIndex,
			CRI:     conf.Signer.CredentialRevocationInformation,
		},
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[35], 1);
		return errors.WithMessage(err, "Failed to setup cryptographic proof of identity")
	}

	// Set up default signer
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[15], 1);msp.signer = &idemixSigningIdentity{
		idemixidentity: newIdemixIdentity(msp, NymPublicKey, role, ou, proof),
		Cred:           conf.Signer.Cred,
		UserKey:        UserKey,
		NymKey:         NymKey,
		enrollmentId:   enrollmentId}

	return nil
}

// GetVersion returns the version of this MSP
func (msp *idemixmsp) GetVersion() MSPVersion {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[36], 1);
	return msp.version
}

func (msp *idemixmsp) GetType() ProviderType {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[37], 1);
	return IDEMIX
}

func (msp *idemixmsp) GetIdentifier() (string, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[38], 1);
	return msp.name, nil
}

func (msp *idemixmsp) GetSigningIdentity(identifier *IdentityIdentifier) (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[39], 1);
	return nil, errors.Errorf("GetSigningIdentity not implemented")
}

func (msp *idemixmsp) GetDefaultSigningIdentity() (SigningIdentity, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[40], 1);
	mspLogger.Debugf("Obtaining default idemix signing identity")

	if msp.signer == nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[42], 1);
		return nil, errors.Errorf("no default signer setup")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[41], 1);return msp.signer, nil
}

func (msp *idemixmsp) DeserializeIdentity(serializedID []byte) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[43], 1);
	sID := &m.SerializedIdentity{}
	err := proto.Unmarshal(serializedID, sID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[46], 1);
		return nil, errors.Wrap(err, "could not deserialize a SerializedIdentity")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[44], 1);if sID.Mspid != msp.name {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[47], 1);
		return nil, errors.Errorf("expected MSP ID %s, received %s", msp.name, sID.Mspid)
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[45], 1);return msp.deserializeIdentityInternal(sID.GetIdBytes())
}

func (msp *idemixmsp) deserializeIdentityInternal(serializedID []byte) (Identity, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[48], 1);
	mspLogger.Debug("idemixmsp: deserializing identity")
	serialized := new(m.SerializedIdemixIdentity)
	err := proto.Unmarshal(serializedID, serialized)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[54], 1);
		return nil, errors.Wrap(err, "could not deserialize a SerializedIdemixIdentity")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[49], 1);if serialized.NymX == nil || serialized.NymY == nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[55], 1);
		return nil, errors.Errorf("unable to deserialize idemix identity: pseudonym is invalid")
	}

	// Import NymPublicKey
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[50], 1);var rawNymPublicKey []byte
	rawNymPublicKey = append(rawNymPublicKey, serialized.NymX...)
	rawNymPublicKey = append(rawNymPublicKey, serialized.NymY...)
	NymPublicKey, err := msp.csp.KeyImport(
		rawNymPublicKey,
		&bccsp.IdemixNymPublicKeyImportOpts{Temporary: true},
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[56], 1);
		return nil, errors.WithMessage(err, "failed to import nym public key")
	}

	// OU
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[51], 1);ou := &m.OrganizationUnit{}
	err = proto.Unmarshal(serialized.Ou, ou)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[57], 1);
		return nil, errors.Wrap(err, "cannot deserialize the OU of the identity")
	}

	// Role
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[52], 1);role := &m.MSPRole{}
	err = proto.Unmarshal(serialized.Role, role)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[58], 1);
		return nil, errors.Wrap(err, "cannot deserialize the role of the identity")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[53], 1);return newIdemixIdentity(msp, NymPublicKey, role, ou, serialized.Proof), nil
}

func (msp *idemixmsp) Validate(id Identity) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[59], 1);
	var identity *idemixidentity
	switch t := id.(type) {
	case *idemixidentity:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[62], 1);
		identity = id.(*idemixidentity)
	case *idemixSigningIdentity:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[63], 1);
		identity = id.(*idemixSigningIdentity).idemixidentity
	default:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[64], 1);
		return errors.Errorf("identity type %T is not recognized", t)
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[60], 1);mspLogger.Debugf("Validating identity %+v", identity)
	if identity.GetMSPIdentifier() != msp.name {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[65], 1);
		return errors.Errorf("the supplied identity does not belong to this msp")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[61], 1);return identity.verifyProof()
}

func (id *idemixidentity) verifyProof() error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[66], 1);
	// Verify signature
	valid, err := id.msp.csp.Verify(
		id.msp.ipk,
		id.associationProof,
		nil,
		&bccsp.IdemixSignerOpts{
			RevocationPublicKey: id.msp.revocationPK,
			Attributes: []bccsp.IdemixAttribute{
				{Type: bccsp.IdemixBytesAttribute, Value: []byte(id.OU.OrganizationalUnitIdentifier)},
				{Type: bccsp.IdemixIntAttribute, Value: getIdemixRoleFromMSPRole(id.Role)},
				{Type: bccsp.IdemixHiddenAttribute},
				{Type: bccsp.IdemixHiddenAttribute},
			},
			RhIndex: rhIndex,
			Epoch:   id.msp.epoch,
		},
	)
	if err == nil && !valid {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[68], 1);
		panic("unexpected condition, an error should be returned for an invalid signature")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[67], 1);return err
}

func (msp *idemixmsp) SatisfiesPrincipal(id Identity, principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[69], 1);
	err := msp.Validate(id)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[71], 1);
		return errors.Wrap(err, "identity is not valid with respect to this MSP")
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[70], 1);return msp.satisfiesPrincipalValidated(id, principal)
}

// satisfiesPrincipalValidated performs all the tasks of satisfiesPrincipal except the identity validation,
// such that combined principals will not cause multiple expensive identity validations.
func (msp *idemixmsp) satisfiesPrincipalValidated(id Identity, principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[72], 1);
	switch principal.PrincipalClassification {
	// in this case, we have to check whether the
	// identity has a role in the msp - member or admin
	case m.MSPPrincipal_ROLE:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[73], 1);
		// Principal contains the msp role
		mspRole := &m.MSPRole{}
		err := proto.Unmarshal(principal.Principal, mspRole)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[92], 1);
			return errors.Wrap(err, "could not unmarshal MSPRole from principal")
		}

		// at first, we check whether the MSP
		// identifier is the same as that of the identity
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[74], 1);if mspRole.MspIdentifier != msp.name {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[93], 1);
			return errors.Errorf("the identity is a member of a different MSP (expected %s, got %s)", mspRole.MspIdentifier, id.GetMSPIdentifier())
		}

		// now we validate the different msp roles
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[75], 1);switch mspRole.Role {
		case m.MSPRole_MEMBER:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[94], 1);
			// in the case of member, we simply check
			// whether this identity is valid for the MSP
			mspLogger.Debugf("Checking if identity satisfies MEMBER role for %s", msp.name)
			return nil
		case m.MSPRole_ADMIN:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[95], 1);
			mspLogger.Debugf("Checking if identity satisfies ADMIN role for %s", msp.name)
			if id.(*idemixidentity).Role.Role != m.MSPRole_ADMIN {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[102], 1);
				return errors.Errorf("user is not an admin")
			}
			_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[96], 1);return nil
		case m.MSPRole_PEER:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[97], 1);
			if msp.version >= MSPv1_3 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[103], 1);
				return errors.Errorf("idemixmsp only supports client use, so it cannot satisfy an MSPRole PEER principal")
			}
			_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[98], 1);fallthrough
		case m.MSPRole_CLIENT:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[99], 1);
			if msp.version >= MSPv1_3 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[104], 1);
				return nil // any valid idemixmsp member must be a client
			}
			_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[100], 1);fallthrough
		default:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[101], 1);
			return errors.Errorf("invalid MSP role type %d", int32(mspRole.Role))
		}
		// in this case we have to serialize this instance
		// and compare it byte-by-byte with Principal
	case m.MSPPrincipal_IDENTITY:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[76], 1);
		mspLogger.Debugf("Checking if identity satisfies IDENTITY principal")
		idBytes, err := id.Serialize()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[105], 1);
			return errors.Wrap(err, "could not serialize this identity instance")
		}

		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[77], 1);rv := bytes.Compare(idBytes, principal.Principal)
		if rv == 0 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[106], 1);
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[78], 1);return errors.Errorf("the identities do not match")

	case m.MSPPrincipal_ORGANIZATION_UNIT:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[79], 1);
		ou := &m.OrganizationUnit{}
		err := proto.Unmarshal(principal.Principal, ou)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[107], 1);
			return errors.Wrap(err, "could not unmarshal OU from principal")
		}

		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[80], 1);mspLogger.Debugf("Checking if identity is part of OU \"%s\" of mspid \"%s\"", ou.OrganizationalUnitIdentifier, ou.MspIdentifier)

		// at first, we check whether the MSP
		// identifier is the same as that of the identity
		if ou.MspIdentifier != msp.name {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[108], 1);
			return errors.Errorf("the identity is a member of a different MSP (expected %s, got %s)", ou.MspIdentifier, id.GetMSPIdentifier())
		}

		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[81], 1);if ou.OrganizationalUnitIdentifier != id.(*idemixidentity).OU.OrganizationalUnitIdentifier {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[109], 1);
			return errors.Errorf("user is not part of the desired organizational unit")
		}

		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[82], 1);return nil
	case m.MSPPrincipal_COMBINED:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[83], 1);
		if msp.version <= MSPv1_1 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[110], 1);
			return errors.Errorf("Combined MSP Principals are unsupported in MSPv1_1")
		}

		// Principal is a combination of multiple principals.
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[84], 1);principals := &m.CombinedPrincipal{}
		err := proto.Unmarshal(principal.Principal, principals)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[111], 1);
			return errors.Wrap(err, "could not unmarshal CombinedPrincipal from principal")
		}
		// Return an error if there are no principals in the combined principal.
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[85], 1);if len(principals.Principals) == 0 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[112], 1);
			return errors.New("no principals in CombinedPrincipal")
		}
		// Recursively call msp.SatisfiesPrincipal for all combined principals.
		// There is no limit for the levels of nesting for the combined principals.
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[86], 1);for _, cp := range principals.Principals {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[113], 1);
			err = msp.satisfiesPrincipalValidated(id, cp)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[114], 1);
				return err
			}
		}
		// The identity satisfies all the principals
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[87], 1);return nil
	case m.MSPPrincipal_ANONYMITY:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[88], 1);
		if msp.version <= MSPv1_1 {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[115], 1);
			return errors.Errorf("Anonymity MSP Principals are unsupported in MSPv1_1")
		}

		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[89], 1);anon := &m.MSPIdentityAnonymity{}
		err := proto.Unmarshal(principal.Principal, anon)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[116], 1);
			return errors.Wrap(err, "could not unmarshal MSPIdentityAnonymity from principal")
		}
		_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[90], 1);switch anon.AnonymityType {
		case m.MSPIdentityAnonymity_ANONYMOUS:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[117], 1);
			return nil
		case m.MSPIdentityAnonymity_NOMINAL:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[118], 1);
			return errors.New("principal is nominal, but idemix MSP is anonymous")
		default:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[119], 1);
			return errors.Errorf("unknown principal anonymity type: %d", anon.AnonymityType)
		}
	default:_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[91], 1);
		return errors.Errorf("invalid principal type %d", int32(principal.PrincipalClassification))
	}
}

// IsWellFormed checks if the given identity can be deserialized into its provider-specific .
// In this MSP implementation, an identity is considered well formed if it contains a
// marshaled SerializedIdemixIdentity protobuf message.
func (id *idemixmsp) IsWellFormed(identity *m.SerializedIdentity) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[120], 1);
	sId := new(m.SerializedIdemixIdentity)
	err := proto.Unmarshal(identity.IdBytes, sId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[122], 1);
		return errors.Wrap(err, "not an idemix identity")
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[121], 1);return nil
}

func (msp *idemixmsp) GetTLSRootCerts() [][]byte {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[123], 1);
	// TODO
	return nil
}

func (msp *idemixmsp) GetTLSIntermediateCerts() [][]byte {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[124], 1);
	// TODO
	return nil
}

type idemixidentity struct {
	NymPublicKey bccsp.Key
	msp          *idemixmsp
	id           *IdentityIdentifier
	Role         *m.MSPRole
	OU           *m.OrganizationUnit
	// associationProof contains cryptographic proof that this identity
	// belongs to the MSP id.msp, i.e., it proves that the pseudonym
	// is constructed from a secret key on which the CA issued a credential.
	associationProof []byte
}

func (id *idemixidentity) Anonymous() bool {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[125], 1);
	return true
}

func newIdemixIdentity(msp *idemixmsp, NymPublicKey bccsp.Key, role *m.MSPRole, ou *m.OrganizationUnit, proof []byte) *idemixidentity {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[126], 1);
	id := &idemixidentity{}
	id.NymPublicKey = NymPublicKey
	id.msp = msp
	id.Role = role
	id.OU = ou
	id.associationProof = proof

	raw, err := NymPublicKey.Bytes()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[128], 1);
		panic(fmt.Sprintf("unexpected condition, failed marshalling nym public key [%s]", err))
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[127], 1);id.id = &IdentityIdentifier{
		Mspid: msp.name,
		Id:    bytes.NewBuffer(raw).String(),
	}

	return id
}

func (id *idemixidentity) ExpiresAt() time.Time {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[129], 1);
	// Idemix MSP currently does not use expiration dates or revocation,
	// so we return the zero time to indicate this.
	return time.Time{}
}

func (id *idemixidentity) GetIdentifier() *IdentityIdentifier {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[130], 1);
	return id.id
}

func (id *idemixidentity) GetMSPIdentifier() string {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[131], 1);
	mspid, _ := id.msp.GetIdentifier()
	return mspid
}

func (id *idemixidentity) GetOrganizationalUnits() []*OUIdentifier {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[132], 1);
	// we use the (serialized) public key of this MSP as the CertifiersIdentifier
	certifiersIdentifier, err := id.msp.ipk.Bytes()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[134], 1);
		mspIdentityLogger.Errorf("Failed to marshal ipk in GetOrganizationalUnits: %s", err)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[133], 1);return []*OUIdentifier{{certifiersIdentifier, id.OU.OrganizationalUnitIdentifier}}
}

func (id *idemixidentity) Validate() error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[135], 1);
	return id.msp.Validate(id)
}

func (id *idemixidentity) Verify(msg []byte, sig []byte) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[136], 1);
	if mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[138], 1);
		mspIdentityLogger.Debugf("Verify Idemix sig: msg = %s", hex.Dump(msg))
		mspIdentityLogger.Debugf("Verify Idemix sig: sig = %s", hex.Dump(sig))
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[137], 1);_, err := id.msp.csp.Verify(
		id.NymPublicKey,
		sig,
		msg,
		&bccsp.IdemixNymSignerOpts{
			IssuerPK: id.msp.ipk,
		},
	)
	return err
}

func (id *idemixidentity) SatisfiesPrincipal(principal *m.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[139], 1);
	return id.msp.SatisfiesPrincipal(id, principal)
}

func (id *idemixidentity) Serialize() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[140], 1);
	serialized := &m.SerializedIdemixIdentity{}

	raw, err := id.NymPublicKey.Bytes()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[146], 1);
		return nil, errors.Wrapf(err, "could not serialize nym of identity %s", id.id)
	}
	// This is an assumption on how the underlying idemix implementation work.
	// TODO: change this in future version
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[141], 1);serialized.NymX = raw[:len(raw)/2]
	serialized.NymY = raw[len(raw)/2:]
	ouBytes, err := proto.Marshal(id.OU)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[147], 1);
		return nil, errors.Wrapf(err, "could not marshal OU of identity %s", id.id)
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[142], 1);roleBytes, err := proto.Marshal(id.Role)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[148], 1);
		return nil, errors.Wrapf(err, "could not marshal role of identity %s", id.id)
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[143], 1);serialized.Ou = ouBytes
	serialized.Role = roleBytes
	serialized.Proof = id.associationProof

	idemixIDBytes, err := proto.Marshal(serialized)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[149], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[144], 1);sID := &m.SerializedIdentity{Mspid: id.GetMSPIdentifier(), IdBytes: idemixIDBytes}
	idBytes, err := proto.Marshal(sID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[150], 1);
		return nil, errors.Wrapf(err, "could not marshal a SerializedIdentity structure for identity %s", id.id)
	}

	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[145], 1);return idBytes, nil
}

type idemixSigningIdentity struct {
	*idemixidentity
	Cred         []byte
	UserKey      bccsp.Key
	NymKey       bccsp.Key
	enrollmentId string
}

func (id *idemixSigningIdentity) Sign(msg []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[151], 1);
	mspLogger.Debugf("Idemix identity %s is signing", id.GetIdentifier())

	sig, err := id.msp.csp.Sign(
		id.UserKey,
		msg,
		&bccsp.IdemixNymSignerOpts{
			Nym:      id.NymKey,
			IssuerPK: id.msp.ipk,
		},
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[153], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[152], 1);return sig, nil
}

func (id *idemixSigningIdentity) GetPublicVersion() Identity {_cover_atomic_.AddUint32(&GoCover_4_636433306662306231613333.Count[154], 1);
	return id.idemixidentity
}

var GoCover_4_636433306662306231613333 = struct {
	Count     [155]uint32
	Pos       [3 * 155]uint32
	NumStmt   [155]uint16
} {
	Pos: [3 * 155]uint32{
		71, 75, 0x100034, // [0]
		79, 81, 0x120002, // [1]
		75, 76, 0x470010, // [2]
		84, 87, 0x120037, // [3]
		91, 91, 0x210002, // [4]
		95, 97, 0x100002, // [5]
		101, 116, 0x100002, // [6]
		136, 143, 0x100002, // [7]
		146, 148, 0x180002, // [8]
		157, 158, 0x100002, // [9]
		163, 164, 0x100002, // [10]
		167, 168, 0x100002, // [11]
		172, 176, 0x2d0002, // [12]
		180, 203, 0x1a0002, // [13]
		208, 225, 0x100002, // [14]
		230, 237, 0xc0002, // [15]
		87, 89, 0x30012, // [16]
		91, 93, 0x30021, // [17]
		97, 99, 0x30010, // [18]
		116, 118, 0xa0010, // [19]
		121, 121, 0x190003, // [20]
		118, 119, 0x6e000a, // [21]
		122, 123, 0x54003e, // [22]
		124, 125, 0x560035, // [23]
		126, 127, 0x55003b, // [24]
		128, 129, 0xf003e, // [25]
		130, 131, 0x74003e, // [26]
		132, 133, 0x71000b, // [27]
		143, 145, 0x30010, // [28]
		148, 152, 0x30018, // [29]
		158, 160, 0x30010, // [30]
		164, 166, 0x30010, // [31]
		168, 170, 0x30010, // [32]
		176, 178, 0x3002d, // [33]
		203, 205, 0x3001a, // [34]
		225, 227, 0x30010, // [35]
		241, 243, 0x2002f, // [36]
		245, 247, 0x2002e, // [37]
		249, 251, 0x20037, // [38]
		253, 255, 0x20063, // [39]
		257, 260, 0x17004c, // [40]
		263, 263, 0x180002, // [41]
		260, 262, 0x30017, // [42]
		266, 269, 0x100052, // [43]
		273, 273, 0x1b0002, // [44]
		277, 277, 0x3a0002, // [45]
		269, 271, 0x30010, // [46]
		273, 275, 0x3001b, // [47]
		280, 284, 0x10005a, // [48]
		287, 287, 0x360002, // [49]
		292, 299, 0x100002, // [50]
		304, 306, 0x100002, // [51]
		311, 313, 0x100002, // [52]
		317, 317, 0x4e0002, // [53]
		284, 286, 0x30010, // [54]
		287, 289, 0x30036, // [55]
		299, 301, 0x30010, // [56]
		306, 308, 0x30010, // [57]
		313, 315, 0x30010, // [58]
		320, 322, 0x180033, // [59]
		331, 332, 0x2d0002, // [60]
		335, 335, 0x1f0002, // [61]
		323, 324, 0x220017, // [62]
		325, 326, 0x38001e, // [63]
		327, 328, 0x40000a, // [64]
		332, 334, 0x3002d, // [65]
		338, 356, 0x1a002f, // [66]
		360, 360, 0xc0002, // [67]
		356, 357, 0x56001a, // [68]
		363, 365, 0x100058, // [69]
		369, 369, 0x370002, // [70]
		365, 367, 0x30010, // [71]
		374, 375, 0x2b0061, // [72]
		378, 382, 0x11001b, // [73]
		388, 388, 0x280003, // [74]
		393, 393, 0x170003, // [75]
		420, 423, 0x11001f, // [76]
		427, 428, 0xe0003, // [77]
		431, 431, 0x360003, // [78]
		433, 436, 0x110028, // [79]
		440, 444, 0x230003, // [80]
		448, 448, 0x5e0003, // [81]
		452, 452, 0xd0003, // [82]
		453, 454, 0x1d001f, // [83]
		459, 461, 0x110003, // [84]
		465, 465, 0x260003, // [85]
		470, 470, 0x2c0003, // [86]
		477, 477, 0xd0003, // [87]
		478, 479, 0x1d0020, // [88]
		483, 485, 0x110003, // [89]
		488, 488, 0x1d0003, // [90]
		496, 497, 0x5e000a, // [91]
		382, 384, 0x40011, // [92]
		388, 390, 0x40028, // [93]
		394, 398, 0xe0019, // [94]
		399, 401, 0x390018, // [95]
		404, 404, 0xe0004, // [96]
		405, 406, 0x1e0017, // [97]
		409, 409, 0xf0004, // [98]
		410, 411, 0x1e0019, // [99]
		414, 414, 0xf0004, // [100]
		415, 416, 0x49000b, // [101]
		401, 403, 0x50039, // [102]
		406, 408, 0x5001e, // [103]
		411, 413, 0x5001e, // [104]
		423, 425, 0x40011, // [105]
		428, 430, 0x4000e, // [106]
		436, 438, 0x40011, // [107]
		444, 446, 0x40023, // [108]
		448, 450, 0x4005e, // [109]
		454, 456, 0x4001d, // [110]
		461, 463, 0x40011, // [111]
		465, 467, 0x40026, // [112]
		470, 472, 0x12002c, // [113]
		472, 474, 0x50012, // [114]
		479, 481, 0x4001d, // [115]
		485, 487, 0x40011, // [116]
		489, 490, 0xe0029, // [117]
		491, 492, 0x4a0027, // [118]
		493, 494, 0x54000b, // [119]
		504, 507, 0x100049, // [120]
		510, 510, 0xc0002, // [121]
		507, 509, 0x30010, // [122]
		513, 516, 0x20032, // [123]
		518, 521, 0x2003a, // [124]
		535, 537, 0x2002c, // [125]
		539, 548, 0x100087, // [126]
		551, 556, 0xb0002, // [127]
		548, 549, 0x5a0010, // [128]
		559, 563, 0x20031, // [129]
		565, 567, 0x2003f, // [130]
		569, 572, 0x20035, // [131]
		574, 577, 0x100044, // [132]
		582, 582, 0x540002, // [133]
		577, 580, 0x30010, // [134]
		585, 587, 0x2002c, // [135]
		589, 590, 0x380040, // [136]
		595, 603, 0xc0002, // [137]
		590, 593, 0x30038, // [138]
		606, 608, 0x2004f, // [139]
		610, 614, 0x100037, // [140]
		619, 622, 0x100002, // [141]
		626, 627, 0x100002, // [142]
		631, 636, 0x100002, // [143]
		640, 642, 0x100002, // [144]
		646, 646, 0x150002, // [145]
		614, 616, 0x30010, // [146]
		622, 624, 0x30010, // [147]
		627, 629, 0x30010, // [148]
		636, 638, 0x30010, // [149]
		642, 644, 0x30010, // [150]
		657, 668, 0x100043, // [151]
		671, 671, 0x110002, // [152]
		668, 670, 0x30010, // [153]
		674, 676, 0x2003e, // [154]
	},
	NumStmt: [155]uint16{
		3, // 0
		3, // 1
		1, // 2
		2, // 3
		1, // 4
		3, // 5
		4, // 6
		3, // 7
		2, // 8
		2, // 9
		2, // 10
		2, // 11
		2, // 12
		4, // 13
		2, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		2, // 40
		1, // 41
		1, // 42
		3, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		4, // 48
		1, // 49
		5, // 50
		3, // 51
		3, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		2, // 59
		2, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		2, // 66
		1, // 67
		1, // 68
		2, // 69
		1, // 70
		1, // 71
		1, // 72
		3, // 73
		1, // 74
		1, // 75
		3, // 76
		2, // 77
		1, // 78
		3, // 79
		2, // 80
		1, // 81
		1, // 82
		1, // 83
		3, // 84
		1, // 85
		1, // 86
		1, // 87
		1, // 88
		3, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		2, // 94
		2, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
		1, // 103
		1, // 104
		1, // 105
		1, // 106
		1, // 107
		1, // 108
		1, // 109
		1, // 110
		1, // 111
		1, // 112
		2, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		1, // 119
		3, // 120
		1, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		8, // 126
		2, // 127
		1, // 128
		1, // 129
		1, // 130
		2, // 131
		2, // 132
		1, // 133
		2, // 134
		1, // 135
		1, // 136
		2, // 137
		2, // 138
		1, // 139
		3, // 140
		4, // 141
		2, // 142
		5, // 143
		3, // 144
		1, // 145
		1, // 146
		1, // 147
		1, // 148
		1, // 149
		1, // 150
		3, // 151
		1, // 152
		1, // 153
		1, // 154
	},
}
var _ = _cover_atomic_.LoadUint32
