//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/cluster/rpc.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cluster; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"sync"

	"github.com/hyperledger/fabric/protos/orderer"
	"github.com/pkg/errors"
	"google.golang.org/grpc"
)

//go:generate mockery -dir . -name SubmitClient -case underscore -output ./mocks/

// SubmitClient is the Submit gRPC stream
type SubmitClient interface {
	Send(request *orderer.SubmitRequest) error
	Recv() (*orderer.SubmitResponse, error)
	grpc.ClientStream
}

//go:generate mockery -dir . -name Client -case underscore -output ./mocks/

// Client is the definition of operations that the Cluster gRPC service
// exposes to cluster nodes.
type Client interface {
	// Submit submits transactions to a cluster member
	Submit(ctx context.Context, opts ...grpc.CallOption) (orderer.Cluster_SubmitClient, error)
	// Step passes an implementation-specific message to another cluster member.
	Step(ctx context.Context, in *orderer.StepRequest, opts ...grpc.CallOption) (*orderer.StepResponse, error)
}

// RPC performs remote procedure calls to remote cluster nodes.
type RPC struct {
	Channel             string
	Comm                Communicator
	lock                sync.RWMutex
	DestinationToStream map[uint64]orderer.Cluster_SubmitClient
}

// Step sends a StepRequest to the given destination node and returns the response
func (s *RPC) Step(destination uint64, msg *orderer.StepRequest) (*orderer.StepResponse, error) {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[0], 1);
	stub, err := s.Comm.Remote(s.Channel, destination)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[2], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[1], 1);return stub.Step(msg)
}

// SendSubmit sends a SubmitRequest to the given destination node
func (s *RPC) SendSubmit(destination uint64, request *orderer.SubmitRequest) error {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[3], 1);
	stream, err := s.getProposeStream(destination)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[6], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[4], 1);err = stream.Send(request)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[7], 1);
		s.unMapStream(destination)
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[5], 1);return err
}

// ReceiveSubmitResponse receives a SubmitResponse from the given destination node
func (s *RPC) ReceiveSubmitResponse(destination uint64) (*orderer.SubmitResponse, error) {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[8], 1);
	stream, err := s.getProposeStream(destination)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[11], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[9], 1);msg, err := stream.Recv()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[12], 1);
		s.unMapStream(destination)
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[10], 1);return msg, err
}

// getProposeStream obtains a Submit stream for the given destination node
func (s *RPC) getProposeStream(destination uint64) (orderer.Cluster_SubmitClient, error) {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[13], 1);
	stream := s.getStream(destination)
	if stream != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[17], 1);
		return stream, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[14], 1);stub, err := s.Comm.Remote(s.Channel, destination)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[18], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[15], 1);stream, err = stub.SubmitStream()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[19], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[16], 1);s.mapStream(destination, stream)
	return stream, nil
}

func (s *RPC) getStream(destination uint64) orderer.Cluster_SubmitClient {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[20], 1);
	s.lock.RLock()
	defer s.lock.RUnlock()
	return s.DestinationToStream[destination]
}

func (s *RPC) mapStream(destination uint64, stream orderer.Cluster_SubmitClient) {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[21], 1);
	s.lock.Lock()
	defer s.lock.Unlock()
	s.DestinationToStream[destination] = stream
}

func (s *RPC) unMapStream(destination uint64) {_cover_atomic_.AddUint32(&GoCover_4_363733313532663932376566.Count[22], 1);
	s.lock.Lock()
	defer s.lock.Unlock()
	delete(s.DestinationToStream, destination)
}

var GoCover_4_363733313532663932376566 = struct {
	Count     [23]uint32
	Pos       [3 * 23]uint32
	NumStmt   [23]uint16
} {
	Pos: [3 * 23]uint32{
		47, 49, 0x100061, // [0]
		52, 52, 0x170002, // [1]
		49, 51, 0x30010, // [2]
		56, 58, 0x100054, // [3]
		61, 62, 0x100002, // [4]
		65, 65, 0xc0002, // [5]
		58, 60, 0x30010, // [6]
		62, 64, 0x30010, // [7]
		69, 71, 0x10005a, // [8]
		74, 75, 0x100002, // [9]
		78, 78, 0x110002, // [10]
		71, 73, 0x30010, // [11]
		75, 77, 0x30010, // [12]
		82, 84, 0x13005a, // [13]
		87, 88, 0x100002, // [14]
		91, 92, 0x100002, // [15]
		95, 96, 0x140002, // [16]
		84, 86, 0x30013, // [17]
		88, 90, 0x30010, // [18]
		92, 94, 0x30010, // [19]
		99, 103, 0x2004a, // [20]
		105, 109, 0x20052, // [21]
		111, 115, 0x2002f, // [22]
	},
	NumStmt: [23]uint16{
		2, // 0
		1, // 1
		1, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		2, // 15
		2, // 16
		1, // 17
		1, // 18
		1, // 19
		3, // 20
		3, // 21
		3, // 22
	},
}
var _ = _cover_atomic_.LoadUint32
