//line /home/cooper/go/src/github.com/hyperledger/fabric/token/client/client.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package client; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/token"
	tk "github.com/hyperledger/fabric/token"
)

//go:generate counterfeiter -o mock/prover.go -fake-name Prover . Prover

type Prover interface {

	// RequestImport allows the client to submit an issue request to a prover peer service;
	// the function takes as parameters tokensToIssue and the signing identity of the client;
	// it returns a response in bytes and an error message in the case the request fails.
	// The response corresponds to a serialized TokenTransaction protobuf message.
	RequestImport(tokensToIssue []*token.TokenToIssue, signingIdentity tk.SigningIdentity) ([]byte, error)

	// RequestTransfer allows the client to submit a transfer request to a prover peer service;
	// the function takes as parameters a fabtoken application credential, the identifiers of the tokens
	// to be transfererd and the shares describing how they are going to be distributed
	// among recipients; it returns a response in bytes and an error message in the case the
	// request fails
	RequestTransfer(tokenIDs [][]byte, shares []*token.RecipientTransferShare, signingIdentity tk.SigningIdentity) ([]byte, error)
}

//go:generate counterfeiter -o mock/fabric_tx_submitter.go -fake-name FabricTxSubmitter . FabricTxSubmitter

type FabricTxSubmitter interface {

	// Submit allows the client to build and submit a fabric transaction for fabtoken that has as
	// payload a serialized tx; it takes as input an array of bytes
	// and returns an error indicating the success or the failure of the tx submission and an error
	// explaining why.
	Submit(tx []byte) error
}

// Client represents the client struct that calls Prover and TxSubmitter
type Client struct {
	SigningIdentity tk.SigningIdentity
	Prover          Prover
	TxSubmitter     FabricTxSubmitter
}

// Issue is the function that the client calls to introduce tokens into the system.
// Issue takes as parameter an array of token.TokenToIssue that define what tokens
// are going to be introduced.

func (c *Client) Issue(tokensToIssue []*token.TokenToIssue) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[0], 1);
	serializedTokenTx, err := c.Prover.RequestImport(tokensToIssue, c.SigningIdentity)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[3], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[1], 1);tx, err := c.createTx(serializedTokenTx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[4], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[2], 1);return tx, c.TxSubmitter.Submit(tx)
}

// Transfer is the function that the client calls to transfer his tokens.
// Transfer takes as parameter an array of token.RecipientTransferShare that
// identifies who receives the tokens and describes how the tokens are distributed.
func (c *Client) Transfer(tokenIDs [][]byte, shares []*token.RecipientTransferShare) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[5], 1);
	serializedTokenTx, err := c.Prover.RequestTransfer(tokenIDs, shares, c.SigningIdentity)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[8], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[6], 1);tx, err := c.createTx(serializedTokenTx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[9], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[7], 1);return tx, c.TxSubmitter.Submit(tx)
}

// TODO to be updated later to have a proper fabric header
// createTx is a function that creates a fabric tx form an array of bytes.
func (c *Client) createTx(tokenTx []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[10], 1);
	payload := &common.Payload{Data: tokenTx}
	payloadBytes, err := proto.Marshal(payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[13], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[11], 1);signature, err := c.SigningIdentity.Sign(payloadBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[14], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_386238643262613636363863.Count[12], 1);envelope := &common.Envelope{Payload: payloadBytes, Signature: signature}
	return proto.Marshal(envelope)
}

var GoCover_0_386238643262613636363863 = struct {
	Count     [15]uint32
	Pos       [3 * 15]uint32
	NumStmt   [15]uint16
} {
	Pos: [3 * 15]uint32{
		56, 58, 0x10004d, // [0]
		62, 63, 0x100002, // [1]
		67, 67, 0x250002, // [2]
		58, 60, 0x30010, // [3]
		63, 65, 0x30010, // [4]
		73, 75, 0x100066, // [5]
		78, 79, 0x100002, // [6]
		83, 83, 0x250002, // [7]
		75, 77, 0x30010, // [8]
		79, 81, 0x30010, // [9]
		88, 91, 0x10003b, // [10]
		94, 95, 0x100002, // [11]
		98, 99, 0x200002, // [12]
		91, 93, 0x30010, // [13]
		95, 97, 0x30010, // [14]
	},
	NumStmt: [15]uint16{
		2, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		3, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
	},
}
var _ = _cover_atomic_.LoadUint32
