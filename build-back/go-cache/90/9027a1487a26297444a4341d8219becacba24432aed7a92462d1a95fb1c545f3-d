//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/consensus/etcdraft/blockcreator.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package etcdraft; import _cover_atomic_ "sync/atomic"

import (
	"bytes"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	cb "github.com/hyperledger/fabric/protos/common"
)

// This governs the max number of created blocks in-flight; i.e. blocks
// that were created but not written.
// CreateNextBLock returns nil once this number of blocks are in-flight.
const createdBlocksBuffersize = 20

// blockCreator optimistically creates blocks in a chain. The created
// blocks may not be written out eventually. This enables us to pipeline
// the creation of blocks with achieving consensus on them leading to
// performance improvements. The created chain is discarded if a
// diverging block is committed
// To safely use blockCreator, only one thread should interact with it.
type blockCreator struct {
	CreatedBlocks      chan *cb.Block
	LastCreatedBlock   *cb.Block
	LastCommittedBlock *cb.Block
	logger             *flogging.FabricLogger
}

func newBlockCreator(lastBlock *cb.Block, logger *flogging.FabricLogger) *blockCreator {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[0], 1);
	if lastBlock == nil {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[2], 1);
		logger.Panic("block creator initialized with nil last block")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[1], 1);bc := &blockCreator{
		CreatedBlocks:      make(chan *cb.Block, createdBlocksBuffersize),
		LastCreatedBlock:   lastBlock,
		LastCommittedBlock: lastBlock,
		logger:             logger,
	}

	logger.Debugf("Initialized block creator with (lastblockNumber=%d)", lastBlock.Header.Number)
	return bc
}

// CreateNextBlock creates a new block with the next block number, and the
// given contents.
// Returns the created block if the block could be created else nil.
// It can fail when the there are `createdBlocksBuffersize` blocks already
// created and no more can be accomodated in the `CreatedBlocks` channel.
func (bc *blockCreator) createNextBlock(messages []*cb.Envelope) *cb.Block {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[3], 1);
	previousBlockHash := bc.LastCreatedBlock.Header.Hash()

	data := &cb.BlockData{
		Data: make([][]byte, len(messages)),
	}

	var err error
	for i, msg := range messages {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[5], 1);
		data.Data[i], err = proto.Marshal(msg)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[6], 1);
			bc.logger.Panicf("Could not marshal envelope: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[4], 1);block := cb.NewBlock(bc.LastCreatedBlock.Header.Number+1, previousBlockHash)
	block.Header.DataHash = data.Hash()
	block.Data = data

	select {
	case bc.CreatedBlocks <- block:_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[7], 1);
		bc.LastCreatedBlock = block
		bc.logger.Debugf("Created block %d", bc.LastCreatedBlock.Header.Number)
		return block
	default:_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[8], 1);
		return nil
	}
}

// ResetCreatedBlocks resets the queue of created blocks.
// Subsequent blocks will be created over the block that was last committed
// using CommitBlock.
func (bc *blockCreator) resetCreatedBlocks() {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[9], 1);
	// We should not recreate CreatedBlocks channel since it can lead to
	// data races on its access
	for len(bc.CreatedBlocks) > 0 {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[11], 1);
		// empties the channel
		<-bc.CreatedBlocks
	}
	_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[10], 1);bc.LastCreatedBlock = bc.LastCommittedBlock
	bc.logger.Debug("Reset created blocks")
}

// commitBlock should be invoked for all blocks to let the blockCreator know
// which blocks have been committed. If the committed block is divergent from
// the stack of created blocks then the stack is reset.
func (bc *blockCreator) commitBlock(block *cb.Block) {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[12], 1);
	bc.LastCommittedBlock = block

	// check if the committed block diverges from the created blocks
	select {
	case b := <-bc.CreatedBlocks:_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[13], 1);
		if !bytes.Equal(b.Header.Bytes(), block.Header.Bytes()) {_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[15], 1);
			// the written block is diverging from the createBlocks stack
			// discard the created blocks
			bc.resetCreatedBlocks()
		}
		// else the written block is part of the createBlocks stack; nothing to be done
	default:_cover_atomic_.AddUint32(&GoCover_0_643961326533346231666662.Count[14], 1);
		// No created blocks; set this block as the last created block.
		// This happens when calls to WriteBlock are being made without a CreateNextBlock being called.
		// For example, in the case of etcd/raft, the leader proposes blocks and the followers
		// only write the proposed blocks.
		bc.LastCreatedBlock = block
	}
}

var GoCover_0_643961326533346231666662 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		35, 36, 0x160058, // [0]
		39, 47, 0xb0002, // [1]
		36, 38, 0x30016, // [2]
		55, 63, 0x1f004c, // [3]
		70, 74, 0x90002, // [4]
		63, 65, 0x11001f, // [5]
		65, 67, 0x40011, // [6]
		75, 78, 0xf0021, // [7]
		79, 80, 0xd000a, // [8]
		87, 90, 0x20002e, // [9]
		94, 95, 0x290002, // [10]
		90, 93, 0x30020, // [11]
		101, 105, 0x90036, // [12]
		106, 107, 0x3b001f, // [13]
		113, 118, 0x1e000a, // [14]
		107, 111, 0x4003b, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		3, // 1
		1, // 2
		4, // 3
		4, // 4
		2, // 5
		1, // 6
		3, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
