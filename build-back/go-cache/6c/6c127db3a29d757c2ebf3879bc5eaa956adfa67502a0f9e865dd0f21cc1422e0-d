//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/platforms/golang/package.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package golang; import _cover_atomic_ "sync/atomic"

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/hyperledger/fabric/common/flogging"
	ccutil "github.com/hyperledger/fabric/core/chaincode/platforms/util"
)

var includeFileTypes = map[string]bool{
	".c":    true,
	".h":    true,
	".s":    true,
	".go":   true,
	".yaml": true,
	".json": true,
}

var logger = flogging.MustGetLogger("chaincode.platform.golang")

func getCodeFromFS(path string) (codegopath string, err error) {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[0], 1);
	logger.Debugf("getCodeFromFS %s", path)
	gopath, err := getGopath()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[3], 1);
		return "", err
	}

	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[1], 1);tmppath := filepath.Join(gopath, "src", path)
	if err := ccutil.IsCodeExist(tmppath); err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[4], 1);
		return "", fmt.Errorf("code does not exist %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[2], 1);return gopath, nil
}

type CodeDescriptor struct {
	Gopath, Pkg string
	Cleanup     func()
}

// collectChaincodeFiles collects chaincode files. If path is a HTTP(s) url it
// downloads the code first.
//
//NOTE: for dev mode, user builds and runs chaincode manually. The name provided
//by the user is equivalent to the path.
func getCode(path string) (*CodeDescriptor, error) {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[5], 1);
	if path == "" {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[8], 1);
		return nil, errors.New("Cannot collect files from empty chaincode path")
	}

	// code root will point to the directory where the code exists
	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[6], 1);var gopath string
	gopath, err := getCodeFromFS(path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[9], 1);
		return nil, fmt.Errorf("Error getting code %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[7], 1);return &CodeDescriptor{Gopath: gopath, Pkg: path, Cleanup: nil}, nil
}

type SourceDescriptor struct {
	Name, Path string
	IsMetadata bool
	Info       os.FileInfo
}
type SourceMap map[string]SourceDescriptor

type Sources []SourceDescriptor

func (s Sources) Len() int {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[10], 1);
	return len(s)
}

func (s Sources) Swap(i, j int) {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[11], 1);
	s[i], s[j] = s[j], s[i]
}

func (s Sources) Less(i, j int) bool {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[12], 1);
	return strings.Compare(s[i].Name, s[j].Name) < 0
}

func findSource(gopath, pkg string) (SourceMap, error) {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[13], 1);
	sources := make(SourceMap)
	tld := filepath.Join(gopath, "src", pkg)
	walkFn := func(path string, info os.FileInfo, err error) error {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[16], 1);

		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[21], 1);
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[17], 1);if info.IsDir() {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[22], 1);

			// Allow import of the top level chaincode directory into chaincode code package
			if path == tld {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[25], 1);
				return nil
			}

			// Allow import of META-INF metadata directories into chaincode code package tar.
			// META-INF directories contain chaincode metadata artifacts such as statedb index definitions
			_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[23], 1);if isMetadataDir(path, tld) {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[26], 1);
				logger.Debug("Files in META-INF directory will be included in code package tar:", path)
				return nil
			}

			// Do not import any other directories into chaincode code package
			_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[24], 1);logger.Debugf("skipping dir: %s", path)
			return filepath.SkipDir
		}

		_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[18], 1);ext := filepath.Ext(path)
		// we only want 'fileTypes' source files at this point
		if _, ok := includeFileTypes[ext]; ok != true {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[27], 1);
			return nil
		}

		_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[19], 1);name, err := filepath.Rel(gopath, path)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[28], 1);
			return fmt.Errorf("error obtaining relative path for %s: %s", path, err)
		}

		_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[20], 1);sources[name] = SourceDescriptor{Name: name, Path: path, IsMetadata: isMetadataDir(path, tld), Info: info}

		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[14], 1);if err := filepath.Walk(tld, walkFn); err != nil {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[29], 1);
		return nil, fmt.Errorf("Error walking directory: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[15], 1);return sources, nil
}

// isMetadataDir checks to see if the current path is in the META-INF directory at the root of the chaincode directory
func isMetadataDir(path, tld string) bool {_cover_atomic_.AddUint32(&GoCover_2_346363666338363036383165.Count[30], 1);
	return strings.HasPrefix(path, filepath.Join(tld, "META-INF"))
}

var GoCover_2_346363666338363036383165 = struct {
	Count     [31]uint32
	Pos       [3 * 31]uint32
	NumStmt   [31]uint16
} {
	Pos: [3 * 31]uint32{
		31, 34, 0x100040, // [0]
		38, 39, 0x340002, // [1]
		43, 43, 0x140002, // [2]
		34, 36, 0x30010, // [3]
		39, 41, 0x30034, // [4]
		56, 57, 0x100034, // [5]
		62, 64, 0x100002, // [6]
		68, 68, 0x460002, // [7]
		57, 59, 0x30010, // [8]
		64, 66, 0x30010, // [9]
		80, 82, 0x2001c, // [10]
		84, 86, 0x20021, // [11]
		88, 90, 0x20026, // [12]
		92, 95, 0x410038, // [13]
		136, 136, 0x330002, // [14]
		140, 140, 0x150002, // [15]
		95, 97, 0x110041, // [16]
		101, 101, 0x130003, // [17]
		120, 122, 0x310003, // [18]
		126, 127, 0x110003, // [19]
		131, 133, 0xd0003, // [20]
		97, 99, 0x40011, // [21]
		101, 104, 0x130013, // [22]
		110, 110, 0x200004, // [23]
		116, 117, 0x1b0004, // [24]
		104, 106, 0x50013, // [25]
		110, 113, 0x50020, // [26]
		122, 124, 0x40031, // [27]
		127, 129, 0x40011, // [28]
		136, 138, 0x30033, // [29]
		144, 146, 0x2002b, // [30]
	},
	NumStmt: [31]uint16{
		3, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		3, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		3, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		2, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
	},
}
var _ = _cover_atomic_.LoadUint32
