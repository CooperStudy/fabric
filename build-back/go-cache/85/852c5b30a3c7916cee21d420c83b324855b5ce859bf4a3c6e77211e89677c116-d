//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/channel.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"math"

	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/common/capabilities"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/msp"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

// Channel config keys
const (
	// ConsortiumKey is the key for the cb.ConfigValue for the Consortium message
	ConsortiumKey = "Consortium"

	// HashingAlgorithmKey is the cb.ConfigItem type key name for the HashingAlgorithm message
	HashingAlgorithmKey = "HashingAlgorithm"

	// BlockDataHashingStructureKey is the cb.ConfigItem type key name for the BlockDataHashingStructure message
	BlockDataHashingStructureKey = "BlockDataHashingStructure"

	// OrdererAddressesKey is the cb.ConfigItem type key name for the OrdererAddresses message
	OrdererAddressesKey = "OrdererAddresses"

	// GroupKey is the name of the channel group
	ChannelGroupKey = "Channel"

	// CapabilitiesKey is the name of the key which refers to capabilities, it appears at the channel,
	// application, and orderer levels and this constant is used for all three.
	CapabilitiesKey = "Capabilities"
)

// ChannelValues gives read only access to the channel configuration
type ChannelValues interface {
	// HashingAlgorithm returns the default algorithm to be used when hashing
	// such as computing block hashes, and CreationPolicy digests
	HashingAlgorithm() func(input []byte) []byte

	// BlockDataHashingStructureWidth returns the width to use when constructing the
	// Merkle tree to compute the BlockData hash
	BlockDataHashingStructureWidth() uint32

	// OrdererAddresses returns the list of valid orderer addresses to connect to to invoke Broadcast/Deliver
	OrdererAddresses() []string
}

// ChannelProtos is where the proposed configuration is unmarshaled into
type ChannelProtos struct {
	HashingAlgorithm          *cb.HashingAlgorithm
	BlockDataHashingStructure *cb.BlockDataHashingStructure
	OrdererAddresses          *cb.OrdererAddresses
	Consortium                *cb.Consortium
	Capabilities              *cb.Capabilities
}

// ChannelConfig stores the channel configuration
type ChannelConfig struct {
	protos *ChannelProtos

	hashingAlgorithm func(input []byte) []byte

	mspManager msp.MSPManager

	appConfig         *ApplicationConfig
	ordererConfig     *OrdererConfig
	consortiumsConfig *ConsortiumsConfig
}

// NewChannelConfig creates a new ChannelConfig
func NewChannelConfig(channelGroup *cb.ConfigGroup) (*ChannelConfig, error) {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[0], 1);
	cc := &ChannelConfig{
		protos: &ChannelProtos{},
	}

	if err := DeserializeProtoValuesFromGroup(channelGroup, cc.protos); err != nil {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[5], 1);
		return nil, errors.Wrap(err, "failed to deserialize values")
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[1], 1);if err := cc.Validate(); err != nil {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[6], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[2], 1);capabilities := cc.Capabilities()
	mspConfigHandler := NewMSPConfigHandler(capabilities.MSPVersion())

	var err error
	for groupName, group := range channelGroup.Groups {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[7], 1);
		switch groupName {
		case ApplicationGroupKey:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[9], 1);
			cc.appConfig, err = NewApplicationConfig(group, mspConfigHandler)
		case OrdererGroupKey:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[10], 1);
			cc.ordererConfig, err = NewOrdererConfig(group, mspConfigHandler)
		case ConsortiumsGroupKey:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[11], 1);
			cc.consortiumsConfig, err = NewConsortiumsConfig(group, mspConfigHandler)
		default:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[12], 1);
			return nil, fmt.Errorf("Disallowed channel group: %s", group)
		}
		_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[8], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[13], 1);
			return nil, errors.Wrapf(err, "could not create channel %s sub-group config", groupName)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[3], 1);if cc.mspManager, err = mspConfigHandler.CreateMSPManager(); err != nil {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[14], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[4], 1);return cc, nil
}

// MSPManager returns the MSP manager for this config
func (cc *ChannelConfig) MSPManager() msp.MSPManager {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[15], 1);
	return cc.mspManager
}

// OrdererConfig returns the orderer config associated with this channel
func (cc *ChannelConfig) OrdererConfig() *OrdererConfig {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[16], 1);
	return cc.ordererConfig
}

// ApplicationConfig returns the application config associated with this channel
func (cc *ChannelConfig) ApplicationConfig() *ApplicationConfig {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[17], 1);
	return cc.appConfig
}

// ConsortiumsConfig returns the consortium config associated with this channel if it exists
func (cc *ChannelConfig) ConsortiumsConfig() *ConsortiumsConfig {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[18], 1);
	return cc.consortiumsConfig
}

// HashingAlgorithm returns a function pointer to the chain hashing algorihtm
func (cc *ChannelConfig) HashingAlgorithm() func(input []byte) []byte {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[19], 1);
	return cc.hashingAlgorithm
}

// BlockDataHashingStructure returns the width to use when forming the block data hashing structure
func (cc *ChannelConfig) BlockDataHashingStructureWidth() uint32 {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[20], 1);
	return cc.protos.BlockDataHashingStructure.Width
}

// OrdererAddresses returns the list of valid orderer addresses to connect to to invoke Broadcast/Deliver
func (cc *ChannelConfig) OrdererAddresses() []string {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[21], 1);
	return cc.protos.OrdererAddresses.Addresses
}

// ConsortiumName returns the name of the consortium this channel was created under
func (cc *ChannelConfig) ConsortiumName() string {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[22], 1);
	return cc.protos.Consortium.Name
}

// Capabilities returns information about the available capabilities for this channel
func (cc *ChannelConfig) Capabilities() ChannelCapabilities {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[23], 1);
	return capabilities.NewChannelProvider(cc.protos.Capabilities.Capabilities)
}

// Validate inspects the generated configuration protos and ensures that the values are correct
func (cc *ChannelConfig) Validate() error {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[24], 1);
	for _, validator := range []func() error{
		cc.validateHashingAlgorithm,
		cc.validateBlockDataHashingStructure,
		cc.validateOrdererAddresses,
	} {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[26], 1);
		if err := validator(); err != nil {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[27], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[25], 1);return nil
}

func (cc *ChannelConfig) validateHashingAlgorithm() error {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[28], 1);
	switch cc.protos.HashingAlgorithm.Name {
	case bccsp.SHA256:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[30], 1);
		cc.hashingAlgorithm = util.ComputeSHA256
	case bccsp.SHA3_256:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[31], 1);
		cc.hashingAlgorithm = util.ComputeSHA3256
	default:_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[32], 1);
		return fmt.Errorf("Unknown hashing algorithm type: %s", cc.protos.HashingAlgorithm.Name)
	}

	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[29], 1);return nil
}

func (cc *ChannelConfig) validateBlockDataHashingStructure() error {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[33], 1);
	if cc.protos.BlockDataHashingStructure.Width != math.MaxUint32 {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[35], 1);
		return fmt.Errorf("BlockDataHashStructure width only supported at MaxUint32 in this version")
	}
	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[34], 1);return nil
}

func (cc *ChannelConfig) validateOrdererAddresses() error {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[36], 1);
	if len(cc.protos.OrdererAddresses.Addresses) == 0 {_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[38], 1);
		return fmt.Errorf("Must set some OrdererAddresses")
	}
	_cover_atomic_.AddUint32(&GoCover_6_373339383034363064316135.Count[37], 1);return nil
}

var GoCover_6_373339383034363064316135 = struct {
	Count     [39]uint32
	Pos       [3 * 39]uint32
	NumStmt   [39]uint16
} {
	Pos: [3 * 39]uint32{
		80, 85, 0x51004d, // [0]
		89, 89, 0x260002, // [1]
		93, 97, 0x340002, // [2]
		113, 113, 0x4a0002, // [3]
		117, 117, 0x100002, // [4]
		85, 87, 0x30051, // [5]
		89, 91, 0x30026, // [6]
		97, 98, 0x140034, // [7]
		108, 108, 0x110003, // [8]
		99, 100, 0x45001c, // [9]
		101, 102, 0x450018, // [10]
		103, 104, 0x4d001c, // [11]
		105, 106, 0x41000b, // [12]
		108, 110, 0x40011, // [13]
		113, 115, 0x3004a, // [14]
		121, 123, 0x20036, // [15]
		126, 128, 0x20039, // [16]
		131, 133, 0x20041, // [17]
		136, 138, 0x20041, // [18]
		141, 143, 0x20047, // [19]
		146, 148, 0x20042, // [20]
		151, 153, 0x20036, // [21]
		156, 158, 0x20032, // [22]
		161, 163, 0x2003d, // [23]
		166, 171, 0x4002b, // [24]
		177, 177, 0xc0002, // [25]
		171, 172, 0x250004, // [26]
		172, 174, 0x40025, // [27]
		180, 181, 0x29003b, // [28]
		190, 190, 0xc0002, // [29]
		182, 183, 0x2b0014, // [30]
		184, 185, 0x2c0016, // [31]
		186, 187, 0x5b000a, // [32]
		193, 194, 0x410044, // [33]
		197, 197, 0xc0002, // [34]
		194, 196, 0x30041, // [35]
		200, 201, 0x34003b, // [36]
		204, 204, 0xc0002, // [37]
		201, 203, 0x30034, // [38]
	},
	NumStmt: [39]uint16{
		2, // 0
		1, // 1
		4, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
	},
}
var _ = _cover_atomic_.LoadUint32
