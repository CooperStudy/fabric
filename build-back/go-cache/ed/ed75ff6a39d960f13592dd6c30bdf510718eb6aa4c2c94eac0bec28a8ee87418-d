//line /home/cooper/go/src/github.com/hyperledger/fabric/common/crypto/expiration.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package crypto; import _cover_atomic_ "sync/atomic"

import (
	"crypto/x509"
	"encoding/pem"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/protos/msp"
)

// ExpiresAt returns when the given identity expires, or a zero time.Time
// in case we cannot determine that
func ExpiresAt(identityBytes []byte) time.Time {_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[0], 1);
	sId := &msp.SerializedIdentity{}
	// If protobuf parsing failed, we make no decisions about the expiration time
	if err := proto.Unmarshal(identityBytes, sId); err != nil {_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[4], 1);
		return time.Time{}
	}
	_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[1], 1);bl, _ := pem.Decode(sId.IdBytes)
	if bl == nil {_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[5], 1);
		// If the identity isn't a PEM block, we make no decisions about the expiration time
		return time.Time{}
	}
	_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[2], 1);cert, err := x509.ParseCertificate(bl.Bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[6], 1);
		return time.Time{}
	}
	_cover_atomic_.AddUint32(&GoCover_0_653639303734353666643263.Count[3], 1);return cert.NotAfter
}

var GoCover_0_653639303734353666643263 = struct {
	Count     [7]uint32
	Pos       [3 * 7]uint32
	NumStmt   [7]uint16
} {
	Pos: [3 * 7]uint32{
		20, 23, 0x3c0030, // [0]
		26, 27, 0xf0002, // [1]
		31, 32, 0x100002, // [2]
		35, 35, 0x160002, // [3]
		23, 25, 0x3003c, // [4]
		27, 30, 0x3000f, // [5]
		32, 34, 0x30010, // [6]
	},
	NumStmt: [7]uint16{
		2, // 0
		2, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
	},
}
var _ = _cover_atomic_.LoadUint32
