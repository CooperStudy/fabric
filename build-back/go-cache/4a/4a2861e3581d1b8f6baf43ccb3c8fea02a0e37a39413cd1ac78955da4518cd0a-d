//line /home/cooper/go/src/github.com/hyperledger/fabric/core/config/config.go:1
/*
Copyright Greg Haskins <gregory.haskins@gmail.com> 2017, All Rights Reserved.
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package config; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/viper"
)

func dirExists(path string) bool {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[0], 1);
	fi, err := os.Stat(path)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[2], 1);
		return false
	}
	_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[1], 1);return fi.IsDir()
}

func AddConfigPath(v *viper.Viper, p string) {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[3], 1);
	if v != nil {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[4], 1);
		v.AddConfigPath(p)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[5], 1);{
		viper.AddConfigPath(p)
	}}
}

//----------------------------------------------------------------------------------
// TranslatePath()
//----------------------------------------------------------------------------------
// Translates a relative path into a fully qualified path relative to the config
// file that specified it.  Absolute paths are passed unscathed.
//----------------------------------------------------------------------------------
func TranslatePath(base, p string) string {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[6], 1);
	if filepath.IsAbs(p) {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[8], 1);
		return p
	}

	_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[7], 1);return filepath.Join(base, p)
}

//----------------------------------------------------------------------------------
// TranslatePathInPlace()
//----------------------------------------------------------------------------------
// Translates a relative path into a fully qualified path in-place (updating the
// pointer) relative to the config file that specified it.  Absolute paths are
// passed unscathed.
//----------------------------------------------------------------------------------
func TranslatePathInPlace(base string, p *string) {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[9], 1);
	*p = TranslatePath(base, *p)
}

//----------------------------------------------------------------------------------
// GetPath()
//----------------------------------------------------------------------------------
// GetPath allows configuration strings that specify a (config-file) relative path
//
// For example: Assume our config is located in /etc/hyperledger/fabric/core.yaml with
// a key "msp.configPath" = "msp/config.yaml".
//
// This function will return:
//      GetPath("msp.configPath") -> /etc/hyperledger/fabric/msp/config.yaml
//
//----------------------------------------------------------------------------------
func GetPath(key string) string {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[10], 1);
	p := viper.GetString(key)
	if p == "" {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[12], 1);
		return ""
	}

	_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[11], 1);return TranslatePath(filepath.Dir(viper.ConfigFileUsed()), p)
}

const OfficialPath = "/etc/hyperledger/fabric"

//----------------------------------------------------------------------------------
// InitViper()
//----------------------------------------------------------------------------------
// Performs basic initialization of our viper-based configuration layer.
// Primary thrust is to establish the paths that should be consulted to find
// the configuration we need.  If v == nil, we will initialize the global
// Viper instance
//----------------------------------------------------------------------------------
func InitViper(v *viper.Viper, configName string) error {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[13], 1);
	var altPath = os.Getenv("FABRIC_CFG_PATH")
	if altPath != "" {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[16], 1);
		// If the user has overridden the path with an envvar, its the only path
		// we will consider

		if !dirExists(altPath) {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[18], 1);
			return fmt.Errorf("FABRIC_CFG_PATH %s does not exist", altPath)
		}

		_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[17], 1);AddConfigPath(v, altPath)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[19], 1);{
		// If we get here, we should use the default paths in priority order:
		//
		// *) CWD
		// *) /etc/hyperledger/fabric

		// CWD
		AddConfigPath(v, "./")

		// And finally, the official path
		if dirExists(OfficialPath) {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[20], 1);
			AddConfigPath(v, OfficialPath)
		}
	}}

	// Now set the configuration file.
	_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[14], 1);if v != nil {_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[21], 1);
		v.SetConfigName(configName)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[22], 1);{
		viper.SetConfigName(configName)
	}}

	_cover_atomic_.AddUint32(&GoCover_0_353361333462353934383933.Count[15], 1);return nil
}

var GoCover_0_353361333462353934383933 = struct {
	Count     [23]uint32
	Pos       [3 * 23]uint32
	NumStmt   [23]uint16
} {
	Pos: [3 * 23]uint32{
		18, 20, 0x100022, // [0]
		23, 23, 0x130002, // [1]
		20, 22, 0x30010, // [2]
		26, 27, 0xe002e, // [3]
		27, 29, 0x3000e, // [4]
		29, 31, 0x30008, // [5]
		40, 41, 0x17002b, // [6]
		45, 45, 0x1f0002, // [7]
		41, 43, 0x30017, // [8]
		55, 57, 0x20033, // [9]
		71, 73, 0xd0021, // [10]
		77, 77, 0x3f0002, // [11]
		73, 75, 0x3000d, // [12]
		90, 92, 0x130039, // [13]
		117, 117, 0xe0002, // [14]
		123, 123, 0xc0002, // [15]
		92, 96, 0x1a0013, // [16]
		100, 100, 0x1c0003, // [17]
		96, 98, 0x4001a, // [18]
		101, 111, 0x1e0008, // [19]
		111, 113, 0x4001e, // [20]
		117, 119, 0x3000e, // [21]
		119, 121, 0x30008, // [22]
	},
	NumStmt: [23]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
	},
}
var _ = _cover_atomic_.LoadUint32
