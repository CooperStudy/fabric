//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/client/selection.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package discovery; import _cover_atomic_ "sync/atomic"

import (
	"math/rand"
	"sort"
	"time"
)

// Filter filters and sorts the given endorsers
type Filter interface {
	Filter(endorsers Endorsers) Endorsers
}

// ExclusionFilter returns true if the given Peer
// is not to be considered when selecting peers
type ExclusionFilter interface {
	// Exclude returns whether the given Peer is to be excluded or not
	Exclude(Peer) bool
}

type selectionFunc func(Peer) bool

func (sf selectionFunc) Exclude(p Peer) bool {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[0], 1);
	return sf(p)
}

// PrioritySelector guides the selection of peers via
// giving peers a relative priority to their selection
type PrioritySelector interface {
	// Compare compares between 2 peers and returns
	// their relative scores
	Compare(Peer, Peer) Priority
}

// Priority defines how likely a peer is to be selected
// over another peer.
// Positive priority means the left peer is selected
// Negative priority means the right peer is selected
// Zero priority means their priorities are the same
type Priority int

var (
	// PrioritiesByHeight selects peers by descending height
	PrioritiesByHeight = &byHeight{}
	// NoExclusion accepts all peers and rejects no peers
	NoExclusion = selectionFunc(noExclusion)
	// NoPriorities is indifferent to how it selects peers
	NoPriorities = &noPriorities{}
)

type noPriorities struct{}

func (nc noPriorities) Compare(_ Peer, _ Peer) Priority {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[1], 1);
	return 0
}

type byHeight struct{}

func (*byHeight) Compare(left Peer, right Peer) Priority {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[2], 1);
	leftHeight := left.StateInfoMessage.GetStateInfo().Properties.LedgerHeight
	rightHeight := right.StateInfoMessage.GetStateInfo().Properties.LedgerHeight

	if leftHeight > rightHeight {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[5], 1);
		return 1
	}
	_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[3], 1);if rightHeight > leftHeight {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[6], 1);
		return -1
	}
	_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[4], 1);return 0
}

func noExclusion(_ Peer) bool {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[7], 1);
	return false
}

// ExcludeHosts returns a ExclusionFilter that excludes the given endpoints
func ExcludeHosts(endpoints ...string) ExclusionFilter {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[8], 1);
	m := make(map[string]struct{})
	for _, endpoint := range endpoints {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[10], 1);
		m[endpoint] = struct{}{}
	}
	_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[9], 1);return ExcludeByHost(func(host string) bool {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[11], 1);
		_, excluded := m[host]
		return excluded
	})
}

// ExcludeByHost creates a ExclusionFilter out of the given exclusion predicate
func ExcludeByHost(reject func(host string) bool) ExclusionFilter {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[12], 1);
	return selectionFunc(func(p Peer) bool {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[13], 1);
		endpoint := p.AliveMessage.GetAliveMsg().Membership.Endpoint
		var internalEndpoint string
		se := p.AliveMessage.GetSecretEnvelope()
		if se != nil {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[15], 1);
			internalEndpoint = se.InternalEndpoint()
		}
		_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[14], 1);return reject(endpoint) || reject(internalEndpoint)
	})
}

// Filter filters the endorsers according to the given ExclusionFilter
func (endorsers Endorsers) Filter(f ExclusionFilter) Endorsers {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[16], 1);
	var res Endorsers
	for _, e := range endorsers {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[18], 1);
		if !f.Exclude(*e) {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[19], 1);
			res = append(res, e)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[17], 1);return res
}

// Shuffle sorts the endorsers in random order
func (endorsers Endorsers) Shuffle() Endorsers {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[20], 1);
	res := make(Endorsers, len(endorsers))
	rand.Seed(time.Now().UnixNano())
	for i, index := range rand.Perm(len(endorsers)) {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[22], 1);
		res[i] = endorsers[index]
	}
	_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[21], 1);return res
}

type endorserSort struct {
	Endorsers
	PrioritySelector
}

// Sort sorts the endorsers according to the given PrioritySelector
func (endorsers Endorsers) Sort(ps PrioritySelector) Endorsers {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[23], 1);
	sort.Sort(&endorserSort{
		Endorsers:        endorsers,
		PrioritySelector: ps,
	})
	return endorsers
}

func (es *endorserSort) Len() int {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[24], 1);
	return len(es.Endorsers)
}

func (es *endorserSort) Less(i, j int) bool {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[25], 1);
	e1 := es.Endorsers[i]
	e2 := es.Endorsers[j]
	less := es.Compare(*e1, *e2)
	return less > Priority(0)
}

func (es *endorserSort) Swap(i, j int) {_cover_atomic_.AddUint32(&GoCover_2_323533613534323836353731.Count[26], 1);
	es.Endorsers[i], es.Endorsers[j] = es.Endorsers[j], es.Endorsers[i]
}

var GoCover_2_323533613534323836353731 = struct {
	Count     [27]uint32
	Pos       [3 * 27]uint32
	NumStmt   [27]uint16
} {
	Pos: [3 * 27]uint32{
		29, 31, 0x2002e, // [0]
		59, 61, 0x20039, // [1]
		65, 69, 0x1e003a, // [2]
		72, 72, 0x1e0002, // [3]
		75, 75, 0xa0002, // [4]
		69, 71, 0x3001e, // [5]
		72, 74, 0x3001e, // [6]
		78, 80, 0x2001f, // [7]
		83, 85, 0x250038, // [8]
		88, 88, 0x2e0002, // [9]
		85, 87, 0x30025, // [10]
		88, 91, 0x3002e, // [11]
		95, 96, 0x290043, // [12]
		96, 100, 0x100029, // [13]
		103, 103, 0x360003, // [14]
		100, 102, 0x40010, // [15]
		108, 110, 0x1e0040, // [16]
		115, 115, 0xc0002, // [17]
		110, 111, 0x15001e, // [18]
		111, 113, 0x40015, // [19]
		119, 122, 0x320030, // [20]
		125, 125, 0xc0002, // [21]
		122, 124, 0x30032, // [22]
		134, 140, 0x20040, // [23]
		142, 144, 0x20023, // [24]
		146, 151, 0x2002d, // [25]
		153, 155, 0x20028, // [26]
	},
	NumStmt: [27]uint16{
		1, // 0
		1, // 1
		3, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		4, // 13
		1, // 14
		1, // 15
		2, // 16
		1, // 17
		1, // 18
		1, // 19
		3, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		4, // 25
		1, // 26
	},
}
var _ = _cover_atomic_.LoadUint32
