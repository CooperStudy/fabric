//line /home/cooper/go/src/github.com/hyperledger/fabric/examples/chaincode/go/example02/chaincode.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package example02; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

// SimpleChaincode example simple Chaincode implementation
type SimpleChaincode struct {
}

func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[0], 1);
	fmt.Println("ex02 Init")
	_, args := stub.GetFunctionAndParameters()
	var A, B string    // Entities
	var Aval, Bval int // Asset holdings
	var err error

	if len(args) != 4 {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[6], 1);
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}

	// Initialize the chaincode
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[1], 1);A = args[0]
	Aval, err = strconv.Atoi(args[1])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[7], 1);
		return shim.Error("Expecting integer value for asset holding")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[2], 1);B = args[2]
	Bval, err = strconv.Atoi(args[3])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[8], 1);
		return shim.Error("Expecting integer value for asset holding")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[3], 1);fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)

	// Write the state to the ledger
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[9], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[4], 1);err = stub.PutState(B, []byte(strconv.Itoa(Bval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[10], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[5], 1);return shim.Success(nil)
}

func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[11], 1);
	fmt.Println("ex02 Invoke")
	function, args := stub.GetFunctionAndParameters()
	if function == "invoke" {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[13], 1);
		// Make payment of X units from A to B
		return t.invoke(stub, args)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[14], 1);if function == "delete" {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[15], 1);
		// Deletes an entity from its state
		return t.delete(stub, args)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[16], 1);if function == "query" {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[17], 1);
		// the old "Query" is now implemtned in invoke
		return t.query(stub, args)
	}}}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[12], 1);return shim.Error("Invalid invoke function name. Expecting \"invoke\" \"delete\" \"query\"")
}

// Transaction makes payment of X units from A to B
func (t *SimpleChaincode) invoke(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[18], 1);
	var A, B string    // Entities
	var Aval, Bval int // Asset holdings
	var X int          // Transaction value
	var err error

	if len(args) != 3 {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[27], 1);
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[19], 1);A = args[0]
	B = args[1]

	// Get the state from the ledger
	// TODO: will be nice to have a GetAllState call to ledger
	Avalbytes, err := stub.GetState(A)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[28], 1);
		return shim.Error("Failed to get state")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[20], 1);if Avalbytes == nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[29], 1);
		return shim.Error("Entity not found")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[21], 1);Aval, _ = strconv.Atoi(string(Avalbytes))

	Bvalbytes, err := stub.GetState(B)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[30], 1);
		return shim.Error("Failed to get state")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[22], 1);if Bvalbytes == nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[31], 1);
		return shim.Error("Entity not found")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[23], 1);Bval, _ = strconv.Atoi(string(Bvalbytes))

	// Perform the execution
	X, err = strconv.Atoi(args[2])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[32], 1);
		return shim.Error("Invalid transaction amount, expecting a integer value")
	}
	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[24], 1);Aval = Aval - X
	Bval = Bval + X
	fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)

	// Write the state back to the ledger
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[33], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[25], 1);err = stub.PutState(B, []byte(strconv.Itoa(Bval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[34], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[26], 1);return shim.Success(nil)
}

// Deletes an entity from state
func (t *SimpleChaincode) delete(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[35], 1);
	if len(args) != 1 {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[38], 1);
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[36], 1);A := args[0]

	// Delete the key from the state in ledger
	err := stub.DelState(A)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[39], 1);
		return shim.Error("Failed to delete state")
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[37], 1);return shim.Success(nil)
}

// query callback representing the query of a chaincode
func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[40], 1);
	var A string // Entities
	var err error

	if len(args) != 1 {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[44], 1);
		return shim.Error("Incorrect number of arguments. Expecting name of the person to query")
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[41], 1);A = args[0]

	// Get the state from the ledger
	Avalbytes, err := stub.GetState(A)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[45], 1);
		jsonResp := "{\"Error\":\"Failed to get state for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[42], 1);if Avalbytes == nil {_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[46], 1);
		jsonResp := "{\"Error\":\"Nil amount for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	_cover_atomic_.AddUint32(&GoCover_0_396634376331346138376133.Count[43], 1);jsonResp := "{\"Name\":\"" + A + "\",\"Amount\":\"" + string(Avalbytes) + "\"}"
	fmt.Printf("Query Response:%s\n", jsonResp)
	return shim.Success(Avalbytes)
}

var GoCover_0_396634376331346138376133 = struct {
	Count     [47]uint32
	Pos       [3 * 47]uint32
	NumStmt   [47]uint16
} {
	Pos: [3 * 47]uint32{
		21, 28, 0x14004e, // [0]
		33, 35, 0x100002, // [1]
		38, 40, 0x100002, // [2]
		43, 47, 0x100002, // [3]
		51, 52, 0x100002, // [4]
		56, 56, 0x1a0002, // [5]
		28, 30, 0x30014, // [6]
		35, 37, 0x30010, // [7]
		40, 42, 0x30010, // [8]
		47, 49, 0x30010, // [9]
		52, 54, 0x30010, // [10]
		59, 62, 0x1a0050, // [11]
		73, 73, 0x5e0002, // [12]
		62, 65, 0x3001a, // [13]
		65, 65, 0x210008, // [14]
		65, 68, 0x30021, // [15]
		68, 68, 0x200008, // [16]
		68, 71, 0x30020, // [17]
		77, 83, 0x14005f, // [18]
		87, 93, 0x100002, // [19]
		96, 96, 0x160002, // [20]
		99, 102, 0x100002, // [21]
		105, 105, 0x160002, // [22]
		108, 112, 0x100002, // [23]
		115, 121, 0x100002, // [24]
		125, 126, 0x100002, // [25]
		130, 130, 0x1a0002, // [26]
		83, 85, 0x30014, // [27]
		93, 95, 0x30010, // [28]
		96, 98, 0x30016, // [29]
		102, 104, 0x30010, // [30]
		105, 107, 0x30016, // [31]
		112, 114, 0x30010, // [32]
		121, 123, 0x30010, // [33]
		126, 128, 0x30010, // [34]
		134, 135, 0x14005f, // [35]
		139, 143, 0x100002, // [36]
		147, 147, 0x1a0002, // [37]
		135, 137, 0x30014, // [38]
		143, 145, 0x30010, // [39]
		151, 155, 0x14005e, // [40]
		159, 163, 0x100002, // [41]
		168, 168, 0x160002, // [42]
		173, 175, 0x200002, // [43]
		155, 157, 0x30014, // [44]
		163, 166, 0x30010, // [45]
		168, 171, 0x30016, // [46]
	},
	NumStmt: [47]uint16{
		6, // 0
		3, // 1
		3, // 2
		3, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		3, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		5, // 18
		4, // 19
		1, // 20
		3, // 21
		1, // 22
		3, // 23
		5, // 24
		2, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		3, // 36
		1, // 37
		1, // 38
		1, // 39
		3, // 40
		3, // 41
		1, // 42
		3, // 43
		1, // 44
		2, // 45
		2, // 46
	},
}
var _ = _cover_atomic_.LoadUint32
