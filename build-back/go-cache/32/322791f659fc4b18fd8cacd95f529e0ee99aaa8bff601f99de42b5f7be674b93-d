//line /home/cooper/go/src/github.com/hyperledger/fabric/bccsp/idemix/handlers/cred.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package handlers; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/bccsp"
	"github.com/pkg/errors"
)

// CredentialRequestSigner produces credential requests
type CredentialRequestSigner struct {
	// CredRequest implements the underlying cryptographic algorithms
	CredRequest CredRequest
}

func (c *CredentialRequestSigner) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[0], 1);
	userSecretKey, ok := k.(*userSecretKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[5], 1);
		return nil, errors.New("invalid key, expected *userSecretKey")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[1], 1);credentialRequestSignerOpts, ok := opts.(*bccsp.IdemixCredentialRequestSignerOpts)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[6], 1);
		return nil, errors.New("invalid options, expected *IdemixCredentialRequestSignerOpts")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[2], 1);if credentialRequestSignerOpts.IssuerPK == nil {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[7], 1);
		return nil, errors.New("invalid options, missing issuer public key")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[3], 1);issuerPK, ok := credentialRequestSignerOpts.IssuerPK.(*issuerPublicKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[8], 1);
		return nil, errors.New("invalid options, expected IssuerPK as *issuerPublicKey")
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[4], 1);return c.CredRequest.Sign(userSecretKey.sk, issuerPK.pk, credentialRequestSignerOpts.IssuerNonce)
}

// CredentialRequestVerifier verifies credential requests
type CredentialRequestVerifier struct {
	// CredRequest implements the underlying cryptographic algorithms
	CredRequest CredRequest
}

func (c *CredentialRequestVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (bool, error) {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[9], 1);
	issuerPublicKey, ok := k.(*issuerPublicKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[13], 1);
		return false, errors.New("invalid key, expected *issuerPublicKey")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[10], 1);credentialRequestSignerOpts, ok := opts.(*bccsp.IdemixCredentialRequestSignerOpts)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[14], 1);
		return false, errors.New("invalid options, expected *IdemixCredentialRequestSignerOpts")
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[11], 1);err := c.CredRequest.Verify(signature, issuerPublicKey.pk, credentialRequestSignerOpts.IssuerNonce)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[15], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[12], 1);return true, nil
}

type CredentialSigner struct {
	Credential Credential
}

func (s *CredentialSigner) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[16], 1);
	issuerSecretKey, ok := k.(*issuerSecretKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[20], 1);
		return nil, errors.New("invalid key, expected *issuerSecretKey")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[17], 1);credOpts, ok := opts.(*bccsp.IdemixCredentialSignerOpts)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[21], 1);
		return nil, errors.New("invalid options, expected *IdemixCredentialSignerOpts")
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[18], 1);signature, err = s.Credential.Sign(issuerSecretKey.sk, digest, credOpts.Attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[22], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[19], 1);return
}

type CredentialVerifier struct {
	Credential Credential
}

func (v *CredentialVerifier) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[23], 1);
	userSecretKey, ok := k.(*userSecretKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[30], 1);
		return false, errors.New("invalid key, expected *userSecretKey")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[24], 1);credOpts, ok := opts.(*bccsp.IdemixCredentialSignerOpts)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[31], 1);
		return false, errors.New("invalid options, expected *IdemixCredentialSignerOpts")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[25], 1);if credOpts.IssuerPK == nil {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[32], 1);
		return false, errors.New("invalid options, missing issuer public key")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[26], 1);ipk, ok := credOpts.IssuerPK.(*issuerPublicKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[33], 1);
		return false, errors.New("invalid issuer public key, expected *issuerPublicKey")
	}
	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[27], 1);if len(signature) == 0 {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[34], 1);
		return false, errors.New("invalid signature, it must not be empty")
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[28], 1);err = v.Credential.Verify(userSecretKey.sk, ipk.pk, signature, credOpts.Attributes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[35], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_353738643438356165663564.Count[29], 1);return true, nil
}

var GoCover_0_353738643438356165663564 = struct {
	Count     [36]uint32
	Pos       [3 * 36]uint32
	NumStmt   [36]uint16
} {
	Pos: [3 * 36]uint32{
		19, 21, 0x9006b, // [0]
		24, 25, 0x90002, // [1]
		28, 28, 0x310002, // [2]
		31, 32, 0x90002, // [3]
		36, 36, 0x630002, // [4]
		21, 23, 0x30009, // [5]
		25, 27, 0x30009, // [6]
		28, 30, 0x30031, // [7]
		32, 34, 0x30009, // [8]
		45, 47, 0x90078, // [9]
		50, 51, 0x90002, // [10]
		55, 56, 0x100002, // [11]
		60, 60, 0x120002, // [12]
		47, 49, 0x30009, // [13]
		51, 53, 0x30009, // [14]
		56, 58, 0x30010, // [15]
		67, 69, 0x90072, // [16]
		72, 73, 0x90002, // [17]
		77, 78, 0x100002, // [18]
		82, 82, 0x80002, // [19]
		69, 71, 0x30009, // [20]
		73, 75, 0x30009, // [21]
		78, 80, 0x30010, // [22]
		89, 91, 0x9007b, // [23]
		94, 95, 0x90002, // [24]
		98, 98, 0x1e0002, // [25]
		101, 102, 0x90002, // [26]
		105, 105, 0x190002, // [27]
		109, 110, 0x100002, // [28]
		114, 114, 0x120002, // [29]
		91, 93, 0x30009, // [30]
		95, 97, 0x30009, // [31]
		98, 100, 0x3001e, // [32]
		102, 104, 0x30009, // [33]
		105, 107, 0x30019, // [34]
		110, 112, 0x30010, // [35]
	},
	NumStmt: [36]uint16{
		2, // 0
		2, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		2, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
		2, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
	},
}
var _ = _cover_atomic_.LoadUint32
