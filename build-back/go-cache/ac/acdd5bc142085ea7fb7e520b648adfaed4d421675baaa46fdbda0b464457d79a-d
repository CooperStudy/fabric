//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package lockbasedtxmgr; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	commonledger "github.com/hyperledger/fabric/common/ledger"
	ledger "github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/storageutil"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/protos/ledger/queryresult"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
	"github.com/pkg/errors"
)

type queryHelper struct {
	txmgr             *LockBasedTxMgr
	collNameValidator *collNameValidator
	rwsetBuilder      *rwsetutil.RWSetBuilder
	itrs              []*resultsItr
	err               error
	doneInvoked       bool
}

func newQueryHelper(txmgr *LockBasedTxMgr, rwsetBuilder *rwsetutil.RWSetBuilder) *queryHelper {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[0], 1);
	helper := &queryHelper{txmgr: txmgr, rwsetBuilder: rwsetBuilder}
	validator := newCollNameValidator(txmgr.ccInfoProvider, &lockBasedQueryExecutor{helper: helper})
	helper.collNameValidator = validator
	return helper
}

func (h *queryHelper) getState(ns string, key string) ([]byte, []byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[1], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[5], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[2], 1);versionedValue, err := h.txmgr.db.GetState(ns, key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[6], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[3], 1);val, metadata, ver := decomposeVersionedValue(versionedValue)
	if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[7], 1);
		h.rwsetBuilder.AddToReadSet(ns, key, ver)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[4], 1);return val, metadata, nil
}

func (h *queryHelper) getStateMultipleKeys(namespace string, keys []string) ([][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[8], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[12], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[9], 1);versionedValues, err := h.txmgr.db.GetStateMultipleKeys(namespace, keys)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[13], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[10], 1);values := make([][]byte, len(versionedValues))
	for i, versionedValue := range versionedValues {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[14], 1);
		val, _, ver := decomposeVersionedValue(versionedValue)
		if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[16], 1);
			h.rwsetBuilder.AddToReadSet(namespace, keys[i], ver)
		}
		_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[15], 1);values[i] = val
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[11], 1);return values, nil
}

func (h *queryHelper) getStateRangeScanIterator(namespace string, startKey string, endKey string) (ledger.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[17], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[20], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[18], 1);itr, err := newResultsItr(namespace, startKey, endKey, nil, h.txmgr.db, h.rwsetBuilder,
		ledgerconfig.IsQueryReadsHashingEnabled(), ledgerconfig.GetMaxDegreeQueryReadsHashing())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[21], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[19], 1);h.itrs = append(h.itrs, itr)
	return itr, nil
}

func (h *queryHelper) getStateRangeScanIteratorWithMetadata(namespace string, startKey string, endKey string, metadata map[string]interface{}) (ledger.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[22], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[25], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[23], 1);itr, err := newResultsItr(namespace, startKey, endKey, metadata, h.txmgr.db, h.rwsetBuilder,
		ledgerconfig.IsQueryReadsHashingEnabled(), ledgerconfig.GetMaxDegreeQueryReadsHashing())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[26], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[24], 1);h.itrs = append(h.itrs, itr)
	return itr, nil
}

func (h *queryHelper) executeQuery(namespace, query string) (commonledger.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[27], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[30], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[28], 1);dbItr, err := h.txmgr.db.ExecuteQuery(namespace, query)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[31], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[29], 1);return &queryResultsItr{DBItr: dbItr, RWSetBuilder: h.rwsetBuilder}, nil
}

func (h *queryHelper) executeQueryWithMetadata(namespace, query string, metadata map[string]interface{}) (ledger.QueryResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[32], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[35], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[33], 1);dbItr, err := h.txmgr.db.ExecuteQueryWithMetadata(namespace, query, metadata)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[36], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[34], 1);return &queryResultsItr{DBItr: dbItr, RWSetBuilder: h.rwsetBuilder}, nil
}

func (h *queryHelper) getPrivateData(ns, coll, key string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[37], 1);
	if err := h.validateCollName(ns, coll); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[44], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[38], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[45], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[39], 1);var err error
	var hashVersion *version.Height
	var versionedValue *statedb.VersionedValue

	if versionedValue, err = h.txmgr.db.GetPrivateData(ns, coll, key); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[46], 1);
		return nil, err
	}

	// metadata is always nil for private data - because, the metadata is part of the hashed key (instead of raw key)
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[40], 1);val, _, ver := decomposeVersionedValue(versionedValue)

	keyHash := util.ComputeStringHash(key)
	if hashVersion, err = h.txmgr.db.GetKeyHashVersion(ns, coll, keyHash); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[47], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[41], 1);if !version.AreSame(hashVersion, ver) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[48], 1);
		return nil, &txmgr.ErrPvtdataNotAvailable{Msg: fmt.Sprintf(
			"private data matching public hash version is not available. Public hash version = %#v, Private data version = %#v",
			hashVersion, ver)}
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[42], 1);if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[49], 1);
		h.rwsetBuilder.AddToHashedReadSet(ns, coll, key, ver)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[43], 1);return val, nil
}

func (h *queryHelper) getPrivateDataValueHash(ns, coll, key string) (valueHash, metadataBytes []byte, err error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[50], 1);
	if err := h.validateCollName(ns, coll); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[55], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[51], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[56], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[52], 1);var versionedValue *statedb.VersionedValue

	keyHash := util.ComputeStringHash(key)
	if versionedValue, err = h.txmgr.db.GetValueHash(ns, coll, keyHash); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[57], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[53], 1);valHash, metadata, ver := decomposeVersionedValue(versionedValue)
	if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[58], 1);
		h.rwsetBuilder.AddToHashedReadSet(ns, coll, key, ver)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[54], 1);return valHash, metadata, nil
}

func (h *queryHelper) getPrivateDataMultipleKeys(ns, coll string, keys []string) ([][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[59], 1);
	if err := h.validateCollName(ns, coll); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[64], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[60], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[65], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[61], 1);versionedValues, err := h.txmgr.db.GetPrivateDataMultipleKeys(ns, coll, keys)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[66], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[62], 1);values := make([][]byte, len(versionedValues))
	for i, versionedValue := range versionedValues {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[67], 1);
		val, _, ver := decomposeVersionedValue(versionedValue)
		if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[69], 1);
			h.rwsetBuilder.AddToHashedReadSet(ns, coll, keys[i], ver)
		}
		_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[68], 1);values[i] = val
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[63], 1);return values, nil
}

func (h *queryHelper) getPrivateDataRangeScanIterator(namespace, collection, startKey, endKey string) (commonledger.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[70], 1);
	if err := h.validateCollName(namespace, collection); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[74], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[71], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[75], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[72], 1);dbItr, err := h.txmgr.db.GetPrivateDataRangeScanIterator(namespace, collection, startKey, endKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[76], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[73], 1);return &pvtdataResultsItr{namespace, collection, dbItr}, nil
}

func (h *queryHelper) executeQueryOnPrivateData(namespace, collection, query string) (commonledger.ResultsIterator, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[77], 1);
	if err := h.validateCollName(namespace, collection); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[81], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[78], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[82], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[79], 1);dbItr, err := h.txmgr.db.ExecuteQueryOnPrivateData(namespace, collection, query)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[83], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[80], 1);return &pvtdataResultsItr{namespace, collection, dbItr}, nil
}

func (h *queryHelper) getStateMetadata(ns string, key string) (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[84], 1);
	if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[87], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[85], 1);var metadataBytes []byte
	var err error
	if h.rwsetBuilder == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[88], 1);
		// reads versions are not getting recorded, retrieve metadata value via optimized path
		if metadataBytes, err = h.txmgr.db.GetStateMetadata(ns, key); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[89], 1);
			return nil, err
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[90], 1);{
		if _, metadataBytes, err = h.getState(ns, key); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[91], 1);
			return nil, err
		}
	}}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[86], 1);return storageutil.DeserializeMetadata(metadataBytes)
}

func (h *queryHelper) getPrivateDataMetadata(ns, coll, key string) (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[92], 1);
	if h.rwsetBuilder == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[97], 1);
		// reads versions are not getting recorded, retrieve metadata value via optimized path
		return h.getPrivateDataMetadataByHash(ns, coll, util.ComputeStringHash(key))
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[93], 1);if err := h.validateCollName(ns, coll); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[98], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[94], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[99], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[95], 1);_, metadataBytes, err := h.getPrivateDataValueHash(ns, coll, key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[100], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[96], 1);return storageutil.DeserializeMetadata(metadataBytes)
}

func (h *queryHelper) getPrivateDataMetadataByHash(ns, coll string, keyhash []byte) (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[101], 1);
	if err := h.validateCollName(ns, coll); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[106], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[102], 1);if err := h.checkDone(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[107], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[103], 1);if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[108], 1);
		// this requires to improve rwset builder to accept a keyhash
		return nil, errors.New("retrieving private data metadata by keyhash is not supported in simulation. This function is only available for query as yet")
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[104], 1);metadataBytes, err := h.txmgr.db.GetPrivateDataMetadataByHash(ns, coll, keyhash)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[109], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[105], 1);return storageutil.DeserializeMetadata(metadataBytes)
}

func (h *queryHelper) done() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[110], 1);
	if h.doneInvoked {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[112], 1);
		return
	}

	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[111], 1);defer func() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[113], 1);
		h.txmgr.commitRWLock.RUnlock()
		h.doneInvoked = true
		for _, itr := range h.itrs {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[114], 1);
			itr.Close()
		}
	}()
}

func (h *queryHelper) addRangeQueryInfo() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[115], 1);
	for _, itr := range h.itrs {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[116], 1);
		if h.rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[117], 1);
			results, hash, err := itr.rangeQueryResultsHelper.Done()
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[121], 1);
				h.err = err
				return
			}
			_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[118], 1);if results != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[122], 1);
				itr.rangeQueryInfo.SetRawReads(results)
			}
			_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[119], 1);if hash != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[123], 1);
				itr.rangeQueryInfo.SetMerkelSummary(hash)
			}
			_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[120], 1);h.rwsetBuilder.AddToRangeQuerySet(itr.ns, itr.rangeQueryInfo)
		}
	}
}

func (h *queryHelper) checkDone() error {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[124], 1);
	if h.doneInvoked {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[126], 1);
		return errors.New("this instance should not be used after calling Done()")
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[125], 1);return nil
}

func (h *queryHelper) validateCollName(ns, coll string) error {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[127], 1);
	return h.collNameValidator.validateCollName(ns, coll)
}

// resultsItr implements interface ledger.ResultsIterator
// this wraps the actual db iterator and intercept the calls
// to build rangeQueryInfo in the ReadWriteSet that is used
// for performing phantom read validation during commit
type resultsItr struct {
	ns                      string
	endKey                  string
	dbItr                   statedb.ResultsIterator
	rwSetBuilder            *rwsetutil.RWSetBuilder
	rangeQueryInfo          *kvrwset.RangeQueryInfo
	rangeQueryResultsHelper *rwsetutil.RangeQueryResultsHelper
}

func newResultsItr(ns string, startKey string, endKey string, metadata map[string]interface{},
	db statedb.VersionedDB, rwsetBuilder *rwsetutil.RWSetBuilder, enableHashing bool, maxDegree uint32) (*resultsItr, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[128], 1);
	var err error
	var dbItr statedb.ResultsIterator
	if metadata == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[132], 1);
		dbItr, err = db.GetStateRangeScanIterator(ns, startKey, endKey)
	} else{ _cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[133], 1);{
		dbItr, err = db.GetStateRangeScanIteratorWithMetadata(ns, startKey, endKey, metadata)
	}}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[129], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[134], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[130], 1);itr := &resultsItr{ns: ns, dbItr: dbItr}
	// it's a simulation request so, enable capture of range query info
	if rwsetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[135], 1);
		itr.rwSetBuilder = rwsetBuilder
		itr.endKey = endKey
		// just set the StartKey... set the EndKey later below in the Next() method.
		itr.rangeQueryInfo = &kvrwset.RangeQueryInfo{StartKey: startKey}
		resultsHelper, err := rwsetutil.NewRangeQueryResultsHelper(enableHashing, maxDegree)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[137], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[136], 1);itr.rangeQueryResultsHelper = resultsHelper
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[131], 1);return itr, nil
}

// Next implements method in interface ledger.ResultsIterator
// Before returning the next result, update the EndKey and ItrExhausted in rangeQueryInfo
// If we set the EndKey in the constructor (as we do for the StartKey) to what is
// supplied in the original query, we may be capturing the unnecessary longer range if the
// caller decides to stop iterating at some intermediate point. Alternatively, we could have
// set the EndKey and ItrExhausted in the Close() function but it may not be desirable to change
// transactional behaviour based on whether the Close() was invoked or not
func (itr *resultsItr) Next() (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[138], 1);
	queryResult, err := itr.dbItr.Next()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[141], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[139], 1);itr.updateRangeQueryInfo(queryResult)
	if queryResult == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[142], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[140], 1);versionedKV := queryResult.(*statedb.VersionedKV)
	return &queryresult.KV{Namespace: versionedKV.Namespace, Key: versionedKV.Key, Value: versionedKV.Value}, nil
}

// GetBookmarkAndClose implements method in interface ledger.ResultsIterator
func (itr *resultsItr) GetBookmarkAndClose() string {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[143], 1);
	returnBookmark := ""
	if queryResultIterator, ok := itr.dbItr.(statedb.QueryResultsIterator); ok {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[145], 1);
		returnBookmark = queryResultIterator.GetBookmarkAndClose()
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[144], 1);return returnBookmark
}

// updateRangeQueryInfo updates two attributes of the rangeQueryInfo
// 1) The EndKey - set to either a) latest key that is to be returned to the caller (if the iterator is not exhausted)
//                                  because, we do not know if the caller is again going to invoke Next() or not.
//                            or b) the last key that was supplied in the original query (if the iterator is exhausted)
// 2) The ItrExhausted - set to true if the iterator is going to return nil as a result of the Next() call
func (itr *resultsItr) updateRangeQueryInfo(queryResult statedb.QueryResult) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[146], 1);
	if itr.rwSetBuilder == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[149], 1);
		return
	}

	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[147], 1);if queryResult == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[150], 1);
		// caller scanned till the iterator got exhausted.
		// So, set the endKey to the actual endKey supplied in the query
		itr.rangeQueryInfo.ItrExhausted = true
		itr.rangeQueryInfo.EndKey = itr.endKey
		return
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[148], 1);versionedKV := queryResult.(*statedb.VersionedKV)
	itr.rangeQueryResultsHelper.AddResult(rwsetutil.NewKVRead(versionedKV.Key, versionedKV.Version))
	// Set the end key to the latest key retrieved by the caller.
	// Because, the caller may actually not invoke the Next() function again
	itr.rangeQueryInfo.EndKey = versionedKV.Key
}

// Close implements method in interface ledger.ResultsIterator
func (itr *resultsItr) Close() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[151], 1);
	itr.dbItr.Close()
}

type queryResultsItr struct {
	DBItr        statedb.ResultsIterator
	RWSetBuilder *rwsetutil.RWSetBuilder
}

// Next implements method in interface ledger.ResultsIterator
func (itr *queryResultsItr) Next() (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[152], 1);

	queryResult, err := itr.DBItr.Next()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[156], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[153], 1);if queryResult == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[157], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[154], 1);versionedQueryRecord := queryResult.(*statedb.VersionedKV)
	logger.Debugf("queryResultsItr.Next() returned a record:%s", string(versionedQueryRecord.Value))

	if itr.RWSetBuilder != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[158], 1);
		itr.RWSetBuilder.AddToReadSet(versionedQueryRecord.Namespace, versionedQueryRecord.Key, versionedQueryRecord.Version)
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[155], 1);return &queryresult.KV{Namespace: versionedQueryRecord.Namespace, Key: versionedQueryRecord.Key, Value: versionedQueryRecord.Value}, nil
}

// Close implements method in interface ledger.ResultsIterator
func (itr *queryResultsItr) Close() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[159], 1);
	itr.DBItr.Close()
}

func (itr *queryResultsItr) GetBookmarkAndClose() string {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[160], 1);
	returnBookmark := ""
	if queryResultIterator, ok := itr.DBItr.(statedb.QueryResultsIterator); ok {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[162], 1);
		returnBookmark = queryResultIterator.GetBookmarkAndClose()
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[161], 1);return returnBookmark
}

func decomposeVersionedValue(versionedValue *statedb.VersionedValue) ([]byte, []byte, *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[163], 1);
	var value []byte
	var metadata []byte
	var ver *version.Height
	if versionedValue != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[165], 1);
		value = versionedValue.Value
		ver = versionedValue.Version
		metadata = versionedValue.Metadata
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[164], 1);return value, metadata, ver
}

// pvtdataResultsItr iterates over results of a query on pvt data
type pvtdataResultsItr struct {
	ns    string
	coll  string
	dbItr statedb.ResultsIterator
}

// Next implements method in interface ledger.ResultsIterator
func (itr *pvtdataResultsItr) Next() (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[166], 1);
	queryResult, err := itr.dbItr.Next()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[169], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[167], 1);if queryResult == nil {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[170], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[168], 1);versionedQueryRecord := queryResult.(*statedb.VersionedKV)
	return &queryresult.KV{
		Namespace: itr.ns,
		Key:       versionedQueryRecord.Key,
		Value:     versionedQueryRecord.Value,
	}, nil
}

// Close implements method in interface ledger.ResultsIterator
func (itr *pvtdataResultsItr) Close() {_cover_atomic_.AddUint32(&GoCover_1_386331373365306636336339.Count[171], 1);
	itr.dbItr.Close()
}

var GoCover_1_386331373365306636336339 = struct {
	Count     [172]uint32
	Pos       [3 * 172]uint32
	NumStmt   [172]uint16
} {
	Pos: [3 * 172]uint32{
		34, 39, 0x2005f, // [0]
		41, 42, 0x26004f, // [1]
		45, 46, 0x100002, // [2]
		49, 50, 0x1b0002, // [3]
		53, 53, 0x1b0002, // [4]
		42, 44, 0x30026, // [5]
		46, 48, 0x30010, // [6]
		50, 52, 0x3001b, // [7]
		56, 57, 0x26005f, // [8]
		60, 61, 0x100002, // [9]
		64, 65, 0x310002, // [10]
		72, 72, 0x140002, // [11]
		57, 59, 0x30026, // [12]
		61, 63, 0x30010, // [13]
		65, 67, 0x1c0031, // [14]
		70, 70, 0x120003, // [15]
		67, 69, 0x4001c, // [16]
		75, 76, 0x260088, // [17]
		79, 81, 0x100002, // [18]
		84, 85, 0x110002, // [19]
		76, 78, 0x30026, // [20]
		81, 83, 0x30010, // [21]
		88, 89, 0x2600b5, // [22]
		92, 94, 0x100002, // [23]
		97, 98, 0x110002, // [24]
		89, 91, 0x30026, // [25]
		94, 96, 0x30010, // [26]
		101, 102, 0x260063, // [27]
		105, 106, 0x100002, // [28]
		109, 109, 0x4a0002, // [29]
		102, 104, 0x30026, // [30]
		106, 108, 0x30010, // [31]
		112, 113, 0x26008f, // [32]
		116, 117, 0x100002, // [33]
		120, 120, 0x4a0002, // [34]
		113, 115, 0x30026, // [35]
		117, 119, 0x30010, // [36]
		123, 124, 0x35004c, // [37]
		127, 127, 0x260002, // [38]
		131, 135, 0x500002, // [39]
		140, 143, 0x540002, // [40]
		146, 146, 0x280002, // [41]
		151, 151, 0x1b0002, // [42]
		154, 154, 0x110002, // [43]
		124, 126, 0x30035, // [44]
		127, 129, 0x30026, // [45]
		135, 137, 0x30050, // [46]
		143, 145, 0x30054, // [47]
		146, 150, 0x30028, // [48]
		151, 153, 0x3001b, // [49]
		157, 158, 0x350072, // [50]
		161, 161, 0x260002, // [51]
		164, 167, 0x520002, // [52]
		170, 171, 0x1b0002, // [53]
		174, 174, 0x1f0002, // [54]
		158, 160, 0x30035, // [55]
		161, 163, 0x30026, // [56]
		167, 169, 0x30052, // [57]
		171, 173, 0x3001b, // [58]
		177, 178, 0x350064, // [59]
		181, 181, 0x260002, // [60]
		184, 185, 0x100002, // [61]
		188, 189, 0x310002, // [62]
		196, 196, 0x140002, // [63]
		178, 180, 0x30035, // [64]
		181, 183, 0x30026, // [65]
		185, 187, 0x30010, // [66]
		189, 191, 0x1c0031, // [67]
		194, 194, 0x120003, // [68]
		191, 193, 0x4001c, // [69]
		199, 200, 0x42008d, // [70]
		203, 203, 0x260002, // [71]
		206, 207, 0x100002, // [72]
		210, 210, 0x3e0002, // [73]
		200, 202, 0x30042, // [74]
		203, 205, 0x30026, // [75]
		207, 209, 0x30010, // [76]
		213, 214, 0x42007c, // [77]
		217, 217, 0x260002, // [78]
		220, 221, 0x100002, // [79]
		224, 224, 0x3e0002, // [80]
		214, 216, 0x30042, // [81]
		217, 219, 0x30026, // [82]
		221, 223, 0x30010, // [83]
		227, 228, 0x26005a, // [84]
		231, 233, 0x1b0002, // [85]
		243, 243, 0x370002, // [86]
		228, 230, 0x30026, // [87]
		233, 235, 0x4c001b, // [88]
		235, 237, 0x4004c, // [89]
		238, 239, 0x3e0008, // [90]
		239, 241, 0x4003e, // [91]
		246, 247, 0x1b005f, // [92]
		251, 251, 0x350002, // [93]
		254, 254, 0x260002, // [94]
		257, 258, 0x100002, // [95]
		261, 261, 0x370002, // [96]
		247, 250, 0x3001b, // [97]
		251, 253, 0x30035, // [98]
		254, 256, 0x30026, // [99]
		258, 260, 0x30010, // [100]
		264, 265, 0x350070, // [101]
		268, 268, 0x260002, // [102]
		271, 271, 0x1b0002, // [103]
		275, 276, 0x100002, // [104]
		279, 279, 0x370002, // [105]
		265, 267, 0x30035, // [106]
		268, 270, 0x30026, // [107]
		271, 274, 0x3001b, // [108]
		276, 278, 0x30010, // [109]
		282, 283, 0x13001e, // [110]
		287, 287, 0xf0002, // [111]
		283, 285, 0x30013, // [112]
		287, 290, 0x1e000f, // [113]
		290, 292, 0x4001e, // [114]
		296, 297, 0x1d002b, // [115]
		297, 298, 0x1c001d, // [116]
		298, 300, 0x12001c, // [117]
		304, 304, 0x160004, // [118]
		307, 307, 0x130004, // [119]
		310, 310, 0x410004, // [120]
		300, 303, 0x50012, // [121]
		304, 306, 0x50016, // [122]
		307, 309, 0x50013, // [123]
		315, 316, 0x130029, // [124]
		319, 319, 0xc0002, // [125]
		316, 318, 0x30013, // [126]
		322, 324, 0x2003f, // [127]
		340, 343, 0x15007b, // [128]
		348, 348, 0x100002, // [129]
		351, 353, 0x190002, // [130]
		364, 364, 0x110002, // [131]
		343, 345, 0x30015, // [132]
		345, 347, 0x30008, // [133]
		348, 350, 0x30010, // [134]
		353, 359, 0x110019, // [135]
		362, 362, 0x2e0003, // [136]
		359, 361, 0x40011, // [137]
		374, 376, 0x100041, // [138]
		379, 380, 0x180002, // [139]
		383, 384, 0x6f0002, // [140]
		376, 378, 0x30010, // [141]
		380, 382, 0x30018, // [142]
		388, 390, 0x4d0035, // [143]
		393, 393, 0x170002, // [144]
		390, 392, 0x3004d, // [145]
		401, 402, 0x1d004e, // [146]
		406, 406, 0x180002, // [147]
		413, 417, 0x2d0002, // [148]
		402, 404, 0x3001d, // [149]
		406, 412, 0x30018, // [150]
		421, 423, 0x20020, // [151]
		431, 434, 0x100046, // [152]
		437, 437, 0x180002, // [153]
		440, 443, 0x1d0002, // [154]
		446, 446, 0x8a0002, // [155]
		434, 436, 0x30010, // [156]
		437, 439, 0x30018, // [157]
		443, 445, 0x3001d, // [158]
		450, 452, 0x20025, // [159]
		454, 456, 0x4d003a, // [160]
		459, 459, 0x170002, // [161]
		456, 458, 0x3004d, // [162]
		462, 466, 0x1b0068, // [163]
		471, 471, 0x1d0002, // [164]
		466, 470, 0x3001b, // [165]
		482, 484, 0x100048, // [166]
		487, 487, 0x180002, // [167]
		490, 495, 0x80002, // [168]
		484, 486, 0x30010, // [169]
		487, 489, 0x30018, // [170]
		499, 501, 0x20027, // [171]
	},
	NumStmt: [172]uint16{
		4, // 0
		1, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		2, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		4, // 39
		3, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
		3, // 52
		2, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		2, // 61
		2, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		2, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		2, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		2, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		3, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		2, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
		1, // 103
		2, // 104
		1, // 105
		1, // 106
		1, // 107
		1, // 108
		1, // 109
		1, // 110
		1, // 111
		1, // 112
		3, // 113
		1, // 114
		1, // 115
		1, // 116
		2, // 117
		1, // 118
		1, // 119
		1, // 120
		2, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		1, // 126
		1, // 127
		3, // 128
		1, // 129
		2, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		5, // 135
		1, // 136
		1, // 137
		2, // 138
		2, // 139
		2, // 140
		1, // 141
		1, // 142
		2, // 143
		1, // 144
		1, // 145
		1, // 146
		1, // 147
		3, // 148
		1, // 149
		3, // 150
		1, // 151
		2, // 152
		1, // 153
		3, // 154
		1, // 155
		1, // 156
		1, // 157
		1, // 158
		1, // 159
		2, // 160
		1, // 161
		1, // 162
		4, // 163
		1, // 164
		3, // 165
		2, // 166
		1, // 167
		2, // 168
		1, // 169
		1, // 170
		1, // 171
	},
}
var _ = _cover_atomic_.LoadUint32
