//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/transaction_contexts.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"sync"

	commonledger "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/ledger"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

type key string

const (
	// TXSimulatorKey is the context key used to provide a ledger.TxSimulator
	// from the endorser to the chaincode.
	TXSimulatorKey key = "txsimulatorkey"

	// HistoryQueryExecutorKey is the context key used to provide a
	// ledger.HistoryQueryExecutor from the endorser to the chaincode.
	HistoryQueryExecutorKey key = "historyqueryexecutorkey"
)

// TransactionContexts maintains active transaction contexts for a Handler.
type TransactionContexts struct {
	mutex    sync.Mutex
	contexts map[string]*TransactionContext
}

// NewTransactionContexts creates a registry for active transaction contexts.
func NewTransactionContexts() *TransactionContexts {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[0], 1);
	return &TransactionContexts{
		contexts: map[string]*TransactionContext{},
	}
}

// contextID creates a transaction identifier that is scoped to a chain.
func contextID(chainID, txID string) string {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[1], 1);
	return chainID + txID
}

// Create creates a new TransactionContext for the specified chain and
// transaction ID. An error is returned when a transaction context has already
// been created for the specified chain and transaction ID.
func (c *TransactionContexts) Create(txParams *ccprovider.TransactionParams) (*TransactionContext, error) {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[2], 1);
	c.mutex.Lock()
	defer c.mutex.Unlock()

	ctxID := contextID(txParams.ChannelID, txParams.TxID)
	if c.contexts[ctxID] != nil {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[4], 1);
		return nil, errors.Errorf("txid: %s(%s) exists", txParams.TxID, txParams.ChannelID)
	}

	_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[3], 1);txctx := &TransactionContext{
		ChainID:              txParams.ChannelID,
		SignedProp:           txParams.SignedProp,
		Proposal:             txParams.Proposal,
		ResponseNotifier:     make(chan *pb.ChaincodeMessage, 1),
		TXSimulator:          txParams.TXSimulator,
		HistoryQueryExecutor: txParams.HistoryQueryExecutor,
		CollectionStore:      txParams.CollectionStore,
		IsInitTransaction:    txParams.IsInitTransaction,

		queryIteratorMap:    map[string]commonledger.ResultsIterator{},
		pendingQueryResults: map[string]*PendingQueryResult{},

		AllowedCollectionAccess: make(map[string]bool),
	}
	c.contexts[ctxID] = txctx

	return txctx, nil
}

func getTxSimulator(ctx context.Context) ledger.TxSimulator {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[5], 1);
	if txsim, ok := ctx.Value(TXSimulatorKey).(ledger.TxSimulator); ok {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[7], 1);
		return txsim
	}
	_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[6], 1);return nil
}

func getHistoryQueryExecutor(ctx context.Context) ledger.HistoryQueryExecutor {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[8], 1);
	if historyQueryExecutor, ok := ctx.Value(HistoryQueryExecutorKey).(ledger.HistoryQueryExecutor); ok {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[10], 1);
		return historyQueryExecutor
	}
	_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[9], 1);return nil
}

// Get retrieves the transaction context associated with the chain and
// transaction ID.
func (c *TransactionContexts) Get(chainID, txID string) *TransactionContext {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[11], 1);
	ctxID := contextID(chainID, txID)
	c.mutex.Lock()
	tc := c.contexts[ctxID]
	c.mutex.Unlock()
	return tc
}

// Delete removes the transaction context associated with the specified chain
// and transaction ID.
func (c *TransactionContexts) Delete(chainID, txID string) {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[12], 1);
	ctxID := contextID(chainID, txID)
	c.mutex.Lock()
	delete(c.contexts, ctxID)
	c.mutex.Unlock()
}

// Close closes all query iterators assocated with the context.
func (c *TransactionContexts) Close() {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[13], 1);
	c.mutex.Lock()
	defer c.mutex.Unlock()

	for _, txctx := range c.contexts {_cover_atomic_.AddUint32(&GoCover_12_323839383963343337363361.Count[14], 1);
		txctx.CloseQueryIterators()
	}
}

var GoCover_12_323839383963343337363361 = struct {
	Count     [15]uint32
	Pos       [3 * 15]uint32
	NumStmt   [15]uint16
} {
	Pos: [3 * 15]uint32{
		39, 43, 0x20034, // [0]
		46, 48, 0x2002d, // [1]
		53, 58, 0x1e006b, // [2]
		62, 79, 0x130002, // [3]
		58, 60, 0x3001e, // [4]
		82, 83, 0x45003d, // [5]
		86, 86, 0xc0002, // [6]
		83, 85, 0x30045, // [7]
		89, 90, 0x66004f, // [8]
		93, 93, 0xc0002, // [9]
		90, 92, 0x30066, // [10]
		98, 104, 0x2004d, // [11]
		108, 113, 0x2003c, // [12]
		116, 120, 0x230027, // [13]
		120, 122, 0x30023, // [14]
	},
	NumStmt: [15]uint16{
		1, // 0
		1, // 1
		4, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		5, // 11
		4, // 12
		3, // 13
		1, // 14
	},
}
var _ = _cover_atomic_.LoadUint32
