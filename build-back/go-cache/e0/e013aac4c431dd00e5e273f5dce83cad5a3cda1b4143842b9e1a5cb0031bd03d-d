//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/support/acl/support.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package acl; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/policies"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
)

var (
	logger = flogging.MustGetLogger("discovery.acl")
)

// ChannelConfigGetter enables to retrieve the channel config resources
type ChannelConfigGetter interface {
	// GetChannelConfig returns the resources of the channel config
	GetChannelConfig(cid string) channelconfig.Resources
}

// ChannelConfigGetterFunc returns the resources of the channel config
type ChannelConfigGetterFunc func(cid string) channelconfig.Resources

// GetChannelConfig returns the resources of the channel config
func (f ChannelConfigGetterFunc) GetChannelConfig(cid string) channelconfig.Resources {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[0], 1);
	return f(cid)
}

// Verifier verifies a signature and a message
type Verifier interface {
	// VerifyByChannel checks that signature is a valid signature of message
	// under a peer's verification key, but also in the context of a specific channel.
	// If the verification succeeded, Verify returns nil meaning no error occurred.
	// If peerIdentity is nil, then the verification fails.
	VerifyByChannel(channel string, sd *cb.SignedData) error
}

// Evaluator evaluates signatures.
// It is used to evaluate signatures for the local MSP
type Evaluator interface {
	// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy
	Evaluate(signatureSet []*cb.SignedData) error
}

// DiscoverySupport implements support that is used for service discovery
// that is related to access control
type DiscoverySupport struct {
	ChannelConfigGetter
	Verifier
	Evaluator
}

// NewDiscoverySupport creates a new DiscoverySupport
func NewDiscoverySupport(v Verifier, e Evaluator, chanConf ChannelConfigGetter) *DiscoverySupport {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[1], 1);
	return &DiscoverySupport{Verifier: v, Evaluator: e, ChannelConfigGetter: chanConf}
}

// Eligible returns whether the given peer is eligible for receiving
// service from the discovery service for a given channel
func (s *DiscoverySupport) EligibleForService(channel string, data cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[2], 1);
	if channel == "" {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[4], 1);
		return s.Evaluate([]*cb.SignedData{&data})
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[3], 1);return s.VerifyByChannel(channel, &data)
}

// ConfigSequence returns the configuration sequence of the given channel
func (s *DiscoverySupport) ConfigSequence(channel string) uint64 {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[5], 1);
	// No sequence if the channel is empty
	if channel == "" {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[9], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[6], 1);conf := s.GetChannelConfig(channel)
	if conf == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[10], 1);
		logger.Panic("Failed obtaining channel config for channel", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[7], 1);v := conf.ConfigtxValidator()
	if v == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[11], 1);
		logger.Panic("ConfigtxValidator for channel", channel, "is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[8], 1);return v.Sequence()
}

func (s *DiscoverySupport) SatisfiesPrincipal(channel string, rawIdentity []byte, principal *msp.MSPPrincipal) error {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[12], 1);
	conf := s.GetChannelConfig(channel)
	if conf == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[16], 1);
		return errors.Errorf("channel %s doesn't exist", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[13], 1);mspMgr := conf.MSPManager()
	if mspMgr == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[17], 1);
		return errors.Errorf("could not find MSP manager for channel %s", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[14], 1);identity, err := mspMgr.DeserializeIdentity(rawIdentity)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[18], 1);
		return errors.Wrap(err, "failed deserializing identity")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[15], 1);return identity.SatisfiesPrincipal(principal)
}

//go:generate mockery -name ChannelPolicyManagerGetter -case underscore  -output ../mocks/

// ChannelPolicyManagerGetter is a support interface
// to get access to the policy manager of a given channel
type ChannelPolicyManagerGetter interface {
	// Returns the policy manager associated to the passed channel
	// and true if it was the manager requested, or false if it is the default manager
	Manager(channelID string) (policies.Manager, bool)
}

// NewChannelVerifier returns a new channel verifier from the given policy and policy manager getter
func NewChannelVerifier(policy string, polMgr policies.ChannelPolicyManagerGetter) *ChannelVerifier {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[19], 1);
	return &ChannelVerifier{
		Policy:                     policy,
		ChannelPolicyManagerGetter: polMgr,
	}
}

// ChannelVerifier verifies a signature and a message on the context of a channel
type ChannelVerifier struct {
	policies.ChannelPolicyManagerGetter
	Policy string
}

// VerifyByChannel checks that signature is a valid signature of message
// under a peer's verification key, but also in the context of a specific channel.
// If the verification succeeded, Verify returns nil meaning no error occurred.
// If peerIdentity is nil, then the verification fails.
func (cv *ChannelVerifier) VerifyByChannel(channel string, sd *cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[20], 1);
	mgr, _ := cv.Manager(channel)
	if mgr == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[23], 1);
		return errors.Errorf("policy manager for channel %s doesn't exist", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[21], 1);pol, _ := mgr.GetPolicy(cv.Policy)
	if pol == nil {_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[24], 1);
		return errors.New("failed obtaining channel application writers policy")
	}
	_cover_atomic_.AddUint32(&GoCover_0_323538343332373633323064.Count[22], 1);return pol.Evaluate([]*cb.SignedData{sd})
}

var GoCover_0_323538343332373633323064 = struct {
	Count     [25]uint32
	Pos       [3 * 25]uint32
	NumStmt   [25]uint16
} {
	Pos: [3 * 25]uint32{
		32, 34, 0x20057, // [0]
		61, 63, 0x20063, // [1]
		67, 68, 0x130059, // [2]
		71, 71, 0x2a0002, // [3]
		68, 70, 0x30013, // [4]
		75, 77, 0x130042, // [5]
		80, 81, 0x110002, // [6]
		84, 85, 0xe0002, // [7]
		88, 88, 0x150002, // [8]
		77, 79, 0x30013, // [9]
		81, 83, 0x30011, // [10]
		85, 87, 0x3000e, // [11]
		91, 93, 0x110076, // [12]
		96, 97, 0x130002, // [13]
		100, 101, 0x100002, // [14]
		104, 104, 0x2f0002, // [15]
		93, 95, 0x30011, // [16]
		97, 99, 0x30013, // [17]
		101, 103, 0x30010, // [18]
		118, 123, 0x20065, // [19]
		135, 137, 0x100055, // [20]
		140, 141, 0x100002, // [21]
		144, 144, 0x2b0002, // [22]
		137, 139, 0x30010, // [23]
		141, 143, 0x30010, // [24]
	},
	NumStmt: [25]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		2, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		2, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
	},
}
var _ = _cover_atomic_.LoadUint32
