//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/shim/handler.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package shim; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/golang/protobuf/proto"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

type state string

const (
	created     state = "created"     //start state
	established state = "established" //connection established
	ready       state = "ready"       //ready for requests

)

// PeerChaincodeStream interface for stream between Peer and chaincode instance.
type PeerChaincodeStream interface {
	Send(*pb.ChaincodeMessage) error
	Recv() (*pb.ChaincodeMessage, error)
	CloseSend() error
}

func (handler *Handler) triggerNextState(msg *pb.ChaincodeMessage, errc chan error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[0], 1);
	chaincodeLogger.Debugf("[%s] send state message %s", shorttxid(msg.Txid), msg.Type)
	handler.serialSendAsync(msg, errc)
}

// Handler handler implementation for shim side of chaincode.
type Handler struct {
	//need lock to protect chaincode from attempting
	//concurrent requests to the peer
	sync.Mutex

	//shim to peer grpc serializer. User only in serialSend
	serialLock sync.Mutex

	To         string
	ChatStream PeerChaincodeStream
	cc         Chaincode
	state      state
	// Multiple queries (and one transaction) with different txids can be executing in parallel for this chaincode
	// responseChannel is the channel on which responses are communicated by the shim to the chaincodeStub.
	responseChannel map[string]chan pb.ChaincodeMessage
}

func shorttxid(txid string) string {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[1], 1);
	if len(txid) < 8 {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[3], 1);
		return txid
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[2], 1);return txid[0:8]
}

//serialSend serializes msgs so gRPC will be happy
func (handler *Handler) serialSend(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[4], 1);
	handler.serialLock.Lock()
	defer handler.serialLock.Unlock()

	err := handler.ChatStream.Send(msg)

	return err
}

//serialSendAsync serves the same purpose as serialSend (serialize msgs so gRPC will
//be happy). In addition, it is also asynchronous so send-remoterecv--localrecv loop
//can be nonblocking. Only errors need to be handled and these are handled by
//communication on supplied error channel. A typical use will be a non-blocking or
//nil channel
func (handler *Handler) serialSendAsync(msg *pb.ChaincodeMessage, errc chan error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[5], 1);
	go func() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[6], 1);
		err := handler.serialSend(msg)
		if errc != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[7], 1);
			errc <- err
		}
	}()
}

//transaction context id should be composed of chainID and txid. While
//needed for CC-2-CC, it also allows users to concurrently send proposals
//with the same TXID to a CC on two multiple channels
func (handler *Handler) getTxCtxId(chainID string, txid string) string {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[8], 1);
	return chainID + txid
}

func (handler *Handler) createChannel(channelID, txid string) (chan pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[9], 1);
	handler.Lock()
	defer handler.Unlock()
	if handler.responseChannel == nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[12], 1);
		return nil, errors.Errorf("[%s] cannot create response channel", shorttxid(txid))
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[10], 1);txCtxID := handler.getTxCtxId(channelID, txid)
	if handler.responseChannel[txCtxID] != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[13], 1);
		return nil, errors.Errorf("[%s] channel exists", shorttxid(txCtxID))
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[11], 1);c := make(chan pb.ChaincodeMessage)
	handler.responseChannel[txCtxID] = c
	return c, nil
}

func (handler *Handler) sendChannel(msg *pb.ChaincodeMessage) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[14], 1);
	handler.Lock()
	defer handler.Unlock()
	if handler.responseChannel == nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[17], 1);
		return errors.Errorf("[%s] Cannot send message response channel", shorttxid(msg.Txid))
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[15], 1);txCtxID := handler.getTxCtxId(msg.ChannelId, msg.Txid)
	if handler.responseChannel[txCtxID] == nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[18], 1);
		return errors.Errorf("[%s] sendChannel does not exist", shorttxid(msg.Txid))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[16], 1);chaincodeLogger.Debugf("[%s] before send", shorttxid(msg.Txid))
	handler.responseChannel[txCtxID] <- *msg
	chaincodeLogger.Debugf("[%s] after send", shorttxid(msg.Txid))

	return nil
}

//sends a message and selects
func (handler *Handler) sendReceive(msg *pb.ChaincodeMessage, c chan pb.ChaincodeMessage) (pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[19], 1);
	errc := make(chan error, 1)
	handler.serialSendAsync(msg, errc)

	//the serialsend above will send an err or nil
	//the select filters that first error(or nil)
	//and continues to wait for the response
	//it is possible that the response triggers first
	//in which case the errc obviously worked and is
	//ignored
	for {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[20], 1);
		select {
		case err := <-errc:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[21], 1);
			if err == nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[25], 1);
				continue
			}
			//would have been logged, return false
			_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[22], 1);return pb.ChaincodeMessage{}, err
		case outmsg, val := <-c:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[23], 1);
			if !val {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[26], 1);
				return pb.ChaincodeMessage{}, errors.New("unexpected failure on receive")
			}
			_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[24], 1);return outmsg, nil
		}
	}
}

func (handler *Handler) deleteChannel(channelID, txid string) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[27], 1);
	handler.Lock()
	defer handler.Unlock()
	if handler.responseChannel != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[28], 1);
		txCtxID := handler.getTxCtxId(channelID, txid)
		delete(handler.responseChannel, txCtxID)
	}
}

// NewChaincodeHandler returns a new instance of the shim side handler.
func newChaincodeHandler(peerChatStream PeerChaincodeStream, chaincode Chaincode) *Handler {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[29], 1);
	v := &Handler{
		ChatStream: peerChatStream,
		cc:         chaincode,
	}
	v.responseChannel = make(map[string]chan pb.ChaincodeMessage)
	v.state = created
	return v
}

// handleInit handles request to initialize chaincode.
func (handler *Handler) handleInit(msg *pb.ChaincodeMessage, errc chan error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[30], 1);
	// The defer followed by triggering a go routine dance is needed to ensure that the previous state transition
	// is completed before the next one is triggered. The previous state transition is deemed complete only when
	// the beforeInit function is exited. Interesting bug fix!!
	go func() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[31], 1);
		var nextStateMsg *pb.ChaincodeMessage

		defer func() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[38], 1);
			handler.triggerNextState(nextStateMsg, errc)
		}()

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[32], 1);errFunc := func(err error, payload []byte, ce *pb.ChaincodeEvent, errFmt string, args ...interface{}) *pb.ChaincodeMessage {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[39], 1);
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[41], 1);
				// Send ERROR message to chaincode support and change state
				if payload == nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[43], 1);
					payload = []byte(err.Error())
				}
				_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[42], 1);chaincodeLogger.Errorf(errFmt, args...)
				return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_ERROR, Payload: payload, Txid: msg.Txid, ChaincodeEvent: ce, ChannelId: msg.ChannelId}
			}
			_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[40], 1);return nil
		}
		// Get the function and args from Payload
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[33], 1);input := &pb.ChaincodeInput{}
		unmarshalErr := proto.Unmarshal(msg.Payload, input)
		if nextStateMsg = errFunc(unmarshalErr, nil, nil, "[%s] Incorrect payload format. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[44], 1);
			return
		}

		// Call chaincode's Run
		// Create the ChaincodeStub which the chaincode can use to callback
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[34], 1);stub := new(ChaincodeStub)
		err := stub.init(handler, msg.ChannelId, msg.Txid, input, msg.Proposal)
		if nextStateMsg = errFunc(err, nil, stub.chaincodeEvent, "[%s] Init get error response. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[45], 1);
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[35], 1);res := handler.cc.Init(stub)
		chaincodeLogger.Debugf("[%s] Init get response status: %d", shorttxid(msg.Txid), res.Status)

		if res.Status >= ERROR {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[46], 1);
			err = errors.New(res.Message)
			if nextStateMsg = errFunc(err, []byte(res.Message), stub.chaincodeEvent, "[%s] Init get error response. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[47], 1);
				return
			}
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[36], 1);resBytes, err := proto.Marshal(&res)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[48], 1);
			payload := []byte(err.Error())
			chaincodeLogger.Errorf("[%s] Init marshal response error [%s]. Sending %s", shorttxid(msg.Txid), err, pb.ChaincodeMessage_ERROR)
			nextStateMsg = &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_ERROR, Payload: payload, Txid: msg.Txid, ChaincodeEvent: stub.chaincodeEvent}
			return
		}

		// Send COMPLETED message to chaincode support and change state
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[37], 1);nextStateMsg = &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_COMPLETED, Payload: resBytes, Txid: msg.Txid, ChaincodeEvent: stub.chaincodeEvent, ChannelId: stub.ChannelId}
		chaincodeLogger.Debugf("[%s] Init succeeded. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_COMPLETED)
	}()
}

// handleTransaction Handles request to execute a transaction.
func (handler *Handler) handleTransaction(msg *pb.ChaincodeMessage, errc chan error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[49], 1);
	// The defer followed by triggering a go routine dance is needed to ensure that the previous state transition
	// is completed before the next one is triggered. The previous state transition is deemed complete only when
	// the beforeInit function is exited. Interesting bug fix!!
	go func() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[50], 1);
		//better not be nil
		var nextStateMsg *pb.ChaincodeMessage

		defer func() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[56], 1);
			handler.triggerNextState(nextStateMsg, errc)
		}()

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[51], 1);errFunc := func(err error, ce *pb.ChaincodeEvent, errStr string, args ...interface{}) *pb.ChaincodeMessage {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[57], 1);
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[59], 1);
				payload := []byte(err.Error())
				chaincodeLogger.Errorf(errStr, args...)
				return &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_ERROR, Payload: payload, Txid: msg.Txid, ChaincodeEvent: ce, ChannelId: msg.ChannelId}
			}
			_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[58], 1);return nil
		}

		// Get the function and args from Payload
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[52], 1);input := &pb.ChaincodeInput{}
		unmarshalErr := proto.Unmarshal(msg.Payload, input)
		if nextStateMsg = errFunc(unmarshalErr, nil, "[%s] Incorrect payload format. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[60], 1);
			return
		}

		// Call chaincode's Run
		// Create the ChaincodeStub which the chaincode can use to callback
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[53], 1);stub := new(ChaincodeStub)
		err := stub.init(handler, msg.ChannelId, msg.Txid, input, msg.Proposal)
		if nextStateMsg = errFunc(err, stub.chaincodeEvent, "[%s] Transaction execution failed. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[61], 1);
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[54], 1);res := handler.cc.Invoke(stub)

		// Endorser will handle error contained in Response.
		resBytes, err := proto.Marshal(&res)
		if nextStateMsg = errFunc(err, stub.chaincodeEvent, "[%s] Transaction execution failed. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_ERROR.String()); nextStateMsg != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[62], 1);
			return
		}

		// Send COMPLETED message to chaincode support and change state
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[55], 1);chaincodeLogger.Debugf("[%s] Transaction completed. Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_COMPLETED)
		nextStateMsg = &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_COMPLETED, Payload: resBytes, Txid: msg.Txid, ChaincodeEvent: stub.chaincodeEvent, ChannelId: stub.ChannelId}
	}()
}

// callPeerWithChaincodeMsg sends a chaincode message (for e.g., GetState along with the key) to the peer for a given txid
// and receives the response.
func (handler *Handler) callPeerWithChaincodeMsg(msg *pb.ChaincodeMessage, channelID, txid string) (pb.ChaincodeMessage, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[63], 1);
	// Create the channel on which to communicate the response from the peer
	var respChan chan pb.ChaincodeMessage
	var err error
	if respChan, err = handler.createChannel(channelID, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[65], 1);
		return pb.ChaincodeMessage{}, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[64], 1);defer handler.deleteChannel(channelID, txid)

	return handler.sendReceive(msg, respChan)
}

// TODO: Implement a method to get multiple keys at a time [FAB-1244]
// handleGetState communicates with the peer to fetch the requested state information from the ledger.
func (handler *Handler) handleGetState(collection string, key string, channelId string, txid string) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[66], 1);
	// Construct payload for GET_STATE
	payloadBytes, _ := proto.Marshal(&pb.GetState{Collection: collection, Key: key})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_STATE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_STATE)

	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelId, txid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[70], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("[%s] error sending GET_STATE", shorttxid(txid)))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[67], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[71], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] GetState received payload %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
		return responseMsg.Payload, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[68], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[72], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] GetState received error %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[69], 1);chaincodeLogger.Errorf("[%s] Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("[%s] incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleGetStateMetadata(collection string, key string, channelID string, txID string) (map[string][]byte, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[73], 1);
	// Construct payload for GET_STATE_METADATA
	payloadBytes, _ := proto.Marshal(&pb.GetStateMetadata{Collection: collection, Key: key})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_STATE_METADATA, Payload: payloadBytes, Txid: txID, ChannelId: channelID}
	chaincodeLogger.Debugf("[%s]Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_STATE_METADATA)

	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelID, txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[77], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("[%s]error sending GET_STATE_METADATA", shorttxid(txID)))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[74], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[78], 1);
		// Success response
		chaincodeLogger.Debugf("[%s]GetStateMetadata received payload %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
		var mdResult pb.StateMetadataResult
		err := proto.Unmarshal(responseMsg.Payload, &mdResult)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[81], 1);
			chaincodeLogger.Errorf("[%s]GetStateMetadata could not unmarshal result", shorttxid(responseMsg.Txid))
			return nil, errors.New("Could not unmarshal metadata response")
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[79], 1);metadata := make(map[string][]byte)
		for _, md := range mdResult.Entries {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[82], 1);
			metadata[md.Metakey] = md.Value
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[80], 1);return metadata, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[75], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[83], 1);
		// Error response
		chaincodeLogger.Errorf("[%s]GetStateMetadata received error %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[76], 1);chaincodeLogger.Errorf("[%s]Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("[%s]incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

// TODO: Implement a method to set multiple keys at a time [FAB-1244]
// handlePutState communicates with the peer to put state information into the ledger.
func (handler *Handler) handlePutState(collection string, key string, value []byte, channelId string, txid string) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[84], 1);
	// Construct payload for PUT_STATE
	payloadBytes, _ := proto.Marshal(&pb.PutState{Collection: collection, Key: key, Value: value})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_PUT_STATE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_PUT_STATE)

	// Execute the request and get response
	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelId, txid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[88], 1);
		return errors.WithMessage(err, fmt.Sprintf("[%s] error sending PUT_STATE", msg.Txid))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[85], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[89], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully updated state", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[86], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[90], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s. Payload: %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR, responseMsg.Payload)
		return errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[87], 1);chaincodeLogger.Errorf("[%s] Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return errors.Errorf("[%s] incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handlePutStateMetadataEntry(collection string, key string, metakey string, metadata []byte, channelID string, txID string) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[91], 1);
	// Construct payload for PUT_STATE_METADATA
	md := &pb.StateMetadata{Metakey: metakey, Value: metadata}
	payloadBytes, _ := proto.Marshal(&pb.PutStateMetadata{Collection: collection, Key: key, Metadata: md})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_PUT_STATE_METADATA, Payload: payloadBytes, Txid: txID, ChannelId: channelID}
	chaincodeLogger.Debugf("[%s]Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_PUT_STATE_METADATA)

	// Execute the request and get response
	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelID, txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[95], 1);
		return errors.WithMessage(err, fmt.Sprintf("[%s]error sending PUT_STATE_METADATA", msg.Txid))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[92], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[96], 1);
		// Success response
		chaincodeLogger.Debugf("[%s]Received %s. Successfully updated state metadata", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[93], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[97], 1);
		// Error response
		chaincodeLogger.Errorf("[%s]Received %s. Payload: %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR, responseMsg.Payload)
		return errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[94], 1);chaincodeLogger.Errorf("[%s]Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return errors.Errorf("[%s]incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

// handleDelState communicates with the peer to delete a key from the state in the ledger.
func (handler *Handler) handleDelState(collection string, key string, channelId string, txid string) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[98], 1);
	//payloadBytes, _ := proto.Marshal(&pb.GetState{Collection: collection, Key: key})
	payloadBytes, _ := proto.Marshal(&pb.DelState{Collection: collection, Key: key})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_DEL_STATE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_STATE)

	// Execute the request and get response
	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelId, txid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[102], 1);
		return errors.Errorf("[%s] error sending DEL_STATE %s", shorttxid(msg.Txid), pb.ChaincodeMessage_DEL_STATE)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[99], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[103], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully deleted state", msg.Txid, pb.ChaincodeMessage_RESPONSE)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[100], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[104], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s. Payload: %s", msg.Txid, pb.ChaincodeMessage_ERROR, responseMsg.Payload)
		return errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[101], 1);chaincodeLogger.Errorf("[%s] Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return errors.Errorf("[%s] incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleGetStateByRange(collection, startKey, endKey string, metadata []byte,
	channelId string, txid string) (*pb.QueryResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[105], 1);
	// Send GET_STATE_BY_RANGE message to peer chaincode support
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.GetStateByRange{Collection: collection, StartKey: startKey, EndKey: endKey, Metadata: metadata})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_STATE_BY_RANGE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_STATE_BY_RANGE)

	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelId, txid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[109], 1);
		return nil, errors.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_STATE_BY_RANGE)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[106], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[110], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully got range", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)

		rangeQueryResponse := &pb.QueryResponse{}
		err = proto.Unmarshal(responseMsg.Payload, rangeQueryResponse)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[112], 1);
			chaincodeLogger.Errorf("[%s] unmarshal error", shorttxid(responseMsg.Txid))
			return nil, errors.Errorf("[%s] GetStateByRangeResponse unmarshall error", shorttxid(responseMsg.Txid))
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[111], 1);return rangeQueryResponse, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[107], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[113], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[108], 1);chaincodeLogger.Errorf("Incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleQueryStateNext(id, channelId, txid string) (*pb.QueryResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[114], 1);
	// Create the channel on which to communicate the response from validating peer
	var respChan chan pb.ChaincodeMessage
	var err error
	if respChan, err = handler.createChannel(channelId, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[119], 1);
		chaincodeLogger.Errorf("[%s] Another state request pending for this Txid. Cannot process.", shorttxid(txid))
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[115], 1);defer handler.deleteChannel(channelId, txid)

	// Send QUERY_STATE_NEXT message to peer chaincode support
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.QueryStateNext{Id: id})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_QUERY_STATE_NEXT, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_NEXT)

	var responseMsg pb.ChaincodeMessage

	if responseMsg, err = handler.sendReceive(msg, respChan); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[120], 1);
		chaincodeLogger.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_NEXT)
		return nil, errors.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_NEXT)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[116], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[121], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully got range", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)

		queryResponse := &pb.QueryResponse{}
		if err = proto.Unmarshal(responseMsg.Payload, queryResponse); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[123], 1);
			chaincodeLogger.Errorf("[%s] unmarshall error", shorttxid(responseMsg.Txid))
			return nil, errors.Errorf("[%s] unmarshal error", shorttxid(responseMsg.Txid))
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[122], 1);return queryResponse, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[117], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[124], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[118], 1);chaincodeLogger.Errorf("Incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleQueryStateClose(id, channelId, txid string) (*pb.QueryResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[125], 1);
	// Create the channel on which to communicate the response from validating peer
	var respChan chan pb.ChaincodeMessage
	var err error
	if respChan, err = handler.createChannel(channelId, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[130], 1);
		chaincodeLogger.Errorf("[%s] Another state request pending for this Txid. Cannot process.", shorttxid(txid))
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[126], 1);defer handler.deleteChannel(channelId, txid)

	// Send QUERY_STATE_CLOSE message to peer chaincode support
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.QueryStateClose{Id: id})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_QUERY_STATE_CLOSE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_CLOSE)

	var responseMsg pb.ChaincodeMessage

	if responseMsg, err = handler.sendReceive(msg, respChan); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[131], 1);
		chaincodeLogger.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_CLOSE)
		return nil, errors.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_QUERY_STATE_CLOSE)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[127], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[132], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully got range", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)

		queryResponse := &pb.QueryResponse{}
		if err = proto.Unmarshal(responseMsg.Payload, queryResponse); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[134], 1);
			chaincodeLogger.Errorf("[%s] unmarshall error", shorttxid(responseMsg.Txid))
			return nil, errors.Errorf("[%s] unmarshal error", shorttxid(responseMsg.Txid))
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[133], 1);return queryResponse, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[128], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[135], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[129], 1);chaincodeLogger.Errorf("Incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleGetQueryResult(collection string, query string, metadata []byte,
	channelId string, txid string) (*pb.QueryResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[136], 1);
	// Send GET_QUERY_RESULT message to peer chaincode support
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.GetQueryResult{Collection: collection, Query: query, Metadata: metadata})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_QUERY_RESULT, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_QUERY_RESULT)

	responseMsg, err := handler.callPeerWithChaincodeMsg(msg, channelId, txid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[140], 1);
		return nil, errors.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_QUERY_RESULT)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[137], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[141], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully got range", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)

		executeQueryResponse := &pb.QueryResponse{}
		if err = proto.Unmarshal(responseMsg.Payload, executeQueryResponse); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[143], 1);
			chaincodeLogger.Errorf("[%s] unmarshall error", shorttxid(responseMsg.Txid))
			return nil, errors.Errorf("[%s] unmarshal error", shorttxid(responseMsg.Txid))
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[142], 1);return executeQueryResponse, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[138], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[144], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[139], 1);chaincodeLogger.Errorf("Incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) handleGetHistoryForKey(key string, channelId string, txid string) (*pb.QueryResponse, error) {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[145], 1);
	// Create the channel on which to communicate the response from validating peer
	var respChan chan pb.ChaincodeMessage
	var err error
	if respChan, err = handler.createChannel(channelId, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[150], 1);
		chaincodeLogger.Errorf("[%s] Another state request pending for this Txid. Cannot process.", shorttxid(txid))
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[146], 1);defer handler.deleteChannel(channelId, txid)

	// Send GET_HISTORY_FOR_KEY message to peer chaincode support
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.GetHistoryForKey{Key: key})

	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_HISTORY_FOR_KEY, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_HISTORY_FOR_KEY)

	var responseMsg pb.ChaincodeMessage

	if responseMsg, err = handler.sendReceive(msg, respChan); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[151], 1);
		chaincodeLogger.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_HISTORY_FOR_KEY)
		return nil, errors.Errorf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_GET_HISTORY_FOR_KEY)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[147], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[152], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully got range", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)

		getHistoryForKeyResponse := &pb.QueryResponse{}
		if err = proto.Unmarshal(responseMsg.Payload, getHistoryForKeyResponse); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[154], 1);
			chaincodeLogger.Errorf("[%s] unmarshall error", shorttxid(responseMsg.Txid))
			return nil, errors.Errorf("[%s] unmarshal error", shorttxid(responseMsg.Txid))
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[153], 1);return getHistoryForKeyResponse, nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[148], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[155], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return nil, errors.New(string(responseMsg.Payload[:]))
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[149], 1);chaincodeLogger.Errorf("Incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return nil, errors.Errorf("incorrect chaincode message %s received. Expecting %s or %s", responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
}

func (handler *Handler) createResponse(status int32, payload []byte) pb.Response {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[156], 1);
	return pb.Response{Status: status, Payload: payload}
}

// handleInvokeChaincode communicates with the peer to invoke another chaincode.
func (handler *Handler) handleInvokeChaincode(chaincodeName string, args [][]byte, channelId string, txid string) pb.Response {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[157], 1);
	//we constructed a valid object. No need to check for error
	payloadBytes, _ := proto.Marshal(&pb.ChaincodeSpec{ChaincodeId: &pb.ChaincodeID{Name: chaincodeName}, Input: &pb.ChaincodeInput{Args: args}})

	// Create the channel on which to communicate the response from validating peer
	var respChan chan pb.ChaincodeMessage
	var err error
	if respChan, err = handler.createChannel(channelId, txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[162], 1);
		return handler.createResponse(ERROR, []byte(err.Error()))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[158], 1);defer handler.deleteChannel(channelId, txid)

	// Send INVOKE_CHAINCODE message to peer chaincode support
	msg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_INVOKE_CHAINCODE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}
	chaincodeLogger.Debugf("[%s] Sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_INVOKE_CHAINCODE)

	var responseMsg pb.ChaincodeMessage

	if responseMsg, err = handler.sendReceive(msg, respChan); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[163], 1);
		errStr := fmt.Sprintf("[%s] error sending %s", shorttxid(msg.Txid), pb.ChaincodeMessage_INVOKE_CHAINCODE)
		chaincodeLogger.Error(errStr)
		return handler.createResponse(ERROR, []byte(errStr))
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[159], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_RESPONSE.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[164], 1);
		// Success response
		chaincodeLogger.Debugf("[%s] Received %s. Successfully invoked chaincode", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
		respMsg := &pb.ChaincodeMessage{}
		if err := proto.Unmarshal(responseMsg.Payload, respMsg); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[167], 1);
			chaincodeLogger.Errorf("[%s] Error unmarshaling called chaincode response: %s", shorttxid(responseMsg.Txid), err)
			return handler.createResponse(ERROR, []byte(err.Error()))
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[165], 1);if respMsg.Type == pb.ChaincodeMessage_COMPLETED {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[168], 1);
			// Success response
			chaincodeLogger.Debugf("[%s] Received %s. Successfully invoked chaincode", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_RESPONSE)
			res := &pb.Response{}
			if err = proto.Unmarshal(respMsg.Payload, res); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[170], 1);
				chaincodeLogger.Errorf("[%s] Error unmarshaling payload of response: %s", shorttxid(responseMsg.Txid), err)
				return handler.createResponse(ERROR, []byte(err.Error()))
			}
			_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[169], 1);return *res
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[166], 1);chaincodeLogger.Errorf("[%s] Received %s. Error from chaincode", shorttxid(responseMsg.Txid), respMsg.Type)
		return handler.createResponse(ERROR, responseMsg.Payload)
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[160], 1);if responseMsg.Type.String() == pb.ChaincodeMessage_ERROR.String() {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[171], 1);
		// Error response
		chaincodeLogger.Errorf("[%s] Received %s.", shorttxid(responseMsg.Txid), pb.ChaincodeMessage_ERROR)
		return handler.createResponse(ERROR, responseMsg.Payload)
	}

	// Incorrect chaincode message received
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[161], 1);chaincodeLogger.Errorf("[%s] Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)
	return handler.createResponse(ERROR, []byte(fmt.Sprintf("[%s] Incorrect chaincode message %s received. Expecting %s or %s", shorttxid(responseMsg.Txid), responseMsg.Type, pb.ChaincodeMessage_RESPONSE, pb.ChaincodeMessage_ERROR)))
}

//handle ready state
func (handler *Handler) handleReady(msg *pb.ChaincodeMessage, errc chan error) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[172], 1);
	switch msg.Type {
	case pb.ChaincodeMessage_RESPONSE:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[174], 1);
		if err := handler.sendChannel(msg); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[180], 1);
			chaincodeLogger.Errorf("[%s] error sending %s (state:%s): %s", shorttxid(msg.Txid), msg.Type, handler.state, err)
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[175], 1);chaincodeLogger.Debugf("[%s] Received %s, communicated (state:%s)", shorttxid(msg.Txid), msg.Type, handler.state)
		return nil

	case pb.ChaincodeMessage_ERROR:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[176], 1);
		if err := handler.sendChannel(msg); err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[181], 1);
			chaincodeLogger.Errorf("[%s] error sending %s (state:%s): %s", shorttxid(msg.Txid), msg.Type, handler.state, err)
		}

		_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[177], 1);chaincodeLogger.Debugf("[%s] Error Received %s, communicated (state:%s)", shorttxid(msg.Txid), msg.Type, handler.state)

		//we don't return error on ERROR
		return nil

	case pb.ChaincodeMessage_INIT:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[178], 1);
		chaincodeLogger.Debugf("[%s] Received %s, initializing chaincode", shorttxid(msg.Txid), msg.Type)
		// Call the chaincode's Run function to initialize
		handler.handleInit(msg, errc)
		return nil

	case pb.ChaincodeMessage_TRANSACTION:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[179], 1);
		chaincodeLogger.Debugf("[%s] Received %s, invoking transaction on chaincode(state:%s)", shorttxid(msg.Txid), msg.Type, handler.state)
		// Call the chaincode's Run function to invoke transaction
		handler.handleTransaction(msg, errc)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[173], 1);return errors.Errorf("[%s] Chaincode handler cannot handle message (%s) with payload size (%d) while in state: %s", msg.Txid, msg.Type, len(msg.Payload), handler.state)
}

//handle established state
func (handler *Handler) handleEstablished(msg *pb.ChaincodeMessage, errc chan error) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[182], 1);
	if msg.Type == pb.ChaincodeMessage_READY {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[184], 1);
		handler.state = ready
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[183], 1);return errors.Errorf("[%s] Chaincode handler cannot handle message (%s) with payload size (%d) while in state: %s", msg.Txid, msg.Type, len(msg.Payload), handler.state)
}

//handle created state
func (handler *Handler) handleCreated(msg *pb.ChaincodeMessage, errc chan error) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[185], 1);
	if msg.Type == pb.ChaincodeMessage_REGISTERED {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[187], 1);
		handler.state = established
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[186], 1);return errors.Errorf("[%s] Chaincode handler cannot handle message (%s) with payload size (%d) while in state: %s", msg.Txid, msg.Type, len(msg.Payload), handler.state)
}

// handleMessage message handles loop for shim side of chaincode/peer stream.
func (handler *Handler) handleMessage(msg *pb.ChaincodeMessage, errc chan error) error {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[188], 1);
	if msg.Type == pb.ChaincodeMessage_KEEPALIVE {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[192], 1);
		chaincodeLogger.Debug("Sending KEEPALIVE response")
		handler.serialSendAsync(msg, nil) // ignore errors, maybe next KEEPALIVE will work
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[189], 1);chaincodeLogger.Debugf("[%s] Handling ChaincodeMessage of type: %s(state:%s)", shorttxid(msg.Txid), msg.Type, handler.state)

	var err error

	switch handler.state {
	case ready:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[193], 1);
		err = handler.handleReady(msg, errc)
	case established:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[194], 1);
		err = handler.handleEstablished(msg, errc)
	case created:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[195], 1);
		err = handler.handleCreated(msg, errc)
	default:_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[196], 1);
		err = errors.Errorf("[%s] Chaincode handler cannot handle message (%s) with payload size (%d) while in state: %s", msg.Txid, msg.Type, len(msg.Payload), handler.state)
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[190], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[197], 1);
		payload := []byte(err.Error())
		errorMsg := &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_ERROR, Payload: payload, Txid: msg.Txid}
		handler.serialSend(errorMsg)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_323061643534336238336134.Count[191], 1);return nil
}

var GoCover_1_323061643534336238336134 = struct {
	Count     [198]uint32
	Pos       [3 * 198]uint32
	NumStmt   [198]uint16
} {
	Pos: [3 * 198]uint32{
		34, 37, 0x20055, // [0]
		57, 58, 0x130024, // [1]
		61, 61, 0x120002, // [2]
		58, 60, 0x30013, // [3]
		65, 72, 0x20044, // [4]
		79, 80, 0xc0054, // [5]
		80, 82, 0x12000c, // [6]
		82, 84, 0x40012, // [7]
		91, 93, 0x20048, // [8]
		95, 98, 0x240061, // [9]
		101, 102, 0x2d0002, // [10]
		105, 107, 0xf0002, // [11]
		98, 100, 0x30024, // [12]
		102, 104, 0x3002d, // [13]
		110, 113, 0x240045, // [14]
		116, 117, 0x2d0002, // [15]
		121, 125, 0xc0002, // [16]
		113, 115, 0x30024, // [17]
		117, 119, 0x3002d, // [18]
		129, 139, 0x60078, // [19]
		139, 140, 0xa0006, // [20]
		141, 142, 0x120016, // [21]
		146, 146, 0x250004, // [22]
		147, 148, 0xc001b, // [23]
		151, 151, 0x160004, // [24]
		142, 143, 0xd0012, // [25]
		148, 150, 0x5000c, // [26]
		156, 159, 0x24003f, // [27]
		159, 162, 0x30024, // [28]
		166, 174, 0x2005c, // [29]
		177, 181, 0xc004f, // [30]
		181, 184, 0x10000c, // [31]
		188, 188, 0x7e0003, // [32]
		200, 202, 0xb00003, // [33]
		208, 210, 0xb60003, // [34]
		213, 216, 0x1a0003, // [35]
		223, 224, 0x110003, // [36]
		232, 233, 0x700003, // [37]
		184, 186, 0x40010, // [38]
		188, 189, 0x12007e, // [39]
		197, 197, 0xe0004, // [40]
		189, 191, 0x170012, // [41]
		194, 195, 0x910005, // [42]
		191, 193, 0x60017, // [43]
		202, 204, 0x400b0, // [44]
		210, 212, 0x400b6, // [45]
		216, 218, 0xc7001a, // [46]
		218, 220, 0x500c7, // [47]
		224, 229, 0x40011, // [48]
		238, 242, 0xc0056, // [49]
		242, 246, 0x10000c, // [50]
		250, 250, 0x6e0003, // [51]
		260, 262, 0xab0003, // [52]
		268, 270, 0xb60003, // [53]
		273, 277, 0xb60003, // [54]
		282, 283, 0xae0003, // [55]
		246, 248, 0x40010, // [56]
		250, 251, 0x12006e, // [57]
		256, 256, 0xe0004, // [58]
		251, 255, 0x50012, // [59]
		262, 264, 0x400ab, // [60]
		270, 272, 0x400b6, // [61]
		277, 279, 0x400b6, // [62]
		289, 293, 0x480081, // [63]
		297, 299, 0x2b0002, // [64]
		293, 295, 0x30048, // [65]
		304, 312, 0x100076, // [66]
		316, 316, 0x480002, // [67]
		321, 321, 0x450002, // [68]
		328, 329, 0xc70002, // [69]
		312, 314, 0x30010, // [70]
		316, 320, 0x30048, // [71]
		321, 325, 0x30045, // [72]
		332, 340, 0x100089, // [73]
		344, 344, 0x480002, // [74]
		360, 360, 0x450002, // [75]
		367, 368, 0xc60002, // [76]
		340, 342, 0x30010, // [77]
		344, 349, 0x110048, // [78]
		353, 354, 0x270003, // [79]
		358, 358, 0x170003, // [80]
		349, 352, 0x40011, // [81]
		354, 356, 0x40027, // [82]
		360, 364, 0x30045, // [83]
		373, 382, 0x10007a, // [84]
		386, 386, 0x480002, // [85]
		392, 392, 0x450002, // [86]
		399, 400, 0xc20002, // [87]
		382, 384, 0x30010, // [88]
		386, 390, 0x30048, // [89]
		392, 396, 0x30045, // [90]
		403, 413, 0x10009a, // [91]
		417, 417, 0x480002, // [92]
		423, 423, 0x450002, // [93]
		430, 431, 0xc10002, // [94]
		413, 415, 0x30010, // [95]
		417, 421, 0x30048, // [96]
		423, 427, 0x30045, // [97]
		435, 444, 0x10006c, // [98]
		448, 448, 0x480002, // [99]
		453, 453, 0x450002, // [100]
		460, 461, 0xc20002, // [101]
		444, 446, 0x30010, // [102]
		448, 452, 0x30048, // [103]
		453, 457, 0x30045, // [104]
		465, 474, 0x10003c, // [105]
		478, 478, 0x480002, // [106]
		491, 491, 0x450002, // [107]
		498, 499, 0xa50002, // [108]
		474, 476, 0x30010, // [109]
		478, 484, 0x110048, // [110]
		489, 489, 0x210003, // [111]
		484, 487, 0x40011, // [112]
		491, 495, 0x30045, // [113]
		502, 506, 0x480065, // [114]
		511, 522, 0x470002, // [115]
		527, 527, 0x480002, // [116]
		539, 539, 0x450002, // [117]
		546, 547, 0xa50002, // [118]
		506, 509, 0x30048, // [119]
		522, 525, 0x30047, // [120]
		527, 532, 0x4c0048, // [121]
		537, 537, 0x1c0003, // [122]
		532, 535, 0x4004c, // [123]
		539, 543, 0x30045, // [124]
		550, 554, 0x480066, // [125]
		559, 570, 0x470002, // [126]
		575, 575, 0x480002, // [127]
		587, 587, 0x450002, // [128]
		594, 595, 0xa50002, // [129]
		554, 557, 0x30048, // [130]
		570, 573, 0x30047, // [131]
		575, 580, 0x4c0048, // [132]
		585, 585, 0x1c0003, // [133]
		580, 583, 0x4004c, // [134]
		587, 591, 0x30045, // [135]
		599, 608, 0x10003c, // [136]
		612, 612, 0x480002, // [137]
		624, 624, 0x450002, // [138]
		631, 632, 0xa50002, // [139]
		608, 610, 0x30010, // [140]
		612, 617, 0x530048, // [141]
		622, 622, 0x230003, // [142]
		617, 620, 0x40053, // [143]
		624, 628, 0x30045, // [144]
		635, 639, 0x480076, // [145]
		644, 655, 0x470002, // [146]
		660, 660, 0x480002, // [147]
		672, 672, 0x450002, // [148]
		679, 680, 0xa50002, // [149]
		639, 642, 0x30048, // [150]
		655, 658, 0x30047, // [151]
		660, 665, 0x570048, // [152]
		670, 670, 0x270003, // [153]
		665, 668, 0x40057, // [154]
		672, 676, 0x30045, // [155]
		683, 685, 0x20052, // [156]
		688, 695, 0x48007f, // [157]
		699, 707, 0x470002, // [158]
		713, 713, 0x480002, // [159]
		734, 734, 0x450002, // [160]
		741, 742, 0xe70002, // [161]
		695, 697, 0x30048, // [162]
		707, 711, 0x30047, // [163]
		713, 717, 0x470048, // [164]
		721, 721, 0x340003, // [165]
		731, 732, 0x3c0003, // [166]
		717, 720, 0x40047, // [167]
		721, 725, 0x3f0034, // [168]
		729, 729, 0xf0004, // [169]
		725, 728, 0x5003f, // [170]
		734, 738, 0x30045, // [171]
		746, 747, 0x120056, // [172]
		779, 779, 0xaa0002, // [173]
		748, 749, 0x320024, // [174]
		753, 754, 0xd0003, // [175]
		756, 757, 0x320021, // [176]
		761, 764, 0xd0003, // [177]
		766, 770, 0xd0020, // [178]
		772, 776, 0xd0027, // [179]
		749, 752, 0x40032, // [180]
		757, 759, 0x40032, // [181]
		783, 784, 0x2b005c, // [182]
		788, 788, 0xaa0002, // [183]
		784, 787, 0x3002b, // [184]
		792, 793, 0x300058, // [185]
		797, 797, 0xaa0002, // [186]
		793, 796, 0x30030, // [187]
		801, 802, 0x2f0058, // [188]
		807, 811, 0x170002, // [189]
		822, 822, 0x100002, // [190]
		829, 829, 0xc0002, // [191]
		802, 806, 0x3002f, // [192]
		812, 813, 0x27000d, // [193]
		814, 815, 0x2d0013, // [194]
		816, 817, 0x29000f, // [195]
		818, 819, 0xaa000a, // [196]
		822, 827, 0x30010, // [197]
	},
	NumStmt: [198]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		4, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		3, // 9
		2, // 10
		3, // 11
		1, // 12
		1, // 13
		3, // 14
		2, // 15
		4, // 16
		1, // 17
		1, // 18
		3, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		3, // 27
		2, // 28
		4, // 29
		1, // 30
		2, // 31
		1, // 32
		3, // 33
		3, // 34
		3, // 35
		2, // 36
		2, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		2, // 42
		1, // 43
		1, // 44
		1, // 45
		2, // 46
		1, // 47
		4, // 48
		1, // 49
		2, // 50
		1, // 51
		3, // 52
		3, // 53
		3, // 54
		2, // 55
		1, // 56
		1, // 57
		1, // 58
		3, // 59
		1, // 60
		1, // 61
		1, // 62
		3, // 63
		2, // 64
		1, // 65
		5, // 66
		1, // 67
		1, // 68
		2, // 69
		1, // 70
		2, // 71
		2, // 72
		5, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		4, // 78
		2, // 79
		1, // 80
		2, // 81
		1, // 82
		2, // 83
		5, // 84
		1, // 85
		1, // 86
		2, // 87
		1, // 88
		2, // 89
		2, // 90
		6, // 91
		1, // 92
		1, // 93
		2, // 94
		1, // 95
		2, // 96
		2, // 97
		5, // 98
		1, // 99
		1, // 100
		2, // 101
		1, // 102
		2, // 103
		2, // 104
		5, // 105
		1, // 106
		1, // 107
		2, // 108
		1, // 109
		4, // 110
		1, // 111
		2, // 112
		2, // 113
		3, // 114
		6, // 115
		1, // 116
		1, // 117
		2, // 118
		2, // 119
		2, // 120
		3, // 121
		1, // 122
		2, // 123
		2, // 124
		3, // 125
		6, // 126
		1, // 127
		1, // 128
		2, // 129
		2, // 130
		2, // 131
		3, // 132
		1, // 133
		2, // 134
		2, // 135
		5, // 136
		1, // 137
		1, // 138
		2, // 139
		1, // 140
		3, // 141
		1, // 142
		2, // 143
		2, // 144
		3, // 145
		6, // 146
		1, // 147
		1, // 148
		2, // 149
		2, // 150
		2, // 151
		3, // 152
		1, // 153
		2, // 154
		2, // 155
		1, // 156
		4, // 157
		5, // 158
		1, // 159
		1, // 160
		2, // 161
		1, // 162
		3, // 163
		3, // 164
		1, // 165
		2, // 166
		2, // 167
		3, // 168
		1, // 169
		2, // 170
		2, // 171
		1, // 172
		1, // 173
		1, // 174
		2, // 175
		1, // 176
		2, // 177
		3, // 178
		3, // 179
		2, // 180
		1, // 181
		1, // 182
		1, // 183
		2, // 184
		1, // 185
		1, // 186
		2, // 187
		1, // 188
		3, // 189
		1, // 190
		1, // 191
		3, // 192
		1, // 193
		1, // 194
		1, // 195
		1, // 196
		4, // 197
	},
}
var _ = _cover_atomic_.LoadUint32
