//line /home/cooper/go/src/github.com/hyperledger/fabric/core/scc/sysccapi.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package scc; import _cover_atomic_ "sync/atomic"

import (
	"errors"
	"fmt"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/common/ccprovider"
	"github.com/hyperledger/fabric/core/container/ccintf"
	"github.com/hyperledger/fabric/core/container/inproccontroller"
	"github.com/hyperledger/fabric/core/peer"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/spf13/viper"
)

var sysccLogger = flogging.MustGetLogger("sccapi")

// Registrar provides a way for system chaincodes to be registered
type Registrar interface {
	// Register registers a system chaincode
	Register(ccid *ccintf.CCID, cc shim.Chaincode) error
}

// SystemChaincode defines the metadata needed to initialize system chaincode
// when the fabric comes up. SystemChaincodes are installed by adding an
// entry in importsysccs.go
type SystemChaincode struct {
	//Unique name of the system chaincode
	Name string

	//Path to the system chaincode; currently not used
	Path string

	//InitArgs initialization arguments to startup the system chaincode
	InitArgs [][]byte

	// Chaincode holds the actual chaincode instance
	Chaincode shim.Chaincode

	// InvokableExternal keeps track of whether
	// this system chaincode can be invoked
	// through a proposal sent to this peer
	InvokableExternal bool

	// InvokableCC2CC keeps track of whether
	// this system chaincode can be invoked
	// by way of a chaincode-to-chaincode
	// invocation
	InvokableCC2CC bool

	// Enabled a convenient switch to enable/disable system chaincode without
	// having to remove entry from importsysccs.go
	Enabled bool
}

type SysCCWrapper struct {
	SCC *SystemChaincode
}

func (sccw *SysCCWrapper) Name() string              {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[0], 1); return sccw.SCC.Name }
func (sccw *SysCCWrapper) Path() string              {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[1], 1); return sccw.SCC.Path }
func (sccw *SysCCWrapper) InitArgs() [][]byte        {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[2], 1); return sccw.SCC.InitArgs }
func (sccw *SysCCWrapper) Chaincode() shim.Chaincode {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[3], 1); return sccw.SCC.Chaincode }
func (sccw *SysCCWrapper) InvokableExternal() bool   {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[4], 1); return sccw.SCC.InvokableExternal }
func (sccw *SysCCWrapper) InvokableCC2CC() bool      {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[5], 1); return sccw.SCC.InvokableCC2CC }
func (sccw *SysCCWrapper) Enabled() bool             {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[6], 1); return sccw.SCC.Enabled }

type SelfDescribingSysCC interface {
	//Unique name of the system chaincode
	Name() string

	//Path to the system chaincode; currently not used
	Path() string

	//InitArgs initialization arguments to startup the system chaincode
	InitArgs() [][]byte

	// Chaincode returns the underlying chaincode
	Chaincode() shim.Chaincode

	// InvokableExternal keeps track of whether
	// this system chaincode can be invoked
	// through a proposal sent to this peer
	InvokableExternal() bool

	// InvokableCC2CC keeps track of whether
	// this system chaincode can be invoked
	// by way of a chaincode-to-chaincode
	// invocation
	InvokableCC2CC() bool

	// Enabled a convenient switch to enable/disable system chaincode without
	// having to remove entry from importsysccs.go
	Enabled() bool
}

// registerSysCC registers the given system chaincode with the peer
func (p *Provider) registerSysCC(syscc SelfDescribingSysCC) (bool, error) {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[7], 1);
	if !syscc.Enabled() || !isWhitelisted(syscc) {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[10], 1);
		sysccLogger.Info(fmt.Sprintf("system chaincode (%s,%s,%t) disabled", syscc.Name(), syscc.Path(), syscc.Enabled()))
		return false, nil
	}

	// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary
	_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[8], 1);version := util.GetSysCCVersion()

	ccid := &ccintf.CCID{
		Name:    syscc.Name(),
		Version: version,
	}
	err := p.Registrar.Register(ccid, syscc.Chaincode())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[11], 1);
		//if the type is registered, the instance may not be... keep going
		if _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[12], 1);
			errStr := fmt.Sprintf("could not register (%s,%v): %s", syscc.Path(), syscc, err)
			sysccLogger.Error(errStr)
			return false, fmt.Errorf(errStr)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[9], 1);sysccLogger.Infof("system chaincode %s(%s) registered", syscc.Name(), syscc.Path())
	return true, err
}

// deploySysCC deploys the given system chaincode on a chain
func deploySysCC(chainID string, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC) error {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[13], 1);
	if !syscc.Enabled() || !isWhitelisted(syscc) {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[17], 1);
		sysccLogger.Info(fmt.Sprintf("system chaincode (%s,%s) disabled", syscc.Name(), syscc.Path()))
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[14], 1);txid := util.GenerateUUID()

	// Note, this structure is barely initialized,
	// we omit the history query executor, the proposal
	// and the signed proposal
	txParams := &ccprovider.TransactionParams{
		TxID:      txid,
		ChannelID: chainID,
	}

	if chainID != "" {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[18], 1);
		lgr := peer.GetLedger(chainID)
		if lgr == nil {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[21], 1);
			panic(fmt.Sprintf("syschain %s start up failure - unexpected nil ledger for channel %s", syscc.Name(), chainID))
		}

		_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[19], 1);txsim, err := lgr.NewTxSimulator(txid)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[22], 1);
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[20], 1);txParams.TXSimulator = txsim
		defer txsim.Done()
	}

	_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[15], 1);chaincodeID := &pb.ChaincodeID{Path: syscc.Path(), Name: syscc.Name()}
	spec := &pb.ChaincodeSpec{Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value["GOLANG"]), ChaincodeId: chaincodeID, Input: &pb.ChaincodeInput{Args: syscc.InitArgs()}}

	chaincodeDeploymentSpec := &pb.ChaincodeDeploymentSpec{ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec}

	// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary
	version := util.GetSysCCVersion()

	cccid := &ccprovider.CCContext{
		Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,
		Version: version,
	}

	resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)
	if err == nil && resp.Status != shim.OK {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[23], 1);
		err = errors.New(resp.Message)
	}

	_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[16], 1);sysccLogger.Infof("system chaincode %s/%s(%s) deployed", syscc.Name(), chainID, syscc.Path())

	return err
}

// deDeploySysCC stops the system chaincode and deregisters it from inproccontroller
func deDeploySysCC(chainID string, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC) error {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[24], 1);
	// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary
	version := util.GetSysCCVersion()

	ccci := &ccprovider.ChaincodeContainerInfo{
		Type:          "GOLANG",
		Name:          syscc.Name(),
		Path:          syscc.Path(),
		Version:       version,
		ContainerType: inproccontroller.ContainerType,
	}

	err := ccprov.Stop(ccci)

	return err
}

func isWhitelisted(syscc SelfDescribingSysCC) bool {_cover_atomic_.AddUint32(&GoCover_4_613163393733346361646563.Count[25], 1);
	chaincodes := viper.GetStringMapString("chaincode.system")
	val, ok := chaincodes[syscc.Name()]
	enabled := val == "enable" || val == "true" || val == "yes"
	return ok && enabled
}

var GoCover_4_613163393733346361646563 = struct {
	Count     [26]uint32
	Pos       [3 * 26]uint32
	NumStmt   [26]uint16
} {
	Pos: [3 * 26]uint32{
		68, 68, 0x4e0036, // [0]
		69, 69, 0x4e0036, // [1]
		70, 70, 0x520036, // [2]
		71, 71, 0x530036, // [3]
		72, 72, 0x5b0036, // [4]
		73, 73, 0x580036, // [5]
		74, 74, 0x510036, // [6]
		106, 107, 0x2f004b, // [7]
		113, 120, 0x100002, // [8]
		129, 130, 0x120002, // [9]
		107, 110, 0x3002f, // [10]
		120, 122, 0x3e0010, // [11]
		122, 126, 0x4003e, // [12]
		134, 135, 0x2f0068, // [13]
		140, 150, 0x130002, // [14]
		165, 179, 0x2a0002, // [15]
		183, 185, 0xc0002, // [16]
		135, 138, 0x3002f, // [17]
		150, 152, 0x110013, // [18]
		156, 157, 0x110003, // [19]
		161, 162, 0x150003, // [20]
		152, 153, 0x740011, // [21]
		157, 159, 0x40011, // [22]
		179, 181, 0x3002a, // [23]
		189, 204, 0x2006a, // [24]
		206, 211, 0x20034, // [25]
	},
	NumStmt: [26]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		4, // 8
		2, // 9
		2, // 10
		1, // 11
		3, // 12
		1, // 13
		3, // 14
		7, // 15
		2, // 16
		2, // 17
		2, // 18
		2, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		4, // 24
		4, // 25
	},
}
var _ = _cover_atomic_.LoadUint32
