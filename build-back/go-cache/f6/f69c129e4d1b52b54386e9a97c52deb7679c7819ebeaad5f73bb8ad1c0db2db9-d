//line /home/cooper/go/src/github.com/hyperledger/fabric/common/metrics/internal/namer/namer.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package namer; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/hyperledger/fabric/common/metrics"
)

type Namer struct {
	namespace  string
	subsystem  string
	name       string
	nameFormat string
	labelNames map[string]struct{}
}

func NewCounterNamer(c metrics.CounterOpts) *Namer {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[0], 1);
	return &Namer{
		namespace:  c.Namespace,
		subsystem:  c.Subsystem,
		name:       c.Name,
		nameFormat: c.StatsdFormat,
		labelNames: sliceToSet(c.LabelNames),
	}
}

func NewGaugeNamer(g metrics.GaugeOpts) *Namer {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[1], 1);
	return &Namer{
		namespace:  g.Namespace,
		subsystem:  g.Subsystem,
		name:       g.Name,
		nameFormat: g.StatsdFormat,
		labelNames: sliceToSet(g.LabelNames),
	}
}

func NewHistogramNamer(h metrics.HistogramOpts) *Namer {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[2], 1);
	return &Namer{
		namespace:  h.Namespace,
		subsystem:  h.Subsystem,
		name:       h.Name,
		nameFormat: h.StatsdFormat,
		labelNames: sliceToSet(h.LabelNames),
	}
}

func (n *Namer) validateKey(name string) {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[3], 1);
	if _, ok := n.labelNames[name]; !ok {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[4], 1);
		panic("invalid label name: " + name)
	}
}

func (n *Namer) FullyQualifiedName() string {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[5], 1);
	switch {
	case n.namespace != "" && n.subsystem != "":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[6], 1);
		return strings.Join([]string{n.namespace, n.subsystem, n.name}, ".")
	case n.namespace != "":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[7], 1);
		return strings.Join([]string{n.namespace, n.name}, ".")
	case n.subsystem != "":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[8], 1);
		return strings.Join([]string{n.subsystem, n.name}, ".")
	default:_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[9], 1);
		return n.name
	}
}

func (n *Namer) labelsToMap(labelValues []string) map[string]string {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[10], 1);
	labels := map[string]string{}
	for i := 0; i < len(labelValues); i += 2 {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[12], 1);
		key := labelValues[i]
		n.validateKey(key)
		if i == len(labelValues)-1 {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[13], 1);
			labels[key] = "unknown"
		} else{ _cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[14], 1);{
			labels[key] = labelValues[i+1]
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[11], 1);return labels
}

var formatRegexp = regexp.MustCompile(`%{([#?[:alnum:]_]+)}`)
var invalidLabelValueRegexp = regexp.MustCompile(`[.|:\s]`)

func (n *Namer) Format(labelValues ...string) string {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[15], 1);
	labels := n.labelsToMap(labelValues)

	cursor := 0
	var segments []string
	// iterate over the regex groups and convert to formatters
	matches := formatRegexp.FindAllStringSubmatchIndex(n.nameFormat, -1)
	for _, m := range matches {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[18], 1);
		start, end := m[0], m[1]
		labelStart, labelEnd := m[2], m[3]

		if start > cursor {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[21], 1);
			segments = append(segments, n.nameFormat[cursor:start])
		}

		_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[19], 1);key := n.nameFormat[labelStart:labelEnd]
		var value string
		switch key {
		case "#namespace":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[22], 1);
			value = n.namespace
		case "#subsystem":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[23], 1);
			value = n.subsystem
		case "#name":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[24], 1);
			value = n.name
		case "#fqname":_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[25], 1);
			value = n.FullyQualifiedName()
		default:_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[26], 1);
			var ok bool
			value, ok = labels[key]
			if !ok {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[28], 1);
				panic(fmt.Sprintf("invalid label in name format: %s", key))
			}
			_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[27], 1);value = invalidLabelValueRegexp.ReplaceAllString(value, "_")
		}
		_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[20], 1);segments = append(segments, value)

		cursor = end
	}

	// handle any trailing suffix
	_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[16], 1);if cursor != len(n.nameFormat) {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[29], 1);
		segments = append(segments, n.nameFormat[cursor:])
	}

	_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[17], 1);return strings.Join(segments, "")
}

func sliceToSet(set []string) map[string]struct{} {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[30], 1);
	labelSet := map[string]struct{}{}
	for _, s := range set {_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[32], 1);
		labelSet[s] = struct{}{}
	}
	_cover_atomic_.AddUint32(&GoCover_0_616436356638653630393961.Count[31], 1);return labelSet
}

var GoCover_0_616436356638653630393961 = struct {
	Count     [33]uint32
	Pos       [3 * 33]uint32
	NumStmt   [33]uint16
} {
	Pos: [3 * 33]uint32{
		25, 33, 0x20034, // [0]
		35, 43, 0x20030, // [1]
		45, 53, 0x20038, // [2]
		55, 56, 0x26002a, // [3]
		56, 57, 0x270026, // [4]
		61, 62, 0x9002d, // [5]
		63, 64, 0x47002e, // [6]
		65, 66, 0x3a0019, // [7]
		67, 68, 0x3a0019, // [8]
		69, 70, 0x10000a, // [9]
		74, 76, 0x2b0045, // [10]
		85, 85, 0xf0002, // [11]
		76, 79, 0x1e002b, // [12]
		79, 81, 0x4001e, // [13]
		81, 83, 0x40009, // [14]
		91, 98, 0x1c0036, // [15]
		131, 131, 0x210002, // [16]
		135, 135, 0x230002, // [17]
		98, 102, 0x15001c, // [18]
		106, 108, 0xe0003, // [19]
		125, 127, 0xf0003, // [20]
		102, 104, 0x40015, // [21]
		109, 110, 0x170015, // [22]
		111, 112, 0x170015, // [23]
		113, 114, 0x120010, // [24]
		115, 116, 0x220012, // [25]
		117, 120, 0xb000b, // [26]
		123, 123, 0x400004, // [27]
		120, 121, 0x40000b, // [28]
		131, 133, 0x30021, // [29]
		138, 140, 0x180033, // [30]
		143, 143, 0x110002, // [31]
		140, 142, 0x30018, // [32]
	},
	NumStmt: [33]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		3, // 12
		1, // 13
		1, // 14
		5, // 15
		1, // 16
		1, // 17
		3, // 18
		3, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		3, // 26
		1, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
	},
}
var _ = _cover_atomic_.LoadUint32
