//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/multichannel/registrar.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

// Package multichannel tracks the channel resources for the orderer.  It initially
// loads the set of existing channels, and provides an interface for users of these
// channels to retrieve them, or create new ones.
package multichannel; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/configtx"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/blockledger"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/orderer/common/blockcutter"
	"github.com/hyperledger/fabric/orderer/common/msgprocessor"
	"github.com/hyperledger/fabric/orderer/consensus"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

const (
	msgVersion = int32(0)
	epoch      = 0
)

var logger = flogging.MustGetLogger("orderer.commmon.multichannel")

// checkResources makes sure that the channel config is compatible with this binary and logs sanity checks
func checkResources(res channelconfig.Resources) error {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[0], 1);
	channelconfig.LogSanityChecks(res)
	oc, ok := res.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[4], 1);
		return errors.New("config does not contain orderer config")
	}
	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[1], 1);if err := oc.Capabilities().Supported(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[5], 1);
		return errors.Wrapf(err, "config requires unsupported orderer capabilities: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[2], 1);if err := res.ChannelConfig().Capabilities().Supported(); err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[6], 1);
		return errors.Wrapf(err, "config requires unsupported channel capabilities: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[3], 1);return nil
}

// checkResourcesOrPanic invokes checkResources and panics if an error is returned
func checkResourcesOrPanic(res channelconfig.Resources) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[7], 1);
	if err := checkResources(res); err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[8], 1);
		logger.Panicf("[channel %s] %s", res.ConfigtxValidator().ChainID(), err)
	}
}

type mutableResources interface {
	channelconfig.Resources
	Update(*channelconfig.Bundle)
}

type configResources struct {
	mutableResources
}

func (cr *configResources) CreateBundle(channelID string, config *cb.Config) (*channelconfig.Bundle, error) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[9], 1);
	return channelconfig.NewBundle(channelID, config)
}

func (cr *configResources) Update(bndl *channelconfig.Bundle) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[10], 1);
	checkResourcesOrPanic(bndl)
	cr.mutableResources.Update(bndl)
}

func (cr *configResources) SharedConfig() channelconfig.Orderer {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[11], 1);
	oc, ok := cr.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[13], 1);
		logger.Panicf("[channel %s] has no orderer configuration", cr.ConfigtxValidator().ChainID())
	}
	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[12], 1);return oc
}

type ledgerResources struct {
	*configResources
	blockledger.ReadWriter
}

// Registrar serves as a point of access and control for the individual channel resources.
type Registrar struct {
	lock   sync.RWMutex
	chains map[string]*ChainSupport

	consenters         map[string]consensus.Consenter
	ledgerFactory      blockledger.Factory
	signer             crypto.LocalSigner
	blockcutterMetrics *blockcutter.Metrics
	systemChannelID    string
	systemChannel      *ChainSupport
	templator          msgprocessor.ChannelConfigTemplator
	callbacks          []func(bundle *channelconfig.Bundle)
}

func getConfigTx(reader blockledger.Reader) *cb.Envelope {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[14], 1);
	lastBlock := blockledger.GetBlock(reader, reader.Height()-1)
	index, err := utils.GetLastConfigIndexFromBlock(lastBlock)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[17], 1);
		logger.Panicf("Chain did not have appropriately encoded last config in its latest block: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[15], 1);configBlock := blockledger.GetBlock(reader, index)
	if configBlock == nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[18], 1);
		logger.Panicf("Config block does not exist")
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[16], 1);return utils.ExtractEnvelopeOrPanic(configBlock, 0)
}

// NewRegistrar produces an instance of a *Registrar.
func NewRegistrar(ledgerFactory blockledger.Factory,
	signer crypto.LocalSigner, metricsProvider metrics.Provider, callbacks ...func(bundle *channelconfig.Bundle)) *Registrar {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[19], 1);
	r := &Registrar{
		chains:             make(map[string]*ChainSupport),
		ledgerFactory:      ledgerFactory,
		signer:             signer,
		blockcutterMetrics: blockcutter.NewMetrics(metricsProvider),
		callbacks:          callbacks,
	}

	return r
}

func (r *Registrar) Initialize(consenters map[string]consensus.Consenter) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[20], 1);
	r.consenters = consenters
	existingChains := r.ledgerFactory.ChainIDs()
	for _, chainID := range existingChains {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[22], 1);
		rl, err := r.ledgerFactory.GetOrCreate(chainID)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[25], 1);
			logger.Panicf("Ledger factory reported chainID %s but could not retrieve it: %s", chainID, err)
		}
		_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[23], 1);configTx := getConfigTx(rl)
		if configTx == nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[26], 1);
			logger.Panic("Programming error, configTx should never be nil here")
		}
		_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[24], 1);ledgerResources := r.newLedgerResources(configTx)
		chainID := ledgerResources.ConfigtxValidator().ChainID()

		if _, ok := ledgerResources.ConsortiumsConfig(); ok {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[27], 1);
			if r.systemChannelID != "" {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[31], 1);
				logger.Panicf("There appear to be two system chains %s and %s", r.systemChannelID, chainID)
			}
			_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[28], 1);chain := newChainSupport(
				r,
				ledgerResources,
				r.consenters,
				r.signer,
				r.blockcutterMetrics)
			r.templator = msgprocessor.NewDefaultTemplator(chain)
			chain.Processor = msgprocessor.NewSystemChannel(chain, r.templator, msgprocessor.CreateSystemChannelFilters(r, chain))

			// Retrieve genesis block to log its hash. See FAB-5450 for the purpose
			iter, pos := rl.Iterator(&ab.SeekPosition{Type: &ab.SeekPosition_Oldest{Oldest: &ab.SeekOldest{}}})
			defer iter.Close()
			if pos != uint64(0) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[32], 1);
				logger.Panicf("Error iterating over system channel: '%s', expected position 0, got %d", chainID, pos)
			}
			_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[29], 1);genesisBlock, status := iter.Next()
			if status != cb.Status_SUCCESS {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[33], 1);
				logger.Panicf("Error reading genesis block of system channel '%s'", chainID)
			}
			_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[30], 1);logger.Infof("Starting system channel '%s' with genesis block hash %x and orderer type %s", chainID, genesisBlock.Header.Hash(), chain.SharedConfig().ConsensusType())

			r.chains[chainID] = chain
			r.systemChannelID = chainID
			r.systemChannel = chain
			// We delay starting this chain, as it might try to copy and replace the chains map via newChain before the map is fully built
			defer chain.start()
		} else{ _cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[34], 1);{
			logger.Debugf("Starting chain: %s", chainID)
			chain := newChainSupport(
				r,
				ledgerResources,
				r.consenters,
				r.signer,
				r.blockcutterMetrics)
			r.chains[chainID] = chain
			chain.start()
		}}

	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[21], 1);if r.systemChannelID == "" {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[35], 1);
		logger.Panicf("No system chain found.  If bootstrapping, does your system channel contain a consortiums group definition?")
	}
}

// SystemChannelID returns the ChannelID for the system channel.
func (r *Registrar) SystemChannelID() string {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[36], 1);
	return r.systemChannelID
}

// BroadcastChannelSupport returns the message channel header, whether the message is a config update
// and the channel resources for a message or an error if the message is not a message which can
// be processed directly (like CONFIG and ORDERER_TRANSACTION messages)
func (r *Registrar) BroadcastChannelSupport(msg *cb.Envelope) (*cb.ChannelHeader, bool, *ChainSupport, error) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[37], 1);
	chdr, err := utils.ChannelHeader(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[41], 1);
		return nil, false, nil, fmt.Errorf("could not determine channel ID: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[38], 1);cs := r.GetChain(chdr.ChannelId)
	if cs == nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[42], 1);
		cs = r.systemChannel
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[39], 1);isConfig := false
	switch cs.ClassifyMsg(chdr) {
	case msgprocessor.ConfigUpdateMsg:_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[43], 1);
		isConfig = true
	case msgprocessor.ConfigMsg:_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[44], 1);
		return chdr, false, nil, errors.New("message is of type that cannot be processed directly")
	default:_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[45], 1);
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[40], 1);return chdr, isConfig, cs, nil
}

// GetChain retrieves the chain support for a chain if it exists
func (r *Registrar) GetChain(chainID string) *ChainSupport {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[46], 1);
	r.lock.RLock()
	defer r.lock.RUnlock()

	return r.chains[chainID]
}

func (r *Registrar) newLedgerResources(configTx *cb.Envelope) *ledgerResources {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[47], 1);
	payload, err := utils.UnmarshalPayload(configTx.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[54], 1);
		logger.Panicf("Error umarshaling envelope to payload: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[48], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[55], 1);
		logger.Panicf("Missing channel header: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[49], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[56], 1);
		logger.Panicf("Error unmarshaling channel header: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[50], 1);configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[57], 1);
		logger.Panicf("Error umarshaling config envelope from payload data: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[51], 1);bundle, err := channelconfig.NewBundle(chdr.ChannelId, configEnvelope.Config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[58], 1);
		logger.Panicf("Error creating channelconfig bundle: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[52], 1);checkResourcesOrPanic(bundle)

	ledger, err := r.ledgerFactory.GetOrCreate(chdr.ChannelId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[59], 1);
		logger.Panicf("Error getting ledger for %s", chdr.ChannelId)
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[53], 1);return &ledgerResources{
		configResources: &configResources{
			mutableResources: channelconfig.NewBundleSource(bundle, r.callbacks...),
		},
		ReadWriter: ledger,
	}
}

func (r *Registrar) newChain(configtx *cb.Envelope) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[60], 1);
	r.lock.Lock()
	defer r.lock.Unlock()

	ledgerResources := r.newLedgerResources(configtx)
	ledgerResources.Append(blockledger.CreateNextBlock(ledgerResources, []*cb.Envelope{configtx}))

	// Copy the map to allow concurrent reads from broadcast/deliver while the new chainSupport is
	newChains := make(map[string]*ChainSupport)
	for key, value := range r.chains {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[62], 1);
		newChains[key] = value
	}

	_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[61], 1);cs := newChainSupport(r, ledgerResources, r.consenters, r.signer, r.blockcutterMetrics)
	chainID := ledgerResources.ConfigtxValidator().ChainID()

	logger.Infof("Created and starting new chain %s", chainID)

	newChains[string(chainID)] = cs
	cs.start()

	r.chains = newChains
}

// ChannelsCount returns the count of the current total number of channels.
func (r *Registrar) ChannelsCount() int {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[63], 1);
	r.lock.RLock()
	defer r.lock.RUnlock()

	return len(r.chains)
}

// NewChannelConfig produces a new template channel configuration based on the system channel's current config.
func (r *Registrar) NewChannelConfig(envConfigUpdate *cb.Envelope) (channelconfig.Resources, error) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[64], 1);
	return r.templator.NewChannelConfig(envConfigUpdate)
}

// CreateBundle calls channelconfig.NewBundle
func (r *Registrar) CreateBundle(channelID string, config *cb.Config) (channelconfig.Resources, error) {_cover_atomic_.AddUint32(&GoCover_2_663537366331353835343737.Count[65], 1);
	return channelconfig.NewBundle(channelID, config)
}

var GoCover_2_663537366331353835343737 = struct {
	Count     [66]uint32
	Pos       [3 * 66]uint32
	NumStmt   [66]uint16
} {
	Pos: [3 * 66]uint32{
		39, 42, 0x90038, // [0]
		45, 45, 0x360002, // [1]
		48, 48, 0x470002, // [2]
		51, 51, 0xc0002, // [3]
		42, 44, 0x30009, // [4]
		45, 47, 0x30036, // [5]
		48, 50, 0x30047, // [6]
		55, 56, 0x2c0039, // [7]
		56, 58, 0x3002c, // [8]
		70, 72, 0x2006d, // [9]
		74, 77, 0x2003f, // [10]
		79, 81, 0x90041, // [11]
		84, 84, 0xb0002, // [12]
		81, 83, 0x30009, // [13]
		107, 110, 0x10003a, // [14]
		113, 114, 0x180002, // [15]
		118, 118, 0x350002, // [16]
		110, 112, 0x30010, // [17]
		114, 116, 0x30018, // [18]
		123, 133, 0x2007b, // [19]
		135, 138, 0x29004b, // [20]
		194, 194, 0x1d0002, // [21]
		138, 140, 0x110029, // [22]
		143, 144, 0x160003, // [23]
		147, 150, 0x370003, // [24]
		140, 142, 0x40011, // [25]
		144, 146, 0x40016, // [26]
		150, 151, 0x1f0037, // [27]
		154, 166, 0x180004, // [28]
		169, 170, 0x230004, // [29]
		173, 179, 0x170004, // [30]
		151, 153, 0x5001f, // [31]
		166, 168, 0x50018, // [32]
		170, 172, 0x50023, // [33]
		180, 190, 0x40009, // [34]
		194, 196, 0x3001d, // [35]
		200, 202, 0x2002e, // [36]
		207, 209, 0x10006f, // [37]
		213, 214, 0xf0002, // [38]
		218, 219, 0x1e0002, // [39]
		227, 227, 0x200002, // [40]
		209, 211, 0x30010, // [41]
		214, 216, 0x3000f, // [42]
		220, 221, 0x120024, // [43]
		222, 223, 0x5e001e, // [44]
		224, 224, 0xa000a, // [45]
		231, 236, 0x2003c, // [46]
		238, 240, 0x100050, // [47]
		244, 244, 0x1b0002, // [48]
		248, 249, 0x100002, // [49]
		253, 254, 0x100002, // [50]
		258, 259, 0x100002, // [51]
		263, 266, 0x100002, // [52]
		270, 275, 0x30002, // [53]
		240, 242, 0x30010, // [54]
		244, 246, 0x3001b, // [55]
		249, 251, 0x30010, // [56]
		254, 256, 0x30010, // [57]
		259, 261, 0x30010, // [58]
		266, 268, 0x30010, // [59]
		278, 287, 0x230035, // [60]
		291, 299, 0x160002, // [61]
		287, 289, 0x30023, // [62]
		303, 308, 0x20029, // [63]
		311, 313, 0x20065, // [64]
		316, 318, 0x20068, // [65]
	},
	NumStmt: [66]uint16{
		3, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		2, // 11
		1, // 12
		1, // 13
		3, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		3, // 20
		1, // 21
		2, // 22
		2, // 23
		3, // 24
		1, // 25
		1, // 26
		1, // 27
		6, // 28
		2, // 29
		5, // 30
		1, // 31
		1, // 32
		1, // 33
		4, // 34
		1, // 35
		1, // 36
		2, // 37
		2, // 38
		2, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		0, // 45
		3, // 46
		2, // 47
		1, // 48
		2, // 49
		2, // 50
		2, // 51
		3, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		6, // 60
		6, // 61
		1, // 62
		3, // 63
		1, // 64
		1, // 65
	},
}
var _ = _cover_atomic_.LoadUint32
