//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/channel/channel.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channel; import _cover_atomic_ "sync/atomic"

import (
	"strings"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/peer/common"
	cb "github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var logger = flogging.MustGetLogger("channelCmd")

const (
	EndorserRequired       bool = true
	EndorserNotRequired    bool = false
	OrdererRequired        bool = true
	OrdererNotRequired     bool = false
	PeerDeliverRequired    bool = true
	PeerDeliverNotRequired bool = false
)

var (
	// join related variables.
	genesisBlockPath string

	// create related variables
	channelID     string
	channelTxFile string
	outputBlock   string
	timeout       time.Duration
)

// Cmd returns the cobra command for Node
func Cmd(cf *ChannelCmdFactory) *cobra.Command {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[0], 1);
	AddFlags(channelCmd)

	channelCmd.AddCommand(createCmd(cf))
	channelCmd.AddCommand(fetchCmd(cf))
	channelCmd.AddCommand(joinCmd(cf))
	channelCmd.AddCommand(listCmd(cf))
	channelCmd.AddCommand(updateCmd(cf))
	channelCmd.AddCommand(signconfigtxCmd(cf))
	channelCmd.AddCommand(getinfoCmd(cf))

	return channelCmd
}

// AddFlags adds flags for create and join
func AddFlags(cmd *cobra.Command) {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[1], 1);
	common.AddOrdererFlags(cmd)
}

var flags *pflag.FlagSet

func init() {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[2], 1);
	resetFlags()
}

// Explicitly define a method to facilitate tests
func resetFlags() {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[3], 1);
	flags = &pflag.FlagSet{}

	flags.StringVarP(&genesisBlockPath, "blockpath", "b", common.UndefinedParamValue, "Path to file containing genesis block")
	flags.StringVarP(&channelID, "channelID", "c", common.UndefinedParamValue, "In case of a newChain command, the channel ID to create. It must be all lower case, less than 250 characters long and match the regular expression: [a-z][a-z0-9.-]*")
	flags.StringVarP(&channelTxFile, "file", "f", "", "Configuration transaction file generated by a tool such as configtxgen for submitting to orderer")
	flags.StringVarP(&outputBlock, "outputBlock", "", common.UndefinedParamValue, `The path to write the genesis block for the channel. (default ./<channelID>.block)`)
	flags.DurationVarP(&timeout, "timeout", "t", 5*time.Second, "Channel creation timeout")
}

func attachFlags(cmd *cobra.Command, names []string) {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[4], 1);
	cmdFlags := cmd.Flags()
	for _, name := range names {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[5], 1);
		if flag := flags.Lookup(name); flag != nil {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[6], 1);
			cmdFlags.AddFlag(flag)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[7], 1);{
			logger.Fatalf("Could not find flag '%s' to attach to commond '%s'", name, cmd.Name())
		}}
	}
}

var channelCmd = &cobra.Command{
	Use:   "channel",
	Short: "Operate a channel: create|fetch|join|list|update|signconfigtx|getinfo.",
	Long:  "Operate a channel: create|fetch|join|list|update|signconfigtx|getinfo.",
	PersistentPreRun: func(cmd *cobra.Command, args []string) {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[8], 1);
		common.InitCmd(cmd, args)
		common.SetOrdererEnv(cmd, args)
	},
}

type BroadcastClientFactory func() (common.BroadcastClient, error)

type deliverClientIntf interface {
	GetSpecifiedBlock(num uint64) (*cb.Block, error)
	GetOldestBlock() (*cb.Block, error)
	GetNewestBlock() (*cb.Block, error)
	Close() error
}

// ChannelCmdFactory holds the clients used by ChannelCmdFactory
type ChannelCmdFactory struct {
	EndorserClient   pb.EndorserClient
	Signer           msp.SigningIdentity
	BroadcastClient  common.BroadcastClient
	DeliverClient    deliverClientIntf
	BroadcastFactory BroadcastClientFactory
}

// InitCmdFactory init the ChannelCmdFactory with clients to endorser and orderer according to params
func InitCmdFactory(isEndorserRequired, isPeerDeliverRequired, isOrdererRequired bool) (*ChannelCmdFactory, error) {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[9], 1);
	if isPeerDeliverRequired && isOrdererRequired {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[16], 1);
		// this is likely a bug during development caused by adding a new cmd
		return nil, errors.New("ERROR - only a single deliver source is currently supported")
	}

	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[10], 1);var err error
	cf := &ChannelCmdFactory{}

	cf.Signer, err = common.GetDefaultSignerFnc()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[17], 1);
		return nil, errors.WithMessage(err, "error getting default signer")
	}

	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[11], 1);cf.BroadcastFactory = func() (common.BroadcastClient, error) {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[18], 1);
		return common.GetBroadcastClientFnc()
	}

	// for join and list, we need the endorser as well
	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[12], 1);if isEndorserRequired {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[19], 1);
		// creating an EndorserClient with these empty parameters will create a
		// connection using the values of "peer.address" and
		// "peer.tls.rootcert.file"
		cf.EndorserClient, err = common.GetEndorserClientFnc(common.UndefinedParamValue, common.UndefinedParamValue)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[20], 1);
			return nil, errors.WithMessage(err, "error getting endorser client for channel")
		}
	}

	// for fetching blocks from a peer
	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[13], 1);if isPeerDeliverRequired {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[21], 1);
		cf.DeliverClient, err = common.NewDeliverClientForPeer(channelID)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[22], 1);
			return nil, errors.WithMessage(err, "error getting deliver client for channel")
		}
	}

	// for create and fetch, we need the orderer as well
	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[14], 1);if isOrdererRequired {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[23], 1);
		if len(strings.Split(common.OrderingEndpoint, ":")) != 2 {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[25], 1);
			return nil, errors.Errorf("ordering service endpoint %s is not valid or missing", common.OrderingEndpoint)
		}
		_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[24], 1);cf.DeliverClient, err = common.NewDeliverClientForOrderer(channelID)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[26], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613931643833636437303432.Count[15], 1);logger.Infof("Endorser and orderer connections initialized")
	return cf, nil
}

var GoCover_0_613931643833636437303432 = struct {
	Count     [27]uint32
	Pos       [3 * 27]uint32
	NumStmt   [27]uint16
} {
	Pos: [3 * 27]uint32{
		46, 58, 0x20030, // [0]
		61, 63, 0x20023, // [1]
		67, 69, 0x2000d, // [2]
		72, 80, 0x20013, // [3]
		82, 84, 0x1d0036, // [4]
		84, 85, 0x2e001d, // [5]
		85, 87, 0x4002e, // [6]
		87, 89, 0x40009, // [7]
		97, 100, 0x3003c, // [8]
		122, 123, 0x300074, // [9]
		128, 132, 0x100002, // [10]
		136, 136, 0x3f0002, // [11]
		141, 141, 0x180002, // [12]
		152, 152, 0x1b0002, // [13]
		160, 160, 0x170002, // [14]
		169, 170, 0x100002, // [15]
		123, 126, 0x30030, // [16]
		132, 134, 0x30010, // [17]
		136, 138, 0x3003f, // [18]
		141, 146, 0x110018, // [19]
		146, 148, 0x40011, // [20]
		152, 154, 0x11001b, // [21]
		154, 156, 0x40011, // [22]
		160, 161, 0x3c0017, // [23]
		164, 165, 0x110003, // [24]
		161, 163, 0x4003c, // [25]
		165, 167, 0x40011, // [26]
	},
	NumStmt: [27]uint16{
		9, // 0
		1, // 1
		1, // 2
		6, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		4, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
	},
}
var _ = _cover_atomic_.LoadUint32
