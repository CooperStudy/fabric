//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/common/peerclient.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package common; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"fmt"
	"io/ioutil"

	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/peer/common/api"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

// PeerClient represents a client for communicating with a peer
type PeerClient struct {
	commonClient
}

// NewPeerClientFromEnv creates an instance of a PeerClient from the global
// Viper instance
func NewPeerClientFromEnv() (*PeerClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[0], 1);
	address, override, clientConfig, err := configFromEnv("peer")
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[2], 1);
		return nil, errors.WithMessage(err, "failed to load config for PeerClient")
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[1], 1);return newPeerClientForClientConfig(address, override, clientConfig)
}

// NewPeerClientForAddress creates an instance of a PeerClient using the
// provided peer address and, if TLS is enabled, the TLS root cert file
func NewPeerClientForAddress(address, tlsRootCertFile string) (*PeerClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[3], 1);
	if address == "" {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[6], 1);
		return nil, errors.New("peer address must be set")
	}

	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[4], 1);_, override, clientConfig, err := configFromEnv("peer")
	if clientConfig.SecOpts.UseTLS {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[7], 1);
		if tlsRootCertFile == "" {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[10], 1);
			return nil, errors.New("tls root cert file must be set")
		}
		_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[8], 1);caPEM, res := ioutil.ReadFile(tlsRootCertFile)
		if res != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[11], 1);
			err = errors.WithMessage(res, fmt.Sprintf("unable to load TLS root cert file from %s", tlsRootCertFile))
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[9], 1);clientConfig.SecOpts.ServerRootCAs = [][]byte{caPEM}
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[5], 1);return newPeerClientForClientConfig(address, override, clientConfig)
}

func newPeerClientForClientConfig(address, override string, clientConfig comm.ClientConfig) (*PeerClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[12], 1);
	gClient, err := comm.NewGRPCClient(clientConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[14], 1);
		return nil, errors.WithMessage(err, "failed to create PeerClient from config")
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[13], 1);pClient := &PeerClient{
		commonClient: commonClient{
			GRPCClient: gClient,
			address:    address,
			sn:         override}}
	return pClient, nil
}

// Endorser returns a client for the Endorser service
func (pc *PeerClient) Endorser() (pb.EndorserClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[15], 1);
	conn, err := pc.commonClient.NewConnection(pc.address, pc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[17], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("endorser client failed to connect to %s", pc.address))
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[16], 1);return pb.NewEndorserClient(conn), nil
}

// Deliver returns a client for the Deliver service
func (pc *PeerClient) Deliver() (pb.Deliver_DeliverClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[18], 1);
	conn, err := pc.commonClient.NewConnection(pc.address, pc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[20], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("deliver client failed to connect to %s", pc.address))
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[19], 1);return pb.NewDeliverClient(conn).Deliver(context.TODO())
}

// PeerDeliver returns a client for the Deliver service for peer-specific use
// cases (i.e. DeliverFiltered)
func (pc *PeerClient) PeerDeliver() (api.PeerDeliverClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[21], 1);
	conn, err := pc.commonClient.NewConnection(pc.address, pc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[23], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("deliver client failed to connect to %s", pc.address))
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[22], 1);pbClient := pb.NewDeliverClient(conn)
	return &PeerDeliverClient{Client: pbClient}, nil
}

// Admin returns a client for the Admin service
func (pc *PeerClient) Admin() (pb.AdminClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[24], 1);
	conn, err := pc.commonClient.NewConnection(pc.address, pc.sn)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[26], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("admin client failed to connect to %s", pc.address))
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[25], 1);return pb.NewAdminClient(conn), nil
}

// Certificate returns the TLS client certificate (if available)
func (pc *PeerClient) Certificate() tls.Certificate {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[27], 1);
	return pc.commonClient.Certificate()
}

// GetEndorserClient returns a new endorser client. If the both the address and
// tlsRootCertFile are not provided, the target values for the client are taken
// from the configuration settings for "peer.address" and
// "peer.tls.rootcert.file"
func GetEndorserClient(address, tlsRootCertFile string) (pb.EndorserClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[28], 1);
	var peerClient *PeerClient
	var err error
	if address != "" {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[31], 1);
		peerClient, err = NewPeerClientForAddress(address, tlsRootCertFile)
	} else{ _cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[32], 1);{
		peerClient, err = NewPeerClientFromEnv()
	}}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[29], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[33], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[30], 1);return peerClient.Endorser()
}

// GetCertificate returns the client's TLS certificate
func GetCertificate() (tls.Certificate, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[34], 1);
	peerClient, err := NewPeerClientFromEnv()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[36], 1);
		return tls.Certificate{}, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[35], 1);return peerClient.Certificate(), nil
}

// GetAdminClient returns a new admin client.  The target address for
// the client is taken from the configuration setting "peer.address"
func GetAdminClient() (pb.AdminClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[37], 1);
	peerClient, err := NewPeerClientFromEnv()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[39], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[38], 1);return peerClient.Admin()
}

// GetDeliverClient returns a new deliver client. If both the address and
// tlsRootCertFile are not provided, the target values for the client are taken
// from the configuration settings for "peer.address" and
// "peer.tls.rootcert.file"
func GetDeliverClient(address, tlsRootCertFile string) (pb.Deliver_DeliverClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[40], 1);
	var peerClient *PeerClient
	var err error
	if address != "" {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[43], 1);
		peerClient, err = NewPeerClientForAddress(address, tlsRootCertFile)
	} else{ _cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[44], 1);{
		peerClient, err = NewPeerClientFromEnv()
	}}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[41], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[45], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[42], 1);return peerClient.Deliver()
}

// GetPeerDeliverClient returns a new deliver client. If both the address and
// tlsRootCertFile are not provided, the target values for the client are taken
// from the configuration settings for "peer.address" and
// "peer.tls.rootcert.file"
func GetPeerDeliverClient(address, tlsRootCertFile string) (api.PeerDeliverClient, error) {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[46], 1);
	var peerClient *PeerClient
	var err error
	if address != "" {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[49], 1);
		peerClient, err = NewPeerClientForAddress(address, tlsRootCertFile)
	} else{ _cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[50], 1);{
		peerClient, err = NewPeerClientFromEnv()
	}}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[47], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[51], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_7_393466303334653164333865.Count[48], 1);return peerClient.PeerDeliver()
}

var GoCover_7_393466303334653164333865 = struct {
	Count     [52]uint32
	Pos       [3 * 52]uint32
	NumStmt   [52]uint16
} {
	Pos: [3 * 52]uint32{
		28, 30, 0x100032, // [0]
		33, 33, 0x460002, // [1]
		30, 32, 0x30010, // [2]
		38, 39, 0x130054, // [3]
		43, 44, 0x210002, // [4]
		55, 55, 0x460002, // [5]
		39, 41, 0x30013, // [6]
		44, 45, 0x1c0021, // [7]
		48, 49, 0x110003, // [8]
		53, 53, 0x370003, // [9]
		45, 47, 0x4001c, // [10]
		49, 52, 0x40011, // [11]
		58, 60, 0x100072, // [12]
		63, 68, 0x150002, // [13]
		60, 62, 0x30010, // [14]
		72, 74, 0x10003d, // [15]
		77, 77, 0x280002, // [16]
		74, 76, 0x30010, // [17]
		81, 83, 0x100043, // [18]
		86, 86, 0x3a0002, // [19]
		83, 85, 0x30010, // [20]
		91, 93, 0x100044, // [21]
		96, 97, 0x320002, // [22]
		93, 95, 0x30010, // [23]
		101, 103, 0x100037, // [24]
		106, 106, 0x250002, // [25]
		103, 105, 0x30010, // [26]
		110, 112, 0x20035, // [27]
		118, 121, 0x130054, // [28]
		126, 126, 0x100002, // [29]
		129, 129, 0x1e0002, // [30]
		121, 123, 0x30013, // [31]
		123, 125, 0x30008, // [32]
		126, 128, 0x30010, // [33]
		133, 135, 0x100030, // [34]
		138, 138, 0x260002, // [35]
		135, 137, 0x30010, // [36]
		143, 145, 0x10002f, // [37]
		148, 148, 0x1b0002, // [38]
		145, 147, 0x30010, // [39]
		155, 158, 0x13005a, // [40]
		163, 163, 0x100002, // [41]
		166, 166, 0x1d0002, // [42]
		158, 160, 0x30013, // [43]
		160, 162, 0x30008, // [44]
		163, 165, 0x30010, // [45]
		173, 176, 0x13005b, // [46]
		181, 181, 0x100002, // [47]
		184, 184, 0x210002, // [48]
		176, 178, 0x30013, // [49]
		178, 180, 0x30008, // [50]
		181, 183, 0x30010, // [51]
	},
	NumStmt: [52]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		2, // 12
		2, // 13
		1, // 14
		2, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		2, // 21
		2, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		3, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		2, // 34
		1, // 35
		1, // 36
		2, // 37
		1, // 38
		1, // 39
		3, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		3, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		1, // 51
	},
}
var _ = _cover_atomic_.LoadUint32
