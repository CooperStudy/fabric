//line /home/cooper/go/src/github.com/hyperledger/fabric/core/comm/util.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"context"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"

	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/peer"
)

// AddPemToCertPool adds PEM-encoded certs to a cert pool
func AddPemToCertPool(pemCerts []byte, pool *x509.CertPool) error {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[0], 1);
	certs, _, err := pemToX509Certs(pemCerts)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[3], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[1], 1);for _, cert := range certs {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[4], 1);
		pool.AddCert(cert)
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[2], 1);return nil
}

//utility function to parse PEM-encoded certs
func pemToX509Certs(pemCerts []byte) ([]*x509.Certificate, []string, error) {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[5], 1);

	//it's possible that multiple certs are encoded
	certs := []*x509.Certificate{}
	subjects := []string{}
	for len(pemCerts) > 0 {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[7], 1);
		var block *pem.Block
		block, pemCerts = pem.Decode(pemCerts)
		if block == nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[9], 1);
			break
		}
		/** TODO: check why msp does not add type to PEM header
		if block.Type != "CERTIFICATE" || len(block.Headers) != 0 {
			continue
		}
		*/

		_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[8], 1);cert, err := x509.ParseCertificate(block.Bytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[10], 1);
			return nil, subjects, err
		} else{ _cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[11], 1);{
			certs = append(certs, cert)
			//extract and append the subject
			subjects = append(subjects, string(cert.RawSubject))
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[6], 1);return certs, subjects, nil
}

// BindingInspector receives as parameters a gRPC context and an Envelope,
// and verifies whether the message contains an appropriate binding to the context
type BindingInspector func(context.Context, proto.Message) error

// CertHashExtractor extracts a certificate from a proto.Message message
type CertHashExtractor func(proto.Message) []byte

// NewBindingInspector returns a BindingInspector according to whether
// mutualTLS is configured or not, and according to a function that extracts
// TLS certificate hashes from proto messages
func NewBindingInspector(mutualTLS bool, extractTLSCertHash CertHashExtractor) BindingInspector {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[12], 1);
	if extractTLSCertHash == nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[15], 1);
		panic(errors.New("extractTLSCertHash parameter is nil"))
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[13], 1);inspectMessage := mutualTLSBinding
	if !mutualTLS {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[16], 1);
		inspectMessage = noopBinding
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[14], 1);return func(ctx context.Context, msg proto.Message) error {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[17], 1);
		if msg == nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[19], 1);
			return errors.New("message is nil")
		}
		_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[18], 1);return inspectMessage(ctx, extractTLSCertHash(msg))
	}
}

// mutualTLSBinding enforces the client to send its TLS cert hash in the message,
// and then compares it to the computed hash that is derived
// from the gRPC context.
// In case they don't match, or the cert hash is missing from the request or
// there is no TLS certificate to be excavated from the gRPC context,
// an error is returned.
func mutualTLSBinding(ctx context.Context, claimedTLScertHash []byte) error {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[20], 1);
	if len(claimedTLScertHash) == 0 {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[24], 1);
		return errors.Errorf("client didn't include its TLS cert hash")
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[21], 1);actualTLScertHash := ExtractCertificateHashFromContext(ctx)
	if len(actualTLScertHash) == 0 {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[25], 1);
		return errors.Errorf("client didn't send a TLS certificate")
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[22], 1);if !bytes.Equal(actualTLScertHash, claimedTLScertHash) {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[26], 1);
		return errors.Errorf("claimed TLS cert hash is %v but actual TLS cert hash is %v", claimedTLScertHash, actualTLScertHash)
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[23], 1);return nil
}

// noopBinding is a BindingInspector that always returns nil
func noopBinding(_ context.Context, _ []byte) error {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[27], 1);
	return nil
}

// ExtractCertificateHashFromContext extracts the hash of the certificate from the given context.
// If the certificate isn't present, nil is returned
func ExtractCertificateHashFromContext(ctx context.Context) []byte {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[28], 1);
	rawCert := ExtractCertificateFromContext(ctx)
	if len(rawCert) == 0 {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[30], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[29], 1);h := sha256.New()
	h.Write(rawCert)
	return h.Sum(nil)
}

// ExtractCertificateFromContext returns the TLS certificate (if applicable)
// from the given context of a gRPC stream
func ExtractCertificateFromContext(ctx context.Context) []byte {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[31], 1);
	pr, extracted := peer.FromContext(ctx)
	if !extracted {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[36], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[32], 1);authInfo := pr.AuthInfo
	if authInfo == nil {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[37], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[33], 1);tlsInfo, isTLSConn := authInfo.(credentials.TLSInfo)
	if !isTLSConn {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[38], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[34], 1);certs := tlsInfo.State.PeerCertificates
	if len(certs) == 0 {_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[39], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_8_643230363037383562363632.Count[35], 1);return certs[0].Raw
}

var GoCover_8_643230363037383562363632 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		23, 25, 0x100043, // [0]
		28, 28, 0x1d0002, // [1]
		31, 31, 0xc0002, // [2]
		25, 27, 0x30010, // [3]
		28, 30, 0x3001d, // [4]
		35, 40, 0x18004d, // [5]
		61, 61, 0x1d0002, // [6]
		40, 43, 0x130018, // [7]
		52, 53, 0x110003, // [8]
		43, 44, 0x90013, // [9]
		53, 55, 0x40011, // [10]
		55, 59, 0x40009, // [11]
		74, 75, 0x1f0061, // [12]
		78, 79, 0x100002, // [13]
		82, 82, 0x3c0002, // [14]
		75, 76, 0x3b001f, // [15]
		79, 81, 0x30010, // [16]
		82, 83, 0x11003c, // [17]
		86, 86, 0x360003, // [18]
		83, 85, 0x40011, // [19]
		96, 97, 0x22004d, // [20]
		100, 101, 0x210002, // [21]
		104, 104, 0x390002, // [22]
		107, 107, 0xc0002, // [23]
		97, 99, 0x30022, // [24]
		101, 103, 0x30021, // [25]
		104, 106, 0x30039, // [26]
		111, 113, 0x20035, // [27]
		117, 119, 0x170044, // [28]
		122, 124, 0x130002, // [29]
		119, 121, 0x30017, // [30]
		129, 131, 0x100040, // [31]
		135, 136, 0x150002, // [32]
		140, 141, 0x100002, // [33]
		144, 145, 0x150002, // [34]
		148, 148, 0x150002, // [35]
		131, 133, 0x30010, // [36]
		136, 138, 0x30015, // [37]
		141, 143, 0x30010, // [38]
		145, 147, 0x30015, // [39]
	},
	NumStmt: [40]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		3, // 5
		1, // 6
		3, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		2, // 28
		3, // 29
		1, // 30
		2, // 31
		2, // 32
		2, // 33
		2, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
