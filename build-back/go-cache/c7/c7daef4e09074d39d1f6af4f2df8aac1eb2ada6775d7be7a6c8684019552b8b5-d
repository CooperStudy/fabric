//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/blockfile_rw.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fsblkstorage; import _cover_atomic_ "sync/atomic"

import (
	"os"

	"github.com/pkg/errors"
)

////  WRITER ////
type blockfileWriter struct {
	filePath string
	file     *os.File
}

func newBlockfileWriter(filePath string) (*blockfileWriter, error) {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[0], 1);
	writer := &blockfileWriter{filePath: filePath}
	return writer, writer.open()
}

func (w *blockfileWriter) truncateFile(targetSize int) error {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[1], 1);
	fileStat, err := w.file.Stat()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[4], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[2], 1);if fileStat.Size() > int64(targetSize) {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[5], 1);
		w.file.Truncate(int64(targetSize))
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[3], 1);return nil
}

func (w *blockfileWriter) append(b []byte, sync bool) error {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[6], 1);
	_, err := w.file.Write(b)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[9], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[7], 1);if sync {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[10], 1);
		return w.file.Sync()
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[8], 1);return nil
}

func (w *blockfileWriter) open() error {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[11], 1);
	file, err := os.OpenFile(w.filePath, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0660)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[13], 1);
		return errors.Wrapf(err, "error opening block file writer for file %s", w.filePath)
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[12], 1);w.file = file
	return nil
}

func (w *blockfileWriter) close() error {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[14], 1);
	return errors.WithStack(w.file.Close())
}

////  READER ////
type blockfileReader struct {
	file *os.File
}

func newBlockfileReader(filePath string) (*blockfileReader, error) {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[15], 1);
	file, err := os.OpenFile(filePath, os.O_RDONLY, 0600)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[17], 1);
		return nil, errors.Wrapf(err, "error opening block file reader for file %s", filePath)
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[16], 1);reader := &blockfileReader{file}
	return reader, nil
}

func (r *blockfileReader) read(offset int, length int) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[18], 1);
	b := make([]byte, length)
	_, err := r.file.ReadAt(b, int64(offset))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[20], 1);
		return nil, errors.Wrapf(err, "error reading block file for offset %d and length %d", offset, length)
	}
	_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[19], 1);return b, nil
}

func (r *blockfileReader) close() error {_cover_atomic_.AddUint32(&GoCover_4_386431356532613230373239.Count[21], 1);
	return errors.WithStack(r.file.Close())
}

var GoCover_4_386431356532613230373239 = struct {
	Count     [22]uint32
	Pos       [3 * 22]uint32
	NumStmt   [22]uint16
} {
	Pos: [3 * 22]uint32{
		21, 24, 0x20044, // [0]
		26, 28, 0x10003e, // [1]
		31, 31, 0x290002, // [2]
		34, 34, 0xc0002, // [3]
		28, 30, 0x30010, // [4]
		31, 33, 0x30029, // [5]
		37, 39, 0x10003d, // [6]
		42, 42, 0xa0002, // [7]
		45, 45, 0xc0002, // [8]
		39, 41, 0x30010, // [9]
		42, 44, 0x3000a, // [10]
		48, 50, 0x100028, // [11]
		53, 54, 0xc0002, // [12]
		50, 52, 0x30010, // [13]
		57, 59, 0x20029, // [14]
		66, 68, 0x100044, // [15]
		71, 72, 0x140002, // [16]
		68, 70, 0x30010, // [17]
		75, 78, 0x100048, // [18]
		81, 81, 0xf0002, // [19]
		78, 80, 0x30010, // [20]
		84, 86, 0x20029, // [21]
	},
	NumStmt: [22]uint16{
		2, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		2, // 15
		2, // 16
		1, // 17
		3, // 18
		1, // 19
		1, // 20
		1, // 21
	},
}
var _ = _cover_atomic_.LoadUint32
