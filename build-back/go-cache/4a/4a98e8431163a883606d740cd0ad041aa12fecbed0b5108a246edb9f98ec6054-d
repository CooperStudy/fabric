//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/bundlesource.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"sync/atomic"

	"github.com/hyperledger/fabric/common/configtx"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/msp"
)

// BundleSource stores a reference to the current configuration bundle
// It also provides a method to update this bundle.  The assorted methods
// largely pass through to the underlying bundle, but do so through an atomic pointer
// so that gross go-routine reads are not vulnerable to out-of-order execution memory
// type bugs.
type BundleSource struct {
	bundle    atomic.Value
	callbacks []func(*Bundle)
}

// NewBundleSource creates a new BundleSource with an initial Bundle value
// The callbacks will be invoked whenever the Update method is called for the
// BundleSource.  Note, these callbacks are called immediately before this function
// returns.
func NewBundleSource(bundle *Bundle, callbacks ...func(*Bundle)) *BundleSource {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[0], 1);
	bs := &BundleSource{
		callbacks: callbacks,
	}
	bs.Update(bundle)
	return bs
}

// Update sets a new bundle as the bundle source and calls any registered callbacks
func (bs *BundleSource) Update(newBundle *Bundle) {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[1], 1);
	bs.bundle.Store(newBundle)
	for _, callback := range bs.callbacks {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[2], 1);
		callback(newBundle)
	}
}

// StableBundle returns a pointer to a stable Bundle.
// It is stable because calls to its assorted methods will always return the same
// result, as the underlying data structures are immutable.  For instance, calling
// BundleSource.Orderer() and BundleSource.MSPManager() to get first the list of orderer
// orgs, then querying the MSP for those org definitions could result in a bug because an
// update might replace the underlying Bundle in between.  Therefore, for operations
// which require consistency between the Bundle calls, the caller should first retrieve
// a StableBundle, then operate on it.
func (bs *BundleSource) StableBundle() *Bundle {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[3], 1);
	return bs.bundle.Load().(*Bundle)
}

// PolicyManager returns the policy manager constructed for this config
func (bs *BundleSource) PolicyManager() policies.Manager {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[4], 1);
	return bs.StableBundle().policyManager
}

// MSPManager returns the MSP manager constructed for this config
func (bs *BundleSource) MSPManager() msp.MSPManager {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[5], 1);
	return bs.StableBundle().mspManager
}

// ChannelConfig returns the config.Channel for the chain
func (bs *BundleSource) ChannelConfig() Channel {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[6], 1);
	return bs.StableBundle().ChannelConfig()
}

// OrdererConfig returns the config.Orderer for the channel
// and whether the Orderer config exists
func (bs *BundleSource) OrdererConfig() (Orderer, bool) {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[7], 1);
	return bs.StableBundle().OrdererConfig()
}

// ConsortiumsConfig() returns the config.Consortiums for the channel
// and whether the consortiums config exists
func (bs *BundleSource) ConsortiumsConfig() (Consortiums, bool) {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[8], 1);
	return bs.StableBundle().ConsortiumsConfig()
}

// ApplicationConfig returns the Application config for the channel
// and whether the Application config exists
func (bs *BundleSource) ApplicationConfig() (Application, bool) {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[9], 1);
	return bs.StableBundle().ApplicationConfig()
}

// ConfigtxValidator returns the configtx.Validator for the channel
func (bs *BundleSource) ConfigtxValidator() configtx.Validator {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[10], 1);
	return bs.StableBundle().ConfigtxValidator()
}

// ValidateNew passes through to the current bundle
func (bs *BundleSource) ValidateNew(resources Resources) error {_cover_atomic_.AddUint32(&GoCover_5_373339383034363064316135.Count[11], 1);
	return bs.StableBundle().ValidateNew(resources)
}

var GoCover_5_373339383034363064316135 = struct {
	Count     [12]uint32
	Pos       [3 * 12]uint32
	NumStmt   [12]uint16
} {
	Pos: [3 * 12]uint32{
		31, 37, 0x20050, // [0]
		40, 42, 0x280033, // [1]
		42, 44, 0x30028, // [2]
		55, 57, 0x20030, // [3]
		60, 62, 0x2003a, // [4]
		65, 67, 0x20035, // [5]
		70, 72, 0x20031, // [6]
		76, 78, 0x20039, // [7]
		82, 84, 0x20041, // [8]
		88, 90, 0x20041, // [9]
		93, 95, 0x20040, // [10]
		98, 100, 0x20040, // [11]
	},
	NumStmt: [12]uint16{
		3, // 0
		2, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
	},
}
var _ = _cover_atomic_.LoadUint32
