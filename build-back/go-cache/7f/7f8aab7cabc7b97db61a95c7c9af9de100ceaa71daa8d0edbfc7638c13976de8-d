//line /home/cooper/go/src/github.com/hyperledger/fabric/common/channelconfig/logsanitychecks.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package channelconfig; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/policies"
)

func LogSanityChecks(res Resources) {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[0], 1);
	pm := res.PolicyManager()
	for _, policyName := range []string{policies.ChannelReaders, policies.ChannelWriters} {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[3], 1);
		_, ok := pm.GetPolicy(policyName)
		if !ok {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[4], 1);
			logger.Warningf("Current configuration has no policy '%s', this will likely cause problems in production systems", policyName)
		} else{ _cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[5], 1);{
			logger.Debugf("As expected, current configuration has policy '%s'", policyName)
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[1], 1);if _, ok := pm.Manager([]string{policies.ApplicationPrefix}); ok {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[6], 1);
		// Check for default application policies if the application component is defined
		for _, policyName := range []string{
			policies.ChannelApplicationReaders,
			policies.ChannelApplicationWriters,
			policies.ChannelApplicationAdmins} {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[7], 1);
			_, ok := pm.GetPolicy(policyName)
			if !ok {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[8], 1);
				logger.Warningf("Current configuration has no policy '%s', this will likely cause problems in production systems", policyName)
			} else{ _cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[9], 1);{
				logger.Debugf("As expected, current configuration has policy '%s'", policyName)
			}}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[2], 1);if _, ok := pm.Manager([]string{policies.OrdererPrefix}); ok {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[10], 1);
		for _, policyName := range []string{policies.BlockValidation} {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[11], 1);
			_, ok := pm.GetPolicy(policyName)
			if !ok {_cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[12], 1);
				logger.Warningf("Current configuration has no policy '%s', this will likely cause problems in production systems", policyName)
			} else{ _cover_atomic_.AddUint32(&GoCover_9_373339383034363064316135.Count[13], 1);{
				logger.Debugf("As expected, current configuration has policy '%s'", policyName)
			}}
		}
	}
}

var GoCover_9_373339383034363064316135 = struct {
	Count     [14]uint32
	Pos       [3 * 14]uint32
	NumStmt   [14]uint16
} {
	Pos: [3 * 14]uint32{
		13, 15, 0x580025, // [0]
		23, 23, 0x430002, // [1]
		37, 37, 0x3f0002, // [2]
		15, 17, 0xa0058, // [3]
		17, 19, 0x4000a, // [4]
		19, 21, 0x40009, // [5]
		23, 28, 0x270043, // [6]
		28, 30, 0xb0027, // [7]
		30, 32, 0x5000b, // [8]
		32, 34, 0x5000a, // [9]
		37, 38, 0x41003f, // [10]
		38, 40, 0xb0041, // [11]
		40, 42, 0x5000b, // [12]
		42, 44, 0x5000a, // [13]
	},
	NumStmt: [14]uint16{
		2, // 0
		1, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
	},
}
var _ = _cover_atomic_.LoadUint32
