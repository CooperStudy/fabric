//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/utils/commonutils.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package utils; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/ptypes/timestamp"
	"github.com/hyperledger/fabric/common/crypto"
	cb "github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

// MarshalOrPanic serializes a protobuf message and panics if this
// operation fails
func MarshalOrPanic(pb proto.Message) []byte {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[0], 1);
	data, err := proto.Marshal(pb)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[2], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[1], 1);return data
}

// Marshal serializes a protobuf message.
func Marshal(pb proto.Message) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[3], 1);
	return proto.Marshal(pb)
}

// CreateNonceOrPanic generates a nonce using the common/crypto package
// and panics if this operation fails.
func CreateNonceOrPanic() []byte {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[4], 1);
	nonce, err := CreateNonce()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[6], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[5], 1);return nonce
}

// CreateNonce generates a nonce using the common/crypto package.
func CreateNonce() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[7], 1);
	nonce, err := crypto.GetRandomNonce()
	return nonce, errors.WithMessage(err, "error generating random nonce")
}

// UnmarshalPayloadOrPanic unmarshals bytes to a Payload structure or panics
// on error
func UnmarshalPayloadOrPanic(encoded []byte) *cb.Payload {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[8], 1);
	payload, err := UnmarshalPayload(encoded)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[10], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[9], 1);return payload
}

// UnmarshalPayload unmarshals bytes to a Payload structure
func UnmarshalPayload(encoded []byte) (*cb.Payload, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[11], 1);
	payload := &cb.Payload{}
	err := proto.Unmarshal(encoded, payload)
	return payload, errors.Wrap(err, "error unmarshaling Payload")
}

// UnmarshalEnvelopeOrPanic unmarshals bytes to an Envelope structure or panics
// on error
func UnmarshalEnvelopeOrPanic(encoded []byte) *cb.Envelope {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[12], 1);
	envelope, err := UnmarshalEnvelope(encoded)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[14], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[13], 1);return envelope
}

// UnmarshalEnvelope unmarshals bytes to an Envelope structure
func UnmarshalEnvelope(encoded []byte) (*cb.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[15], 1);
	envelope := &cb.Envelope{}
	err := proto.Unmarshal(encoded, envelope)
	return envelope, errors.Wrap(err, "error unmarshaling Envelope")
}

// UnmarshalBlockOrPanic unmarshals bytes to an Block structure or panics
// on error
func UnmarshalBlockOrPanic(encoded []byte) *cb.Block {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[16], 1);
	block, err := UnmarshalBlock(encoded)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[18], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[17], 1);return block
}

// UnmarshalBlock unmarshals bytes to an Block structure
func UnmarshalBlock(encoded []byte) (*cb.Block, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[19], 1);
	block := &cb.Block{}
	err := proto.Unmarshal(encoded, block)
	return block, errors.Wrap(err, "error unmarshaling Block")
}

// UnmarshalEnvelopeOfType unmarshals an envelope of the specified type,
// including unmarshaling the payload data
func UnmarshalEnvelopeOfType(envelope *cb.Envelope, headerType cb.HeaderType, message proto.Message) (*cb.ChannelHeader, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[20], 1);
	payload, err := UnmarshalPayload(envelope.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[25], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[21], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[26], 1);
		return nil, errors.New("envelope must have a Header")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[22], 1);chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[27], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[23], 1);if chdr.Type != int32(headerType) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[28], 1);
		return nil, errors.Errorf("invalid type %s, expected %s", cb.HeaderType(chdr.Type), headerType)
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[24], 1);err = proto.Unmarshal(payload.Data, message)
	err = errors.Wrapf(err, "error unmarshaling message for type %s", headerType)
	return chdr, err
}

// ExtractEnvelopeOrPanic retrieves the requested envelope from a given block
// and unmarshals it -- it panics if either of these operations fail
func ExtractEnvelopeOrPanic(block *cb.Block, index int) *cb.Envelope {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[29], 1);
	envelope, err := ExtractEnvelope(block, index)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[31], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[30], 1);return envelope
}

// ExtractEnvelope retrieves the requested envelope from a given block and
// unmarshals it
func ExtractEnvelope(block *cb.Block, index int) (*cb.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[32], 1);
	if block.Data == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[35], 1);
		return nil, errors.New("block data is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[33], 1);envelopeCount := len(block.Data.Data)
	if index < 0 || index >= envelopeCount {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[36], 1);
		return nil, errors.New("envelope index out of bounds")
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[34], 1);marshaledEnvelope := block.Data.Data[index]
	envelope, err := GetEnvelopeFromBlock(marshaledEnvelope)
	err = errors.WithMessage(err, fmt.Sprintf("block data does not carry an envelope at index %d", index))
	return envelope, err
}

// ExtractPayloadOrPanic retrieves the payload of a given envelope and
// unmarshals it -- it panics if either of these operations fail
func ExtractPayloadOrPanic(envelope *cb.Envelope) *cb.Payload {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[37], 1);
	payload, err := ExtractPayload(envelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[39], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[38], 1);return payload
}

// ExtractPayload retrieves the payload of a given envelope and unmarshals it.
func ExtractPayload(envelope *cb.Envelope) (*cb.Payload, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[40], 1);
	payload := &cb.Payload{}
	err := proto.Unmarshal(envelope.Payload, payload)
	err = errors.Wrap(err, "no payload in envelope")
	return payload, err
}

// MakeChannelHeader creates a ChannelHeader.
func MakeChannelHeader(headerType cb.HeaderType, version int32, chainID string, epoch uint64) *cb.ChannelHeader {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[41], 1);
	return &cb.ChannelHeader{
		Type:    int32(headerType),
		Version: version,
		Timestamp: &timestamp.Timestamp{
			Seconds: time.Now().Unix(),
			Nanos:   0,
		},
		ChannelId: chainID,
		Epoch:     epoch,
	}
}

// MakeSignatureHeader creates a SignatureHeader.
func MakeSignatureHeader(serializedCreatorCertChain []byte, nonce []byte) *cb.SignatureHeader {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[42], 1);
	return &cb.SignatureHeader{
		Creator: serializedCreatorCertChain,
		Nonce:   nonce,
	}
}

// SetTxID generates a transaction id based on the provided signature header
// and sets the TxId field in the channel header
func SetTxID(channelHeader *cb.ChannelHeader, signatureHeader *cb.SignatureHeader) error {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[43], 1);
	txid, err := ComputeTxID(
		signatureHeader.Nonce,
		signatureHeader.Creator,
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[45], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[44], 1);channelHeader.TxId = txid
	return nil
}

// MakePayloadHeader creates a Payload Header.
func MakePayloadHeader(ch *cb.ChannelHeader, sh *cb.SignatureHeader) *cb.Header {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[46], 1);
	return &cb.Header{
		ChannelHeader:   MarshalOrPanic(ch),
		SignatureHeader: MarshalOrPanic(sh),
	}
}

// NewSignatureHeaderOrPanic returns a signature header and panics on error.
func NewSignatureHeaderOrPanic(signer crypto.LocalSigner) *cb.SignatureHeader {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[47], 1);
	if signer == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[50], 1);
		panic(errors.New("invalid signer. cannot be nil"))
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[48], 1);signatureHeader, err := signer.NewSignatureHeader()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[51], 1);
		panic(fmt.Errorf("failed generating a new SignatureHeader: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[49], 1);return signatureHeader
}

// SignOrPanic signs a message and panics on error.
func SignOrPanic(signer crypto.LocalSigner, msg []byte) []byte {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[52], 1);
	if signer == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[55], 1);
		panic(errors.New("invalid signer. cannot be nil"))
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[53], 1);sigma, err := signer.Sign(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[56], 1);
		panic(fmt.Errorf("failed generating signature: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[54], 1);return sigma
}

// UnmarshalChannelHeader returns a ChannelHeader from bytes
func UnmarshalChannelHeader(bytes []byte) (*cb.ChannelHeader, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[57], 1);
	chdr := &cb.ChannelHeader{}
	err := proto.Unmarshal(bytes, chdr)
	return chdr, errors.Wrap(err, "error unmarshaling ChannelHeader")
}

// UnmarshalChannelHeaderOrPanic unmarshals bytes to a ChannelHeader or panics
// on error
func UnmarshalChannelHeaderOrPanic(bytes []byte) *cb.ChannelHeader {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[58], 1);
	chdr, err := UnmarshalChannelHeader(bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[60], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[59], 1);return chdr
}

// UnmarshalChaincodeID returns a ChaincodeID from bytes
func UnmarshalChaincodeID(bytes []byte) (*pb.ChaincodeID, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[61], 1);
	ccid := &pb.ChaincodeID{}
	err := proto.Unmarshal(bytes, ccid)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[63], 1);
		return nil, errors.Wrap(err, "error unmarshaling ChaincodeID")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[62], 1);return ccid, nil
}

// IsConfigBlock validates whenever given block contains configuration
// update transaction
func IsConfigBlock(block *cb.Block) bool {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[64], 1);
	envelope, err := ExtractEnvelope(block, 0)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[69], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[65], 1);payload, err := GetPayload(envelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[70], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[66], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[71], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[67], 1);hdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[72], 1);
		return false
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[68], 1);return cb.HeaderType(hdr.Type) == cb.HeaderType_CONFIG || cb.HeaderType(hdr.Type) == cb.HeaderType_ORDERER_TRANSACTION
}

// ChannelHeader returns the *cb.ChannelHeader for a given *cb.Envelope.
func ChannelHeader(env *cb.Envelope) (*cb.ChannelHeader, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[73], 1);
	envPayload, err := UnmarshalPayload(env.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[78], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[74], 1);if envPayload.Header == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[79], 1);
		return nil, errors.New("header not set")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[75], 1);if envPayload.Header.ChannelHeader == nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[80], 1);
		return nil, errors.New("channel header not set")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[76], 1);chdr, err := UnmarshalChannelHeader(envPayload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[81], 1);
		return nil, errors.WithMessage(err, "error unmarshaling channel header")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[77], 1);return chdr, nil
}

// ChannelID returns the Channel ID for a given *cb.Envelope.
func ChannelID(env *cb.Envelope) (string, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[82], 1);
	chdr, err := ChannelHeader(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[84], 1);
		return "", errors.WithMessage(err, "error retrieving channel header")
	}

	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[83], 1);return chdr.ChannelId, nil
}

// EnvelopeToConfigUpdate is used to extract a ConfigUpdateEnvelope from an envelope of
// type CONFIG_UPDATE
func EnvelopeToConfigUpdate(configtx *cb.Envelope) (*cb.ConfigUpdateEnvelope, error) {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[85], 1);
	configUpdateEnv := &cb.ConfigUpdateEnvelope{}
	_, err := UnmarshalEnvelopeOfType(configtx, cb.HeaderType_CONFIG_UPDATE, configUpdateEnv)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[87], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_333834643165316261363934.Count[86], 1);return configUpdateEnv, nil
}

var GoCover_2_333834643165316261363934 = struct {
	Count     [88]uint32
	Pos       [3 * 88]uint32
	NumStmt   [88]uint16
} {
	Pos: [3 * 88]uint32{
		23, 25, 0x10002e, // [0]
		28, 28, 0xd0002, // [1]
		25, 26, 0xd0010, // [2]
		32, 34, 0x20030, // [3]
		38, 40, 0x100022, // [4]
		43, 43, 0xe0002, // [5]
		40, 41, 0xd0010, // [6]
		47, 50, 0x20024, // [7]
		54, 56, 0x10003a, // [8]
		59, 59, 0x100002, // [9]
		56, 57, 0xd0010, // [10]
		63, 67, 0x2003c, // [11]
		71, 73, 0x10003c, // [12]
		76, 76, 0x110002, // [13]
		73, 74, 0xd0010, // [14]
		80, 84, 0x2003e, // [15]
		88, 90, 0x100036, // [16]
		93, 93, 0xe0002, // [17]
		90, 91, 0xd0010, // [18]
		97, 101, 0x20038, // [19]
		105, 107, 0x100081, // [20]
		111, 111, 0x1b0002, // [21]
		115, 116, 0x100002, // [22]
		120, 120, 0x240002, // [23]
		124, 126, 0x120002, // [24]
		107, 109, 0x30010, // [25]
		111, 113, 0x3001b, // [26]
		116, 118, 0x30010, // [27]
		120, 122, 0x30024, // [28]
		131, 133, 0x100046, // [29]
		136, 136, 0x110002, // [30]
		133, 134, 0xd0010, // [31]
		141, 142, 0x170048, // [32]
		146, 147, 0x290002, // [33]
		150, 153, 0x160002, // [34]
		142, 144, 0x30017, // [35]
		147, 149, 0x30029, // [36]
		158, 160, 0x10003f, // [37]
		163, 163, 0x100002, // [38]
		160, 161, 0xd0010, // [39]
		167, 172, 0x20041, // [40]
		175, 186, 0x20071, // [41]
		189, 194, 0x2005f, // [42]
		198, 203, 0x10005a, // [43]
		206, 207, 0xc0002, // [44]
		203, 205, 0x30010, // [45]
		211, 216, 0x20051, // [46]
		219, 220, 0x13004f, // [47]
		224, 225, 0x100002, // [48]
		228, 228, 0x180002, // [49]
		220, 221, 0x350013, // [50]
		225, 226, 0x480010, // [51]
		232, 233, 0x130040, // [52]
		237, 238, 0x100002, // [53]
		241, 241, 0xe0002, // [54]
		233, 234, 0x350013, // [55]
		238, 239, 0x3c0010, // [56]
		245, 249, 0x20046, // [57]
		253, 255, 0x100044, // [58]
		258, 258, 0xd0002, // [59]
		255, 256, 0xd0010, // [60]
		262, 265, 0x100042, // [61]
		269, 269, 0x120002, // [62]
		265, 267, 0x30010, // [63]
		274, 276, 0x10002a, // [64]
		280, 281, 0x100002, // [65]
		285, 285, 0x1b0002, // [66]
		289, 290, 0x100002, // [67]
		294, 294, 0x780002, // [68]
		276, 278, 0x30010, // [69]
		281, 283, 0x30010, // [70]
		285, 287, 0x3001b, // [71]
		290, 292, 0x30010, // [72]
		298, 300, 0x100041, // [73]
		304, 304, 0x1e0002, // [74]
		308, 308, 0x2c0002, // [75]
		312, 313, 0x100002, // [76]
		317, 317, 0x120002, // [77]
		300, 302, 0x30010, // [78]
		304, 306, 0x3001e, // [79]
		308, 310, 0x3002c, // [80]
		313, 315, 0x30010, // [81]
		321, 323, 0x100032, // [82]
		327, 327, 0x1c0002, // [83]
		323, 325, 0x30010, // [84]
		332, 335, 0x100056, // [85]
		338, 338, 0x1d0002, // [86]
		335, 337, 0x30010, // [87]
	},
	NumStmt: [88]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		3, // 11
		2, // 12
		1, // 13
		1, // 14
		3, // 15
		2, // 16
		1, // 17
		1, // 18
		3, // 19
		2, // 20
		1, // 21
		2, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		2, // 33
		4, // 34
		1, // 35
		1, // 36
		2, // 37
		1, // 38
		1, // 39
		4, // 40
		1, // 41
		1, // 42
		2, // 43
		2, // 44
		1, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		2, // 53
		1, // 54
		1, // 55
		1, // 56
		3, // 57
		2, // 58
		1, // 59
		1, // 60
		3, // 61
		1, // 62
		1, // 63
		2, // 64
		2, // 65
		1, // 66
		2, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		2, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		2, // 82
		1, // 83
		1, // 84
		3, // 85
		1, // 86
		1, // 87
	},
}
var _ = _cover_atomic_.LoadUint32
