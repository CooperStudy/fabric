//line /home/cooper/go/src/github.com/hyperledger/fabric/token/server/prover.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package server; import _cover_atomic_ "sync/atomic"

import (
	"context"

	"github.com/hyperledger/fabric/protos/token"
	"github.com/pkg/errors"
)

//go:generate counterfeiter -o mock/access_control.go -fake-name PolicyChecker . PolicyChecker

// A PolicyChecker is responsible for performing policy based access control
// checks related to token commands.
type PolicyChecker interface {
	Check(sc *token.SignedCommand, c *token.Command) error
}

//go:generate counterfeiter -o mock/marshaler.go -fake-name Marshaler . Marshaler

// A Marshaler is responsible for marshaling and signging command responses.
type Marshaler interface {
	MarshalCommandResponse(command []byte, responsePayload interface{}) (*token.SignedCommandResponse, error)
}

// A Provider is responslble for processing token commands.
type Prover struct {
	CapabilityChecker CapabilityChecker
	Marshaler         Marshaler
	PolicyChecker     PolicyChecker
	TMSManager        TMSManager
}

// NewProver creates a Prover
func NewProver(policyChecker PolicyChecker, signingIdentity SignerIdentity) (*Prover, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[0], 1);
	responseMarshaler, err := NewResponseMarshaler(signingIdentity)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[2], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[1], 1);return &Prover{
		Marshaler:     responseMarshaler,
		PolicyChecker: policyChecker,
		TMSManager: &Manager{
			LedgerManager: &PeerLedgerManager{},
		},
	}, nil
}

func (s *Prover) ProcessCommand(ctx context.Context, sc *token.SignedCommand) (*token.SignedCommandResponse, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[3], 1);
	command, err := UnmarshalCommand(sc.Command)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[11], 1);
		return s.MarshalErrorResponse(sc.Command, err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[4], 1);err = s.ValidateHeader(command.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[12], 1);
		return s.MarshalErrorResponse(sc.Command, err)
	}

	// check if FabToken capability is enabled
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[5], 1);channelId := command.Header.ChannelId
	enabled, err := s.CapabilityChecker.FabToken(channelId)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[13], 1);
		return s.MarshalErrorResponse(sc.Command, err)
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[6], 1);if !enabled {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[14], 1);
		return s.MarshalErrorResponse(sc.Command, errors.Errorf("FabToken capability not enabled for channel %s", channelId))
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[7], 1);err = s.PolicyChecker.Check(sc, command)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[15], 1);
		return s.MarshalErrorResponse(sc.Command, err)
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[8], 1);var payload interface{}
	switch t := command.GetPayload().(type) {
	case *token.Command_ImportRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[16], 1);
		payload, err = s.RequestImport(ctx, command.Header, t.ImportRequest)
	case *token.Command_TransferRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[17], 1);
		payload, err = s.RequestTransfer(ctx, command.Header, t.TransferRequest)
	case *token.Command_RedeemRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[18], 1);
		payload, err = s.RequestRedeem(ctx, command.Header, t.RedeemRequest)
	case *token.Command_ListRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[19], 1);
		payload, err = s.ListUnspentTokens(ctx, command.Header, t.ListRequest)
	case *token.Command_ApproveRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[20], 1);
		payload, err = s.RequestApprove(ctx, command.Header, t.ApproveRequest)
	case *token.Command_TransferFromRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[21], 1);
		payload, err = s.RequestTransferFrom(ctx, command.Header, t.TransferFromRequest)
	case *token.Command_ExpectationRequest:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[22], 1);
		payload, err = s.RequestExpectation(ctx, command.Header, t.ExpectationRequest)
	default:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[23], 1);
		err = errors.Errorf("command type not recognized: %T", t)
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[9], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[24], 1);
		payload = &token.CommandResponse_Err{
			Err: &token.Error{Message: err.Error()},
		}
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[10], 1);return s.Marshaler.MarshalCommandResponse(sc.Command, payload)
}

func (s *Prover) RequestImport(ctx context.Context, header *token.Header, requestImport *token.ImportRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[25], 1);
	issuer, err := s.TMSManager.GetIssuer(header.ChannelId, requestImport.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[28], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[26], 1);tokenTransaction, err := issuer.RequestImport(requestImport.TokensToIssue)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[29], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[27], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

func (s *Prover) RequestTransfer(ctx context.Context, header *token.Header, request *token.TransferRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[30], 1);
	transactor, err := s.TMSManager.GetTransactor(header.ChannelId, request.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[33], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[31], 1);defer transactor.Done()

	tokenTransaction, err := transactor.RequestTransfer(request)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[34], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[32], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

func (s *Prover) RequestRedeem(ctx context.Context, header *token.Header, request *token.RedeemRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[35], 1);
	transactor, err := s.TMSManager.GetTransactor(header.ChannelId, request.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[38], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[36], 1);defer transactor.Done()

	tokenTransaction, err := transactor.RequestRedeem(request)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[39], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[37], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

func (s *Prover) ListUnspentTokens(ctxt context.Context, header *token.Header, listRequest *token.ListRequest) (*token.CommandResponse_UnspentTokens, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[40], 1);
	transactor, err := s.TMSManager.GetTransactor(header.ChannelId, listRequest.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[43], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[41], 1);defer transactor.Done()

	tokens, err := transactor.ListTokens()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[44], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[42], 1);return &token.CommandResponse_UnspentTokens{UnspentTokens: tokens}, nil
}

func (s *Prover) RequestApprove(ctx context.Context, header *token.Header, request *token.ApproveRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[45], 1);
	transactor, err := s.TMSManager.GetTransactor(header.ChannelId, request.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[48], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[46], 1);defer transactor.Done()

	tokenTransaction, err := transactor.RequestApprove(request)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[49], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[47], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

func (s *Prover) RequestTransferFrom(ctx context.Context, header *token.Header, request *token.TransferRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[50], 1);
	transactor, err := s.TMSManager.GetTransactor(header.ChannelId, request.Credential, header.Creator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[53], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[51], 1);defer transactor.Done()

	tokenTransaction, err := transactor.RequestTransferFrom(request)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[54], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[52], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

// RequestExpectation gets an issuer or transactor and creates a token transaction response
// for import, transfer or redemption.
func (s *Prover) RequestExpectation(ctx context.Context, header *token.Header, request *token.ExpectationRequest) (*token.CommandResponse_TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[55], 1);
	if request.GetExpectation() == nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[59], 1);
		return nil, errors.New("ExpectationRequest has nil Expectation")
	}
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[56], 1);plainExpectation := request.GetExpectation().GetPlainExpectation()
	if plainExpectation == nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[60], 1);
		return nil, errors.New("ExpectationRequest has nil PlainExpectation")
	}

	// get either issuer or transactor based on payload type in the request
	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[57], 1);var tokenTransaction *token.TokenTransaction
	switch t := plainExpectation.GetPayload().(type) {
	case *token.PlainExpectation_ImportExpectation:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[61], 1);
		issuer, err := s.TMSManager.GetIssuer(header.ChannelId, request.Credential, header.Creator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[66], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[62], 1);tokenTransaction, err = issuer.RequestExpectation(request)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[67], 1);
			return nil, err
		}
	case *token.PlainExpectation_TransferExpectation:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[63], 1);
		transactor, err := s.TMSManager.GetTransactor(header.ChannelId, request.Credential, header.Creator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[68], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[64], 1);defer transactor.Done()

		tokenTransaction, err = transactor.RequestExpectation(request)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[69], 1);
			return nil, err
		}
	default:_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[65], 1);
		return nil, errors.Errorf("expectation payload type not recognized: %T", t)
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[58], 1);return &token.CommandResponse_TokenTransaction{TokenTransaction: tokenTransaction}, nil
}

func (s *Prover) ValidateHeader(header *token.Header) error {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[70], 1);
	if header == nil {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[75], 1);
		return errors.New("command header is required")
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[71], 1);if header.ChannelId == "" {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[76], 1);
		return errors.New("channel ID is required in header")
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[72], 1);if len(header.Nonce) == 0 {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[77], 1);
		return errors.New("nonce is required in header")
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[73], 1);if len(header.Creator) == 0 {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[78], 1);
		return errors.New("creator is required in header")
	}

	_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[74], 1);return nil
}

func (s *Prover) MarshalErrorResponse(command []byte, e error) (*token.SignedCommandResponse, error) {_cover_atomic_.AddUint32(&GoCover_6_626466633561326138353830.Count[79], 1);
	return s.Marshaler.MarshalCommandResponse(
		command,
		&token.CommandResponse_Err{
			Err: &token.Error{Message: e.Error()},
		})
}

var GoCover_6_626466633561326138353830 = struct {
	Count     [80]uint32
	Pos       [3 * 80]uint32
	NumStmt   [80]uint16
} {
	Pos: [3 * 80]uint32{
		40, 42, 0x10005e, // [0]
		46, 52, 0x80002, // [1]
		42, 44, 0x30010, // [2]
		55, 57, 0x100075, // [3]
		61, 62, 0x100002, // [4]
		67, 69, 0x100002, // [5]
		72, 72, 0xe0002, // [6]
		76, 77, 0x100002, // [7]
		81, 82, 0x2a0002, // [8]
		101, 101, 0x100002, // [9]
		107, 107, 0x400002, // [10]
		57, 59, 0x30010, // [11]
		62, 64, 0x30010, // [12]
		69, 71, 0x30010, // [13]
		72, 74, 0x3000e, // [14]
		77, 79, 0x30010, // [15]
		83, 84, 0x470024, // [16]
		85, 86, 0x4b0026, // [17]
		87, 88, 0x470024, // [18]
		89, 90, 0x490022, // [19]
		91, 92, 0x490025, // [20]
		93, 94, 0x53002a, // [21]
		95, 96, 0x510029, // [22]
		97, 98, 0x3c000a, // [23]
		101, 105, 0x30010, // [24]
		110, 112, 0x1000a0, // [25]
		116, 117, 0x100002, // [26]
		121, 121, 0x590002, // [27]
		112, 114, 0x30010, // [28]
		117, 119, 0x30010, // [29]
		124, 126, 0x10009e, // [30]
		129, 132, 0x100002, // [31]
		136, 136, 0x590002, // [32]
		126, 128, 0x30010, // [33]
		132, 134, 0x30010, // [34]
		139, 141, 0x10009a, // [35]
		144, 147, 0x100002, // [36]
		151, 151, 0x590002, // [37]
		141, 143, 0x30010, // [38]
		147, 149, 0x30010, // [39]
		154, 156, 0x10009e, // [40]
		159, 162, 0x100002, // [41]
		166, 166, 0x490002, // [42]
		156, 158, 0x30010, // [43]
		162, 164, 0x30010, // [44]
		169, 171, 0x10009c, // [45]
		174, 177, 0x100002, // [46]
		181, 181, 0x590002, // [47]
		171, 173, 0x30010, // [48]
		177, 179, 0x30010, // [49]
		184, 186, 0x1000a2, // [50]
		189, 192, 0x100002, // [51]
		196, 196, 0x590002, // [52]
		186, 188, 0x30010, // [53]
		192, 194, 0x30010, // [54]
		201, 202, 0x2500a4, // [55]
		205, 206, 0x1d0002, // [56]
		211, 212, 0x330002, // [57]
		237, 237, 0x590002, // [58]
		202, 204, 0x30025, // [59]
		206, 208, 0x3001d, // [60]
		213, 215, 0x110031, // [61]
		218, 219, 0x110003, // [62]
		222, 224, 0x110033, // [63]
		227, 230, 0x110003, // [64]
		233, 234, 0x4e000a, // [65]
		215, 217, 0x40011, // [66]
		219, 221, 0x40011, // [67]
		224, 226, 0x40011, // [68]
		230, 232, 0x40011, // [69]
		240, 241, 0x13003d, // [70]
		245, 245, 0x1c0002, // [71]
		249, 249, 0x1c0002, // [72]
		253, 253, 0x1e0002, // [73]
		257, 257, 0xc0002, // [74]
		241, 243, 0x30013, // [75]
		245, 247, 0x3001c, // [76]
		249, 251, 0x3001c, // [77]
		253, 255, 0x3001e, // [78]
		260, 266, 0x20066, // [79]
	},
	NumStmt: [80]uint16{
		2, // 0
		1, // 1
		1, // 2
		2, // 3
		2, // 4
		3, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		2, // 30
		3, // 31
		1, // 32
		1, // 33
		1, // 34
		2, // 35
		3, // 36
		1, // 37
		1, // 38
		1, // 39
		2, // 40
		3, // 41
		1, // 42
		1, // 43
		1, // 44
		2, // 45
		3, // 46
		1, // 47
		1, // 48
		1, // 49
		2, // 50
		3, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		2, // 56
		2, // 57
		1, // 58
		1, // 59
		1, // 60
		2, // 61
		2, // 62
		2, // 63
		3, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
	},
}
var _ = _cover_atomic_.LoadUint32
