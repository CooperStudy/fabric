//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/support/config/support.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package config; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"net"
	"strconv"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/flogging"
	mspconstants "github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/discovery"
	"github.com/hyperledger/fabric/protos/msp"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("discovery.config")

// CurrentConfigBlockGetter enables to fetch the last config block
type CurrentConfigBlockGetter interface {
	// GetCurrConfigBlock returns the current config block for the given channel
	GetCurrConfigBlock(channel string) *common.Block
}

// CurrentConfigBlockGetterFunc enables to fetch the last config block
type CurrentConfigBlockGetterFunc func(channel string) *common.Block

// CurrentConfigBlockGetterFunc enables to fetch the last config block
func (f CurrentConfigBlockGetterFunc) GetCurrConfigBlock(channel string) *common.Block {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[0], 1);
	return f(channel)
}

// DiscoverySupport implements support that is used for service discovery
// that is related to configuration
type DiscoverySupport struct {
	CurrentConfigBlockGetter
}

// NewDiscoverySupport creates a new DiscoverySupport
func NewDiscoverySupport(getLastConfigBlock CurrentConfigBlockGetter) *DiscoverySupport {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[1], 1);
	return &DiscoverySupport{
		CurrentConfigBlockGetter: getLastConfigBlock,
	}
}

// Config returns the channel's configuration
func (s *DiscoverySupport) Config(channel string) (*discovery.ConfigResult, error) {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[2], 1);
	block := s.GetCurrConfigBlock(channel)
	if block == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[12], 1);
		return nil, errors.Errorf("could not get last config block for channel %s", channel)
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[3], 1);if block.Data == nil || len(block.Data.Data) == 0 {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[13], 1);
		return nil, errors.Errorf("no transactions in block")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[4], 1);env := &common.Envelope{}
	if err := proto.Unmarshal(block.Data.Data[0], env); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[14], 1);
		return nil, errors.Wrap(err, "failed unmarshaling envelope")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[5], 1);pl := &common.Payload{}
	if err := proto.Unmarshal(env.Payload, pl); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[15], 1);
		return nil, errors.Wrap(err, "failed unmarshaling payload")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[6], 1);ce := &common.ConfigEnvelope{}
	if err := proto.Unmarshal(pl.Data, ce); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[16], 1);
		return nil, errors.Wrap(err, "failed unmarshaling config envelope")
	}

	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[7], 1);if err := ValidateConfigEnvelope(ce); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[17], 1);
		return nil, errors.Wrap(err, "config envelope is invalid")
	}

	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[8], 1);res := &discovery.ConfigResult{
		Msps:     make(map[string]*msp.FabricMSPConfig),
		Orderers: make(map[string]*discovery.Endpoints),
	}
	ordererGrp := ce.Config.ChannelGroup.Groups[channelconfig.OrdererGroupKey].Groups
	appGrp := ce.Config.ChannelGroup.Groups[channelconfig.ApplicationGroupKey].Groups

	ordererAddresses := &common.OrdererAddresses{}
	if err := proto.Unmarshal(ce.Config.ChannelGroup.Values[channelconfig.OrdererAddressesKey].Value, ordererAddresses); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[18], 1);
		return nil, errors.Wrap(err, "failed unmarshaling orderer addresses")
	}

	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[9], 1);ordererEndpoints, err := computeOrdererEndpoints(ordererGrp, ordererAddresses)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[19], 1);
		return nil, errors.Wrap(err, "failed computing orderer addresses")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[10], 1);res.Orderers = ordererEndpoints

	if err := appendMSPConfigs(ordererGrp, appGrp, res.Msps); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[20], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[11], 1);return res, nil

}

func computeOrdererEndpoints(ordererGrp map[string]*common.ConfigGroup, ordererAddresses *common.OrdererAddresses) (map[string]*discovery.Endpoints, error) {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[21], 1);
	res := make(map[string]*discovery.Endpoints)
	for name, group := range ordererGrp {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[23], 1);
		mspConfig := &msp.MSPConfig{}
		if err := proto.Unmarshal(group.Values[channelconfig.MSPKey].Value, mspConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[27], 1);
			return nil, errors.Wrap(err, "failed parsing MSPConfig")
		}
		// Skip non fabric MSPs, as they don't carry useful information for service discovery.
		// An idemix MSP shouldn't appear inside an orderer group, but this isn't a fatal error
		// for the discovery service and we can just ignore it.
		_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[24], 1);if mspConfig.Type != int32(mspconstants.FABRIC) {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[28], 1);
			logger.Error("Orderer group", name, "is not a FABRIC MSP, but is of type", mspConfig.Type)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[25], 1);fabricConfig := &msp.FabricMSPConfig{}
		if err := proto.Unmarshal(mspConfig.Config, fabricConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[29], 1);
			return nil, errors.Wrap(err, "failed marshaling FabricMSPConfig")
		}
		_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[26], 1);res[fabricConfig.Name] = &discovery.Endpoints{}
		for _, endpoint := range ordererAddresses.Addresses {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[30], 1);
			host, portStr, err := net.SplitHostPort(endpoint)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[33], 1);
				return nil, errors.Errorf("failed parsing orderer endpoint %s", endpoint)
			}
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[31], 1);port, err := strconv.ParseInt(portStr, 10, 32)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[34], 1);
				return nil, errors.Errorf("%s is not a valid port number", portStr)
			}
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[32], 1);res[fabricConfig.Name].Endpoint = append(res[fabricConfig.Name].Endpoint, &discovery.Endpoint{
				Host: host,
				Port: uint32(port),
			})
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[22], 1);return res, nil
}

func appendMSPConfigs(ordererGrp, appGrp map[string]*common.ConfigGroup, output map[string]*msp.FabricMSPConfig) error {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[35], 1);
	for _, group := range []map[string]*common.ConfigGroup{ordererGrp, appGrp} {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[37], 1);
		for _, grp := range group {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[38], 1);
			mspConfig := &msp.MSPConfig{}
			if err := proto.Unmarshal(grp.Values[channelconfig.MSPKey].Value, mspConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[43], 1);
				return errors.Wrap(err, "failed parsing MSPConfig")
			}
			// Skip non fabric MSPs, as they don't carry useful information for service discovery
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[39], 1);if mspConfig.Type != int32(mspconstants.FABRIC) {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[44], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[40], 1);fabricConfig := &msp.FabricMSPConfig{}
			if err := proto.Unmarshal(mspConfig.Config, fabricConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[45], 1);
				return errors.Wrap(err, "failed marshaling FabricMSPConfig")
			}
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[41], 1);if _, exists := output[fabricConfig.Name]; exists {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[46], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[42], 1);output[fabricConfig.Name] = fabricConfig
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[36], 1);return nil
}

func ValidateConfigEnvelope(ce *common.ConfigEnvelope) error {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[47], 1);
	if ce.Config == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[54], 1);
		return fmt.Errorf("field Config is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[48], 1);if ce.Config.ChannelGroup == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[55], 1);
		return fmt.Errorf("field Config.ChannelGroup is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[49], 1);grps := ce.Config.ChannelGroup.Groups
	if grps == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[56], 1);
		return fmt.Errorf("field Config.ChannelGroup.Groups is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[50], 1);for _, field := range []string{channelconfig.OrdererGroupKey, channelconfig.ApplicationGroupKey} {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[57], 1);
		grp, exists := grps[field]
		if !exists {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[59], 1);
			return fmt.Errorf("key Config.ChannelGroup.Groups[%s] is missing", field)
		}
		_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[58], 1);if grp.Groups == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[60], 1);
			return fmt.Errorf("key Config.ChannelGroup.Groups[%s].Groups is nil", field)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[51], 1);if ce.Config.ChannelGroup.Values == nil {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[61], 1);
		return fmt.Errorf("field Config.ChannelGroup.Values is nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[52], 1);if _, exists := ce.Config.ChannelGroup.Values[channelconfig.OrdererAddressesKey]; !exists {_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[62], 1);
		return fmt.Errorf("field Config.ChannelGroup.Values is empty")
	}
	_cover_atomic_.AddUint32(&GoCover_0_636434623866643135303665.Count[53], 1);return nil
}

var GoCover_0_636434623866643135303665 = struct {
	Count     [63]uint32
	Pos       [3 * 63]uint32
	NumStmt   [63]uint16
} {
	Pos: [3 * 63]uint32{
		36, 38, 0x20058, // [0]
		47, 51, 0x20059, // [1]
		54, 56, 0x120054, // [2]
		59, 59, 0x340002, // [3]
		62, 63, 0x410002, // [4]
		66, 67, 0x390002, // [5]
		70, 71, 0x350002, // [6]
		75, 75, 0x330002, // [7]
		79, 87, 0x820002, // [8]
		91, 92, 0x100002, // [9]
		95, 97, 0x470002, // [10]
		100, 100, 0x110002, // [11]
		56, 58, 0x30012, // [12]
		59, 61, 0x30034, // [13]
		63, 65, 0x30041, // [14]
		67, 69, 0x30039, // [15]
		71, 73, 0x30035, // [16]
		75, 77, 0x30033, // [17]
		87, 89, 0x30082, // [18]
		92, 94, 0x30010, // [19]
		97, 99, 0x30047, // [20]
		104, 106, 0x26009d, // [21]
		138, 138, 0x110002, // [22]
		106, 108, 0x5e0026, // [23]
		114, 114, 0x330003, // [24]
		118, 119, 0x490003, // [25]
		122, 123, 0x370003, // [26]
		108, 110, 0x4005e, // [27]
		114, 116, 0xc0033, // [28]
		119, 121, 0x40049, // [29]
		123, 125, 0x120037, // [30]
		128, 129, 0x120004, // [31]
		132, 135, 0x60004, // [32]
		125, 127, 0x50012, // [33]
		129, 131, 0x50012, // [34]
		141, 142, 0x4d0078, // [35]
		163, 163, 0xc0002, // [36]
		142, 143, 0x1d004d, // [37]
		143, 145, 0x5d001d, // [38]
		149, 149, 0x340004, // [39]
		152, 153, 0x4a0004, // [40]
		156, 156, 0x360004, // [41]
		159, 159, 0x2c0004, // [42]
		145, 147, 0x5005d, // [43]
		149, 150, 0xd0034, // [44]
		153, 155, 0x5004a, // [45]
		156, 157, 0xd0036, // [46]
		166, 167, 0x16003e, // [47]
		170, 170, 0x230002, // [48]
		173, 174, 0x110002, // [49]
		177, 177, 0x630002, // [50]
		186, 186, 0x2a0002, // [51]
		189, 189, 0x5c0002, // [52]
		192, 192, 0xc0002, // [53]
		167, 169, 0x30016, // [54]
		170, 172, 0x30023, // [55]
		174, 176, 0x30011, // [56]
		177, 179, 0xe0063, // [57]
		182, 182, 0x180003, // [58]
		179, 181, 0x4000e, // [59]
		182, 184, 0x40018, // [60]
		186, 188, 0x3002a, // [61]
		189, 191, 0x3005c, // [62]
	},
	NumStmt: [63]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		2, // 4
		2, // 5
		2, // 6
		1, // 7
		5, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		2, // 23
		1, // 24
		2, // 25
		2, // 26
		1, // 27
		2, // 28
		1, // 29
		2, // 30
		2, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		1, // 39
		2, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		2, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
	},
}
var _ = _cover_atomic_.LoadUint32
