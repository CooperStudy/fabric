//line /home/cooper/go/src/github.com/hyperledger/fabric/core/comm/client.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package comm; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"time"

	"github.com/pkg/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/keepalive"
)

type GRPCClient struct {
	// TLS configuration used by the grpc.ClientConn
	tlsConfig *tls.Config
	// Options for setting up new connections
	dialOpts []grpc.DialOption
	// Duration for which to block while established a new connection
	timeout time.Duration
	// Maximum message size the client can receive
	maxRecvMsgSize int
	// Maximum message size the client can send
	maxSendMsgSize int
}

// NewGRPCClient creates a new implementation of GRPCClient given an address
// and client configuration
func NewGRPCClient(config ClientConfig) (*GRPCClient, error) {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[0], 1);
	client := &GRPCClient{}

	// parse secure options
	err := client.parseSecureOptions(config.SecOpts)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[4], 1);
		return client, err
	}

	// keepalive options
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[1], 1);var kap keepalive.ClientParameters
	if config.KaOpts != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[5], 1);
		kap = keepalive.ClientParameters{
			Time:    config.KaOpts.ClientInterval,
			Timeout: config.KaOpts.ClientTimeout}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[6], 1);{
		// use defaults
		kap = keepalive.ClientParameters{
			Time:    DefaultKeepaliveOptions.ClientInterval,
			Timeout: DefaultKeepaliveOptions.ClientTimeout}
	}}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[2], 1);kap.PermitWithoutStream = true
	// set keepalive
	client.dialOpts = append(client.dialOpts, grpc.WithKeepaliveParams(kap))
	// Unless asynchronous connect is set, make connection establishment blocking.
	if !config.AsyncConnect {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[7], 1);
		client.dialOpts = append(client.dialOpts, grpc.WithBlock())
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[3], 1);client.timeout = config.Timeout
	// set send/recv message size to package defaults
	client.maxRecvMsgSize = MaxRecvMsgSize
	client.maxSendMsgSize = MaxSendMsgSize

	return client, nil
}

func (client *GRPCClient) parseSecureOptions(opts *SecureOptions) error {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[8], 1);

	if opts == nil || !opts.UseTLS {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[12], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[9], 1);client.tlsConfig = &tls.Config{
		VerifyPeerCertificate: opts.VerifyCertificate,
		MinVersion:            tls.VersionTLS12} // TLS 1.2 only
	if len(opts.ServerRootCAs) > 0 {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[13], 1);
		client.tlsConfig.RootCAs = x509.NewCertPool()
		for _, certBytes := range opts.ServerRootCAs {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[14], 1);
			err := AddPemToCertPool(certBytes, client.tlsConfig.RootCAs)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[15], 1);
				commLogger.Debugf("error adding root certificate: %v", err)
				return errors.WithMessage(err,
					"error adding root certificate")
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[10], 1);if opts.RequireClientCert {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[16], 1);
		// make sure we have both Key and Certificate
		if opts.Key != nil &&
			opts.Certificate != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[17], 1);
			cert, err := tls.X509KeyPair(opts.Certificate,
				opts.Key)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[19], 1);
				return errors.WithMessage(err, "failed to "+
					"load client certificate")
			}
			_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[18], 1);client.tlsConfig.Certificates = append(
				client.tlsConfig.Certificates, cert)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[20], 1);{
			return errors.New("both Key and Certificate " +
				"are required when using mutual TLS")
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[11], 1);return nil
}

// Certificate returns the tls.Certificate used to make TLS connections
// when client certificates are required by the server
func (client *GRPCClient) Certificate() tls.Certificate {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[21], 1);
	cert := tls.Certificate{}
	if client.tlsConfig != nil && len(client.tlsConfig.Certificates) > 0 {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[23], 1);
		cert = client.tlsConfig.Certificates[0]
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[22], 1);return cert
}

// TLSEnabled is a flag indicating whether to use TLS for client
// connections
func (client *GRPCClient) TLSEnabled() bool {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[24], 1);
	return client.tlsConfig != nil
}

// MutualTLSRequired is a flag indicating whether the client
// must send a certificate when making TLS connections
func (client *GRPCClient) MutualTLSRequired() bool {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[25], 1);
	return client.tlsConfig != nil &&
		len(client.tlsConfig.Certificates) > 0
}

// SetMaxRecvMsgSize sets the maximum message size the client can receive
func (client *GRPCClient) SetMaxRecvMsgSize(size int) {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[26], 1);
	client.maxRecvMsgSize = size
}

// SetMaxSendMsgSize sets the maximum message size the client can send
func (client *GRPCClient) SetMaxSendMsgSize(size int) {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[27], 1);
	client.maxSendMsgSize = size
}

// SetServerRootCAs sets the list of authorities used to verify server
// certificates based on a list of PEM-encoded X509 certificate authorities
func (client *GRPCClient) SetServerRootCAs(serverRoots [][]byte) error {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[28], 1);

	// NOTE: if no serverRoots are specified, the current cert pool will be
	// replaced with an empty one
	certPool := x509.NewCertPool()
	for _, root := range serverRoots {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[30], 1);
		err := AddPemToCertPool(root, certPool)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[31], 1);
			return errors.WithMessage(err, "error adding root certificate")
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[29], 1);client.tlsConfig.RootCAs = certPool
	return nil
}

// NewConnection returns a grpc.ClientConn for the target address and
// overrides the server name used to verify the hostname on the
// certificate returned by a server when using TLS
func (client *GRPCClient) NewConnection(address string, serverNameOverride string) (
	*grpc.ClientConn, error) {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[32], 1);

	var dialOpts []grpc.DialOption
	dialOpts = append(dialOpts, client.dialOpts...)

	// set transport credentials and max send/recv message sizes
	// immediately before creating a connection in order to allow
	// SetServerRootCAs / SetMaxRecvMsgSize / SetMaxSendMsgSize
	//  to take effect on a per connection basis
	if client.tlsConfig != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[35], 1);
		client.tlsConfig.ServerName = serverNameOverride
		dialOpts = append(dialOpts,
			grpc.WithTransportCredentials(
				credentials.NewTLS(client.tlsConfig)))
	} else{ _cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[36], 1);{
		dialOpts = append(dialOpts, grpc.WithInsecure())
	}}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[33], 1);dialOpts = append(dialOpts, grpc.WithDefaultCallOptions(
		grpc.MaxCallRecvMsgSize(client.maxRecvMsgSize),
		grpc.MaxCallSendMsgSize(client.maxSendMsgSize)))

	ctx, cancel := context.WithTimeout(context.Background(), client.timeout)
	defer cancel()
	conn, err := grpc.DialContext(ctx, address, dialOpts...)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[37], 1);
		return nil, errors.WithMessage(errors.WithStack(err),
			"failed to create new connection")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643230363037383562363632.Count[34], 1);return conn, nil
}

var GoCover_0_643230363037383562363632 = struct {
	Count     [38]uint32
	Pos       [3 * 38]uint32
	NumStmt   [38]uint16
} {
	Pos: [3 * 38]uint32{
		36, 41, 0x10003e, // [0]
		46, 47, 0x1a0002, // [1]
		57, 61, 0x1a0002, // [2]
		64, 69, 0x140002, // [3]
		41, 43, 0x30010, // [4]
		47, 51, 0x3001a, // [5]
		51, 56, 0x30008, // [6]
		61, 63, 0x3001a, // [7]
		72, 74, 0x210049, // [8]
		77, 80, 0x210002, // [9]
		91, 91, 0x1c0002, // [10]
		108, 108, 0xc0002, // [11]
		74, 76, 0x30021, // [12]
		80, 82, 0x300021, // [13]
		82, 84, 0x120030, // [14]
		84, 88, 0x50012, // [15]
		91, 94, 0x1c001c, // [16]
		94, 97, 0x12001c, // [17]
		101, 102, 0x290004, // [18]
		97, 100, 0x50012, // [19]
		103, 106, 0x40009, // [20]
		113, 115, 0x470039, // [21]
		118, 118, 0xd0002, // [22]
		115, 117, 0x30047, // [23]
		123, 125, 0x2002d, // [24]
		129, 132, 0x20034, // [25]
		135, 137, 0x20037, // [26]
		140, 142, 0x20037, // [27]
		146, 151, 0x230048, // [28]
		157, 158, 0xc0002, // [29]
		151, 153, 0x110023, // [30]
		153, 155, 0x40011, // [31]
		165, 174, 0x1d001b, // [32]
		182, 189, 0x100002, // [33]
		193, 193, 0x120002, // [34]
		174, 179, 0x3001d, // [35]
		179, 181, 0x30008, // [36]
		189, 192, 0x30010, // [37]
	},
	NumStmt: [38]uint16{
		3, // 0
		2, // 1
		3, // 2
		4, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		2, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		2, // 28
		2, // 29
		2, // 30
		1, // 31
		3, // 32
		5, // 33
		1, // 34
		2, // 35
		1, // 36
		1, // 37
	},
}
var _ = _cover_atomic_.LoadUint32
