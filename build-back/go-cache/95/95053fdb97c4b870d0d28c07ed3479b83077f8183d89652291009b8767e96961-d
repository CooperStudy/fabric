//line /home/cooper/go/src/github.com/hyperledger/fabric/core/cclifecycle/lifecycle.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package cc; import _cover_atomic_ "sync/atomic"

import (
	"sync"

	"github.com/hyperledger/fabric/common/chaincode"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger/cceventmgmt"
	"github.com/pkg/errors"
)

var (
	// Logger is the logging instance for this package.
	// It's exported because the tests override its backend
	Logger = flogging.MustGetLogger("discovery.lifecycle")
)

// Lifecycle manages information regarding chaincode lifecycle
type Lifecycle struct {
	sync.RWMutex
	listeners              []LifeCycleChangeListener
	installedCCs           []chaincode.InstalledChaincode
	deployedCCsByChannel   map[string]*chaincode.MetadataMapping
	queryCreatorsByChannel map[string]QueryCreator
}

// LifeCycleChangeListener runs whenever there is a change to the metadata
// of a chaincode in the context of a specific channel
type LifeCycleChangeListener interface {
	LifeCycleChangeListener(channel string, chaincodes chaincode.MetadataSet)
}

// HandleMetadataUpdate is triggered upon a change in the chaincode lifecycle change
type HandleMetadataUpdate func(channel string, chaincodes chaincode.MetadataSet)

//go:generate mockery -dir . -name LifeCycleChangeListener -case underscore  -output mocks/

// LifeCycleChangeListener runs whenever there is a change to the metadata
// // of a chaincode in the context of a specific channel
func (mdUpdate HandleMetadataUpdate) LifeCycleChangeListener(channel string, chaincodes chaincode.MetadataSet) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[0], 1);
	mdUpdate(channel, chaincodes)
}

//go:generate mockery -dir . -name Enumerator -case underscore  -output mocks/

// Enumerator enumerates chaincodes
type Enumerator interface {
	// Enumerate returns the installed chaincodes
	Enumerate() ([]chaincode.InstalledChaincode, error)
}

// Enumerate enumerates installed chaincodes
type Enumerate func() ([]chaincode.InstalledChaincode, error)

// Enumerate enumerates chaincodes
func (listCCs Enumerate) Enumerate() ([]chaincode.InstalledChaincode, error) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[1], 1);
	return listCCs()
}

//go:generate mockery -dir . -name Query -case underscore  -output mocks/

// Query queries the state
type Query interface {
	// GetState gets the value for given namespace and key. For a chaincode, the namespace corresponds to the chaincodeId
	GetState(namespace string, key string) ([]byte, error)

	// Done releases resources occupied by the QueryExecutor
	Done()
}

//go:generate mockery -dir . -name QueryCreator -case underscore  -output mocks/

// QueryCreator creates queries
type QueryCreator interface {
	// NewQuery creates a new Query, or error on failure
	NewQuery() (Query, error)
}

// QueryCreatorFunc creates a new query
type QueryCreatorFunc func() (Query, error)

// NewQuery creates a new Query, or error on failure
func (qc QueryCreatorFunc) NewQuery() (Query, error) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[2], 1);
	return qc()
}

// NewLifeCycle creates a new Lifecycle instance
func NewLifeCycle(installedChaincodes Enumerator) (*Lifecycle, error) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[3], 1);
	installedCCs, err := installedChaincodes.Enumerate()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[5], 1);
		return nil, errors.Wrap(err, "failed listing installed chaincodes")
	}

	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[4], 1);lc := &Lifecycle{
		installedCCs:           installedCCs,
		deployedCCsByChannel:   make(map[string]*chaincode.MetadataMapping),
		queryCreatorsByChannel: make(map[string]QueryCreator),
	}

	return lc, nil
}

// Metadata returns the metadata of the chaincode on the given channel,
// or nil if not found or an error occurred at retrieving it
func (lc *Lifecycle) Metadata(channel string, cc string, collections bool) *chaincode.Metadata {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[6], 1);
	queryCreator := lc.queryCreatorsByChannel[channel]
	if queryCreator == nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[12], 1);
		Logger.Warning("Requested Metadata for non-existent channel", channel)
		return nil
	}
	// Search the metadata in our local cache, and if it exists - return it, but only if
	// no collections were specified in the invocation.
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[7], 1);if md, found := lc.deployedCCsByChannel[channel].Lookup(cc); found && !collections {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[13], 1);
		Logger.Debug("Returning metadata for channel", channel, ", chaincode", cc, ":", md)
		return &md
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[8], 1);query, err := queryCreator.NewQuery()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[14], 1);
		Logger.Error("Failed obtaining new query for channel", channel, ":", err)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[9], 1);md, err := DeployedChaincodes(query, AcceptAll, collections, cc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[15], 1);
		Logger.Error("Failed querying LSCC for channel", channel, ":", err)
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[10], 1);if len(md) == 0 {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[16], 1);
		Logger.Info("Chaincode", cc, "isn't defined in channel", channel)
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[11], 1);return &md[0]
}

func (lc *Lifecycle) initMetadataForChannel(channel string, queryCreator QueryCreator) error {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[17], 1);
	if lc.isChannelMetadataInitialized(channel) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[21], 1);
		return nil
	}
	// Create a new metadata mapping for the channel
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[18], 1);query, err := queryCreator.NewQuery()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[22], 1);
		return errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[19], 1);ccs, err := queryChaincodeDefinitions(query, lc.installedCCs, DeployedChaincodes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[23], 1);
		return errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[20], 1);lc.createMetadataForChannel(channel, queryCreator)
	lc.updateState(channel, ccs)
	return nil
}

func (lc *Lifecycle) createMetadataForChannel(channel string, newQuery QueryCreator) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[24], 1);
	lc.Lock()
	defer lc.Unlock()
	lc.deployedCCsByChannel[channel] = chaincode.NewMetadataMapping()
	lc.queryCreatorsByChannel[channel] = newQuery
}

func (lc *Lifecycle) isChannelMetadataInitialized(channel string) bool {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[25], 1);
	lc.RLock()
	defer lc.RUnlock()
	_, exists := lc.deployedCCsByChannel[channel]
	return exists
}

func (lc *Lifecycle) updateState(channel string, ccUpdate chaincode.MetadataSet) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[26], 1);
	lc.RLock()
	defer lc.RUnlock()
	for _, cc := range ccUpdate {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[27], 1);
		lc.deployedCCsByChannel[channel].Update(cc)
	}
}

func (lc *Lifecycle) fireChangeListeners(channel string) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[28], 1);
	lc.RLock()
	md := lc.deployedCCsByChannel[channel]
	lc.RUnlock()
	for _, listener := range lc.listeners {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[30], 1);
		aggregatedMD := md.Aggregate()
		listener.LifeCycleChangeListener(channel, aggregatedMD)
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[29], 1);Logger.Debug("Listeners for channel", channel, "invoked")
}

// NewChannelSubscription subscribes to a channel
func (lc *Lifecycle) NewChannelSubscription(channel string, queryCreator QueryCreator) (*Subscription, error) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[31], 1);
	sub := &Subscription{
		lc:             lc,
		channel:        channel,
		queryCreator:   queryCreator,
		pendingUpdates: make(chan *cceventmgmt.ChaincodeDefinition, 1),
	}
	// Initialize metadata for the channel.
	// This loads metadata about all installed chaincodes
	if err := lc.initMetadataForChannel(channel, queryCreator); err != nil {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[33], 1);
		return nil, errors.WithStack(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[32], 1);lc.fireChangeListeners(channel)
	return sub, nil
}

// AddListener registers the given listener to be triggered upon a lifecycle change
func (lc *Lifecycle) AddListener(listener LifeCycleChangeListener) {_cover_atomic_.AddUint32(&GoCover_0_303966633866396236633762.Count[34], 1);
	lc.Lock()
	defer lc.Unlock()
	lc.listeners = append(lc.listeners, listener)
}

var GoCover_0_303966633866396236633762 = struct {
	Count     [35]uint32
	Pos       [3 * 35]uint32
	NumStmt   [35]uint16
} {
	Pos: [3 * 35]uint32{
		46, 48, 0x20070, // [0]
		62, 64, 0x2004e, // [1]
		89, 91, 0x20036, // [2]
		94, 96, 0x100047, // [3]
		100, 106, 0x100002, // [4]
		96, 98, 0x30010, // [5]
		111, 113, 0x190060, // [6]
		119, 119, 0x550002, // [7]
		123, 124, 0x100002, // [8]
		128, 129, 0x100002, // [9]
		133, 133, 0x120002, // [10]
		138, 138, 0xf0002, // [11]
		113, 116, 0x30019, // [12]
		119, 122, 0x30055, // [13]
		124, 127, 0x30010, // [14]
		129, 132, 0x30010, // [15]
		133, 136, 0x30012, // [16]
		141, 142, 0x2e005e, // [17]
		146, 147, 0x100002, // [18]
		150, 151, 0x100002, // [19]
		154, 156, 0xc0002, // [20]
		142, 144, 0x3002e, // [21]
		147, 149, 0x30010, // [22]
		151, 153, 0x30010, // [23]
		159, 164, 0x20056, // [24]
		166, 171, 0x20048, // [25]
		173, 176, 0x1e0052, // [26]
		176, 178, 0x3001e, // [27]
		181, 185, 0x28003a, // [28]
		189, 189, 0x3b0002, // [29]
		185, 188, 0x30028, // [30]
		193, 202, 0x49006f, // [31]
		205, 206, 0x110002, // [32]
		202, 204, 0x30049, // [33]
		210, 214, 0x20044, // [34]
	},
	NumStmt: [35]uint16{
		1, // 0
		1, // 1
		1, // 2
		2, // 3
		2, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		2, // 9
		1, // 10
		1, // 11
		2, // 12
		2, // 13
		2, // 14
		2, // 15
		2, // 16
		1, // 17
		2, // 18
		2, // 19
		3, // 20
		1, // 21
		1, // 22
		1, // 23
		4, // 24
		4, // 25
		3, // 26
		1, // 27
		4, // 28
		1, // 29
		2, // 30
		2, // 31
		2, // 32
		1, // 33
		3, // 34
	},
}
var _ = _cover_atomic_.LoadUint32
