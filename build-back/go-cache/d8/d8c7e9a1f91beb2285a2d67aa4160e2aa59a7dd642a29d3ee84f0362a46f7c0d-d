//line /home/cooper/go/src/github.com/hyperledger/fabric/core/committer/txvalidator/validator.go:1
/*
Copyright IBM Corp. 2016 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package txvalidator; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/configtx"
	commonerrors "github.com/hyperledger/fabric/common/errors"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/chaincode/platforms"
	"github.com/hyperledger/fabric/core/chaincode/platforms/golang"
	"github.com/hyperledger/fabric/core/common/sysccprovider"
	"github.com/hyperledger/fabric/core/common/validation"
	"github.com/hyperledger/fabric/core/ledger"
	ledgerUtil "github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	mspprotos "github.com/hyperledger/fabric/protos/msp"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

// Support provides all of the needed to evaluate the VSCC
type Support interface {
	// Acquire implements semaphore-like acquire semantics
	Acquire(ctx context.Context, n int64) error

	// Release implements semaphore-like release semantics
	Release(n int64)

	// Ledger returns the ledger associated with this validator
	Ledger() ledger.PeerLedger

	// MSPManager returns the MSP manager for this channel
	MSPManager() msp.MSPManager

	// Apply attempts to apply a configtx to become the new config
	Apply(configtx *common.ConfigEnvelope) error

	// GetMSPIDs returns the IDs for the application MSPs
	// that have been defined in the channel
	GetMSPIDs(cid string) []string

	// Capabilities defines the capabilities for the application portion of this channel
	Capabilities() channelconfig.ApplicationCapabilities
}

//Validator interface which defines API to validate block transactions
// and return the bit array mask indicating invalid transactions which
// didn't pass validation.
type Validator interface {
	Validate(block *common.Block) error
}

// private interface to decouple tx validator
// and vscc execution, in order to increase
// testability of TxValidator
type vsccValidator interface {
	VSCCValidateTx(seq int, payload *common.Payload, envBytes []byte, block *common.Block) (error, peer.TxValidationCode)
}

// implementation of Validator interface, keeps
// reference to the ledger to enable tx simulation
// and execution of vscc
type TxValidator struct {
	ChainID string
	Support Support
	Vscc    vsccValidator
}

var logger = flogging.MustGetLogger("committer.txvalidator")

type blockValidationRequest struct {
	block *common.Block
	d     []byte
	tIdx  int
}

type blockValidationResult struct {
	tIdx                 int
	validationCode       peer.TxValidationCode
	txsChaincodeName     *sysccprovider.ChaincodeInstance
	txsUpgradedChaincode *sysccprovider.ChaincodeInstance
	err                  error
	txid                 string
}

// NewTxValidator creates new transactions validator
func NewTxValidator(chainID string, support Support, sccp sysccprovider.SystemChaincodeProvider, pm PluginMapper) *TxValidator {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[0], 1);
	// Encapsulates interface implementation
	pluginValidator := NewPluginValidator(pm, support.Ledger(), &dynamicDeserializer{support: support}, &dynamicCapabilities{support: support})
	return &TxValidator{
		ChainID: chainID,
		Support: support,
		Vscc:    newVSCCValidator(chainID, support, sccp, pluginValidator)}
}

func (v *TxValidator) chainExists(chain string) bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[1], 1);
	// TODO: implement this function!
	return true
}

// Validate performs the validation of a block. The validation
// of each transaction in the block is performed in parallel.
// The approach is as follows: the committer thread starts the
// tx validation function in a goroutine (using a semaphore to cap
// the number of concurrent validating goroutines). The committer
// thread then reads results of validation (in orderer of completion
// of the goroutines) from the results channel. The goroutines
// perform the validation of the txs in the block and enqueue the
// validation result in the results channel. A few note-worthy facts:
// 1) to keep the approach simple, the committer thread enqueues
//    all transactions in the block and then moves on to reading the
//    results.
// 2) for parallel validation to work, it is important that the
//    validation function does not change the state of the system.
//    Otherwise the order in which validation is perform matters
//    and we have to resort to sequential validation (or some locking).
//    This is currently true, because the only function that affects
//    state is when a config transaction is received, but they are
//    guaranteed to be alone in the block. If/when this assumption
//    is violated, this code must be changed.
func (v *TxValidator) Validate(block *common.Block) error {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[2], 1);
	var err error
	var errPos int

	startValidation := time.Now() // timer to log Validate block duration
	logger.Debugf("[%s] START Block Validation for block [%d]", v.ChainID, block.Header.Number)

	// Initialize trans as valid here, then set invalidation reason code upon invalidation below
	txsfltr := ledgerUtil.NewTxValidationFlags(len(block.Data.Data))
	// txsChaincodeNames records all the invoked chaincodes by tx in a block
	txsChaincodeNames := make(map[int]*sysccprovider.ChaincodeInstance)
	// upgradedChaincodes records all the chaincodes that are upgraded in a block
	txsUpgradedChaincodes := make(map[int]*sysccprovider.ChaincodeInstance)
	// array of txids
	txidArray := make([]string, len(block.Data.Data))

	results := make(chan *blockValidationResult)
	go func() {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[8], 1);
		for tIdx, d := range block.Data.Data {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[9], 1);
			// ensure that we don't have too many concurrent validation workers
			v.Support.Acquire(context.Background(), 1)

			go func(index int, data []byte) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[10], 1);
				defer v.Support.Release(1)

				v.validateTx(&blockValidationRequest{
					d:     data,
					block: block,
					tIdx:  index,
				}, results)
			}(tIdx, d)
		}
	}()

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[3], 1);logger.Debugf("expecting %d block validation responses", len(block.Data.Data))

	// now we read responses in the order in which they come back
	for i := 0; i < len(block.Data.Data); i++ {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[11], 1);
		res := <-results

		if res.err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[12], 1);
			// if there is an error, we buffer its value, wait for
			// all workers to complete validation and then return
			// the error from the first tx in this block that returned an error
			logger.Debugf("got terminal error %s for idx %d", res.err, res.tIdx)

			if err == nil || res.tIdx < errPos {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[13], 1);
				err = res.err
				errPos = res.tIdx
			}
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[14], 1);{
			// if there was no error, we set the txsfltr and we set the
			// txsChaincodeNames and txsUpgradedChaincodes maps
			logger.Debugf("got result for idx %d, code %d", res.tIdx, res.validationCode)

			txsfltr.SetFlag(res.tIdx, res.validationCode)

			if res.validationCode == peer.TxValidationCode_VALID {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[15], 1);
				if res.txsChaincodeName != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[18], 1);
					txsChaincodeNames[res.tIdx] = res.txsChaincodeName
				}
				_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[16], 1);if res.txsUpgradedChaincode != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[19], 1);
					txsUpgradedChaincodes[res.tIdx] = res.txsUpgradedChaincode
				}
				_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[17], 1);txidArray[res.tIdx] = res.txid
			}
		}}
	}

	// if we're here, all workers have completed the validation.
	// If there was an error we return the error from the first
	// tx in this block that returned an error
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[4], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[20], 1);
		return err
	}

	// if we operate with this capability, we mark invalid any transaction that has a txid
	// which is equal to that of a previous tx in this block
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[5], 1);if v.Support.Capabilities().ForbidDuplicateTXIdInBlock() {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[21], 1);
		markTXIdDuplicates(txidArray, txsfltr)
	}

	// if we're here, all workers have completed validation and
	// no error was reported; we set the tx filter and return
	// success
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[6], 1);v.invalidTXsForUpgradeCC(txsChaincodeNames, txsUpgradedChaincodes, txsfltr)

	// make sure no transaction has skipped validation
	err = v.allValidated(txsfltr, block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[22], 1);
		return err
	}

	// Initialize metadata structure
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[7], 1);utils.InitBlockMetadata(block)

	block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = txsfltr

	elapsedValidation := time.Since(startValidation) / time.Millisecond // duration in ms
	logger.Infof("[%s] Validated block [%d] in %dms", v.ChainID, block.Header.Number, elapsedValidation)

	return nil
}

// allValidated returns error if some of the validation flags have not been set
// during validation
func (v *TxValidator) allValidated(txsfltr ledgerUtil.TxValidationFlags, block *common.Block) error {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[23], 1);
	for id, f := range txsfltr {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[25], 1);
		if peer.TxValidationCode(f) == peer.TxValidationCode_NOT_VALIDATED {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[26], 1);
			return errors.Errorf("transaction %d in block %d has skipped validation", id, block.Header.Number)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[24], 1);return nil
}

func markTXIdDuplicates(txids []string, txsfltr ledgerUtil.TxValidationFlags) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[27], 1);
	txidMap := make(map[string]struct{})

	for id, txid := range txids {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[28], 1);
		if txid == "" {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[30], 1);
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[29], 1);_, in := txidMap[txid]
		if in {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[31], 1);
			logger.Error("Duplicate txid", txid, "found, skipping")
			txsfltr.SetFlag(id, peer.TxValidationCode_DUPLICATE_TXID)
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[32], 1);{
			txidMap[txid] = struct{}{}
		}}
	}
}

func (v *TxValidator) validateTx(req *blockValidationRequest, results chan<- *blockValidationResult) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[33], 1);
	block := req.block
	d := req.d
	tIdx := req.tIdx
	txID := ""

	if d == nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[35], 1);
		results <- &blockValidationResult{
			tIdx: tIdx,
		}
		return
	}

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[34], 1);if env, err := utils.GetEnvelopeFromBlock(d); err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[36], 1);
		logger.Warningf("Error getting tx from block: %+v", err)
		results <- &blockValidationResult{
			tIdx:           tIdx,
			validationCode: peer.TxValidationCode_INVALID_OTHER_REASON,
		}
		return
	} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[37], 1);if env != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[38], 1);
		// validate the transaction: here we check that the transaction
		// is properly formed, properly signed and that the security
		// chain binding proposal to endorsements to tx holds. We do
		// NOT check the validity of endorsements, though. That's a
		// job for VSCC below
		logger.Debugf("[%s] validateTx starts for block %p env %p txn %d", v.ChainID, block, env, tIdx)
		defer logger.Debugf("[%s] validateTx completes for block %p env %p txn %d", v.ChainID, block, env, tIdx)
		var payload *common.Payload
		var err error
		var txResult peer.TxValidationCode
		var txsChaincodeName *sysccprovider.ChaincodeInstance
		var txsUpgradedChaincode *sysccprovider.ChaincodeInstance

		if payload, txResult = validation.ValidateTransaction(env, v.Support.Capabilities()); txResult != peer.TxValidationCode_VALID {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[44], 1);
			logger.Errorf("Invalid transaction with index %d", tIdx)
			results <- &blockValidationResult{
				tIdx:           tIdx,
				validationCode: txResult,
			}
			return
		}

		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[39], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[45], 1);
			logger.Warningf("Could not unmarshal channel header, err %s, skipping", err)
			results <- &blockValidationResult{
				tIdx:           tIdx,
				validationCode: peer.TxValidationCode_INVALID_OTHER_REASON,
			}
			return
		}

		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[40], 1);channel := chdr.ChannelId
		logger.Debugf("Transaction is for channel %s", channel)

		if !v.chainExists(channel) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[46], 1);
			logger.Errorf("Dropping transaction for non-existent channel %s", channel)
			results <- &blockValidationResult{
				tIdx:           tIdx,
				validationCode: peer.TxValidationCode_TARGET_CHAIN_NOT_FOUND,
			}
			return
		}

		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[41], 1);if common.HeaderType(chdr.Type) == common.HeaderType_ENDORSER_TRANSACTION {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[47], 1);

			txID = chdr.TxId

			// Check duplicate transactions
			erroneousResultEntry := v.checkTxIdDupsLedger(tIdx, chdr, v.Support.Ledger())
			if erroneousResultEntry != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[51], 1);
				results <- erroneousResultEntry
				return
			}

			// Validate tx with vscc and policy
			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[48], 1);logger.Debug("Validating transaction vscc tx validate")
			err, cde := v.Vscc.VSCCValidateTx(tIdx, payload, d, block)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[52], 1);
				logger.Errorf("VSCCValidateTx for transaction txId = %s returned error: %s", txID, err)
				switch err.(type) {
				case *commonerrors.VSCCExecutionFailureError:_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[53], 1);
					results <- &blockValidationResult{
						tIdx: tIdx,
						err:  err,
					}
					return
				case *commonerrors.VSCCInfoLookupFailureError:_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[54], 1);
					results <- &blockValidationResult{
						tIdx: tIdx,
						err:  err,
					}
					return
				default:_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[55], 1);
					results <- &blockValidationResult{
						tIdx:           tIdx,
						validationCode: cde,
					}
					return
				}
			}

			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[49], 1);invokeCC, upgradeCC, err := v.getTxCCInstance(payload)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[56], 1);
				logger.Errorf("Get chaincode instance from transaction txId = %s returned error: %+v", txID, err)
				results <- &blockValidationResult{
					tIdx:           tIdx,
					validationCode: peer.TxValidationCode_INVALID_OTHER_REASON,
				}
				return
			}
			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[50], 1);txsChaincodeName = invokeCC
			if upgradeCC != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[57], 1);
				logger.Infof("Find chaincode upgrade transaction for chaincode %s on channel %s with new version %s", upgradeCC.ChaincodeName, upgradeCC.ChainID, upgradeCC.ChaincodeVersion)
				txsUpgradedChaincode = upgradeCC
			}
			// FAB-12971 comment out below block before v1.4 cut. Will uncomment after v1.4.
			/*
				} else if common.HeaderType(chdr.Type) == common.HeaderType_TOKEN_TRANSACTION {

					txID = chdr.TxId
					if !v.Support.Capabilities().FabToken() {
						logger.Errorf("FabToken capability is not enabled. Unsupported transaction type [%s] in block [%d] transaction [%d]",
							common.HeaderType(chdr.Type), block.Header.Number, tIdx)
						results <- &blockValidationResult{
							tIdx:           tIdx,
							validationCode: peer.TxValidationCode_UNSUPPORTED_TX_PAYLOAD,
						}
						return
					}

					// Check if there is a duplicate of such transaction in the ledger and
					// obtain the corresponding result that acknowledges the error type
					erroneousResultEntry := v.checkTxIdDupsLedger(tIdx, chdr, v.Support.Ledger())
					if erroneousResultEntry != nil {
						results <- erroneousResultEntry
						return
					}

					// Set the namespace of the invocation field
					txsChaincodeName = &sysccprovider.ChaincodeInstance{
						ChainID:          channel,
						ChaincodeName:    "Token",
						ChaincodeVersion: ""}
			*/
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[58], 1);if common.HeaderType(chdr.Type) == common.HeaderType_CONFIG {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[59], 1);
			configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[62], 1);
				err = errors.WithMessage(err, "error unmarshalling config which passed initial validity checks")
				logger.Criticalf("%+v", err)
				results <- &blockValidationResult{
					tIdx: tIdx,
					err:  err,
				}
				return
			}

			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[60], 1);if err := v.Support.Apply(configEnvelope); err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[63], 1);
				err = errors.WithMessage(err, "error validating config which passed initial validity checks")
				logger.Criticalf("%+v", err)
				results <- &blockValidationResult{
					tIdx: tIdx,
					err:  err,
				}
				return
			}
			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[61], 1);logger.Debugf("config transaction received for chain %s", channel)
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[64], 1);{
			logger.Warningf("Unknown transaction type [%s] in block number [%d] transaction index [%d]",
				common.HeaderType(chdr.Type), block.Header.Number, tIdx)
			results <- &blockValidationResult{
				tIdx:           tIdx,
				validationCode: peer.TxValidationCode_UNKNOWN_TX_TYPE,
			}
			return
		}}}

		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[42], 1);if _, err := proto.Marshal(env); err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[65], 1);
			logger.Warningf("Cannot marshal transaction: %s", err)
			results <- &blockValidationResult{
				tIdx:           tIdx,
				validationCode: peer.TxValidationCode_MARSHAL_TX_ERROR,
			}
			return
		}
		// Succeeded to pass down here, transaction is valid
		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[43], 1);results <- &blockValidationResult{
			tIdx:                 tIdx,
			txsChaincodeName:     txsChaincodeName,
			txsUpgradedChaincode: txsUpgradedChaincode,
			validationCode:       peer.TxValidationCode_VALID,
			txid:                 txID,
		}
		return
	} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[66], 1);{
		logger.Warning("Nil tx from block")
		results <- &blockValidationResult{
			tIdx:           tIdx,
			validationCode: peer.TxValidationCode_NIL_ENVELOPE,
		}
		return
	}}}
}

// CheckTxIdDupsLedger returns a vlockValidationResult enhanced with the respective
// error codes if and only if there is transaction with the same transaction identifier
// in the ledger or no decision can be made for whether such transaction exists;
// the function returns nil if it has ensured that there is no such duplicate, such
// that its consumer can proceed with the transaction processing
func (v *TxValidator) checkTxIdDupsLedger(tIdx int, chdr *common.ChannelHeader, ldgr ledger.PeerLedger) (errorTuple *blockValidationResult) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[67], 1);

	// Retrieve the transaction identifier of the input header
	txID := chdr.TxId

	// Look for a transaction with the same identifier inside the ledger
	_, err := ldgr.GetTransactionByID(txID)

	// if returned error is nil, it means that there is already a tx in
	// the ledger with the supplied id
	if err == nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[70], 1);
		logger.Error("Duplicate transaction found, ", txID, ", skipping")
		return &blockValidationResult{
			tIdx:           tIdx,
			validationCode: peer.TxValidationCode_DUPLICATE_TXID,
		}
	}

	// if returned error is not of type blkstorage.NotFoundInIndexErr, it means
	// we could not verify whether a tx with the supplied id is in the ledger
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[68], 1);if _, isNotFoundInIndexErrType := err.(ledger.NotFoundInIndexErr); !isNotFoundInIndexErrType {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[71], 1);
		logger.Errorf("Ledger failure while attempting to detect duplicate status for "+
			"txid %s, err '%s'. Aborting", txID, err)
		return &blockValidationResult{
			tIdx: tIdx,
			err:  err,
		}
	}

	// it otherwise means that there is no transaction with the same identifier
	// residing in the ledger
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[69], 1);return nil
}

// generateCCKey generates a unique identifier for chaincode in specific channel
func (v *TxValidator) generateCCKey(ccName, chainID string) string {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[72], 1);
	return fmt.Sprintf("%s/%s", ccName, chainID)
}

// invalidTXsForUpgradeCC invalid all txs that should be invalided because of chaincode upgrade txs
func (v *TxValidator) invalidTXsForUpgradeCC(txsChaincodeNames map[int]*sysccprovider.ChaincodeInstance, txsUpgradedChaincodes map[int]*sysccprovider.ChaincodeInstance, txsfltr ledgerUtil.TxValidationFlags) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[73], 1);
	if len(txsUpgradedChaincodes) == 0 {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[76], 1);
		return
	}

	// Invalid former cc upgrade txs if there're two or more txs upgrade the same cc
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[74], 1);finalValidUpgradeTXs := make(map[string]int)
	upgradedChaincodes := make(map[string]*sysccprovider.ChaincodeInstance)
	for tIdx, cc := range txsUpgradedChaincodes {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[77], 1);
		if cc == nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[79], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[78], 1);upgradedCCKey := v.generateCCKey(cc.ChaincodeName, cc.ChainID)

		if finalIdx, exist := finalValidUpgradeTXs[upgradedCCKey]; !exist {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[80], 1);
			finalValidUpgradeTXs[upgradedCCKey] = tIdx
			upgradedChaincodes[upgradedCCKey] = cc
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[81], 1);if finalIdx < tIdx {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[82], 1);
			logger.Infof("Invalid transaction with index %d: chaincode was upgraded by latter tx", finalIdx)
			txsfltr.SetFlag(finalIdx, peer.TxValidationCode_CHAINCODE_VERSION_CONFLICT)

			// record latter cc upgrade tx info
			finalValidUpgradeTXs[upgradedCCKey] = tIdx
			upgradedChaincodes[upgradedCCKey] = cc
		} else{ _cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[83], 1);{
			logger.Infof("Invalid transaction with index %d: chaincode was upgraded by latter tx", tIdx)
			txsfltr.SetFlag(tIdx, peer.TxValidationCode_CHAINCODE_VERSION_CONFLICT)
		}}}
	}

	// invalid txs which invoke the upgraded chaincodes
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[75], 1);for tIdx, cc := range txsChaincodeNames {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[84], 1);
		if cc == nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[86], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[85], 1);ccKey := v.generateCCKey(cc.ChaincodeName, cc.ChainID)
		if _, exist := upgradedChaincodes[ccKey]; exist {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[87], 1);
			if txsfltr.IsValid(tIdx) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[88], 1);
				logger.Infof("Invalid transaction with index %d: chaincode was upgraded in the same block", tIdx)
				txsfltr.SetFlag(tIdx, peer.TxValidationCode_CHAINCODE_VERSION_CONFLICT)
			}
		}
	}
}

func (v *TxValidator) getTxCCInstance(payload *common.Payload) (invokeCCIns, upgradeCCIns *sysccprovider.ChaincodeInstance, err error) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[89], 1);
	// This is duplicated unpacking work, but make test easier.
	chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[97], 1);
		return nil, nil, err
	}

	// Chain ID
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[90], 1);chainID := chdr.ChannelId // it is guaranteed to be an existing channel by now

	// ChaincodeID
	hdrExt, err := utils.GetChaincodeHeaderExtension(payload.Header)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[98], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[91], 1);invokeCC := hdrExt.ChaincodeId
	invokeIns := &sysccprovider.ChaincodeInstance{ChainID: chainID, ChaincodeName: invokeCC.Name, ChaincodeVersion: invokeCC.Version}

	// Transaction
	tx, err := utils.GetTransaction(payload.Data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[99], 1);
		logger.Errorf("GetTransaction failed: %+v", err)
		return invokeIns, nil, nil
	}

	// ChaincodeActionPayload
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[92], 1);cap, err := utils.GetChaincodeActionPayload(tx.Actions[0].Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[100], 1);
		logger.Errorf("GetChaincodeActionPayload failed: %+v", err)
		return invokeIns, nil, nil
	}

	// ChaincodeProposalPayload
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[93], 1);cpp, err := utils.GetChaincodeProposalPayload(cap.ChaincodeProposalPayload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[101], 1);
		logger.Errorf("GetChaincodeProposalPayload failed: %+v", err)
		return invokeIns, nil, nil
	}

	// ChaincodeInvocationSpec
	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[94], 1);cis := &peer.ChaincodeInvocationSpec{}
	err = proto.Unmarshal(cpp.Input, cis)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[102], 1);
		logger.Errorf("GetChaincodeInvokeSpec failed: %+v", err)
		return invokeIns, nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[95], 1);if invokeCC.Name == "lscc" {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[103], 1);
		if string(cis.ChaincodeSpec.Input.Args[0]) == "upgrade" {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[104], 1);
			upgradeIns, err := v.getUpgradeTxInstance(chainID, cis.ChaincodeSpec.Input.Args[2])
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[106], 1);
				return invokeIns, nil, nil
			}
			_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[105], 1);return invokeIns, upgradeIns, nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[96], 1);return invokeIns, nil, nil
}

func (v *TxValidator) getUpgradeTxInstance(chainID string, cdsBytes []byte) (*sysccprovider.ChaincodeInstance, error) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[107], 1);
	cds, err := utils.GetChaincodeDeploymentSpec(cdsBytes, platforms.NewRegistry(&golang.Platform{}))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[109], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[108], 1);return &sysccprovider.ChaincodeInstance{
		ChainID:          chainID,
		ChaincodeName:    cds.ChaincodeSpec.ChaincodeId.Name,
		ChaincodeVersion: cds.ChaincodeSpec.ChaincodeId.Version,
	}, nil
}

type dynamicDeserializer struct {
	support Support
}

func (ds *dynamicDeserializer) DeserializeIdentity(serializedIdentity []byte) (msp.Identity, error) {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[110], 1);
	return ds.support.MSPManager().DeserializeIdentity(serializedIdentity)
}

func (ds *dynamicDeserializer) IsWellFormed(identity *mspprotos.SerializedIdentity) error {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[111], 1);
	return ds.support.MSPManager().IsWellFormed(identity)
}

type dynamicCapabilities struct {
	support Support
}

func (ds *dynamicCapabilities) ACLs() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[112], 1);
	return ds.support.Capabilities().ACLs()
}

func (ds *dynamicCapabilities) CollectionUpgrade() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[113], 1);
	return ds.support.Capabilities().CollectionUpgrade()
}

// FabToken returns true if fabric token function is supported.
func (ds *dynamicCapabilities) FabToken() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[114], 1);
	return ds.support.Capabilities().FabToken()
}

func (ds *dynamicCapabilities) ForbidDuplicateTXIdInBlock() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[115], 1);
	return ds.support.Capabilities().ForbidDuplicateTXIdInBlock()
}

func (ds *dynamicCapabilities) KeyLevelEndorsement() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[116], 1);
	return ds.support.Capabilities().KeyLevelEndorsement()
}

func (ds *dynamicCapabilities) MetadataLifecycle() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[117], 1);
	return ds.support.Capabilities().MetadataLifecycle()
}

func (ds *dynamicCapabilities) PrivateChannelData() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[118], 1);
	return ds.support.Capabilities().PrivateChannelData()
}

func (ds *dynamicCapabilities) Supported() error {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[119], 1);
	return ds.support.Capabilities().Supported()
}

func (ds *dynamicCapabilities) V1_1Validation() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[120], 1);
	return ds.support.Capabilities().V1_1Validation()
}

func (ds *dynamicCapabilities) V1_2Validation() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[121], 1);
	return ds.support.Capabilities().V1_2Validation()
}

func (ds *dynamicCapabilities) V1_3Validation() bool {_cover_atomic_.AddUint32(&GoCover_1_653337613337663834376338.Count[122], 1);
	return ds.support.Capabilities().V1_3Validation()
}

var GoCover_1_653337613337663834376338 = struct {
	Count     [123]uint32
	Pos       [3 * 123]uint32
	NumStmt   [123]uint16
} {
	Pos: [3 * 123]uint32{
		99, 106, 0x20080, // [0]
		108, 111, 0x20036, // [1]
		133, 150, 0xc003b, // [2]
		167, 170, 0x2c0002, // [3]
		205, 205, 0x100002, // [4]
		211, 211, 0x3b0002, // [5]
		218, 222, 0x100002, // [6]
		227, 234, 0xc0002, // [7]
		150, 151, 0x28000c, // [8]
		151, 155, 0x240028, // [9]
		155, 163, 0x50024, // [10]
		170, 173, 0x15002c, // [11]
		173, 179, 0x270015, // [12]
		179, 182, 0x50027, // [13]
		183, 190, 0x390009, // [14]
		190, 191, 0x240039, // [15]
		194, 194, 0x280005, // [16]
		197, 197, 0x230005, // [17]
		191, 193, 0x60024, // [18]
		194, 196, 0x60028, // [19]
		205, 207, 0x30010, // [20]
		211, 213, 0x3003b, // [21]
		222, 224, 0x30010, // [22]
		239, 240, 0x1d0065, // [23]
		246, 246, 0xc0002, // [24]
		240, 241, 0x46001d, // [25]
		241, 243, 0x40046, // [26]
		249, 252, 0x1e004f, // [27]
		252, 253, 0x11001e, // [28]
		257, 258, 0x90003, // [29]
		253, 254, 0xc0011, // [30]
		258, 261, 0x40009, // [31]
		261, 263, 0x40009, // [32]
		267, 273, 0xe0066, // [33]
		280, 280, 0x3b0002, // [34]
		273, 278, 0x3000e, // [35]
		280, 287, 0x3003b, // [36]
		287, 287, 0x170008, // [37]
		287, 301, 0x810017, // [38]
		310, 311, 0x110003, // [39]
		320, 323, 0x1e0003, // [40]
		332, 332, 0x4d0003, // [41]
		445, 445, 0x2f0003, // [42]
		454, 461, 0x90003, // [43]
		301, 308, 0x40081, // [44]
		311, 318, 0x40011, // [45]
		323, 330, 0x4001e, // [46]
		332, 338, 0x23004d, // [47]
		344, 346, 0x120004, // [48]
		370, 371, 0x120004, // [49]
		379, 380, 0x180004, // [50]
		338, 341, 0x50023, // [51]
		346, 348, 0x170012, // [52]
		349, 354, 0xc0032, // [53]
		355, 360, 0xc0033, // [54]
		361, 366, 0xc000d, // [55]
		371, 378, 0x50012, // [56]
		380, 383, 0x50018, // [57]
		413, 413, 0x460009, // [58]
		413, 415, 0x120046, // [59]
		425, 425, 0x3a0004, // [60]
		434, 434, 0x460004, // [61]
		415, 423, 0x50012, // [62]
		425, 433, 0x5003a, // [63]
		435, 443, 0x40009, // [64]
		445, 452, 0x4002f, // [65]
		462, 469, 0x30008, // [66]
		477, 487, 0x10008d, // [67]
		497, 497, 0x5f0002, // [68]
		508, 508, 0xc0002, // [69]
		487, 493, 0x30010, // [70]
		497, 504, 0x3005f, // [71]
		512, 514, 0x20044, // [72]
		517, 518, 0x2500d0, // [73]
		523, 525, 0x2e0002, // [74]
		548, 548, 0x2a0002, // [75]
		518, 520, 0x30025, // [76]
		525, 526, 0x10002e, // [77]
		529, 531, 0x450003, // [78]
		526, 527, 0xc0010, // [79]
		531, 534, 0x40045, // [80]
		534, 534, 0x1d0009, // [81]
		534, 541, 0x4001d, // [82]
		541, 544, 0x40009, // [83]
		548, 549, 0x10002a, // [84]
		552, 553, 0x330003, // [85]
		549, 550, 0xc0010, // [86]
		553, 554, 0x1d0033, // [87]
		554, 557, 0x5001d, // [88]
		562, 565, 0x100088, // [89]
		570, 574, 0x100002, // [90]
		577, 582, 0x100002, // [91]
		588, 589, 0x100002, // [92]
		595, 596, 0x100002, // [93]
		602, 604, 0x100002, // [94]
		609, 609, 0x1d0002, // [95]
		619, 619, 0x1c0002, // [96]
		565, 567, 0x30010, // [97]
		574, 576, 0x30010, // [98]
		582, 585, 0x30010, // [99]
		589, 592, 0x30010, // [100]
		596, 599, 0x30010, // [101]
		604, 607, 0x30010, // [102]
		609, 610, 0x3b001d, // [103]
		610, 612, 0x12003b, // [104]
		615, 615, 0x250004, // [105]
		612, 614, 0x50012, // [106]
		622, 624, 0x100077, // [107]
		628, 632, 0x80002, // [108]
		624, 626, 0x30010, // [109]
		639, 641, 0x20065, // [110]
		643, 645, 0x2005b, // [111]
		651, 653, 0x2002c, // [112]
		655, 657, 0x20039, // [113]
		660, 662, 0x20030, // [114]
		664, 666, 0x20042, // [115]
		668, 670, 0x2003b, // [116]
		672, 674, 0x20039, // [117]
		676, 678, 0x2003a, // [118]
		680, 682, 0x20032, // [119]
		684, 686, 0x20036, // [120]
		688, 690, 0x20036, // [121]
		692, 694, 0x20036, // [122]
	},
	NumStmt: [123]uint16{
		2, // 0
		1, // 1
		10, // 2
		2, // 3
		1, // 4
		1, // 5
		3, // 6
		5, // 7
		1, // 8
		2, // 9
		2, // 10
		2, // 11
		2, // 12
		2, // 13
		3, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		2, // 29
		1, // 30
		2, // 31
		1, // 32
		5, // 33
		1, // 34
		2, // 35
		3, // 36
		1, // 37
		8, // 38
		2, // 39
		3, // 40
		1, // 41
		1, // 42
		2, // 43
		3, // 44
		3, // 45
		3, // 46
		3, // 47
		3, // 48
		2, // 49
		2, // 50
		2, // 51
		2, // 52
		2, // 53
		2, // 54
		2, // 55
		3, // 56
		2, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		4, // 62
		4, // 63
		3, // 64
		3, // 65
		3, // 66
		3, // 67
		1, // 68
		1, // 69
		2, // 70
		2, // 71
		1, // 72
		1, // 73
		3, // 74
		1, // 75
		1, // 76
		1, // 77
		2, // 78
		1, // 79
		2, // 80
		1, // 81
		4, // 82
		2, // 83
		1, // 84
		2, // 85
		1, // 86
		1, // 87
		2, // 88
		2, // 89
		3, // 90
		4, // 91
		2, // 92
		2, // 93
		3, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		2, // 99
		2, // 100
		2, // 101
		2, // 102
		1, // 103
		2, // 104
		1, // 105
		1, // 106
		2, // 107
		1, // 108
		1, // 109
		1, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		1, // 119
		1, // 120
		1, // 121
		1, // 122
	},
}
var _ = _cover_atomic_.LoadUint32
