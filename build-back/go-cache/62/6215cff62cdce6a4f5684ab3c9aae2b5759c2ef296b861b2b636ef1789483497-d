//line /home/cooper/go/src/github.com/hyperledger/fabric/common/deliver/deliver.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package deliver; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"io"
	"math"
	"strconv"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/blockledger"
	"github.com/hyperledger/fabric/common/policies"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/comm"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("common.deliver")

//go:generate counterfeiter -o mock/chain_manager.go -fake-name ChainManager . ChainManager

// ChainManager provides a way for the Handler to look up the Chain.
type ChainManager interface {
	GetChain(chainID string) Chain
}

//go:generate counterfeiter -o mock/chain.go -fake-name Chain . Chain

// Chain encapsulates chain operations and data.
type Chain interface {
	// Sequence returns the current config sequence number, can be used to detect config changes
	Sequence() uint64

	// PolicyManager returns the current policy manager as specified by the chain configuration
	PolicyManager() policies.Manager

	// Reader returns the chain Reader for the chain
	Reader() blockledger.Reader

	// Errored returns a channel which closes when the backing consenter has errored
	Errored() <-chan struct{}
}

//go:generate counterfeiter -o mock/policy_checker.go -fake-name PolicyChecker . PolicyChecker

// PolicyChecker checks the envelope against the policy logic supplied by the
// function.
type PolicyChecker interface {
	CheckPolicy(envelope *cb.Envelope, channelID string) error
}

// The PolicyCheckerFunc is an adapter that allows the use of an ordinary
// function as a PolicyChecker.
type PolicyCheckerFunc func(envelope *cb.Envelope, channelID string) error

// CheckPolicy calls pcf(envelope, channelID)
func (pcf PolicyCheckerFunc) CheckPolicy(envelope *cb.Envelope, channelID string) error {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[0], 1);
	return pcf(envelope, channelID)
}

//go:generate counterfeiter -o mock/inspector.go -fake-name Inspector . Inspector

// Inspector verifies an appropriate binding between the message and the context.
type Inspector interface {
	Inspect(context.Context, proto.Message) error
}

// The InspectorFunc is an adapter that allows the use of an ordinary
// function as an Inspector.
type InspectorFunc func(context.Context, proto.Message) error

// Inspect calls inspector(ctx, p)
func (inspector InspectorFunc) Inspect(ctx context.Context, p proto.Message) error {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[1], 1);
	return inspector(ctx, p)
}

// Handler handles server requests.
type Handler struct {
	ChainManager     ChainManager
	TimeWindow       time.Duration
	BindingInspector Inspector
	Metrics          *Metrics
}

//go:generate counterfeiter -o mock/receiver.go -fake-name Receiver . Receiver

// Receiver is used to receive enveloped seek requests.
type Receiver interface {
	Recv() (*cb.Envelope, error)
}

//go:generate counterfeiter -o mock/response_sender.go -fake-name ResponseSender . ResponseSender

// ResponseSender defines the interface a handler must implement to send
// responses.
type ResponseSender interface {
	SendStatusResponse(status cb.Status) error
	SendBlockResponse(block *cb.Block) error
}

// Filtered is a marker interface that indicates a response sender
// is configured to send filtered blocks
type Filtered interface {
	IsFiltered() bool
}

// Server is a polymorphic structure to support generalization of this handler
// to be able to deliver different type of responses.
type Server struct {
	Receiver
	PolicyChecker
	ResponseSender
}

// ExtractChannelHeaderCertHash extracts the TLS cert hash from a channel header.
func ExtractChannelHeaderCertHash(msg proto.Message) []byte {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[2], 1);
	chdr, isChannelHeader := msg.(*cb.ChannelHeader)
	if !isChannelHeader || chdr == nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[4], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[3], 1);return chdr.TlsCertHash
}

// NewHandler creates an implementation of the Handler interface.
func NewHandler(cm ChainManager, timeWindow time.Duration, mutualTLS bool, metrics *Metrics) *Handler {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[5], 1);
	return &Handler{
		ChainManager:     cm,
		TimeWindow:       timeWindow,
		BindingInspector: InspectorFunc(comm.NewBindingInspector(mutualTLS, ExtractChannelHeaderCertHash)),
		Metrics:          metrics,
	}
}

// Handle receives incoming deliver requests.
func (h *Handler) Handle(ctx context.Context, srv *Server) error {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[6], 1);
	addr := util.ExtractRemoteAddress(ctx)
	logger.Debugf("Starting new deliver loop for %s", addr)
	h.Metrics.StreamsOpened.Add(1)
	defer h.Metrics.StreamsClosed.Add(1)
	for {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[7], 1);
		logger.Debugf("Attempting to read seek info message from %s", addr)
		envelope, err := srv.Recv()
		if err == io.EOF {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[13], 1);
			logger.Debugf("Received EOF from %s, hangup", addr)
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[8], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[14], 1);
			logger.Warningf("Error reading from %s: %s", addr, err)
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[9], 1);status, err := h.deliverBlocks(ctx, srv, envelope)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[15], 1);
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[10], 1);err = srv.SendStatusResponse(status)
		if status != cb.Status_SUCCESS {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[16], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[11], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[17], 1);
			logger.Warningf("Error sending to %s: %s", addr, err)
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[12], 1);logger.Debugf("Waiting for new SeekInfo from %s", addr)
	}
}

func isFiltered(srv *Server) bool {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[18], 1);
	if filtered, ok := srv.ResponseSender.(Filtered); ok {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[20], 1);
		return filtered.IsFiltered()
	}
	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[19], 1);return false
}

func (h *Handler) deliverBlocks(ctx context.Context, srv *Server, envelope *cb.Envelope) (status cb.Status, err error) {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[21], 1);
	addr := util.ExtractRemoteAddress(ctx)
	payload, err := utils.UnmarshalPayload(envelope.Payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[35], 1);
		logger.Warningf("Received an envelope from %s with no payload: %s", addr, err)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[22], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[36], 1);
		logger.Warningf("Malformed envelope received from %s with bad header", addr)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[23], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[37], 1);
		logger.Warningf("Failed to unmarshal channel header from %s: %s", addr, err)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[24], 1);err = h.validateChannelHeader(ctx, chdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[38], 1);
		logger.Warningf("Rejecting deliver for %s due to envelope validation error: %s", addr, err)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[25], 1);chain := h.ChainManager.GetChain(chdr.ChannelId)
	if chain == nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[39], 1);
		// Note, we log this at DEBUG because SDKs will poll waiting for channels to be created
		// So we would expect our log to be somewhat flooded with these
		logger.Debugf("Rejecting deliver for %s because channel %s not found", addr, chdr.ChannelId)
		return cb.Status_NOT_FOUND, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[26], 1);labels := []string{
		"channel", chdr.ChannelId,
		"filtered", strconv.FormatBool(isFiltered(srv)),
	}
	h.Metrics.RequestsReceived.With(labels...).Add(1)
	defer func() {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[40], 1);
		labels := append(labels, "success", strconv.FormatBool(status == cb.Status_SUCCESS))
		h.Metrics.RequestsCompleted.With(labels...).Add(1)
	}()

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[27], 1);erroredChan := chain.Errored()
	select {
	case <-erroredChan:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[41], 1);
		logger.Warningf("[channel: %s] Rejecting deliver request for %s because of consenter error", chdr.ChannelId, addr)
		return cb.Status_SERVICE_UNAVAILABLE, nil
	default:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[42], 1);
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[28], 1);accessControl, err := NewSessionAC(chain, envelope, srv.PolicyChecker, chdr.ChannelId, crypto.ExpiresAt)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[43], 1);
		logger.Warningf("[channel: %s] failed to create access control object due to %s", chdr.ChannelId, err)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[29], 1);if err := accessControl.Evaluate(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[44], 1);
		logger.Warningf("[channel: %s] Client authorization revoked for deliver request from %s: %s", chdr.ChannelId, addr, err)
		return cb.Status_FORBIDDEN, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[30], 1);seekInfo := &ab.SeekInfo{}
	if err = proto.Unmarshal(payload.Data, seekInfo); err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[45], 1);
		logger.Warningf("[channel: %s] Received a signed deliver request from %s with malformed seekInfo payload: %s", chdr.ChannelId, addr, err)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[31], 1);if seekInfo.Start == nil || seekInfo.Stop == nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[46], 1);
		logger.Warningf("[channel: %s] Received seekInfo message from %s with missing start or stop %v, %v", chdr.ChannelId, addr, seekInfo.Start, seekInfo.Stop)
		return cb.Status_BAD_REQUEST, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[32], 1);logger.Debugf("[channel: %s] Received seekInfo (%p) %v from %s", chdr.ChannelId, seekInfo, seekInfo, addr)

	cursor, number := chain.Reader().Iterator(seekInfo.Start)
	defer cursor.Close()
	var stopNum uint64
	switch stop := seekInfo.Stop.Type.(type) {
	case *ab.SeekPosition_Oldest:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[47], 1);
		stopNum = number
	case *ab.SeekPosition_Newest:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[48], 1);
		stopNum = chain.Reader().Height() - 1
	case *ab.SeekPosition_Specified:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[49], 1);
		stopNum = stop.Specified.Number
		if stopNum < number {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[50], 1);
			logger.Warningf("[channel: %s] Received invalid seekInfo message from %s: start number %d greater than stop number %d", chdr.ChannelId, addr, number, stopNum)
			return cb.Status_BAD_REQUEST, nil
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[33], 1);for {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[51], 1);
		if seekInfo.Behavior == ab.SeekInfo_FAIL_IF_NOT_READY {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[58], 1);
			if number > chain.Reader().Height()-1 {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[59], 1);
				return cb.Status_NOT_FOUND, nil
			}
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[52], 1);var block *cb.Block
		var status cb.Status

		iterCh := make(chan struct{})
		go func() {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[60], 1);
			block, status = cursor.Next()
			close(iterCh)
		}()

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[53], 1);select {
		case <-ctx.Done():_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[61], 1);
			logger.Debugf("Context canceled, aborting wait for next block")
			return cb.Status_INTERNAL_SERVER_ERROR, errors.Wrapf(ctx.Err(), "context finished before block retrieved")
		case <-erroredChan:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[62], 1);
			logger.Warningf("Aborting deliver for request because of background error")
			return cb.Status_SERVICE_UNAVAILABLE, nil
		case <-iterCh:_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[63], 1);
			// Iterator has set the block and status vars
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[54], 1);if status != cb.Status_SUCCESS {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[64], 1);
			logger.Errorf("[channel: %s] Error reading from channel, cause was: %v", chdr.ChannelId, status)
			return status, nil
		}

		// increment block number to support FAIL_IF_NOT_READY deliver behavior
		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[55], 1);number++

		if err := accessControl.Evaluate(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[65], 1);
			logger.Warningf("[channel: %s] Client authorization revoked for deliver request from %s: %s", chdr.ChannelId, addr, err)
			return cb.Status_FORBIDDEN, nil
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[56], 1);logger.Debugf("[channel: %s] Delivering block for (%p) for %s", chdr.ChannelId, seekInfo, addr)

		if err := srv.SendBlockResponse(block); err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[66], 1);
			logger.Warningf("[channel: %s] Error sending to %s: %s", chdr.ChannelId, addr, err)
			return cb.Status_INTERNAL_SERVER_ERROR, err
		}

		_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[57], 1);h.Metrics.BlocksSent.With(labels...).Add(1)

		if stopNum == block.Header.Number {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[67], 1);
			break
		}
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[34], 1);logger.Debugf("[channel: %s] Done delivering to %s for (%p)", chdr.ChannelId, addr, seekInfo)

	return cb.Status_SUCCESS, nil
}

func (h *Handler) validateChannelHeader(ctx context.Context, chdr *cb.ChannelHeader) error {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[68], 1);
	if chdr.GetTimestamp() == nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[72], 1);
		err := errors.New("channel header in envelope must contain timestamp")
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[69], 1);envTime := time.Unix(chdr.GetTimestamp().Seconds, int64(chdr.GetTimestamp().Nanos)).UTC()
	serverTime := time.Now()

	if math.Abs(float64(serverTime.UnixNano()-envTime.UnixNano())) > float64(h.TimeWindow.Nanoseconds()) {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[73], 1);
		err := errors.Errorf("envelope timestamp %s is more than %s apart from current server time %s", envTime, h.TimeWindow, serverTime)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[70], 1);err := h.BindingInspector.Inspect(ctx, chdr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[74], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_1_313735643635643662363634.Count[71], 1);return nil
}

var GoCover_1_313735643635643662363634 = struct {
	Count     [75]uint32
	Pos       [3 * 75]uint32
	NumStmt   [75]uint16
} {
	Pos: [3 * 75]uint32{
		68, 70, 0x20059, // [0]
		84, 86, 0x20054, // [1]
		127, 129, 0x25003d, // [2]
		132, 132, 0x190002, // [3]
		129, 131, 0x30025, // [4]
		136, 143, 0x20067, // [5]
		146, 151, 0x60042, // [6]
		151, 154, 0x140006, // [7]
		158, 158, 0x110003, // [8]
		163, 164, 0x110003, // [9]
		168, 169, 0x220003, // [10]
		172, 172, 0x110003, // [11]
		177, 177, 0x3a0003, // [12]
		154, 157, 0x40014, // [13]
		158, 161, 0x40011, // [14]
		164, 166, 0x40011, // [15]
		169, 171, 0x40022, // [16]
		172, 175, 0x40011, // [17]
		181, 182, 0x370023, // [18]
		185, 185, 0xe0002, // [19]
		182, 184, 0x30037, // [20]
		188, 191, 0x100078, // [21]
		196, 196, 0x1b0002, // [22]
		201, 202, 0x100002, // [23]
		207, 208, 0x100002, // [24]
		213, 214, 0x120002, // [25]
		221, 226, 0xf0002, // [26]
		231, 232, 0x90002, // [27]
		239, 240, 0x100002, // [28]
		245, 245, 0x310002, // [29]
		250, 251, 0x3f0002, // [30]
		256, 256, 0x330002, // [31]
		261, 266, 0x2b0002, // [32]
		279, 279, 0x60002, // [33]
		333, 335, 0x1f0002, // [34]
		191, 194, 0x30010, // [35]
		196, 199, 0x3001b, // [36]
		202, 205, 0x30010, // [37]
		208, 211, 0x30010, // [38]
		214, 219, 0x30012, // [39]
		226, 229, 0x3000f, // [40]
		233, 235, 0x2c0015, // [41]
		236, 236, 0xa000a, // [42]
		240, 243, 0x30010, // [43]
		245, 248, 0x30031, // [44]
		251, 254, 0x3003f, // [45]
		256, 259, 0x30033, // [46]
		267, 268, 0x13001f, // [47]
		269, 270, 0x28001f, // [48]
		271, 273, 0x170022, // [49]
		273, 276, 0x40017, // [50]
		279, 280, 0x390006, // [51]
		286, 290, 0xd0003, // [52]
		295, 295, 0xa0003, // [53]
		306, 306, 0x220003, // [54]
		312, 314, 0x320003, // [55]
		319, 321, 0x360003, // [56]
		326, 328, 0x250003, // [57]
		280, 281, 0x2a0039, // [58]
		281, 283, 0x5002a, // [59]
		290, 293, 0x4000d, // [60]
		296, 298, 0x6e0015, // [61]
		299, 301, 0x2d0016, // [62]
		302, 302, 0x110011, // [63]
		306, 309, 0x40022, // [64]
		314, 317, 0x40032, // [65]
		321, 324, 0x40036, // [66]
		328, 329, 0x90025, // [67]
		338, 339, 0x20005c, // [68]
		344, 347, 0x670002, // [69]
		352, 353, 0x100002, // [70]
		357, 357, 0xc0002, // [71]
		339, 342, 0x30020, // [72]
		347, 350, 0x30067, // [73]
		353, 355, 0x30010, // [74]
	},
	NumStmt: [75]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		5, // 6
		3, // 7
		1, // 8
		2, // 9
		2, // 10
		1, // 11
		1, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		3, // 21
		1, // 22
		2, // 23
		2, // 24
		2, // 25
		3, // 26
		2, // 27
		2, // 28
		1, // 29
		2, // 30
		1, // 31
		5, // 32
		1, // 33
		2, // 34
		2, // 35
		2, // 36
		2, // 37
		2, // 38
		2, // 39
		2, // 40
		2, // 41
		0, // 42
		2, // 43
		2, // 44
		2, // 45
		2, // 46
		1, // 47
		1, // 48
		2, // 49
		2, // 50
		1, // 51
		4, // 52
		1, // 53
		1, // 54
		2, // 55
		2, // 56
		2, // 57
		1, // 58
		1, // 59
		2, // 60
		2, // 61
		2, // 62
		0, // 63
		2, // 64
		2, // 65
		2, // 66
		1, // 67
		1, // 68
		3, // 69
		2, // 70
		1, // 71
		2, // 72
		2, // 73
		1, // 74
	},
}
var _ = _cover_atomic_.LoadUint32
