//line /home/cooper/go/src/github.com/hyperledger/fabric/core/common/validation/statebased/vpmanagerimpl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package statebased; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/handlers/validation/api/state"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("vscc")

/**********************************************************************************************************/
/**********************************************************************************************************/

type ledgerKeyID struct {
	cc   string
	coll string
	key  string
}

func newLedgerKeyID(cc, coll, key string) *ledgerKeyID {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[0], 1);
	return &ledgerKeyID{cc, coll, key}
}

/**********************************************************************************************************/
/**********************************************************************************************************/

// txDependency provides synchronization mechanisms for a transaction's
// dependencies at a vscc scope, where transactions are validated on a per-
// namespace basis:
// -) the pair waitForDepInserted() / signalDepInserted() is used to sync on
//    insertion of dependencies
// -) the pair waitForAndRetrieveValidationResult() / signalValidationResult()
//    is used to sync on the validation results for a given namespace
type txDependency struct {
	mutex               sync.Mutex
	cond                *sync.Cond
	validationResultMap map[string]error
	depInserted         chan struct{}
}

func newTxDependency() *txDependency {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[1], 1);
	txd := &txDependency{
		depInserted:         make(chan struct{}),
		validationResultMap: make(map[string]error),
	}
	txd.cond = sync.NewCond(&txd.mutex)
	return txd
}

// waitForDepInserted waits until dependencies introduced by a transaction
// have been inserted. The function returns as soon as
// d.depInserted has been closed by signalDepInserted
func (d *txDependency) waitForDepInserted() {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[2], 1);
	<-d.depInserted
}

// signalDepInserted signals that transactions dependencies introduced
// by transaction d.txNum have been inserted. The function
// closes d.depInserted, causing all callers of waitForDepInserted to
// return. This function can only be called once on this object
func (d *txDependency) signalDepInserted() {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[3], 1);
	close(d.depInserted)
}

// waitForAndRetrieveValidationResult returns the validation results
// for namespace `ns` - possibly waiting for the corresponding call
// to signalValidationResult to finish first.
func (d *txDependency) waitForAndRetrieveValidationResult(ns string) error {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[4], 1);
	d.mutex.Lock()
	defer d.mutex.Unlock()

	err, ok := d.validationResultMap[ns]
	if ok {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[7], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[5], 1);for !ok {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[8], 1);
		d.cond.Wait()
		err, ok = d.validationResultMap[ns]
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[6], 1);return err
}

// signalValidationResult signals that validation of namespace `ns`
// for transaction `d.txnum` completed with error `err`. Results
// are cached into a map. We also broadcast a conditional variable
// to wake up possible callers of waitForAndRetrieveValidationResult
func (d *txDependency) signalValidationResult(ns string, err error) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[9], 1);
	d.mutex.Lock()
	defer d.mutex.Unlock()

	d.validationResultMap[ns] = err
	d.cond.Broadcast()
}

/**********************************************************************************************************/
/**********************************************************************************************************/

// validationContext captures the all dependencies within a single block
type validationContext struct {
	// mutex ensures that only one goroutine at a
	// time will modify blockHeight, depsByTxnumMap
	// or depsByLedgerKeyIDMap
	mutex                sync.RWMutex
	blockHeight          uint64
	depsByTxnumMap       map[uint64]*txDependency
	depsByLedgerKeyIDMap map[ledgerKeyID]map[uint64]*txDependency
}

func (c *validationContext) forBlock(newHeight uint64) *validationContext {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[10], 1);
	c.mutex.RLock()
	curHeight := c.blockHeight
	c.mutex.RUnlock()

	if curHeight > newHeight {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[13], 1);
		logger.Panicf("programming error: block with number %d validated after block with number %d", newHeight, curHeight)
	}

	// block 0 is the genesis block, and so the first block that comes here
	// will actually be block 1, forcing a reset
	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[11], 1);if curHeight < newHeight {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[14], 1);
		c.mutex.Lock()
		defer c.mutex.Unlock()

		if c.blockHeight < newHeight {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[15], 1);
			c.blockHeight = newHeight
			c.depsByLedgerKeyIDMap = map[ledgerKeyID]map[uint64]*txDependency{}
			c.depsByTxnumMap = map[uint64]*txDependency{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[12], 1);return c
}

func (c *validationContext) addDependency(kid *ledgerKeyID, txnum uint64, dep *txDependency) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[16], 1);
	c.mutex.Lock()
	defer c.mutex.Unlock()

	// create map if necessary
	_, ok := c.depsByLedgerKeyIDMap[*kid]
	if !ok {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[18], 1);
		c.depsByLedgerKeyIDMap[*kid] = map[uint64]*txDependency{}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[17], 1);c.depsByLedgerKeyIDMap[*kid][txnum] = dep
}

func (c *validationContext) dependenciesForTxnum(kid *ledgerKeyID, txnum uint64) []*txDependency {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[19], 1);
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	var deps []*txDependency

	dl, in := c.depsByLedgerKeyIDMap[*kid]
	if in {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[21], 1);
		deps = make([]*txDependency, 0, len(dl))
		for depTxnum, dep := range dl {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[22], 1);
			if depTxnum < txnum {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[23], 1);
				deps = append(deps, dep)
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[20], 1);return deps
}

func (c *validationContext) getOrCreateDependencyByTxnum(txnum uint64) *txDependency {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[24], 1);
	c.mutex.RLock()
	dep, ok := c.depsByTxnumMap[txnum]
	c.mutex.RUnlock()

	if !ok {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[26], 1);
		c.mutex.Lock()
		defer c.mutex.Unlock()
		dep, ok = c.depsByTxnumMap[txnum]
		if !ok {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[27], 1);
			dep = newTxDependency()
			c.depsByTxnumMap[txnum] = dep
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[25], 1);return dep
}

func (c *validationContext) waitForValidationResults(kid *ledgerKeyID, blockNum uint64, txnum uint64) error {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[28], 1);
	// in the code below we see whether any transaction in this block
	// that precedes txnum introduces a dependency. We do so by
	// extracting from the map all txDependency instances for txnum
	// strictly lower than ours and retrieving their validation
	// result. If the validation result of *any* of them is a nil
	// error, we have a dependency. Otherwise we have no dependency.
	// Note that depsMap is iterated in non-predictable order.
	// This does not violate correctness, since the hasDependencies
	// should return true if *any* dependency has been introduced

	// we proceed in two steps:
	// 1) while holding the mutex, we get a snapshot of all dependencies
	//    that affect us and put them in a local slice; we then release
	//    the mutex
	// 2) we traverse the slice of dependencies and for each, retrieve
	//    the validartion result
	// The two step approach is required to avoid a deadlock where the
	// consumer (the caller of this function) holds the mutex and thus
	// prevents the producer (the caller of signalValidationResult) to
	// produce the result.

	for _, dep := range c.dependenciesForTxnum(kid, txnum) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[30], 1);
		if valErr := dep.waitForAndRetrieveValidationResult(kid.cc); valErr == nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[31], 1);
			return &ValidationParameterUpdatedError{
				CC:     kid.cc,
				Coll:   kid.coll,
				Key:    kid.key,
				Height: blockNum,
				Txnum:  txnum,
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[29], 1);return nil
}

/**********************************************************************************************************/
/**********************************************************************************************************/

type KeyLevelValidationParameterManagerImpl struct {
	StateFetcher  validation.StateFetcher
	validationCtx validationContext
}

// ExtractValidationParameterDependency implements the method of
// the same name of the KeyLevelValidationParameterManager interface
// Note that this function doesn't take any namespace argument. This is
// because we want to inspect all namespaces for which this transaction
// modifies metadata.
func (m *KeyLevelValidationParameterManagerImpl) ExtractValidationParameterDependency(blockNum, txNum uint64, rwsetBytes []byte) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[32], 1);
	vCtx := m.validationCtx.forBlock(blockNum)

	// this object represents the dependency that transaction (blockNum, txNum) introduces
	dep := vCtx.getOrCreateDependencyByTxnum(txNum)

	rwset := &rwsetutil.TxRwSet{}
	err := rwset.FromProtoBytes(rwsetBytes)
	// note that we silently discard broken read-write
	// sets - ledger will invalidate them anyway
	if err == nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[34], 1);
		// here we cycle through all metadata updates generated by this transaction
		// and signal that transaction (blockNum, txNum) modifies them so that
		// all subsequent transaction know they have to wait for validation of
		// transaction (blockNum, txNum) before they can continue
		for _, rws := range rwset.NsRwSets {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[35], 1);
			for _, mw := range rws.KvRwSet.MetadataWrites {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[37], 1);
				// record the fact that this key has a dependency on our tx
				vCtx.addDependency(newLedgerKeyID(rws.NameSpace, "", mw.Key), txNum, dep)
			}

			_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[36], 1);for _, cw := range rws.CollHashedRwSets {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[38], 1);
				for _, mw := range cw.HashedRwSet.MetadataWrites {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[39], 1);
					// record the fact that this (pvt) key has a dependency on our tx
					vCtx.addDependency(newLedgerKeyID(rws.NameSpace, cw.CollectionName, string(mw.KeyHash)), txNum, dep)
				}
			}
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[40], 1);{
		logger.Warningf("unmarshalling the read write set returned error '%s', skipping", err)
	}}

	// signal that we have introduced all dependencies for this transaction
	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[33], 1);dep.signalDepInserted()
}

// GetValidationParameterForKey implements the method of
// the same name of the KeyLevelValidationParameterManager interface
func (m *KeyLevelValidationParameterManagerImpl) GetValidationParameterForKey(cc, coll, key string, blockNum, txNum uint64) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[41], 1);
	vCtx := m.validationCtx.forBlock(blockNum)

	// wait until all txes before us have introduced dependencies
	for i := int64(txNum) - 1; i >= 0; i-- {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[46], 1);
		txdep := vCtx.getOrCreateDependencyByTxnum(uint64(i))
		txdep.waitForDepInserted()
	}

	// wait until the validation results for all dependencies in the cc namespace are available
	// bail, if the validation parameter has been updated in the meantime
	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[42], 1);err := vCtx.waitForValidationResults(newLedgerKeyID(cc, coll, key), blockNum, txNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[47], 1);
		logger.Errorf(err.Error())
		return nil, err
	}

	// if we're here, it means that it is safe to retrieve validation
	// parameters for the requested key from the ledger

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[43], 1);state, err := m.StateFetcher.FetchState()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[48], 1);
		err = errors.WithMessage(err, "could not retrieve ledger")
		logger.Errorf(err.Error())
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[44], 1);defer state.Done()

	var mdMap map[string][]byte
	if coll == "" {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[49], 1);
		mdMap, err = state.GetStateMetadata(cc, key)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[50], 1);
			err = errors.WithMessage(err, fmt.Sprintf("could not retrieve metadata for %s:%s", cc, key))
			logger.Errorf(err.Error())
			return nil, err
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[51], 1);{
		mdMap, err = state.GetPrivateDataMetadataByHash(cc, coll, []byte(key))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[52], 1);
			err = errors.WithMessage(err, fmt.Sprintf("could not retrieve metadata for %s:%s:%x", cc, coll, []byte(key)))
			logger.Errorf(err.Error())
			return nil, err
		}
	}}

	_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[45], 1);return mdMap[pb.MetaDataKeys_VALIDATION_PARAMETER.String()], nil
}

// SetTxValidationCode implements the method of the same name of
// the KeyLevelValidationParameterManager interface. Note that
// this function receives a namespace argument so that it records
// the validation result for this transaction and for this chaincode.
func (m *KeyLevelValidationParameterManagerImpl) SetTxValidationResult(ns string, blockNum, txNum uint64, err error) {_cover_atomic_.AddUint32(&GoCover_2_616264363130383339383531.Count[53], 1);
	vCtx := m.validationCtx.forBlock(blockNum)

	// this object represents the dependency that the transaction of our caller introduces
	dep := vCtx.getOrCreateDependencyByTxnum(txNum)

	// signal the validation status of this tx
	dep.signalValidationResult(ns, err)
}

var GoCover_2_616264363130383339383531 = struct {
	Count     [54]uint32
	Pos       [3 * 54]uint32
	NumStmt   [54]uint16
} {
	Pos: [3 * 54]uint32{
		31, 33, 0x20038, // [0]
		52, 59, 0x20026, // [1]
		64, 66, 0x2002d, // [2]
		72, 74, 0x2002c, // [3]
		79, 84, 0x8004c, // [4]
		88, 88, 0xa0002, // [5]
		93, 93, 0xc0002, // [6]
		84, 86, 0x30008, // [7]
		88, 91, 0x3000a, // [8]
		100, 106, 0x20045, // [9]
		122, 127, 0x1b004b, // [10]
		133, 133, 0x1b0002, // [11]
		144, 144, 0xa0002, // [12]
		127, 129, 0x3001b, // [13]
		133, 137, 0x20001b, // [14]
		137, 141, 0x40020, // [15]
		147, 153, 0x9005e, // [16]
		157, 157, 0x2b0002, // [17]
		153, 155, 0x30009, // [18]
		160, 167, 0x80062, // [19]
		176, 176, 0xd0002, // [20]
		167, 169, 0x210008, // [21]
		169, 170, 0x180021, // [22]
		170, 172, 0x50018, // [23]
		179, 184, 0x90056, // [24]
		194, 194, 0xc0002, // [25]
		184, 188, 0xa0009, // [26]
		188, 191, 0x4000a, // [27]
		197, 219, 0x39006d, // [28]
		230, 230, 0xc0002, // [29]
		219, 220, 0x4e0039, // [30]
		220, 228, 0x4004e, // [31]
		246, 256, 0x100082, // [32]
		279, 279, 0x190002, // [33]
		256, 261, 0x260010, // [34]
		261, 262, 0x320026, // [35]
		267, 267, 0x2c0004, // [36]
		262, 265, 0x50032, // [37]
		267, 268, 0x36002c, // [38]
		268, 271, 0x60036, // [39]
		274, 276, 0x30008, // [40]
		284, 288, 0x29008d, // [41]
		295, 296, 0x100002, // [42]
		304, 305, 0x100002, // [43]
		310, 313, 0x100002, // [44]
		329, 329, 0x420002, // [45]
		288, 291, 0x30029, // [46]
		296, 299, 0x30010, // [47]
		305, 309, 0x30010, // [48]
		313, 315, 0x110010, // [49]
		315, 319, 0x40011, // [50]
		320, 322, 0x110008, // [51]
		322, 326, 0x40011, // [52]
		336, 344, 0x20076, // [53]
	},
	NumStmt: [54]uint16{
		1, // 0
		3, // 1
		1, // 2
		1, // 3
		4, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		4, // 9
		4, // 10
		1, // 11
		1, // 12
		1, // 13
		3, // 14
		3, // 15
		4, // 16
		1, // 17
		1, // 18
		5, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		4, // 24
		1, // 25
		4, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		5, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		2, // 41
		2, // 42
		2, // 43
		3, // 44
		1, // 45
		2, // 46
		2, // 47
		3, // 48
		2, // 49
		3, // 50
		2, // 51
		3, // 52
		3, // 53
	},
}
var _ = _cover_atomic_.LoadUint32
