//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/validator/valimpl/helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package valimpl; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"

	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/customtx"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/validator"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/validator/internal"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
)

// validateAndPreparePvtBatch pulls out the private write-set for the transactions that are marked as valid
// by the internal public data validator. Finally, it validates (if not already self-endorsed) the pvt rwset against the
// corresponding hash present in the public rwset
func validateAndPreparePvtBatch(block *internal.Block, db privacyenabledstate.DB,
	pubAndHashUpdates *internal.PubAndHashUpdates, pvtdata map[uint64]*ledger.TxPvtData) (*privacyenabledstate.PvtUpdateBatch, error) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[0], 1);
	pvtUpdates := privacyenabledstate.NewPvtUpdateBatch()
	metadataUpdates := metadataUpdates{}
	for _, tx := range block.Txs {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[3], 1);
		if tx.ValidationCode != peer.TxValidationCode_VALID {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[9], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[4], 1);if !tx.ContainsPvtWrites() {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[10], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[5], 1);txPvtdata := pvtdata[uint64(tx.IndexInBlock)]
		if txPvtdata == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[11], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[6], 1);if requiresPvtdataValidation(txPvtdata) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[12], 1);
			if err := validatePvtdata(tx, txPvtdata); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[13], 1);
				return nil, err
			}
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[7], 1);var pvtRWSet *rwsetutil.TxPvtRwSet
		var err error
		if pvtRWSet, err = rwsetutil.TxPvtRwSetFromProtoMsg(txPvtdata.WriteSet); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[14], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[8], 1);addPvtRWSetToPvtUpdateBatch(pvtRWSet, pvtUpdates, version.NewHeight(block.Num, uint64(tx.IndexInBlock)))
		addEntriesToMetadataUpdates(metadataUpdates, pvtRWSet)
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[1], 1);if err := incrementPvtdataVersionIfNeeded(metadataUpdates, pvtUpdates, pubAndHashUpdates, db); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[15], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[2], 1);return pvtUpdates, nil
}

// requiresPvtdataValidation returns whether or not a hashes of the collection should be computed
// for the collections of present in the private data
// TODO for now always return true. Add capabilty of checking if this data was produced by
// the validating peer itself during similation and in that case return false
func requiresPvtdataValidation(tx *ledger.TxPvtData) bool {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[16], 1);
	return true
}

// validPvtdata returns true if hashes of all the collections writeset present in the pvt data
// match with the corresponding hashes present in the public read-write set
func validatePvtdata(tx *internal.Transaction, pvtdata *ledger.TxPvtData) error {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[17], 1);
	if pvtdata.WriteSet == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[20], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[18], 1);for _, nsPvtdata := range pvtdata.WriteSet.NsPvtRwset {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[21], 1);
		for _, collPvtdata := range nsPvtdata.CollectionPvtRwset {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[22], 1);
			collPvtdataHash := util.ComputeHash(collPvtdata.Rwset)
			hashInPubdata := tx.RetrieveHash(nsPvtdata.Namespace, collPvtdata.CollectionName)
			if !bytes.Equal(collPvtdataHash, hashInPubdata) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[23], 1);
				return &validator.ErrPvtdataHashMissmatch{
					Msg: fmt.Sprintf(`Hash of pvt data for collection [%s:%s] does not match with the corresponding hash in the public data.
					public hash = [%#v], pvt data hash = [%#v]`, nsPvtdata.Namespace, collPvtdata.CollectionName, hashInPubdata, collPvtdataHash),
				}
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[19], 1);return nil
}

// preprocessProtoBlock parses the proto instance of block into 'Block' structure.
// The retuned 'Block' structure contains only transactions that are endorser transactions and are not alredy marked as invalid
func preprocessProtoBlock(txMgr txmgr.TxMgr,
	validateKVFunc func(key string, value []byte) error,
	block *common.Block, doMVCCValidation bool,
) (*internal.Block, []*txmgr.TxStatInfo, error) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[24], 1);
	b := &internal.Block{Num: block.Header.Number}
	txsStatInfo := []*txmgr.TxStatInfo{}
	// Committer validator has already set validation flags based on well formed tran checks
	txsFilter := util.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
	for txIndex, envBytes := range block.Data.Data {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[26], 1);
		var env *common.Envelope
		var chdr *common.ChannelHeader
		var payload *common.Payload
		var err error
		txStatInfo := &txmgr.TxStatInfo{TxType: -1}
		txsStatInfo = append(txsStatInfo, txStatInfo)
		if env, err = utils.GetEnvelopeFromBlock(envBytes); err == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[31], 1);
			if payload, err = utils.GetPayload(env); err == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[32], 1);
				chdr, err = utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
			}
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[27], 1);if txsFilter.IsInvalid(txIndex) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[33], 1);
			// Skipping invalid transaction
			logger.Warningf("Channel [%s]: Block [%d] Transaction index [%d] TxId [%s]"+
				" marked as invalid by committer. Reason code [%s]",
				chdr.GetChannelId(), block.Header.Number, txIndex, chdr.GetTxId(),
				txsFilter.Flag(txIndex).String())
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[28], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[34], 1);
			return nil, nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[29], 1);var txRWSet *rwsetutil.TxRwSet
		txType := common.HeaderType(chdr.Type)
		logger.Debugf("txType=%s", txType)
		txStatInfo.TxType = txType
		if txType == common.HeaderType_ENDORSER_TRANSACTION {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[35], 1);
			// extract actions from the envelope message
			respPayload, err := utils.GetActionFromEnvelope(envBytes)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[37], 1);
				txsFilter.SetFlag(txIndex, peer.TxValidationCode_NIL_TXACTION)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[36], 1);txStatInfo.ChaincodeID = respPayload.ChaincodeId
			txRWSet = &rwsetutil.TxRwSet{}
			if err = txRWSet.FromProtoBytes(respPayload.Results); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[38], 1);
				txsFilter.SetFlag(txIndex, peer.TxValidationCode_INVALID_OTHER_REASON)
				continue
			}
		} else{ _cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[39], 1);{
			rwsetProto, err := processNonEndorserTx(env, chdr.TxId, txType, txMgr, !doMVCCValidation)
			if _, ok := err.(*customtx.InvalidTxError); ok {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[42], 1);
				txsFilter.SetFlag(txIndex, peer.TxValidationCode_INVALID_OTHER_REASON)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[40], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[43], 1);
				return nil, nil, err
			}
			_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[41], 1);if rwsetProto != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[44], 1);
				if txRWSet, err = rwsetutil.TxRwSetFromProtoMsg(rwsetProto); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[45], 1);
					return nil, nil, err
				}
			}
		}}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[30], 1);if txRWSet != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[46], 1);
			txStatInfo.NumCollections = txRWSet.NumCollections()
			if err := validateWriteset(txRWSet, validateKVFunc); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[48], 1);
				logger.Warningf("Channel [%s]: Block [%d] Transaction index [%d] TxId [%s]"+
					" marked as invalid. Reason code [%s]",
					chdr.GetChannelId(), block.Header.Number, txIndex, chdr.GetTxId(), peer.TxValidationCode_INVALID_WRITESET)
				txsFilter.SetFlag(txIndex, peer.TxValidationCode_INVALID_WRITESET)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[47], 1);b.Txs = append(b.Txs, &internal.Transaction{IndexInBlock: txIndex, ID: chdr.TxId, RWSet: txRWSet})
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[25], 1);return b, txsStatInfo, nil
}

func processNonEndorserTx(txEnv *common.Envelope, txid string, txType common.HeaderType, txmgr txmgr.TxMgr, synchingState bool) (*rwset.TxReadWriteSet, error) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[49], 1);
	logger.Debugf("Performing custom processing for transaction [txid=%s], [txType=%s]", txid, txType)
	processor := customtx.GetProcessor(txType)
	logger.Debugf("Processor for custom tx processing:%#v", processor)
	if processor == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[54], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[50], 1);var err error
	var sim ledger.TxSimulator
	var simRes *ledger.TxSimulationResults
	if sim, err = txmgr.NewTxSimulator(txid); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[55], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[51], 1);defer sim.Done()
	if err = processor.GenerateSimulationResults(txEnv, sim, synchingState); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[56], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[52], 1);if simRes, err = sim.GetTxSimulationResults(); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[57], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[53], 1);return simRes.PubSimulationResults, nil
}

func validateWriteset(txRWSet *rwsetutil.TxRwSet, validateKVFunc func(key string, value []byte) error) error {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[58], 1);
	for _, nsRwSet := range txRWSet.NsRwSets {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[60], 1);
		pubWriteset := nsRwSet.KvRwSet
		if pubWriteset == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[62], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[61], 1);for _, kvwrite := range pubWriteset.Writes {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[63], 1);
			if err := validateKVFunc(kvwrite.Key, kvwrite.Value); err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[64], 1);
				return err
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[59], 1);return nil
}

// postprocessProtoBlock updates the proto block's validation flags (in metadata) by the results of validation process
func postprocessProtoBlock(block *common.Block, validatedBlock *internal.Block) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[65], 1);
	txsFilter := util.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
	for _, tx := range validatedBlock.Txs {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[67], 1);
		txsFilter.SetFlag(tx.IndexInBlock, tx.ValidationCode)
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[66], 1);block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = txsFilter
}

func addPvtRWSetToPvtUpdateBatch(pvtRWSet *rwsetutil.TxPvtRwSet, pvtUpdateBatch *privacyenabledstate.PvtUpdateBatch, ver *version.Height) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[68], 1);
	for _, ns := range pvtRWSet.NsPvtRwSet {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[69], 1);
		for _, coll := range ns.CollPvtRwSets {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[70], 1);
			for _, kvwrite := range coll.KvRwSet.Writes {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[71], 1);
				if !kvwrite.IsDelete {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[72], 1);
					pvtUpdateBatch.Put(ns.NameSpace, coll.CollectionName, kvwrite.Key, kvwrite.Value, ver)
				} else{ _cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[73], 1);{
					pvtUpdateBatch.Delete(ns.NameSpace, coll.CollectionName, kvwrite.Key, ver)
				}}
			}
		}
	}
}

// incrementPvtdataVersionIfNeeded changes the versions of the private data keys if the version of the corresponding hashed key has
// been upgrded. A metadata-update-only type of transaction may have caused the version change of the existing value in the hashed space.
// Iterate through all the metadata writes and try to get these keys and increment the version in the private writes to be the same as of the hashed key version - if the latest
// value of the key is available. Otherwise, in this scenario, we end up having the latest value in the private state but the version
// gets left as stale and will cause simulation failure because of wrongly assuming that we have stale value
func incrementPvtdataVersionIfNeeded(
	metadataUpdates metadataUpdates,
	pvtUpdateBatch *privacyenabledstate.PvtUpdateBatch,
	pubAndHashUpdates *internal.PubAndHashUpdates,
	db privacyenabledstate.DB) error {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[74], 1);

	for collKey := range metadataUpdates {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[76], 1);
		ns, coll, key := collKey.ns, collKey.coll, collKey.key
		keyHash := util.ComputeStringHash(key)
		hashedVal := pubAndHashUpdates.HashUpdates.Get(ns, coll, string(keyHash))
		if hashedVal == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[80], 1);
			// This key is finally not getting updated in the hashed space by this block -
			// either the metadata update was on a non-existing key or the key gets deleted by a latter transaction in the block
			// ignore the metadata update for this key
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[77], 1);latestVal, err := retrieveLatestVal(ns, coll, key, pvtUpdateBatch, db)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[81], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[78], 1);if latestVal == nil || // latest value not found either in db or in the pvt updates (caused by commit with missing data)
			version.AreSame(latestVal.Version, hashedVal.Version) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[82], 1); // version is already same as in hashed space - No version increment because of metadata-only transaction took place
			continue
		}
		// TODO - computing hash could be avoided. In the hashed updates, we can augment additional info that
		// which original version has been renewed
		_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[79], 1);latestValHash := util.ComputeHash(latestVal.Value)
		if bytes.Equal(latestValHash, hashedVal.Value) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[83], 1); // since we allow block commits with missing pvt data, the private value available may be stale.
			// upgrade the version only if the pvt value matches with corresponding hash in the hashed space
			pvtUpdateBatch.Put(ns, coll, key, latestVal.Value, hashedVal.Version)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[75], 1);return nil
}

type collKey struct {
	ns, coll, key string
}

type metadataUpdates map[collKey]bool

func addEntriesToMetadataUpdates(metadataUpdates metadataUpdates, pvtRWSet *rwsetutil.TxPvtRwSet) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[84], 1);
	for _, ns := range pvtRWSet.NsPvtRwSet {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[85], 1);
		for _, coll := range ns.CollPvtRwSets {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[86], 1);
			for _, metadataWrite := range coll.KvRwSet.MetadataWrites {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[87], 1);
				ns, coll, key := ns.NameSpace, coll.CollectionName, metadataWrite.Key
				metadataUpdates[collKey{ns, coll, key}] = true
			}
		}
	}
}

func retrieveLatestVal(ns, coll, key string, pvtUpdateBatch *privacyenabledstate.PvtUpdateBatch,
	db privacyenabledstate.DB) (val *statedb.VersionedValue, err error) {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[88], 1);
	val = pvtUpdateBatch.Get(ns, coll, key)
	if val == nil {_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[90], 1);
		val, err = db.GetPrivateData(ns, coll, key)
	}
	_cover_atomic_.AddUint32(&GoCover_1_376364336236376665646463.Count[89], 1);return
}

var GoCover_1_376364336236376665646463 = struct {
	Count     [91]uint32
	Pos       [3 * 91]uint32
	NumStmt   [91]uint16
} {
	Pos: [3 * 91]uint32{
		33, 36, 0x1f0084, // [0]
		60, 60, 0x6c0002, // [1]
		63, 63, 0x180002, // [2]
		36, 37, 0x37001f, // [3]
		40, 40, 0x1e0003, // [4]
		43, 44, 0x170003, // [5]
		47, 47, 0x2b0003, // [6]
		52, 54, 0x570003, // [7]
		57, 58, 0x390003, // [8]
		37, 38, 0xc0037, // [9]
		40, 41, 0xc001e, // [10]
		44, 45, 0xc0017, // [11]
		47, 48, 0x39002b, // [12]
		48, 50, 0x50039, // [13]
		54, 56, 0x40057, // [14]
		60, 62, 0x3006c, // [15]
		70, 72, 0x2003b, // [16]
		76, 77, 0x1d0051, // [17]
		81, 81, 0x380002, // [18]
		93, 93, 0xc0002, // [19]
		77, 79, 0x3001d, // [20]
		81, 82, 0x3c0038, // [21]
		82, 85, 0x34003c, // [22]
		85, 90, 0x50034, // [23]
		101, 106, 0x310031, // [24]
		174, 174, 0x1c0002, // [25]
		106, 113, 0x420031, // [26]
		118, 118, 0x230003, // [27]
		126, 126, 0x110003, // [28]
		130, 134, 0x370003, // [29]
		162, 162, 0x150003, // [30]
		113, 114, 0x380042, // [31]
		114, 116, 0x50038, // [32]
		118, 124, 0xc0023, // [33]
		126, 128, 0x40011, // [34]
		134, 137, 0x120037, // [35]
		141, 143, 0x450004, // [36]
		137, 139, 0xd0012, // [37]
		143, 145, 0xd0045, // [38]
		147, 149, 0x330009, // [39]
		153, 153, 0x120004, // [40]
		156, 156, 0x190004, // [41]
		149, 151, 0xd0033, // [42]
		153, 155, 0x50012, // [43]
		156, 157, 0x4d0019, // [44]
		157, 159, 0x6004d, // [45]
		162, 164, 0x440015, // [46]
		171, 171, 0x660004, // [47]
		164, 169, 0xd0044, // [48]
		177, 181, 0x1600a0, // [49]
		185, 188, 0x370002, // [50]
		191, 192, 0x560002, // [51]
		195, 195, 0x3c0002, // [52]
		198, 198, 0x290002, // [53]
		181, 183, 0x30016, // [54]
		188, 190, 0x30037, // [55]
		192, 194, 0x30056, // [56]
		195, 197, 0x3003c, // [57]
		201, 202, 0x2b006e, // [58]
		213, 213, 0xc0002, // [59]
		202, 204, 0x19002b, // [60]
		207, 207, 0x2e0003, // [61]
		204, 205, 0xc0019, // [62]
		207, 208, 0x45002e, // [63]
		208, 210, 0x50045, // [64]
		217, 219, 0x280051, // [65]
		222, 222, 0x540002, // [66]
		219, 221, 0x30028, // [67]
		225, 226, 0x29008b, // [68]
		226, 227, 0x290029, // [69]
		227, 228, 0x300029, // [70]
		228, 229, 0x1a0030, // [71]
		229, 231, 0x6001a, // [72]
		231, 233, 0x6000b, // [73]
		248, 250, 0x270023, // [74]
		276, 276, 0xc0002, // [75]
		250, 254, 0x170027, // [76]
		260, 261, 0x110003, // [77]
		264, 265, 0x3a0003, // [78]
		270, 271, 0x320003, // [79]
		254, 258, 0xc0017, // [80]
		261, 263, 0x40011, // [81]
		265, 266, 0xc003a, // [82]
		271, 274, 0x40032, // [83]
		285, 286, 0x290063, // [84]
		286, 287, 0x290029, // [85]
		287, 288, 0x3e0029, // [86]
		288, 291, 0x5003e, // [87]
		297, 299, 0x100046, // [88]
		302, 302, 0x80002, // [89]
		299, 301, 0x30010, // [90]
	},
	NumStmt: [91]uint16{
		3, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
		1, // 6
		3, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		3, // 22
		1, // 23
		4, // 24
		1, // 25
		7, // 26
		1, // 27
		1, // 28
		5, // 29
		1, // 30
		1, // 31
		1, // 32
		2, // 33
		1, // 34
		2, // 35
		3, // 36
		2, // 37
		2, // 38
		2, // 39
		1, // 40
		1, // 41
		2, // 42
		1, // 43
		1, // 44
		1, // 45
		2, // 46
		1, // 47
		3, // 48
		4, // 49
		4, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		2, // 60
		1, // 61
		1, // 62
		1, // 63
		1, // 64
		2, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		4, // 76
		2, // 77
		1, // 78
		2, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		1, // 86
		2, // 87
		2, // 88
		1, // 89
		1, // 90
	},
}
var _ = _cover_atomic_.LoadUint32
