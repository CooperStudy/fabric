//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/util/leveldbhelper/leveldb_helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package leveldbhelper; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sync"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/util"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb"
	"github.com/syndtr/goleveldb/leveldb/iterator"
	"github.com/syndtr/goleveldb/leveldb/opt"
	goleveldbutil "github.com/syndtr/goleveldb/leveldb/util"
)

var logger = flogging.MustGetLogger("leveldbhelper")

type dbState int32

const (
	closed dbState = iota
	opened
)

// Conf configuration for `DB`
type Conf struct {
	DBPath string
}

// DB - a wrapper on an actual store
type DB struct {
	conf    *Conf
	db      *leveldb.DB
	dbState dbState
	mux     sync.Mutex

	readOpts        *opt.ReadOptions
	writeOptsNoSync *opt.WriteOptions
	writeOptsSync   *opt.WriteOptions
}

// CreateDB constructs a `DB`
func CreateDB(conf *Conf) *DB {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[0], 1);
	readOpts := &opt.ReadOptions{}
	writeOptsNoSync := &opt.WriteOptions{}
	writeOptsSync := &opt.WriteOptions{}
	writeOptsSync.Sync = true

	return &DB{
		conf:            conf,
		dbState:         closed,
		readOpts:        readOpts,
		writeOptsNoSync: writeOptsNoSync,
		writeOptsSync:   writeOptsSync}
}

// Open opens the underlying db
func (dbInst *DB) Open() {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[1], 1);
	dbInst.mux.Lock()
	defer dbInst.mux.Unlock()
	if dbInst.dbState == opened {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[5], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[2], 1);dbOpts := &opt.Options{}
	dbPath := dbInst.conf.DBPath
	var err error
	var dirEmpty bool
	if dirEmpty, err = util.CreateDirIfMissing(dbPath); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[6], 1);
		panic(fmt.Sprintf("Error creating dir if missing: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[3], 1);dbOpts.ErrorIfMissing = !dirEmpty
	if dbInst.db, err = leveldb.OpenFile(dbPath, dbOpts); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[7], 1);
		panic(fmt.Sprintf("Error opening leveldb: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[4], 1);dbInst.dbState = opened
}

// Close closes the underlying db
func (dbInst *DB) Close() {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[8], 1);
	dbInst.mux.Lock()
	defer dbInst.mux.Unlock()
	if dbInst.dbState == closed {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[11], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[9], 1);if err := dbInst.db.Close(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[12], 1);
		logger.Errorf("Error closing leveldb: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[10], 1);dbInst.dbState = closed
}

// Get returns the value for the given key
func (dbInst *DB) Get(key []byte) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[13], 1);
	value, err := dbInst.db.Get(key, dbInst.readOpts)
	if err == leveldb.ErrNotFound {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[16], 1);
		value = nil
		err = nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[14], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[17], 1);
		logger.Errorf("Error retrieving leveldb key [%#v]: %s", key, err)
		return nil, errors.Wrapf(err, "error retrieving leveldb key [%#v]", key)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[15], 1);return value, nil
}

// Put saves the key/value
func (dbInst *DB) Put(key []byte, value []byte, sync bool) error {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[18], 1);
	wo := dbInst.writeOptsNoSync
	if sync {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[21], 1);
		wo = dbInst.writeOptsSync
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[19], 1);err := dbInst.db.Put(key, value, wo)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[22], 1);
		logger.Errorf("Error writing leveldb key [%#v]", key)
		return errors.Wrapf(err, "error writing leveldb key [%#v]", key)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[20], 1);return nil
}

// Delete deletes the given key
func (dbInst *DB) Delete(key []byte, sync bool) error {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[23], 1);
	wo := dbInst.writeOptsNoSync
	if sync {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[26], 1);
		wo = dbInst.writeOptsSync
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[24], 1);err := dbInst.db.Delete(key, wo)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[27], 1);
		logger.Errorf("Error deleting leveldb key [%#v]", key)
		return errors.Wrapf(err, "error deleting leveldb key [%#v]", key)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[25], 1);return nil
}

// GetIterator returns an iterator over key-value store. The iterator should be released after the use.
// The resultset contains all the keys that are present in the db between the startKey (inclusive) and the endKey (exclusive).
// A nil startKey represents the first available key and a nil endKey represent a logical key after the last available key
func (dbInst *DB) GetIterator(startKey []byte, endKey []byte) iterator.Iterator {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[28], 1);
	return dbInst.db.NewIterator(&goleveldbutil.Range{Start: startKey, Limit: endKey}, dbInst.readOpts)
}

// WriteBatch writes a batch
func (dbInst *DB) WriteBatch(batch *leveldb.Batch, sync bool) error {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[29], 1);
	wo := dbInst.writeOptsNoSync
	if sync {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[32], 1);
		wo = dbInst.writeOptsSync
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[30], 1);if err := dbInst.db.Write(batch, wo); err != nil {_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[33], 1);
		return errors.Wrap(err, "error writing batch to leveldb")
	}
	_cover_atomic_.AddUint32(&GoCover_0_623966383234353232616331.Count[31], 1);return nil
}

var GoCover_0_623966383234353232616331 = struct {
	Count     [34]uint32
	Pos       [3 * 34]uint32
	NumStmt   [34]uint16
} {
	Pos: [3 * 34]uint32{
		49, 61, 0x2001f, // [0]
		64, 67, 0x1e001a, // [1]
		70, 74, 0x410002, // [2]
		77, 78, 0x430002, // [3]
		81, 81, 0x190002, // [4]
		67, 69, 0x3001e, // [5]
		74, 75, 0x3f0041, // [6]
		78, 79, 0x370043, // [7]
		85, 88, 0x1e001b, // [8]
		91, 91, 0x2a0002, // [9]
		94, 94, 0x190002, // [10]
		88, 90, 0x3001e, // [11]
		91, 93, 0x3002a, // [12]
		98, 100, 0x200033, // [13]
		104, 104, 0x100002, // [14]
		108, 108, 0x130002, // [15]
		100, 103, 0x30020, // [16]
		104, 107, 0x30010, // [17]
		112, 114, 0xa0042, // [18]
		117, 118, 0x100002, // [19]
		122, 122, 0xc0002, // [20]
		114, 116, 0x3000a, // [21]
		118, 121, 0x30010, // [22]
		126, 128, 0xa0037, // [23]
		131, 132, 0x100002, // [24]
		136, 136, 0xc0002, // [25]
		128, 130, 0x3000a, // [26]
		132, 135, 0x30010, // [27]
		142, 144, 0x20051, // [28]
		147, 149, 0xa0045, // [29]
		152, 152, 0x330002, // [30]
		155, 155, 0xc0002, // [31]
		149, 151, 0x3000a, // [32]
		152, 154, 0x30033, // [33]
	},
	NumStmt: [34]uint16{
		5, // 0
		3, // 1
		5, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		2, // 16
		2, // 17
		2, // 18
		2, // 19
		1, // 20
		1, // 21
		2, // 22
		2, // 23
		2, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
	},
}
var _ = _cover_atomic_.LoadUint32
