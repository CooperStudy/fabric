//line /home/cooper/go/src/github.com/hyperledger/fabric/common/graph/perm.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package graph; import _cover_atomic_ "sync/atomic"

// treePermutations represents possible permutations
// of a tree
type treePermutations struct {
	originalRoot           *TreeVertex                     // The root vertex of all sub-trees
	permutations           []*TreeVertex                   // The accumulated permutations
	descendantPermutations map[*TreeVertex][][]*TreeVertex // Defines the combinations of sub-trees based on the threshold of the current vertex
}

// newTreePermutation creates a new treePermutations object with a given root vertex
func newTreePermutation(root *TreeVertex) *treePermutations {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[0], 1);
	return &treePermutations{
		descendantPermutations: make(map[*TreeVertex][][]*TreeVertex),
		originalRoot:           root,
		permutations:           []*TreeVertex{root},
	}
}

// permute returns Trees that their vertices and edges all exist in the original tree who's vertex
// is the 'originalRoot' field of the treePermutations
func (tp *treePermutations) permute() []*Tree {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[1], 1);
	tp.computeDescendantPermutations()

	it := newBFSIterator(tp.originalRoot)
	for {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[4], 1);
		v := it.Next()
		if v == nil {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[8], 1);
			break
		}

		_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[5], 1);if len(v.Descendants) == 0 {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[9], 1);
			continue
		}

		// Iterate over all permutations where v exists
		// and separate them to 2 sets: a indiceSet where it exists and a indiceSet where it doesn't
		_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[6], 1);var permutationsWhereVexists []*TreeVertex
		var permutationsWhereVdoesntExist []*TreeVertex
		for _, perm := range tp.permutations {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[10], 1);
			if perm.Exists(v.Id) {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[11], 1);
				permutationsWhereVexists = append(permutationsWhereVexists, perm)
			} else{ _cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[12], 1);{
				permutationsWhereVdoesntExist = append(permutationsWhereVdoesntExist, perm)
			}}
		}

		// Remove the permutations where v exists from the permutations
		_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[7], 1);tp.permutations = permutationsWhereVdoesntExist

		// Next, we replace each occurrence of a permutation where v exists,
		// with multiple occurrences of its descendants permutations
		for _, perm := range permutationsWhereVexists {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[13], 1);
			// For each permutation of v's descendants, clone the graph
			// and create a new graph with v replaced with the permutated graph
			// of v connected to the descendant permutation
			for _, permutation := range tp.descendantPermutations[v] {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[14], 1);
				subGraph := &TreeVertex{
					Id:          v.Id,
					Data:        v.Data,
					Descendants: permutation,
				}
				newTree := perm.Clone()
				newTree.replace(v.Id, subGraph)
				// Add the new option to the permutations
				tp.permutations = append(tp.permutations, newTree)
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[2], 1);res := make([]*Tree, len(tp.permutations))
	for i, perm := range tp.permutations {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[15], 1);
		res[i] = perm.ToTree()
	}
	_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[3], 1);return res
}

// computeDescendantPermutations computes all possible combinations of sub-trees
// for all vertices, based on the thresholds.
func (tp *treePermutations) computeDescendantPermutations() {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[16], 1);
	it := newBFSIterator(tp.originalRoot)
	for {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[17], 1);
		v := it.Next()
		if v == nil {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[20], 1);
			return
		}

		// Skip leaves
		_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[18], 1);if len(v.Descendants) == 0 {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[21], 1);
			continue
		}

		// Iterate over all options of selecting the threshold out of the descendants
		_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[19], 1);for _, el := range chooseKoutOfN(len(v.Descendants), v.Threshold) {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[22], 1);
			// And for each such option, append it to the current TreeVertex
			tp.descendantPermutations[v] = append(tp.descendantPermutations[v], v.selectDescendants(el.indices))
		}
	}
}

// selectDescendants returns a subset of descendants according to given indices
func (v *TreeVertex) selectDescendants(indices []int) []*TreeVertex {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[23], 1);
	r := make([]*TreeVertex, len(indices))
	i := 0
	for _, index := range indices {_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[25], 1);
		r[i] = v.Descendants[index]
		i++
	}
	_cover_atomic_.AddUint32(&GoCover_2_333364376162323263303436.Count[24], 1);return r
}

var GoCover_2_333364376162323263303436 = struct {
	Count     [26]uint32
	Pos       [3 * 26]uint32
	NumStmt   [26]uint16
} {
	Pos: [3 * 26]uint32{
		18, 24, 0x2003d, // [0]
		28, 32, 0x6002f, // [1]
		77, 78, 0x270002, // [2]
		81, 81, 0xc0002, // [3]
		32, 34, 0xf0006, // [4]
		38, 38, 0x1e0003, // [5]
		44, 46, 0x280003, // [6]
		55, 59, 0x310003, // [7]
		34, 35, 0x9000f, // [8]
		38, 39, 0xc001e, // [9]
		46, 47, 0x190028, // [10]
		47, 49, 0x50019, // [11]
		49, 51, 0x5000a, // [12]
		59, 63, 0x3d0031, // [13]
		63, 73, 0x5003d, // [14]
		78, 80, 0x30027, // [15]
		86, 88, 0x6003d, // [16]
		88, 90, 0xf0006, // [17]
		95, 95, 0x1e0003, // [18]
		100, 100, 0x450003, // [19]
		90, 92, 0x4000f, // [20]
		95, 96, 0xc001e, // [21]
		100, 103, 0x40045, // [22]
		108, 111, 0x200045, // [23]
		115, 115, 0xa0002, // [24]
		111, 114, 0x30020, // [25]
	},
	NumStmt: [26]uint16{
		1, // 0
		3, // 1
		2, // 2
		1, // 3
		2, // 4
		1, // 5
		3, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		4, // 14
		1, // 15
		2, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		3, // 23
		1, // 24
		2, // 25
	},
}
var _ = _cover_atomic_.LoadUint32
