//line /home/cooper/go/src/github.com/hyperledger/fabric/discovery/authcache.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package discovery; import _cover_atomic_ "sync/atomic"

import (
	"encoding/asn1"
	"encoding/hex"
	"sync"

	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

const (
	defaultMaxCacheSize   = 1000
	defaultRetentionRatio = 0.75
)

var (
	// asBytes is the function that is used to marshal common.SignedData to bytes
	asBytes = asn1.Marshal
)

type acSupport interface {
	// Eligible returns whether the given peer is eligible for receiving
	// service from the discovery service for a given channel
	EligibleForService(channel string, data common.SignedData) error

	// ConfigSequence returns the configuration sequence of the given channel
	ConfigSequence(channel string) uint64
}

type authCacheConfig struct {
	enabled bool
	// maxCacheSize is the maximum size of the cache, after which
	// a purge takes place
	maxCacheSize int
	// purgeRetentionRatio is the % of entries that remain in the cache
	// after the cache is purged due to overpopulation
	purgeRetentionRatio float64
}

// authCache defines an interface that authenticates a request in a channel context,
// and does memoization of invocations
type authCache struct {
	credentialCache map[string]*accessCache
	acSupport
	sync.RWMutex
	conf authCacheConfig
}

func newAuthCache(s acSupport, conf authCacheConfig) *authCache {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[0], 1);
	return &authCache{
		acSupport:       s,
		credentialCache: make(map[string]*accessCache),
		conf:            conf,
	}
}

// Eligible returns whether the given peer is eligible for receiving
// service from the discovery service for a given channel
func (ac *authCache) EligibleForService(channel string, data common.SignedData) error {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[1], 1);
	if !ac.conf.enabled {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[4], 1);
		return ac.acSupport.EligibleForService(channel, data)
	}
	// Check whether we already have a cache for this channel
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[2], 1);ac.RLock()
	cache := ac.credentialCache[channel]
	ac.RUnlock()
	if cache == nil {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[5], 1);
		// Cache for given channel wasn't found, so create a new one
		ac.Lock()
		cache = ac.newAccessCache(channel)
		// And store the cache instance.
		ac.credentialCache[channel] = cache
		ac.Unlock()
	}
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[3], 1);return cache.EligibleForService(data)
}

type accessCache struct {
	sync.RWMutex
	channel      string
	ac           *authCache
	lastSequence uint64
	entries      map[string]error
}

func (ac *authCache) newAccessCache(channel string) *accessCache {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[6], 1);
	return &accessCache{
		channel: channel,
		ac:      ac,
		entries: make(map[string]error),
	}
}

func (cache *accessCache) EligibleForService(data common.SignedData) error {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[7], 1);
	key, err := signedDataToKey(data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[11], 1);
		logger.Warningf("Failed computing key of signed data: +%v", err)
		return errors.Wrap(err, "failed computing key of signed data")
	}
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[8], 1);currSeq := cache.ac.acSupport.ConfigSequence(cache.channel)
	if cache.isValid(currSeq) {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[12], 1);
		foundInCache, isEligibleErr := cache.lookup(key)
		if foundInCache {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[13], 1);
			return isEligibleErr
		}
	} else{ _cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[14], 1);{
		cache.configChange(currSeq)
	}}

	// Make sure the cache doesn't overpopulate.
	// It might happen that it overgrows the maximum size due to concurrent
	// goroutines waiting on the lock above, but that's acceptable.
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[9], 1);cache.purgeEntriesIfNeeded()

	// Compute the eligibility of the client for the service
	err = cache.ac.acSupport.EligibleForService(cache.channel, data)
	cache.Lock()
	defer cache.Unlock()
	// Check if the sequence hasn't changed since last time
	if currSeq != cache.ac.acSupport.ConfigSequence(cache.channel) {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[15], 1);
		// The sequence at which we computed the eligibility might have changed,
		// so we can't put it into the cache because a more fresh computation result
		// might already be present in the cache by now, and we don't want to override it
		// with a stale computation result, so just return the result.
		return err
	}
	// Else, the eligibility of the client has been computed under the latest sequence,
	// so store the computation result in the cache
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[10], 1);cache.entries[key] = err
	return err
}

func (cache *accessCache) isPurgeNeeded() bool {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[16], 1);
	cache.RLock()
	defer cache.RUnlock()
	return len(cache.entries)+1 > cache.ac.conf.maxCacheSize
}

func (cache *accessCache) purgeEntriesIfNeeded() {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[17], 1);
	if !cache.isPurgeNeeded() {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[19], 1);
		return
	}

	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[18], 1);cache.Lock()
	defer cache.Unlock()

	maxCacheSize := cache.ac.conf.maxCacheSize
	purgeRatio := cache.ac.conf.purgeRetentionRatio
	entries2evict := maxCacheSize - int(purgeRatio*float64(maxCacheSize))

	for key := range cache.entries {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[20], 1);
		if entries2evict == 0 {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[22], 1);
			return
		}
		_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[21], 1);entries2evict--
		delete(cache.entries, key)
	}
}

func (cache *accessCache) isValid(currSeq uint64) bool {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[23], 1);
	cache.RLock()
	defer cache.RUnlock()
	return currSeq == cache.lastSequence
}

func (cache *accessCache) configChange(currSeq uint64) {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[24], 1);
	cache.Lock()
	defer cache.Unlock()
	cache.lastSequence = currSeq
	// Invalidate entries
	cache.entries = make(map[string]error)
}

func (cache *accessCache) lookup(key string) (cacheHit bool, lookupResult error) {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[25], 1);
	cache.RLock()
	defer cache.RUnlock()

	lookupResult, cacheHit = cache.entries[key]
	return
}

func signedDataToKey(data common.SignedData) (string, error) {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[26], 1);
	b, err := asBytes(data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[28], 1);
		return "", errors.Wrap(err, "failed marshaling signed data")
	}
	_cover_atomic_.AddUint32(&GoCover_1_303564613738346231343033.Count[27], 1);return hex.EncodeToString(util.ComputeSHA256(b)), nil
}

var GoCover_1_303564613738346231343033 = struct {
	Count     [29]uint32
	Pos       [3 * 29]uint32
	NumStmt   [29]uint16
} {
	Pos: [3 * 29]uint32{
		57, 63, 0x20041, // [0]
		67, 68, 0x160057, // [1]
		72, 75, 0x120002, // [2]
		83, 83, 0x270002, // [3]
		68, 70, 0x30016, // [4]
		75, 82, 0x30012, // [5]
		94, 100, 0x20042, // [6]
		102, 104, 0x10004c, // [7]
		108, 109, 0x1c0002, // [8]
		121, 128, 0x410002, // [9]
		137, 138, 0xc0002, // [10]
		104, 107, 0x30010, // [11]
		109, 111, 0x13001c, // [12]
		111, 113, 0x40013, // [13]
		114, 116, 0x30008, // [14]
		128, 134, 0x30041, // [15]
		141, 145, 0x20030, // [16]
		147, 148, 0x1c0032, // [17]
		152, 159, 0x210002, // [18]
		148, 150, 0x3001c, // [19]
		159, 160, 0x190021, // [20]
		163, 164, 0x1d0003, // [21]
		160, 162, 0x40019, // [22]
		168, 172, 0x20038, // [23]
		174, 180, 0x20038, // [24]
		182, 188, 0x20052, // [25]
		190, 192, 0x10003e, // [26]
		195, 195, 0x370002, // [27]
		192, 194, 0x30010, // [28]
	},
	NumStmt: [29]uint16{
		1, // 0
		1, // 1
		4, // 2
		1, // 3
		1, // 4
		4, // 5
		1, // 6
		2, // 7
		2, // 8
		5, // 9
		2, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		6, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		3, // 23
		4, // 24
		4, // 25
		2, // 26
		1, // 27
		1, // 28
	},
}
var _ = _cover_atomic_.LoadUint32
