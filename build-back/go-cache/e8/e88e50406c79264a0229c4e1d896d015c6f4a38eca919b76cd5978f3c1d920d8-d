//line /home/cooper/go/src/github.com/hyperledger/fabric/token/tms/plain/transactor.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package plain; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/protos/ledger/queryresult"
	"github.com/hyperledger/fabric/protos/token"
	"github.com/hyperledger/fabric/token/ledger"
	"github.com/pkg/errors"
)

// A Transactor that can transfer tokens.
type Transactor struct {
	PublicCredential []byte
	Ledger           ledger.LedgerReader
}

// RequestTransfer creates a TokenTransaction of type transfer request
//func (t *Transactor) RequestTransfer(inTokens []*token.InputId, tokensToTransfer []*token.RecipientTransferShare) (*token.TokenTransaction, error) {
func (t *Transactor) RequestTransfer(request *token.TransferRequest) (*token.TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[0], 1);
	var outputs []*token.PlainOutput

	inputs, tokenType, _, err := t.getInputsFromTokenIds(request.GetTokenIds())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[3], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[1], 1);for _, ttt := range request.GetShares() {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[4], 1);
		outputs = append(outputs, &token.PlainOutput{
			Owner:    ttt.Recipient,
			Type:     tokenType,
			Quantity: ttt.Quantity,
		})
	}

	// prepare transfer request
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[2], 1);transaction := &token.TokenTransaction{
		Action: &token.TokenTransaction_PlainAction{
			PlainAction: &token.PlainTokenAction{
				Data: &token.PlainTokenAction_PlainTransfer{
					PlainTransfer: &token.PlainTransfer{
						Inputs:  inputs,
						Outputs: outputs,
					},
				},
			},
		},
	}

	return transaction, nil
}

// RequestRedeem creates a TokenTransaction of type redeem request
func (t *Transactor) RequestRedeem(request *token.RedeemRequest) (*token.TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[5], 1);
	if len(request.GetTokenIds()) == 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[11], 1);
		return nil, errors.New("no token ids in RedeemRequest")
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[6], 1);if request.GetQuantityToRedeem() <= 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[12], 1);
		return nil, errors.Errorf("quantity to redeem [%d] must be greater than 0", request.GetQuantityToRedeem())
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[7], 1);inputs, tokenType, quantitySum, err := t.getInputsFromTokenIds(request.GetTokenIds())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[13], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[8], 1);if quantitySum < request.QuantityToRedeem {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[14], 1);
		return nil, errors.Errorf("total quantity [%d] from TokenIds is less than quantity [%d] to be redeemed", quantitySum, request.QuantityToRedeem)
	}

	// add the output for redeem itself
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[9], 1);var outputs []*token.PlainOutput
	outputs = append(outputs, &token.PlainOutput{
		Type:     tokenType,
		Quantity: request.QuantityToRedeem,
	})

	// add another output if there is remaining quantity after redemption
	if quantitySum > request.QuantityToRedeem {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[15], 1);
		outputs = append(outputs, &token.PlainOutput{
			Owner:    t.PublicCredential, // PublicCredential is serialized identity for the creator
			Type:     tokenType,
			Quantity: quantitySum - request.QuantityToRedeem,
		})
	}

	// PlainRedeem shares the same data structure as PlainTransfer
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[10], 1);transaction := &token.TokenTransaction{
		Action: &token.TokenTransaction_PlainAction{
			PlainAction: &token.PlainTokenAction{
				Data: &token.PlainTokenAction_PlainRedeem{
					PlainRedeem: &token.PlainTransfer{
						Inputs:  inputs,
						Outputs: outputs,
					},
				},
			},
		},
	}

	return transaction, nil
}

// read token data from ledger for each token ids and calculate the sum of quantities for all token ids
// Returns InputIds, token type, sum of token quantities, and error in the case of failure
func (t *Transactor) getInputsFromTokenIds(tokenIds [][]byte) ([]*token.InputId, string, uint64, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[16], 1);
	var inputs []*token.InputId
	var tokenType string = ""
	var quantitySum uint64 = 0
	for _, inKeyBytes := range tokenIds {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[18], 1);
		// parse the composite key bytes into a string
		inKey := parseCompositeKeyBytes(inKeyBytes)

		// check whether the composite key conforms to the composite key of an output
		namespace, components, err := splitCompositeKey(inKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[28], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("error splitting input composite key: '%s'", err))
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[19], 1);if namespace != tokenOutput {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[29], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("namespace not '%s': '%s'", tokenOutput, namespace))
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[20], 1);if len(components) != 2 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[30], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("not enough components in output ID composite key; expected 2, received '%s'", components))
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[21], 1);txID := components[0]
		index, err := strconv.Atoi(components[1])
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[31], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("error parsing output index '%s': '%s'", components[1], err))
		}

		// make sure the output exists in the ledger
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[22], 1);inBytes, err := t.Ledger.GetState(tokenNameSpace, inKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[32], 1);
			return nil, "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[23], 1);if inBytes == nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[33], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("input '%s' does not exist", inKey))
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[24], 1);input := &token.PlainOutput{}
		err = proto.Unmarshal(inBytes, input)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[34], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("error unmarshaling input bytes: '%s'", err))
		}

		// check the owner of the token
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[25], 1);if !bytes.Equal(t.PublicCredential, input.Owner) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[35], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("the requestor does not own inputs"))
		}

		// check the token type - only one type allowed per transfer
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[26], 1);if tokenType == "" {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[36], 1);
			tokenType = input.Type
		} else{ _cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[37], 1);if tokenType != input.Type {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[38], 1);
			return nil, "", 0, errors.New(fmt.Sprintf("two or more token types specified in input: '%s', '%s'", tokenType, input.Type))
		}}
		// add input to list of inputs
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[27], 1);inputs = append(inputs, &token.InputId{TxId: txID, Index: uint32(index)})

		// sum up the quantity
		quantitySum += input.Quantity
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[17], 1);return inputs, tokenType, quantitySum, nil
}

// ListTokens creates a TokenTransaction that lists the unspent tokens owned by owner.
func (t *Transactor) ListTokens() (*token.UnspentTokens, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[39], 1);
	iterator, err := t.Ledger.GetStateRangeScanIterator(tokenNameSpace, "", "")
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[42], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[40], 1);tokens := make([]*token.TokenOutput, 0)
	prefix, err := createPrefix(tokenOutput)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[43], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[41], 1);for {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[44], 1);
		next, err := iterator.Next()

		switch {
		case err != nil:_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[45], 1);
			return nil, err

		case next == nil:_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[46], 1);
			// nil response from iterator indicates end of query results
			return &token.UnspentTokens{Tokens: tokens}, nil

		default:_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[47], 1);
			result, ok := next.(*queryresult.KV)
			if !ok {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[49], 1);
				return nil, errors.New("failed to retrieve unspent tokens: casting error")
			}
			_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[48], 1);if strings.HasPrefix(result.Key, prefix) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[50], 1);
				output := &token.PlainOutput{}
				err = proto.Unmarshal(result.Value, output)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[52], 1);
					return nil, errors.New("failed to retrieve unspent tokens: casting error")
				}
				_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[51], 1);if string(output.Owner) == string(t.PublicCredential) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[53], 1);
					spent, err := t.isSpent(result.Key)
					if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[55], 1);
						return nil, err
					}
					_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[54], 1);if !spent {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[56], 1);
						tokens = append(tokens,
							&token.TokenOutput{
								Type:     output.Type,
								Quantity: output.Quantity,
								Id:       getCompositeKeyBytes(result.Key),
							})
					}
				}
			}
		}
	}

}

func (t *Transactor) RequestApprove(request *token.ApproveRequest) (*token.TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[57], 1);
	if len(request.GetTokenIds()) == 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[64], 1);
		return nil, errors.New("no token ids in ApproveAllowanceRequest")
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[58], 1);if len(request.AllowanceShares) == 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[65], 1);
		return nil, errors.New("no recipient shares in ApproveAllowanceRequest")
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[59], 1);var delegatedOutputs []*token.PlainDelegatedOutput

	inputs, tokenType, sumQuantity, err := t.getInputsFromTokenIds(request.GetTokenIds())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[66], 1);
		return nil, err
	}

	// prepare approve tx

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[60], 1);delegatedQuantity := uint64(0)
	for _, share := range request.GetAllowanceShares() {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[67], 1);
		if len(share.Recipient) == 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[70], 1);
			return nil, errors.Errorf("the recipient in approve must be specified")
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[68], 1);if share.Quantity <= 0 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[71], 1);
			return nil, errors.Errorf("the quantity to approve [%d] must be greater than 0", share.GetQuantity())
		}
		_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[69], 1);delegatedOutputs = append(delegatedOutputs, &token.PlainDelegatedOutput{
			Owner:      []byte(request.Credential),
			Delegatees: [][]byte{share.Recipient},
			Type:       tokenType,
			Quantity:   share.Quantity,
		})
		delegatedQuantity = delegatedQuantity + share.Quantity
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[61], 1);if sumQuantity < delegatedQuantity {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[72], 1);
		return nil, errors.Errorf("insufficient funds: %v < %v", sumQuantity, delegatedQuantity)

	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[62], 1);var output *token.PlainOutput
	if sumQuantity != delegatedQuantity {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[73], 1);
		output = &token.PlainOutput{
			Owner:    request.Credential,
			Type:     tokenType,
			Quantity: sumQuantity - delegatedQuantity,
		}
	}

	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[63], 1);transaction := &token.TokenTransaction{
		Action: &token.TokenTransaction_PlainAction{
			PlainAction: &token.PlainTokenAction{
				Data: &token.PlainTokenAction_PlainApprove{
					PlainApprove: &token.PlainApprove{
						Inputs:           inputs,
						DelegatedOutputs: delegatedOutputs,
						Output:           output,
					},
				},
			},
		},
	}

	return transaction, nil
}

func (t *Transactor) RequestTransferFrom(request *token.TransferRequest) (*token.TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[74], 1);
	panic("implement me!")
}

// RequestExpectation allows indirect transfer based on the expectation.
// It creates a token transaction based on the outputs as specified in the expectation.
func (t *Transactor) RequestExpectation(request *token.ExpectationRequest) (*token.TokenTransaction, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[75], 1);
	panic("not implemented yet")
}

// Done releases any resources held by this transactor
func (t *Transactor) Done() {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[76], 1);
	if t.Ledger != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[77], 1);
		t.Ledger.Done()
	}
}

// isSpent checks whether an output token with identifier outputID has been spent.
func (t *Transactor) isSpent(outputID string) (bool, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[78], 1);
	key, err := createInputKey(outputID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[82], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[79], 1);result, err := t.Ledger.GetState(tokenNameSpace, key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[83], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[80], 1);if result == nil {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[84], 1);
		return false, nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[81], 1);return true, nil
}

// Create a ledger key for an individual input in a token transaction, as a function of
// the outputID
func createInputKey(outputID string) (string, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[85], 1);
	att := strings.Split(outputID, string(minUnicodeRuneValue))
	return createCompositeKey(tokenInput, att[1:])
}

// Create a prefix as a function of the string passed as argument
func createPrefix(keyword string) (string, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[86], 1);
	return createCompositeKey(keyword, nil)
}

// GenerateKeyForTest is here only for testing purposes, to be removed later.
func GenerateKeyForTest(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[87], 1);
	return createOutputKey(txID, index)
}

func splitCompositeKey(compositeKey string) (string, []string, error) {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[88], 1);
	componentIndex := 1
	components := []string{}
	for i := 1; i < len(compositeKey); i++ {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[91], 1);
		if compositeKey[i] == minUnicodeRuneValue {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[92], 1);
			components = append(components, compositeKey[componentIndex:i])
			componentIndex = i + 1
		}
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[89], 1);if len(components) < 2 {_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[93], 1);
		return "", nil, errors.New("invalid composite key - no components found")
	}
	_cover_atomic_.AddUint32(&GoCover_4_376538356362393564346637.Count[90], 1);return components[0], components[1:], nil
}

var GoCover_4_376538356362393564346637 = struct {
	Count     [94]uint32
	Pos       [3 * 94]uint32
	NumStmt   [94]uint16
} {
	Pos: [3 * 94]uint32{
		30, 34, 0x100067, // [0]
		38, 38, 0x2a0002, // [1]
		47, 60, 0x190002, // [2]
		34, 36, 0x30010, // [3]
		38, 44, 0x3002a, // [4]
		64, 65, 0x250063, // [5]
		68, 68, 0x280002, // [6]
		72, 73, 0x100002, // [7]
		77, 77, 0x2c0002, // [8]
		82, 89, 0x2c0002, // [9]
		98, 111, 0x190002, // [10]
		65, 67, 0x30025, // [11]
		68, 70, 0x30028, // [12]
		73, 75, 0x30010, // [13]
		77, 79, 0x3002c, // [14]
		89, 95, 0x3002c, // [15]
		116, 120, 0x260069, // [16]
		173, 173, 0x2c0002, // [17]
		120, 126, 0x110026, // [18]
		129, 129, 0x1f0003, // [19]
		132, 132, 0x1b0003, // [20]
		135, 137, 0x110003, // [21]
		142, 143, 0x110003, // [22]
		146, 146, 0x150003, // [23]
		149, 151, 0x110003, // [24]
		156, 156, 0x340003, // [25]
		161, 161, 0x160003, // [26]
		167, 170, 0x200003, // [27]
		126, 128, 0x40011, // [28]
		129, 131, 0x4001f, // [29]
		132, 134, 0x4001b, // [30]
		137, 139, 0x40011, // [31]
		143, 145, 0x40011, // [32]
		146, 148, 0x40015, // [33]
		151, 153, 0x40011, // [34]
		156, 158, 0x40034, // [35]
		161, 163, 0x40016, // [36]
		163, 163, 0x250009, // [37]
		163, 165, 0x40025, // [38]
		177, 179, 0x100041, // [39]
		183, 185, 0x100002, // [40]
		188, 188, 0x60002, // [41]
		179, 181, 0x30010, // [42]
		185, 187, 0x30010, // [43]
		188, 191, 0xa0006, // [44]
		192, 193, 0x130013, // [45]
		195, 197, 0x340014, // [46]
		199, 201, 0xb000b, // [47]
		204, 204, 0x2d0004, // [48]
		201, 203, 0x5000b, // [49]
		204, 207, 0x13002d, // [50]
		210, 210, 0x3b0005, // [51]
		207, 209, 0x60013, // [52]
		210, 212, 0x14003b, // [53]
		215, 215, 0x100006, // [54]
		212, 214, 0x70014, // [55]
		215, 222, 0x70010, // [56]
		230, 231, 0x250065, // [57]
		235, 235, 0x270002, // [58]
		239, 242, 0x100002, // [59]
		248, 249, 0x350002, // [60]
		264, 264, 0x250002, // [61]
		268, 269, 0x260002, // [62]
		277, 291, 0x190002, // [63]
		231, 233, 0x30025, // [64]
		235, 237, 0x30027, // [65]
		242, 244, 0x30010, // [66]
		249, 250, 0x200035, // [67]
		253, 253, 0x1a0003, // [68]
		256, 262, 0x390003, // [69]
		250, 252, 0x40020, // [70]
		253, 255, 0x4001a, // [71]
		264, 267, 0x30025, // [72]
		269, 275, 0x30026, // [73]
		294, 295, 0x18006b, // [74]
		300, 301, 0x1e006d, // [75]
		305, 306, 0x15001d, // [76]
		306, 308, 0x30015, // [77]
		312, 314, 0x10003d, // [78]
		317, 318, 0x100002, // [79]
		321, 321, 0x130002, // [80]
		324, 324, 0x120002, // [81]
		314, 316, 0x30010, // [82]
		318, 320, 0x30010, // [83]
		321, 323, 0x30013, // [84]
		329, 332, 0x20036, // [85]
		335, 337, 0x20033, // [86]
		340, 342, 0x20041, // [87]
		344, 347, 0x290047, // [88]
		353, 353, 0x190002, // [89]
		356, 356, 0x2b0002, // [90]
		347, 348, 0x2d0029, // [91]
		348, 351, 0x4002d, // [92]
		353, 355, 0x30019, // [93]
	},
	NumStmt: [94]uint16{
		3, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		3, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		4, // 16
		1, // 17
		3, // 18
		1, // 19
		1, // 20
		3, // 21
		2, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		2, // 39
		3, // 40
		1, // 41
		1, // 42
		1, // 43
		2, // 44
		1, // 45
		1, // 46
		2, // 47
		1, // 48
		1, // 49
		3, // 50
		1, // 51
		1, // 52
		2, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		3, // 59
		2, // 60
		1, // 61
		2, // 62
		2, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		2, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		2, // 78
		2, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		2, // 85
		1, // 86
		1, // 87
		3, // 88
		1, // 89
		1, // 90
		1, // 91
		2, // 92
		1, // 93
	},
}
var _ = _cover_atomic_.LoadUint32
