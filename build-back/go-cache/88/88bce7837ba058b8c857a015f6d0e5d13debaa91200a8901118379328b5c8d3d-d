//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/chaincode/list.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package chaincode; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"context"
	"encoding/hex"
	"fmt"
	"reflect"
	"strings"

	"github.com/golang/protobuf/proto"
	cb "github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
)

var getInstalledChaincodes bool
var getInstantiatedChaincodes bool
var chaincodeListCmd *cobra.Command

const list_cmdname = "list"

// installCmd returns the cobra command for Chaincode Deploy
func listCmd(cf *ChaincodeCmdFactory) *cobra.Command {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[0], 1);
	chaincodeListCmd = &cobra.Command{
		Use:   "list",
		Short: "Get the instantiated chaincodes on a channel or installed chaincodes on a peer.",
		Long:  "Get the instantiated chaincodes in the channel if specify channel, or get installed chaincodes on the peer",
		RunE: func(cmd *cobra.Command, args []string) error {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[2], 1);
			return getChaincodes(cmd, cf)
		},
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[1], 1);flagList := []string{
		"channelID",
		"installed",
		"instantiated",
		"peerAddresses",
		"tlsRootCertFiles",
		"connectionProfile",
	}
	attachFlags(chaincodeListCmd, flagList)

	return chaincodeListCmd
}

func getChaincodes(cmd *cobra.Command, cf *ChaincodeCmdFactory) error {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[3], 1);
	if getInstantiatedChaincodes && channelID == "" {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[16], 1);
		return errors.New("The required parameter 'channelID' is empty. Rerun the command with -C flag")
	}
	// Parsing of the command line is done so silence cmd usage
	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[4], 1);cmd.SilenceUsage = true

	var err error
	if cf == nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[17], 1);
		cf, err = InitCmdFactory(cmd.Name(), true, false)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[18], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[5], 1);creator, err := cf.Signer.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[19], 1);
		return fmt.Errorf("Error serializing identity for %s: %s", cf.Signer.GetIdentifier(), err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[6], 1);var prop *pb.Proposal
	if getInstalledChaincodes && (!getInstantiatedChaincodes) {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[20], 1);
		prop, _, err = utils.CreateGetInstalledChaincodesProposal(creator)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[21], 1);if getInstantiatedChaincodes && (!getInstalledChaincodes) {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[22], 1);
		prop, _, err = utils.CreateGetChaincodesProposal(channelID, creator)
	} else{ _cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[23], 1);{
		return fmt.Errorf("Must explicitly specify \"--installed\" or \"--instantiated\"")
	}}}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[7], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[24], 1);
		return fmt.Errorf("Error creating proposal %s: %s", chainFuncName, err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[8], 1);var signedProp *pb.SignedProposal
	signedProp, err = utils.GetSignedProposal(prop, cf.Signer)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[25], 1);
		return fmt.Errorf("Error creating signed proposal  %s: %s", chainFuncName, err)
	}

	// list is currently only supported for one peer
	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[9], 1);proposalResponse, err := cf.EndorserClients[0].ProcessProposal(context.Background(), signedProp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[26], 1);
		return errors.Errorf("Error endorsing %s: %s", chainFuncName, err)
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[10], 1);if proposalResponse.Response == nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[27], 1);
		return errors.Errorf("Proposal response had nil 'response'")
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[11], 1);if proposalResponse.Response.Status != int32(cb.Status_SUCCESS) {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[28], 1);
		return errors.Errorf("Bad response: %d - %s", proposalResponse.Response.Status, proposalResponse.Response.Message)
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[12], 1);cqr := &pb.ChaincodeQueryResponse{}
	err = proto.Unmarshal(proposalResponse.Response.Payload, cqr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[29], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[13], 1);if getInstalledChaincodes {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[30], 1);
		fmt.Println("Get installed chaincodes on peer:")
	} else{ _cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[31], 1);{
		fmt.Printf("Get instantiated chaincodes on channel %s:\n", channelID)
	}}
	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[14], 1);for _, chaincode := range cqr.Chaincodes {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[32], 1);
		fmt.Printf("%v\n", ccInfo{chaincode}.String())
	}
	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[15], 1);return nil
}

type ccInfo struct {
	*pb.ChaincodeInfo
}

func (cci ccInfo) String() string {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[33], 1);
	b := bytes.Buffer{}
	md := reflect.ValueOf(*cci.ChaincodeInfo)
	md2 := reflect.Indirect(reflect.ValueOf(*cci.ChaincodeInfo)).Type()
	for i := 0; i < md.NumField(); i++ {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[35], 1);
		f := md.Field(i)
		val := f.String()
		if isBytes(f) {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[39], 1);
			val = hex.EncodeToString(f.Bytes())
		}
		_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[36], 1);if len(val) == 0 {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[40], 1);
			continue
		}
		// Skip the proto-internal generated fields
		_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[37], 1);if strings.HasPrefix(md2.Field(i).Name, "XXX") {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[41], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[38], 1);b.WriteString(fmt.Sprintf("%s: %s, ", md2.Field(i).Name, val))
	}
	_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[34], 1);return b.String()[:len(b.String())-2]

}

func isBytes(v reflect.Value) bool {_cover_atomic_.AddUint32(&GoCover_5_316135646539653831366338.Count[42], 1);
	return v.Kind() == reflect.Slice && v.Type().Elem().Kind() == reflect.Uint8
}

var GoCover_5_316135646539653831366338 = struct {
	Count     [43]uint32
	Pos       [3 * 43]uint32
	NumStmt   [43]uint16
} {
	Pos: [3 * 43]uint32{
		32, 37, 0x370036, // [0]
		42, 52, 0x190002, // [1]
		37, 39, 0x40037, // [2]
		55, 56, 0x320047, // [3]
		60, 63, 0xf0002, // [4]
		70, 71, 0x100002, // [5]
		75, 76, 0x3c0002, // [6]
		84, 84, 0x100002, // [7]
		88, 90, 0x100002, // [8]
		95, 96, 0x100002, // [9]
		100, 100, 0x260002, // [10]
		104, 104, 0x420002, // [11]
		108, 110, 0x100002, // [12]
		114, 114, 0x1c0002, // [13]
		119, 119, 0x2b0002, // [14]
		122, 122, 0xc0002, // [15]
		56, 58, 0x30032, // [16]
		63, 65, 0x11000f, // [17]
		65, 67, 0x40011, // [18]
		71, 73, 0x30010, // [19]
		76, 78, 0x3003c, // [20]
		78, 78, 0x430008, // [21]
		78, 80, 0x30043, // [22]
		80, 82, 0x30008, // [23]
		84, 86, 0x30010, // [24]
		90, 92, 0x30010, // [25]
		96, 98, 0x30010, // [26]
		100, 102, 0x30026, // [27]
		104, 106, 0x30042, // [28]
		110, 112, 0x30010, // [29]
		114, 116, 0x3001c, // [30]
		116, 118, 0x30008, // [31]
		119, 121, 0x3002b, // [32]
		129, 133, 0x250023, // [33]
		148, 148, 0x270002, // [34]
		133, 136, 0x110025, // [35]
		139, 139, 0x140003, // [36]
		143, 143, 0x320003, // [37]
		146, 146, 0x410003, // [38]
		136, 138, 0x40011, // [39]
		139, 140, 0xc0014, // [40]
		143, 144, 0xc0032, // [41]
		152, 154, 0x20024, // [42]
	},
	NumStmt: [43]uint16{
		1, // 0
		3, // 1
		1, // 2
		1, // 3
		3, // 4
		2, // 5
		2, // 6
		1, // 7
		3, // 8
		2, // 9
		1, // 10
		1, // 11
		3, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		4, // 33
		1, // 34
		3, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
	},
}
var _ = _cover_atomic_.LoadUint32
