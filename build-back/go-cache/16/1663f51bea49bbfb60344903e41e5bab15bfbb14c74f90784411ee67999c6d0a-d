//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/msgprocessor/systemchannelfilter.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msgprocessor; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/channelconfig"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

// ChainCreator defines the methods necessary to simulate channel creation.
type ChainCreator interface {
	// NewChannelConfig returns a template config for a new channel.
	NewChannelConfig(envConfigUpdate *cb.Envelope) (channelconfig.Resources, error)

	// CreateBundle parses the config into resources
	CreateBundle(channelID string, config *cb.Config) (channelconfig.Resources, error)

	// ChannelsCount returns the count of channels which currently exist.
	ChannelsCount() int
}

// LimitedSupport defines the subset of the channel resources required by the systemchannel filter.
type LimitedSupport interface {
	OrdererConfig() (channelconfig.Orderer, bool)
}

// SystemChainFilter implements the filter.Rule interface.
type SystemChainFilter struct {
	cc      ChainCreator
	support LimitedSupport
}

// NewSystemChannelFilter returns a new instance of a *SystemChainFilter.
func NewSystemChannelFilter(ls LimitedSupport, cc ChainCreator) *SystemChainFilter {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[0], 1);
	return &SystemChainFilter{
		support: ls,
		cc:      cc,
	}
}

// Apply rejects bad messages with an error.
func (scf *SystemChainFilter) Apply(env *cb.Envelope) error {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[1], 1);
	msgData := &cb.Payload{}

	err := proto.Unmarshal(env.Payload, msgData)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[9], 1);
		return errors.Errorf("bad payload: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[2], 1);if msgData.Header == nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[10], 1);
		return errors.Errorf("missing payload header")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[3], 1);chdr, err := utils.UnmarshalChannelHeader(msgData.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[11], 1);
		return errors.Errorf("bad channel header: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[4], 1);if chdr.Type != int32(cb.HeaderType_ORDERER_TRANSACTION) {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[12], 1);
		return nil
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[5], 1);ordererConfig, ok := scf.support.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[13], 1);
		logger.Panicf("System channel does not have orderer config")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[6], 1);maxChannels := ordererConfig.MaxChannelsCount()
	if maxChannels > 0 {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[14], 1);
		// We check for strictly greater than to accommodate the system channel
		if uint64(scf.cc.ChannelsCount()) > maxChannels {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[15], 1);
			return errors.Errorf("channel creation would exceed maximimum number of channels: %d", maxChannels)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[7], 1);configTx := &cb.Envelope{}
	err = proto.Unmarshal(msgData.Data, configTx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[16], 1);
		return errors.Errorf("payload data error unmarshaling to envelope: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[8], 1);return scf.authorizeAndInspect(configTx)
}

func (scf *SystemChainFilter) authorizeAndInspect(configTx *cb.Envelope) error {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[17], 1);
	payload := &cb.Payload{}
	err := proto.Unmarshal(configTx.Payload, payload)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[32], 1);
		return errors.Errorf("error unmarshaling wrapped configtx envelope payload: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[18], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[33], 1);
		return errors.Errorf("wrapped configtx envelope missing header")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[19], 1);chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[34], 1);
		return errors.Errorf("error unmarshaling wrapped configtx envelope channel header: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[20], 1);if chdr.Type != int32(cb.HeaderType_CONFIG) {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[35], 1);
		return errors.Errorf("wrapped configtx envelope not a config transaction")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[21], 1);configEnvelope := &cb.ConfigEnvelope{}
	err = proto.Unmarshal(payload.Data, configEnvelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[36], 1);
		return errors.Errorf("error unmarshalling wrapped configtx config envelope from payload: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[22], 1);if configEnvelope.LastUpdate == nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[37], 1);
		return errors.Errorf("updated config does not include a config update")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[23], 1);res, err := scf.cc.NewChannelConfig(configEnvelope.LastUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[38], 1);
		return errors.Errorf("error constructing new channel config from update: %s", err)
	}

	// Make sure that the config was signed by the appropriate authorized entities
	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[24], 1);newChannelConfigEnv, err := res.ConfigtxValidator().ProposeConfigUpdate(configEnvelope.LastUpdate)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[39], 1);
		return errors.Errorf("error proposing channel update to new channel config: %s", err)
	}

	// reflect.DeepEqual will not work here, because it considers nil and empty maps as unequal
	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[25], 1);if !proto.Equal(newChannelConfigEnv, configEnvelope) {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[40], 1);
		return errors.Errorf("config proposed by the channel creation request did not match the config received with the channel creation request")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[26], 1);bundle, err := scf.cc.CreateBundle(res.ConfigtxValidator().ChainID(), newChannelConfigEnv.Config)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[41], 1);
		return errors.Wrap(err, "config does not validly parse")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[27], 1);if err = res.ValidateNew(bundle); err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[42], 1);
		return errors.Wrap(err, "new bundle invalid")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[28], 1);oc, ok := bundle.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[43], 1);
		return errors.New("config is missing orderer group")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[29], 1);if err = oc.Capabilities().Supported(); err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[44], 1);
		return errors.Wrap(err, "config update is not compatible")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[30], 1);if err = bundle.ChannelConfig().Capabilities().Supported(); err != nil {_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[45], 1);
		return errors.Wrap(err, "config update is not compatible")
	}

	_cover_atomic_.AddUint32(&GoCover_7_646330373837303238396264.Count[31], 1);return nil
}

var GoCover_7_646330373837303238396264 = struct {
	Count     [46]uint32
	Pos       [3 * 46]uint32
	NumStmt   [46]uint16
} {
	Pos: [3 * 46]uint32{
		41, 46, 0x20054, // [0]
		49, 53, 0x10003d, // [1]
		57, 57, 0x1b0002, // [2]
		61, 62, 0x100002, // [3]
		66, 66, 0x3b0002, // [4]
		70, 71, 0x90002, // [5]
		75, 76, 0x150002, // [6]
		83, 85, 0x100002, // [7]
		89, 89, 0x2a0002, // [8]
		53, 55, 0x30010, // [9]
		57, 59, 0x3001b, // [10]
		62, 64, 0x30010, // [11]
		66, 68, 0x3003b, // [12]
		71, 73, 0x30009, // [13]
		76, 78, 0x330015, // [14]
		78, 80, 0x40033, // [15]
		85, 87, 0x30010, // [16]
		92, 95, 0x100050, // [17]
		99, 99, 0x1b0002, // [18]
		103, 104, 0x100002, // [19]
		108, 108, 0x2e0002, // [20]
		112, 114, 0x100002, // [21]
		118, 118, 0x260002, // [22]
		122, 123, 0x100002, // [23]
		128, 129, 0x100002, // [24]
		134, 134, 0x370002, // [25]
		138, 139, 0x100002, // [26]
		143, 143, 0x2f0002, // [27]
		147, 148, 0x90002, // [28]
		152, 152, 0x350002, // [29]
		156, 156, 0x490002, // [30]
		160, 160, 0xc0002, // [31]
		95, 97, 0x30010, // [32]
		99, 101, 0x3001b, // [33]
		104, 106, 0x30010, // [34]
		108, 110, 0x3002e, // [35]
		114, 116, 0x30010, // [36]
		118, 120, 0x30026, // [37]
		123, 125, 0x30010, // [38]
		129, 131, 0x30010, // [39]
		134, 136, 0x30037, // [40]
		139, 141, 0x30010, // [41]
		143, 145, 0x3002f, // [42]
		148, 150, 0x30009, // [43]
		152, 154, 0x30035, // [44]
		156, 158, 0x30049, // [45]
	},
	NumStmt: [46]uint16{
		1, // 0
		3, // 1
		1, // 2
		2, // 3
		1, // 4
		2, // 5
		2, // 6
		3, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		3, // 17
		1, // 18
		2, // 19
		1, // 20
		3, // 21
		1, // 22
		2, // 23
		2, // 24
		1, // 25
		2, // 26
		1, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
	},
}
var _ = _cover_atomic_.LoadUint32
