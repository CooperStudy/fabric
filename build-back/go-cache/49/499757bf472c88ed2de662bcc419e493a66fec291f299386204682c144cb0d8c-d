//line /home/cooper/go/src/github.com/hyperledger/fabric/common/policies/inquire/merge.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package inquire; import _cover_atomic_ "sync/atomic"

import (
	"reflect"

	"github.com/hyperledger/fabric/common/policies"
)

// ComparablePrincipalSets aggregate ComparablePrincipalSets
type ComparablePrincipalSets []ComparablePrincipalSet

// ToPrincipalSets converts this ComparablePrincipalSets to a PrincipalSets
func (cps ComparablePrincipalSets) ToPrincipalSets() policies.PrincipalSets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[0], 1);
	var res policies.PrincipalSets
	for _, cp := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[2], 1);
		res = append(res, cp.ToPrincipalSet())
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[1], 1);return res
}

// Merge returns ComparablePrincipalSets that the underlying PrincipalSets consist of
// PrincipalSets that satisfy the endorsement policies that both ComparablePrincipalSets were derived of.
// More formally speaking, let EP1 and EP2 be endorsement policies, and
// P1 and P2 be the principal sets that each principal set p in P1 satisfies EP1,
// and each principal set p in P2 satisfies EP2.
// Denote as S1 and S2 the ComparablePrincipalSets derived from EP1 and EP2 respectively.
// Then, S = Merge(S1, S2) wields ComparablePrincipalSets
// such that every ComparablePrincipalSet s in S, satisfies both EP1 and EP2.
func Merge(s1, s2 ComparablePrincipalSets) ComparablePrincipalSets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[3], 1);
	var res ComparablePrincipalSets
	setsIn1ToTheContainingSetsIn2 := computeContainedInMapping(s1, s2)
	setsIn1ThatAreIn2 := s1.OfMapping(setsIn1ToTheContainingSetsIn2, s2)
	// Without loss of generality, remove all principal sets in s1 that
	// are contained by principal sets in s2, in order not to have duplicates
	s1 = s1.ExcludeIndices(setsIn1ToTheContainingSetsIn2)
	setsIn2ToTheContainingSetsIn1 := computeContainedInMapping(s2, s1)
	setsIn2ThatAreIn1 := s2.OfMapping(setsIn2ToTheContainingSetsIn1, s1)
	s2 = s2.ExcludeIndices(setsIn2ToTheContainingSetsIn1)

	// In the interim, the result contains sets from either the first of the second
	// set, that also contain some other set(s) in the other set
	res = append(res, setsIn1ThatAreIn2.ToMergedPrincipalSets()...)
	res = append(res, setsIn2ThatAreIn1.ToMergedPrincipalSets()...)

	// Now, purge the principal sets from the original groups s1 and s2
	// that are found to contain sets from the other group.
	// The motivation is to be left with s1 and s2 that only contain sets that aren't
	// contained or contain any set of the other group.
	s1 = s1.ExcludeIndices(setsIn2ToTheContainingSetsIn1.invert())
	s2 = s2.ExcludeIndices(setsIn1ToTheContainingSetsIn2.invert())

	// We're left with principal sets either in both or in one of the sets
	// that are entirely contained by the other sets, so there is nothing more to be done
	if len(s1) == 0 || len(s2) == 0 {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[5], 1);
		return res.Reduce()
	}

	// We're only left with sets that are not contained in the other sets,
	// in both sets. Therefore we should combine them to form principal sets
	// that contain both sets.
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[4], 1);combinedPairs := CartesianProduct(s1, s2)
	res = append(res, combinedPairs.ToMergedPrincipalSets()...)
	return res.Reduce()
}

// CartesianProduct returns a comparablePrincipalSetPairs that is comprised of the combination
// of every possible pair of ComparablePrincipalSet such that the first element is in s1,
// and the second element is in s2.
func CartesianProduct(s1, s2 ComparablePrincipalSets) comparablePrincipalSetPairs {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[6], 1);
	var res comparablePrincipalSetPairs
	for _, x := range s1 {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[8], 1);
		var set comparablePrincipalSetPairs
		// For every set in the first sets,
		// combine it with every set in the second sets
		for _, y := range s2 {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[10], 1);
			set = append(set, comparablePrincipalSetPair{
				contained:  x,
				containing: y,
			})
		}
		_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[9], 1);res = append(res, set...)
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[7], 1);return res
}

// comparablePrincipalSetPair is a tuple of 2 ComparablePrincipalSets
type comparablePrincipalSetPair struct {
	contained  ComparablePrincipalSet
	containing ComparablePrincipalSet
}

// EnsurePlurality returns a ComparablePrincipalSet such that plurality requirements over
// the contained ComparablePrincipalSet in the comparablePrincipalSetPair hold
func (pair comparablePrincipalSetPair) MergeWithPlurality() ComparablePrincipalSet {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[11], 1);
	var principalsToAdd []*ComparablePrincipal
	used := make(map[int]struct{})
	// Iterate over the contained set and for each principal
	for _, principal := range pair.contained {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[13], 1);
		var covered bool
		// Search a principal in the containing set to cover the principal in the contained set
		for i, coveringPrincipal := range pair.containing {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[15], 1);
			// The principal found shouldn't be used twice
			if _, isUsed := used[i]; isUsed {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[17], 1);
				continue
			}
			// All identities that satisfy the found principal, should satisfy the covered principal as well.
			_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[16], 1);if coveringPrincipal.IsA(principal) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[18], 1);
				used[i] = struct{}{}
				covered = true
				break
			}
		}
		// If we haven't found a cover to the principal, it's because we already used up all the potential candidates
		// among the containing set, so just add it to the principals set to be added later.
		_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[14], 1);if !covered {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[19], 1);
			principalsToAdd = append(principalsToAdd, principal)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[12], 1);res := pair.containing.Clone()
	res = append(res, principalsToAdd...)
	return res
}

// comparablePrincipalSetPairs aggregates []comparablePrincipalSetPairs
type comparablePrincipalSetPairs []comparablePrincipalSetPair

// ToPrincipalSets converts the comparablePrincipalSetPairs to ComparablePrincipalSets
// while taking into account plurality of each pair
func (pairs comparablePrincipalSetPairs) ToMergedPrincipalSets() ComparablePrincipalSets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[20], 1);
	var res ComparablePrincipalSets
	for _, pair := range pairs {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[22], 1);
		res = append(res, pair.MergeWithPlurality())
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[21], 1);return res
}

// OfMapping returns comparablePrincipalSetPairs comprising only of the indices found in the given keys
func (cps ComparablePrincipalSets) OfMapping(mapping map[int][]int, sets2 ComparablePrincipalSets) comparablePrincipalSetPairs {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[23], 1);
	var res []comparablePrincipalSetPair
	for i, js := range mapping {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[25], 1);
		for _, j := range js {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[26], 1);
			res = append(res, comparablePrincipalSetPair{
				contained:  cps[i],
				containing: sets2[j],
			})
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[24], 1);return res
}

// Reduce returns the ComparablePrincipalSets in a form such that no element contains another element.
// Every element that contains some other element is omitted from the result.
func (cps ComparablePrincipalSets) Reduce() ComparablePrincipalSets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[27], 1);
	var res ComparablePrincipalSets
	for i, s1 := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[29], 1);
		var isContaining bool
		for j, s2 := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[31], 1);
			if i == j {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[33], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[32], 1);if s2.IsSubset(s1) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[34], 1);
				isContaining = true
			}
		}
		_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[30], 1);if !isContaining {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[35], 1);
			res = append(res, s1)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[28], 1);return res
}

// ExcludeIndices returns a ComparablePrincipalSets without the given indices found in the keys
func (cps ComparablePrincipalSets) ExcludeIndices(mapping map[int][]int) ComparablePrincipalSets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[36], 1);
	var res ComparablePrincipalSets
	for i, set := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[38], 1);
		if _, exists := mapping[i]; exists {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[40], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[39], 1);res = append(res, set)
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[37], 1);return res
}

// Contains returns whether this ComparablePrincipalSet contains the given ComparablePrincipal.
// A ComparablePrincipalSet X contains a ComparablePrincipal y if
// there is a ComparablePrincipal x in X such that x.IsA(y).
// From here it follows that every signature set that satisfies X, also satisfies y.
func (cps ComparablePrincipalSet) Contains(s *ComparablePrincipal) bool {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[41], 1);
	for _, cp := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[43], 1);
		if cp.IsA(s) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[44], 1);
			return true
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[42], 1);return false
}

// IsContainedIn returns whether this ComparablePrincipalSet is contained in the given ComparablePrincipalSet.
// More formally- a ComparablePrincipalSet X is said to be contained in ComparablePrincipalSet Y
// if for each ComparablePrincipalSet x in X there is a ComparablePrincipalSet y in Y such that y.IsA(x) is true.
// If a ComparablePrincipalSet X is contained by a ComparablePrincipalSet Y then if a signature set satisfies Y,
// it also satisfies X, because for each x in X there is a y in Y such that there exists a signature of a corresponding
// identity such that the identity satisfies y, and therefore satisfies x too.
func (cps ComparablePrincipalSet) IsContainedIn(set ComparablePrincipalSet) bool {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[45], 1);
	for _, cp := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[47], 1);
		if !set.Contains(cp) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[48], 1);
			return false
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[46], 1);return true
}

// computeContainedInMapping returns a mapping from the indices in the first ComparablePrincipalSets
// to the indices in the second ComparablePrincipalSets that the corresponding ComparablePrincipalSets in
// the first ComparablePrincipalSets are contained in the second ComparablePrincipalSets given.
func computeContainedInMapping(s1, s2 []ComparablePrincipalSet) intMapping {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[49], 1);
	mapping := make(map[int][]int)
	for i, ps1 := range s1 {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[51], 1);
		for j, ps2 := range s2 {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[52], 1);
			if !ps1.IsContainedIn(ps2) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[54], 1);
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[53], 1);mapping[i] = append(mapping[i], j)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[50], 1);return mapping
}

// intMapping maps integers to sets of integers
type intMapping map[int][]int

func (im intMapping) invert() intMapping {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[55], 1);
	res := make(intMapping)
	for i, js := range im {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[57], 1);
		for _, j := range js {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[58], 1);
			res[j] = append(res[j], i)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[56], 1);return res
}

// IsSubset returns whether this ComparablePrincipalSet is a subset of the given ComparablePrincipalSet
func (cps ComparablePrincipalSet) IsSubset(sets ComparablePrincipalSet) bool {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[59], 1);
	for _, p1 := range cps {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[61], 1);
		var found bool
		for _, p2 := range sets {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[63], 1);
			if reflect.DeepEqual(p1, p2) {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[64], 1);
				found = true
			}
		}
		_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[62], 1);if !found {_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[65], 1);
			return false
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_666534393065343133333939.Count[60], 1);return true
}

var GoCover_2_666534393065343133333939 = struct {
	Count     [66]uint32
	Pos       [3 * 66]uint32
	NumStmt   [66]uint16
} {
	Pos: [3 * 66]uint32{
		19, 21, 0x19004d, // [0]
		24, 24, 0xc0002, // [1]
		21, 23, 0x30019, // [2]
		35, 60, 0x220044, // [3]
		67, 69, 0x150002, // [4]
		60, 62, 0x30022, // [5]
		75, 77, 0x170053, // [6]
		89, 89, 0xc0002, // [7]
		77, 81, 0x180017, // [8]
		87, 87, 0x1c0003, // [9]
		81, 86, 0x40018, // [10]
		100, 104, 0x2b0054, // [11]
		126, 128, 0xc0002, // [12]
		104, 107, 0x35002b, // [13]
		121, 121, 0xf0003, // [14]
		107, 109, 0x240035, // [15]
		113, 113, 0x280004, // [16]
		109, 110, 0xd0024, // [17]
		113, 116, 0xa0028, // [18]
		121, 123, 0x4000f, // [19]
		136, 138, 0x1d005a, // [20]
		141, 141, 0xc0002, // [21]
		138, 140, 0x3001d, // [22]
		145, 147, 0x1d0080, // [23]
		155, 155, 0xc0002, // [24]
		147, 148, 0x18001d, // [25]
		148, 153, 0x40018, // [26]
		160, 162, 0x190045, // [27]
		176, 176, 0xc0002, // [28]
		162, 164, 0x1a0019, // [29]
		172, 172, 0x140003, // [30]
		164, 165, 0xe001a, // [31]
		168, 168, 0x170004, // [32]
		165, 166, 0xd000e, // [33]
		168, 170, 0x50017, // [34]
		172, 174, 0x40014, // [35]
		180, 182, 0x1a0062, // [36]
		188, 188, 0xc0002, // [37]
		182, 183, 0x26001a, // [38]
		186, 186, 0x190003, // [39]
		183, 184, 0xc0026, // [40]
		195, 196, 0x190049, // [41]
		201, 201, 0xe0002, // [42]
		196, 197, 0x100019, // [43]
		197, 199, 0x40010, // [44]
		210, 211, 0x190052, // [45]
		216, 216, 0xd0002, // [46]
		211, 212, 0x180019, // [47]
		212, 214, 0x40018, // [48]
		222, 224, 0x19004c, // [49]
		232, 232, 0x100002, // [50]
		224, 225, 0x1a0019, // [51]
		225, 226, 0x1f001a, // [52]
		229, 229, 0x260004, // [53]
		226, 227, 0xd001f, // [54]
		238, 240, 0x18002a, // [55]
		245, 245, 0xc0002, // [56]
		240, 241, 0x180018, // [57]
		241, 243, 0x40018, // [58]
		249, 250, 0x19004e, // [59]
		261, 261, 0xd0002, // [60]
		250, 252, 0x1b0019, // [61]
		257, 257, 0xd0003, // [62]
		252, 253, 0x21001b, // [63]
		253, 255, 0x50021, // [64]
		257, 259, 0x4000d, // [65]
	},
	NumStmt: [66]uint16{
		2, // 0
		1, // 1
		1, // 2
		12, // 3
		3, // 4
		1, // 5
		2, // 6
		1, // 7
		2, // 8
		1, // 9
		1, // 10
		3, // 11
		3, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		3, // 18
		1, // 19
		2, // 20
		1, // 21
		1, // 22
		2, // 23
		1, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		1, // 46
		1, // 47
		1, // 48
		2, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		2, // 55
		1, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		2, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
	},
}
var _ = _cover_atomic_.LoadUint32
