//line /home/cooper/go/src/github.com/hyperledger/fabric/examples/chaincode/go/example03/chaincode.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

// This program is an erroneous chaincode program that attempts to put state in query context - query should return error
package example03; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

// SimpleChaincode example simple Chaincode implementation
type SimpleChaincode struct{}

// Init takes a string and int. These are stored as a key/value pair in the state
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[0], 1);
	var A string // Entity
	var Aval int // Asset holding
	var err error
	_, args := stub.GetFunctionAndParameters()
	if len(args) != 2 {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[4], 1);
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	// Initialize the chaincode
	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[1], 1);A = args[0]
	Aval, err = strconv.Atoi(args[1])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[5], 1);
		return shim.Error("Expecting integer value for asset holding")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[2], 1);fmt.Printf("Aval = %d\n", Aval)

	// Write the state to the ledger - this put is legal within Run
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[6], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[3], 1);return shim.Success(nil)
}

// Invoke is a no-op
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[7], 1);
	function, args := stub.GetFunctionAndParameters()
	if function == "query" {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[9], 1);
		return t.query(stub, args)
	}

	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[8], 1);return shim.Error("Invalid invoke function name. Expecting \"query\"")
}

func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[10], 1);
	var A string // Entity
	var Aval int // Asset holding
	var err error

	if len(args) != 2 {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[14], 1);
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[11], 1);A = args[0]
	Aval, err = strconv.Atoi(args[1])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[15], 1);
		return shim.Error("Expecting integer value for asset holding")
	}
	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[12], 1);fmt.Printf("Aval = %d\n", Aval)

	// Write the state to the ledger - this put is illegal within Run
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[16], 1);
		jsonResp := "{\"Error\":\"Cannot put state within chaincode query\"}"
		return shim.Error(jsonResp)
	}

	_cover_atomic_.AddUint32(&GoCover_0_643563323562646236383463.Count[13], 1);return shim.Success(nil)
}

var GoCover_0_643563323562646236383463 = struct {
	Count     [17]uint32
	Pos       [3 * 17]uint32
	NumStmt   [17]uint16
} {
	Pos: [3 * 17]uint32{
		22, 27, 0x14004e, // [0]
		32, 34, 0x100002, // [1]
		37, 41, 0x100002, // [2]
		45, 45, 0x1a0002, // [3]
		27, 29, 0x30014, // [4]
		34, 36, 0x30010, // [5]
		41, 43, 0x30010, // [6]
		49, 51, 0x190050, // [7]
		55, 55, 0x480002, // [8]
		51, 53, 0x30019, // [9]
		58, 63, 0x14005e, // [10]
		67, 69, 0x100002, // [11]
		72, 76, 0x100002, // [12]
		81, 81, 0x1a0002, // [13]
		63, 65, 0x30014, // [14]
		69, 71, 0x30010, // [15]
		76, 79, 0x30010, // [16]
	},
	NumStmt: [17]uint16{
		5, // 0
		3, // 1
		3, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		4, // 10
		3, // 11
		3, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
	},
}
var _ = _cover_atomic_.LoadUint32
