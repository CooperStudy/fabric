//line /home/cooper/go/src/github.com/hyperledger/fabric/examples/chaincode/go/example05/chaincode.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package example05; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

// This chaincode is a test for chaincode querying another chaincode - invokes chaincode_example02 and computes the sum of a and b and stores it as state

// SimpleChaincode example simple Chaincode implementation
type SimpleChaincode struct{}

func toChaincodeArgs(args ...string) [][]byte {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[0], 1);
	bargs := make([][]byte, len(args))
	for i, arg := range args {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[2], 1);
		bargs[i] = []byte(arg)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[1], 1);return bargs
}

// Init takes two arguments, a string and int. The string will be a key with
// the int as a value.
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[3], 1);
	var sum string // Sum of asset holdings across accounts. Initially 0
	var sumVal int // Sum of holdings
	var err error
	_, args := stub.GetFunctionAndParameters()
	if len(args) != 2 {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[7], 1);
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	// Initialize the chaincode
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[4], 1);sum = args[0]
	sumVal, err = strconv.Atoi(args[1])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[8], 1);
		return shim.Error("Expecting integer value for sum")
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[5], 1);fmt.Printf("sumVal = %d\n", sumVal)

	// Write the state to the ledger
	err = stub.PutState(sum, []byte(strconv.Itoa(sumVal)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[9], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[6], 1);return shim.Success(nil)
}

// Invoke queries another chaincode and updates its own state
func (t *SimpleChaincode) invoke(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[10], 1);
	var sum, channelName string // Sum entity
	var Aval, Bval, sumVal int  // value of sum entity - to be computed
	var err error

	if len(args) < 2 {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[18], 1);
		return shim.Error("Incorrect number of arguments. Expecting atleast 2")
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[11], 1);chaincodeName := args[0] // Expecting name of the chaincode you would like to call, this name would be given during chaincode install time
	sum = args[1]

	if len(args) > 2 {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[19], 1);
		channelName = args[2]
	} else{ _cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[20], 1);{
		channelName = ""
	}}

	// Query chaincode_example02
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[12], 1);f := "query"
	queryArgs := toChaincodeArgs(f, "a")

	//   if chaincode being invoked is on the same channel,
	//   then channel defaults to the current channel and args[2] can be "".
	//   If the chaincode being called is on a different channel,
	//   then you must specify the channel name in args[2]

	response := stub.InvokeChaincode(chaincodeName, queryArgs, channelName)
	if response.Status != shim.OK {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[21], 1);
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", response.Payload)
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[13], 1);Aval, err = strconv.Atoi(string(response.Payload))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[22], 1);
		errStr := fmt.Sprintf("Error retrieving state from ledger for queried chaincode: %s", err.Error())
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[14], 1);queryArgs = toChaincodeArgs(f, "b")
	response = stub.InvokeChaincode(chaincodeName, queryArgs, channelName)
	if response.Status != shim.OK {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[23], 1);
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", response.Payload)
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[15], 1);Bval, err = strconv.Atoi(string(response.Payload))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[24], 1);
		errStr := fmt.Sprintf("Error retrieving state from ledger for queried chaincode: %s", err.Error())
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}

	// Compute sum
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[16], 1);sumVal = Aval + Bval

	// Write sumVal back to the ledger
	err = stub.PutState(sum, []byte(strconv.Itoa(sumVal)))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[25], 1);
		return shim.Error(err.Error())
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[17], 1);fmt.Printf("Invoke chaincode successful. Got sum %d\n", sumVal)
	return shim.Success([]byte(strconv.Itoa(sumVal)))
}

func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[26], 1);
	var sum, channelName string // Sum entity
	var Aval, Bval, sumVal int  // value of sum entity - to be computed
	var err error

	if len(args) < 2 {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[33], 1);
		return shim.Error("Incorrect number of arguments. Expecting atleast 2")
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[27], 1);chaincodeName := args[0] // Expecting name of the chaincode you would like to call, this name would be given during chaincode install time
	sum = args[1]

	if len(args) > 2 {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[34], 1);
		channelName = args[2]
	} else{ _cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[35], 1);{
		channelName = ""
	}}

	// Query chaincode_example02
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[28], 1);f := "query"
	queryArgs := toChaincodeArgs(f, "a")

	//   if chaincode being invoked is on the same channel,
	//   then channel defaults to the current channel and args[2] can be "".
	//   If the chaincode being called is on a different channel,
	//   then you must specify the channel name in args[2]
	response := stub.InvokeChaincode(chaincodeName, queryArgs, channelName)
	if response.Status != shim.OK {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[36], 1);
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", response.Payload)
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[29], 1);Aval, err = strconv.Atoi(string(response.Payload))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[37], 1);
		errStr := fmt.Sprintf("Error retrieving state from ledger for queried chaincode: %s", err.Error())
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[30], 1);queryArgs = toChaincodeArgs(f, "b")
	response = stub.InvokeChaincode(chaincodeName, queryArgs, channelName)
	if response.Status != shim.OK {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[38], 1);
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", response.Payload)
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[31], 1);Bval, err = strconv.Atoi(string(response.Payload))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[39], 1);
		errStr := fmt.Sprintf("Error retrieving state from ledger for queried chaincode: %s", err.Error())
		fmt.Printf(errStr)
		return shim.Error(errStr)
	}

	// Compute sum
	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[32], 1);sumVal = Aval + Bval

	fmt.Printf("Query chaincode successful. Got sum %d\n", sumVal)
	jsonResp := "{\"Name\":\"" + sum + "\",\"Value\":\"" + strconv.Itoa(sumVal) + "\"}"
	fmt.Printf("Query Response:%s\n", jsonResp)
	return shim.Success([]byte(strconv.Itoa(sumVal)))
}

func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[40], 1);
	function, args := stub.GetFunctionAndParameters()
	if function == "invoke" {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[42], 1);
		return t.invoke(stub, args)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[43], 1);if function == "query" {_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[44], 1);
		return t.query(stub, args)
	}}

	_cover_atomic_.AddUint32(&GoCover_0_623562323538373066643339.Count[41], 1);return shim.Success([]byte("Invalid invoke function name. Expecting \"invoke\" \"query\""))
}

var GoCover_0_623562323538373066643339 = struct {
	Count     [45]uint32
	Pos       [3 * 45]uint32
	NumStmt   [45]uint16
} {
	Pos: [3 * 45]uint32{
		22, 24, 0x1b002f, // [0]
		27, 27, 0xe0002, // [1]
		24, 26, 0x3001b, // [2]
		32, 37, 0x14004e, // [3]
		42, 44, 0x100002, // [4]
		47, 51, 0x100002, // [5]
		55, 55, 0x1a0002, // [6]
		37, 39, 0x30014, // [7]
		44, 46, 0x30010, // [8]
		51, 53, 0x30010, // [9]
		59, 64, 0x13005f, // [10]
		68, 71, 0x130002, // [11]
		78, 87, 0x200002, // [12]
		92, 93, 0x100002, // [13]
		99, 101, 0x200002, // [14]
		106, 107, 0x100002, // [15]
		114, 118, 0x100002, // [16]
		122, 123, 0x330002, // [17]
		64, 66, 0x30013, // [18]
		71, 73, 0x30013, // [19]
		73, 75, 0x30008, // [20]
		87, 91, 0x30020, // [21]
		93, 97, 0x30010, // [22]
		101, 105, 0x30020, // [23]
		107, 111, 0x30010, // [24]
		118, 120, 0x30010, // [25]
		126, 131, 0x13005e, // [26]
		135, 138, 0x130002, // [27]
		145, 153, 0x200002, // [28]
		158, 159, 0x100002, // [29]
		165, 167, 0x200002, // [30]
		172, 173, 0x100002, // [31]
		180, 185, 0x330002, // [32]
		131, 133, 0x30013, // [33]
		138, 140, 0x30013, // [34]
		140, 142, 0x30008, // [35]
		153, 157, 0x30020, // [36]
		159, 163, 0x30010, // [37]
		167, 171, 0x30020, // [38]
		173, 177, 0x30010, // [39]
		188, 190, 0x1a0050, // [40]
		196, 196, 0x5d0002, // [41]
		190, 192, 0x3001a, // [42]
		192, 192, 0x200008, // [43]
		192, 194, 0x30020, // [44]
	},
	NumStmt: [45]uint16{
		2, // 0
		1, // 1
		1, // 2
		5, // 3
		3, // 4
		3, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		4, // 10
		3, // 11
		4, // 12
		2, // 13
		3, // 14
		2, // 15
		3, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
		3, // 21
		3, // 22
		3, // 23
		3, // 24
		1, // 25
		4, // 26
		3, // 27
		4, // 28
		2, // 29
		3, // 30
		2, // 31
		5, // 32
		1, // 33
		1, // 34
		1, // 35
		3, // 36
		3, // 37
		3, // 38
		3, // 39
		2, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
	},
}
var _ = _cover_atomic_.LoadUint32
