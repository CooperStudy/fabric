//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blockledger/file/impl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fileledger; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/common/ledger/blockledger"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
)

var logger = flogging.MustGetLogger("common.ledger.blockledger.file")

// FileLedger is a struct used to interact with a node's ledger
type FileLedger struct {
	blockStore FileLedgerBlockStore
	signal     chan struct{}
}

// FileLedgerBlockStore defines the interface to interact with deliver when using a
// file ledger
type FileLedgerBlockStore interface {
	AddBlock(block *cb.Block) error
	GetBlockchainInfo() (*cb.BlockchainInfo, error)
	RetrieveBlocks(startBlockNumber uint64) (ledger.ResultsIterator, error)
}

// NewFileLedger creates a new FileLedger for interaction with the ledger
func NewFileLedger(blockStore FileLedgerBlockStore) *FileLedger {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[0], 1);
	return &FileLedger{blockStore: blockStore, signal: make(chan struct{})}
}

type fileLedgerIterator struct {
	ledger         *FileLedger
	blockNumber    uint64
	commonIterator ledger.ResultsIterator
}

// Next blocks until there is a new block available, or until Close is called.
// It returns an error if the next block is no longer retrievable.
func (i *fileLedgerIterator) Next() (*cb.Block, cb.Status) {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[1], 1);
	result, err := i.commonIterator.Next()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[4], 1);
		logger.Error(err)
		return nil, cb.Status_SERVICE_UNAVAILABLE
	}
	// Cover the case where another thread calls Close on the iterator.
	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[2], 1);if result == nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[5], 1);
		return nil, cb.Status_SERVICE_UNAVAILABLE
	}
	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[3], 1);return result.(*cb.Block), cb.Status_SUCCESS
}

// Close releases resources acquired by the Iterator
func (i *fileLedgerIterator) Close() {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[6], 1);
	i.commonIterator.Close()
}

// Iterator returns an Iterator, as specified by an ab.SeekInfo message, and its
// starting block number
func (fl *FileLedger) Iterator(startPosition *ab.SeekPosition) (blockledger.Iterator, uint64) {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[7], 1);
	var startingBlockNumber uint64
	switch start := startPosition.Type.(type) {
	case *ab.SeekPosition_Oldest:_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[10], 1);
		startingBlockNumber = 0
	case *ab.SeekPosition_Newest:_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[11], 1);
		info, err := fl.blockStore.GetBlockchainInfo()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[15], 1);
			logger.Panic(err)
		}
		_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[12], 1);newestBlockNumber := info.Height - 1
		startingBlockNumber = newestBlockNumber
	case *ab.SeekPosition_Specified:_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[13], 1);
		startingBlockNumber = start.Specified.Number
		height := fl.Height()
		if startingBlockNumber > height {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[16], 1);
			return &blockledger.NotFoundErrorIterator{}, 0
		}
	default:_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[14], 1);
		return &blockledger.NotFoundErrorIterator{}, 0
	}

	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[8], 1);iterator, err := fl.blockStore.RetrieveBlocks(startingBlockNumber)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[17], 1);
		return &blockledger.NotFoundErrorIterator{}, 0
	}

	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[9], 1);return &fileLedgerIterator{ledger: fl, blockNumber: startingBlockNumber, commonIterator: iterator}, startingBlockNumber
}

// Height returns the number of blocks on the ledger
func (fl *FileLedger) Height() uint64 {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[18], 1);
	info, err := fl.blockStore.GetBlockchainInfo()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[20], 1);
		logger.Panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[19], 1);return info.Height
}

// Append a new block to the ledger
func (fl *FileLedger) Append(block *cb.Block) error {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[21], 1);
	err := fl.blockStore.AddBlock(block)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[23], 1);
		close(fl.signal)
		fl.signal = make(chan struct{})
	}
	_cover_atomic_.AddUint32(&GoCover_1_633861303864623437393736.Count[22], 1);return err
}

var GoCover_1_633861303864623437393736 = struct {
	Count     [24]uint32
	Pos       [3 * 24]uint32
	NumStmt   [24]uint16
} {
	Pos: [3 * 24]uint32{
		34, 36, 0x20041, // [0]
		46, 48, 0x10003c, // [1]
		53, 53, 0x130002, // [2]
		56, 56, 0x2e0002, // [3]
		48, 51, 0x30010, // [4]
		53, 55, 0x30013, // [5]
		60, 62, 0x20026, // [6]
		66, 68, 0x2c005f, // [7]
		88, 89, 0x100002, // [8]
		93, 93, 0x790002, // [9]
		69, 70, 0x1a001f, // [10]
		71, 73, 0x11001f, // [11]
		76, 77, 0x2a0003, // [12]
		78, 81, 0x230022, // [13]
		84, 85, 0x31000a, // [14]
		73, 75, 0x40011, // [15]
		81, 83, 0x40023, // [16]
		89, 91, 0x30010, // [17]
		97, 99, 0x100027, // [18]
		102, 102, 0x140002, // [19]
		99, 101, 0x30010, // [20]
		106, 108, 0x100035, // [21]
		112, 112, 0xc0002, // [22]
		108, 111, 0x30010, // [23]
	},
	NumStmt: [24]uint16{
		1, // 0
		2, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		2, // 12
		3, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		2, // 23
	},
}
var _ = _cover_atomic_.LoadUint32
