//line /home/cooper/go/src/github.com/hyperledger/fabric/common/capabilities/capabilities.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package capabilities; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/flogging"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("common.capabilities")

// provider is the 'plugin' parameter for registry.
type provider interface {
	// HasCapability should report whether the binary supports this capability.
	HasCapability(capability string) bool

	// Type is used to make error messages more legible.
	Type() string
}

// registry is a common structure intended to be used to support specific aspects of capabilities
// such as orderer, application, and channel.
type registry struct {
	provider     provider
	capabilities map[string]*cb.Capability
}

func newRegistry(p provider, capabilities map[string]*cb.Capability) *registry {_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[0], 1);
	return &registry{
		provider:     p,
		capabilities: capabilities,
	}
}

// Supported checks that all of the required capabilities are supported by this binary.
func (r *registry) Supported() error {_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[1], 1);
	for capabilityName := range r.capabilities {_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[3], 1);
		if r.provider.HasCapability(capabilityName) {_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[5], 1);
			logger.Debugf("%s capability %s is supported and is enabled", r.provider.Type(), capabilityName)
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[4], 1);return errors.Errorf("%s capability %s is required but not supported", r.provider.Type(), capabilityName)
	}
	_cover_atomic_.AddUint32(&GoCover_1_333764323863383062363335.Count[2], 1);return nil
}

var GoCover_1_333764323863383062363335 = struct {
	Count     [6]uint32
	Pos       [3 * 6]uint32
	NumStmt   [6]uint16
} {
	Pos: [3 * 6]uint32{
		33, 38, 0x20050, // [0]
		41, 42, 0x2d0026, // [1]
		50, 50, 0xc0002, // [2]
		42, 43, 0x2f002d, // [3]
		48, 48, 0x6c0003, // [4]
		43, 45, 0xc002f, // [5]
	},
	NumStmt: [6]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		2, // 5
	},
}
var _ = _cover_atomic_.LoadUint32
