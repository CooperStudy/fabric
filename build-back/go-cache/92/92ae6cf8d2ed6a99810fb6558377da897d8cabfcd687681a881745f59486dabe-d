//line /home/cooper/go/src/github.com/hyperledger/fabric/bccsp/idemix/bridge/credential.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package bridge; import _cover_atomic_ "sync/atomic"

import (
	"bytes"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric-amcl/amcl"
	"github.com/hyperledger/fabric-amcl/amcl/FP256BN"
	"github.com/hyperledger/fabric/bccsp"
	"github.com/hyperledger/fabric/bccsp/idemix/handlers"
	cryptolib "github.com/hyperledger/fabric/idemix"
	"github.com/pkg/errors"
)

// Credential encapsulates the idemix algorithms to produce (sign) a credential
// and verify it. Recall that a credential is produced by the Issuer upon a credential request,
// and it is verified by the requester.
type Credential struct {
	NewRand func() *amcl.RAND
}

// Sign produces an idemix credential. It takes in input the issuer secret key,
// a serialised  credential request, and a list of attribute values.
// Notice that attributes should not contain attributes whose type is IdemixHiddenAttribute
// cause the credential needs to carry all the attribute values.
func (c *Credential) Sign(key handlers.IssuerSecretKey, credentialRequest []byte, attributes []bccsp.IdemixAttribute) (res []byte, err error) {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[0], 1);
	defer func() {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[6], 1);
		if r := recover(); r != nil {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[7], 1);
			res = nil
			err = errors.Errorf("failure [%s]", r)
		}
	}()

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[1], 1);iisk, ok := key.(*IssuerSecretKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[8], 1);
		return nil, errors.Errorf("invalid issuer secret key, expected *Big, got [%T]", key)
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[2], 1);cr := &cryptolib.CredRequest{}
	err = proto.Unmarshal(credentialRequest, cr)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[9], 1);
		return nil, errors.Wrap(err, "failed unmarshalling credential request")
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[3], 1);attrValues := make([]*FP256BN.BIG, len(attributes))
	for i := 0; i < len(attributes); i++ {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[10], 1);
		switch attributes[i].Type {
		case bccsp.IdemixBytesAttribute:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[11], 1);
			attrValues[i] = cryptolib.HashModOrder(attributes[i].Value.([]byte))
		case bccsp.IdemixIntAttribute:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[12], 1);
			attrValues[i] = FP256BN.NewBIGint(attributes[i].Value.(int))
		default:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[13], 1);
			return nil, errors.Errorf("attribute type not allowed or supported [%v] at position [%d]", attributes[i].Type, i)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[4], 1);cred, err := cryptolib.NewCredential(iisk.SK, cr, attrValues, c.NewRand())
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[14], 1);
		return nil, errors.WithMessage(err, "failed creating new credential")
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[5], 1);return proto.Marshal(cred)
}

// Verify checks that an idemix credential is cryptographically correct. It takes
// in input the user secret key (sk), the issuer public key (ipk), the serialised credential (credential),
// and a list of attributes. The list of attributes is optional, in case it is specified, Verify
// checks that the credential carries the specified attributes.
func (*Credential) Verify(sk handlers.Big, ipk handlers.IssuerPublicKey, credential []byte, attributes []bccsp.IdemixAttribute) (err error) {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[15], 1);
	defer func() {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[21], 1);
		if r := recover(); r != nil {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[22], 1);
			err = errors.Errorf("failure [%s]", r)
		}
	}()

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[16], 1);isk, ok := sk.(*Big)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[23], 1);
		return errors.Errorf("invalid user secret key, expected *Big, got [%T]", sk)
	}
	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[17], 1);iipk, ok := ipk.(*IssuerPublicKey)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[24], 1);
		return errors.Errorf("invalid issuer public key, expected *IssuerPublicKey, got [%T]", sk)
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[18], 1);cred := &cryptolib.Credential{}
	err = proto.Unmarshal(credential, cred)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[25], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[19], 1);for i := 0; i < len(attributes); i++ {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[26], 1);
		switch attributes[i].Type {
		case bccsp.IdemixBytesAttribute:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[27], 1);
			if !bytes.Equal(
				cryptolib.BigToBytes(cryptolib.HashModOrder(attributes[i].Value.([]byte))),
				cred.Attrs[i]) {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[31], 1);
				return errors.Errorf("credential does not contain the correct attribute value at position [%d]", i)
			}
		case bccsp.IdemixIntAttribute:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[28], 1);
			if !bytes.Equal(
				cryptolib.BigToBytes(FP256BN.NewBIGint(attributes[i].Value.(int))),
				cred.Attrs[i]) {_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[32], 1);
				return errors.Errorf("credential does not contain the correct attribute value at position [%d]", i)
			}
		case bccsp.IdemixHiddenAttribute:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[29], 1);
			continue
		default:_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[30], 1);
			return errors.Errorf("attribute type not allowed or supported [%v] at position [%d]", attributes[i].Type, i)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_373430303738666139356161.Count[20], 1);return cred.Ver(isk.E, iipk.PK)
}

var GoCover_0_373430303738666139356161 = struct {
	Count     [33]uint32
	Pos       [3 * 33]uint32
	NumStmt   [33]uint16
} {
	Pos: [3 * 33]uint32{
		31, 32, 0xf008f, // [0]
		39, 40, 0x90002, // [1]
		44, 46, 0x100002, // [2]
		50, 51, 0x270002, // [3]
		62, 63, 0x100002, // [4]
		67, 67, 0x1c0002, // [5]
		32, 33, 0x1f000f, // [6]
		33, 36, 0x4001f, // [7]
		40, 42, 0x30009, // [8]
		46, 48, 0x30010, // [9]
		51, 52, 0x1d0027, // [10]
		53, 54, 0x480023, // [11]
		55, 56, 0x400021, // [12]
		57, 58, 0x75000b, // [13]
		63, 65, 0x30010, // [14]
		74, 75, 0xf008d, // [15]
		81, 82, 0x90002, // [16]
		85, 86, 0x90002, // [17]
		90, 92, 0x100002, // [18]
		96, 96, 0x270002, // [19]
		117, 117, 0x210002, // [20]
		75, 76, 0x1f000f, // [21]
		76, 78, 0x4001f, // [22]
		82, 84, 0x30009, // [23]
		86, 88, 0x30009, // [24]
		92, 94, 0x30010, // [25]
		96, 97, 0x1d0027, // [26]
		98, 101, 0x140023, // [27]
		104, 107, 0x140021, // [28]
		110, 111, 0xc0024, // [29]
		112, 113, 0x70000b, // [30]
		101, 103, 0x50014, // [31]
		107, 109, 0x50014, // [32]
	},
	NumStmt: [33]uint16{
		1, // 0
		2, // 1
		3, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
		2, // 17
		3, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
	},
}
var _ = _cover_atomic_.LoadUint32
