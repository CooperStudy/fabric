//line /home/cooper/go/src/github.com/hyperledger/fabric/token/tms/plain/verifier.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package plain; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"strconv"
	"unicode/utf8"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger/customtx"
	"github.com/hyperledger/fabric/protos/token"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/hyperledger/fabric/token/identity"
	"github.com/hyperledger/fabric/token/ledger"
	"github.com/pkg/errors"
)

const (
	minUnicodeRuneValue   = 0            //U+0000
	maxUnicodeRuneValue   = utf8.MaxRune //U+10FFFF - maximum (and unallocated) code point
	compositeKeyNamespace = "\x00"
	tokenOutput           = "tokenOutput"
	tokenRedeem           = "tokenRedeem"
	tokenTx               = "tokenTx"
	tokenDelegatedOutput  = "tokenDelegatedOutput"
	tokenInput            = "tokenInput"
	tokenDelegatedInput   = "tokenDelegateInput"
	tokenNameSpace        = "tms"
)

var verifierLogger = flogging.MustGetLogger("token.tms.plain.verifier")

// A Verifier validates and commits token transactions.
type Verifier struct {
	IssuingValidator identity.IssuingValidator
}

// ProcessTx checks that transactions are correct wrt. the most recent ledger state.
// ProcessTx checks are ones that shall be done sequentially, since transactions within a block may introduce dependencies.
func (v *Verifier) ProcessTx(txID string, creator identity.PublicInfo, ttx *token.TokenTransaction, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[0], 1);
	verifierLogger.Debugf("checking transaction with txID '%s'", txID)
	err := v.checkProcess(txID, creator, ttx, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[3], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[1], 1);verifierLogger.Debugf("committing transaction with txID '%s'", txID)
	err = v.commitProcess(txID, creator, ttx, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[4], 1);
		verifierLogger.Errorf("error committing transaction with txID '%s': %s", txID, err)
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[2], 1);verifierLogger.Debugf("successfully processed transaction with txID '%s'", txID)
	return nil
}

func (v *Verifier) checkProcess(txID string, creator identity.PublicInfo, ttx *token.TokenTransaction, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[5], 1);
	action := ttx.GetPlainAction()
	if action == nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[9], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("check process failed for transaction '%s': missing token action", txID)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[6], 1);err := v.checkAction(creator, action, txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[10], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[7], 1);err = v.checkTxDoesNotExist(txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[11], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[8], 1);return nil
}

func (v *Verifier) checkAction(creator identity.PublicInfo, plainAction *token.PlainTokenAction, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[12], 1);
	switch action := plainAction.Data.(type) {
	case *token.PlainTokenAction_PlainImport:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[13], 1);
		return v.checkImportAction(creator, action.PlainImport, txID, simulator)
	case *token.PlainTokenAction_PlainTransfer:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[14], 1);
		return v.checkTransferAction(creator, action.PlainTransfer, txID, simulator)
	case *token.PlainTokenAction_PlainRedeem:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[15], 1);
		return v.checkRedeemAction(creator, action.PlainRedeem, txID, simulator)
	case *token.PlainTokenAction_PlainApprove:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[16], 1);
		return v.checkApproveAction(creator, action.PlainApprove, txID, simulator)
	default:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[17], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("unknown plain token action: %T", action)}
	}
}

func (v *Verifier) checkImportAction(creator identity.PublicInfo, importAction *token.PlainImport, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[18], 1);
	err := v.checkImportOutputs(importAction.GetOutputs(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[20], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[19], 1);return v.checkImportPolicy(creator, txID, importAction)
}

func (v *Verifier) checkImportOutputs(outputs []*token.PlainOutput, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[21], 1);
	if len(outputs) == 0 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[24], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("no outputs in transaction: %s", txID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[22], 1);for i, output := range outputs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[25], 1);
		err := v.checkOutputDoesNotExist(i, txID, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[27], 1);
			return err
		}

		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[26], 1);if output.Quantity == 0 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[28], 1);
			return &customtx.InvalidTxError{Msg: fmt.Sprintf("output %d quantity is 0 in transaction: %s", i, txID)}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[23], 1);return nil
}

func (v *Verifier) checkTransferAction(creator identity.PublicInfo, transferAction *token.PlainTransfer, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[29], 1);
	outputType, outputSum, err := v.checkTransferOutputs(transferAction.GetOutputs(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[34], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[30], 1);inputType, inputSum, err := v.checkTransferInputs(creator, transferAction.GetInputs(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[35], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[31], 1);if outputType != inputType {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[36], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("token type mismatch in inputs and outputs for transfer with ID %s (%s vs %s)", txID, outputType, inputType)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[32], 1);if outputSum != inputSum {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[37], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("token sum mismatch in inputs and outputs for transfer with ID %s (%d vs %d)", txID, outputSum, inputSum)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[33], 1);return nil
}

func (v *Verifier) checkRedeemAction(creator identity.PublicInfo, redeemAction *token.PlainTransfer, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[38], 1);
	// first perform the same checking as transfer
	err := v.checkTransferAction(creator, redeemAction, txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[43], 1);
		return err
	}

	// then perform additional checking for redeem outputs
	// redeem transaction should not have more than 2 outputs.
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[39], 1);outputs := redeemAction.GetOutputs()
	if len(outputs) > 2 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[44], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("too many outputs (%d) in a redeem transaction", len(outputs))}
	}

	// output[0] should always be a redeem output - i.e., owner should be nil
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[40], 1);if outputs[0].Owner != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[45], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("owner should be nil in a redeem output")}
	}

	// if output[1] presents, its owner must be same as the creator
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[41], 1);if len(outputs) == 2 && !bytes.Equal(creator.Public(), outputs[1].Owner) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[46], 1);
		println(hex.EncodeToString(creator.Public()))
		println(hex.EncodeToString(outputs[1].Owner))
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("wrong owner for remaining tokens, should be original owner %s, but got %s", creator.Public(), outputs[1].Owner)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[42], 1);return nil
}

func (v *Verifier) checkOutputDoesNotExist(index int, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[47], 1);
	outputID, err := createOutputKey(txID, index)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[51], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating output ID: %s", err)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[48], 1);existingOutputBytes, err := simulator.GetState(tokenNameSpace, outputID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[52], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[49], 1);if existingOutputBytes != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[53], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("output already exists: %s", outputID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[50], 1);return nil
}

func (v *Verifier) checkTransferOutputs(outputs []*token.PlainOutput, txID string, simulator ledger.LedgerReader) (string, uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[54], 1);
	tokenType := ""
	tokenSum := uint64(0)
	for i, output := range outputs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[56], 1);
		err := v.checkOutputDoesNotExist(i, txID, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[59], 1);
			return "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[57], 1);if tokenType == "" {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[60], 1);
			tokenType = output.GetType()
		} else{ _cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[61], 1);if tokenType != output.GetType() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[62], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("multiple token types ('%s', '%s') in transfer output for txID '%s'", tokenType, output.GetType(), txID)}
		}}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[58], 1);tokenSum += output.GetQuantity()
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[55], 1);return tokenType, tokenSum, nil
}

func (v *Verifier) checkTransferInputs(creator identity.PublicInfo, inputIDs []*token.InputId, txID string, simulator ledger.LedgerReader) (string, uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[63], 1);
	tokenType := ""
	inputSum := uint64(0)
	processedIDs := make(map[string]bool)
	for _, id := range inputIDs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[65], 1);
		inputKey, err := createOutputKey(id.TxId, int(id.Index))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[73], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating output ID for transfer input: %s", err)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[66], 1);input, err := v.getOutput(inputKey, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[74], 1);
			return "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[67], 1);err = v.checkInputOwner(creator, input, inputKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[75], 1);
			return "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[68], 1);if tokenType == "" {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[76], 1);
			tokenType = input.GetType()
		} else{ _cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[77], 1);if tokenType != input.GetType() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[78], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("multiple token types in transfer input for txID: %s (%s, %s)", txID, tokenType, input.GetType())}
		}}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[69], 1);if processedIDs[inputKey] {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[79], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("token input '%s' spent more than once in single transfer with txID '%s'", inputKey, txID)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[70], 1);processedIDs[inputKey] = true
		inputSum += input.GetQuantity()
		spentKey, err := createSpentKey(id.TxId, int(id.Index))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[80], 1);
			return "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[71], 1);spent, err := v.isSpent(spentKey, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[81], 1);
			return "", 0, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[72], 1);if spent {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[82], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("input with ID %s for transfer has already been spent", inputKey)}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[64], 1);return tokenType, inputSum, nil
}

func (v *Verifier) checkInputOwner(creator identity.PublicInfo, input *token.PlainOutput, inputID string) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[83], 1);
	if !bytes.Equal(creator.Public(), input.Owner) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[85], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("transfer input with ID %s not owned by creator", inputID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[84], 1);return nil
}

func (v *Verifier) checkTxDoesNotExist(txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[86], 1);
	txKey, err := createTxKey(txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[90], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating txID: %s", err)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[87], 1);existingTx, err := simulator.GetState(tokenNameSpace, txKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[91], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[88], 1);if existingTx != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[92], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("transaction already exists: %s", txID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[89], 1);return nil
}

func (v *Verifier) checkImportPolicy(creator identity.PublicInfo, txID string, importData *token.PlainImport) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[93], 1);
	for _, output := range importData.Outputs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[95], 1);
		err := v.IssuingValidator.Validate(creator, output.Type)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[96], 1);
			return &customtx.InvalidTxError{Msg: fmt.Sprintf("import policy check failed: %s", err)}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[94], 1);return nil
}

func (v *Verifier) commitProcess(txID string, creator identity.PublicInfo, ttx *token.TokenTransaction, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[97], 1);
	verifierLogger.Debugf("committing action with txID '%s'", txID)
	err := v.commitAction(ttx.GetPlainAction(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[100], 1);
		verifierLogger.Errorf("error committing action with txID '%s': %s", txID, err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[98], 1);verifierLogger.Debugf("adding transaction with txID '%s'", txID)
	err = v.addTransaction(txID, ttx, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[101], 1);
		verifierLogger.Debugf("error adding transaction with txID '%s': %s", txID, err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[99], 1);verifierLogger.Debugf("action with txID '%s' committed successfully", txID)
	return nil
}

func (v *Verifier) commitAction(plainAction *token.PlainTokenAction, txID string, simulator ledger.LedgerWriter) (err error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[102], 1);
	switch action := plainAction.Data.(type) {
	case *token.PlainTokenAction_PlainImport:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[104], 1);
		err = v.commitImportAction(action.PlainImport, txID, simulator)
	case *token.PlainTokenAction_PlainTransfer:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[105], 1);
		err = v.commitTransferAction(action.PlainTransfer, txID, simulator)
	case *token.PlainTokenAction_PlainRedeem:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[106], 1);
		// call the same commit method as transfer because PlainRedeem points to the same type of outputs as transfer
		err = v.commitTransferAction(action.PlainRedeem, txID, simulator)
	case *token.PlainTokenAction_PlainApprove:_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[107], 1);
		err = v.commitApproveAction(action.PlainApprove, txID, simulator)
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[103], 1);return
}

func (v *Verifier) commitImportAction(importAction *token.PlainImport, txID string, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[108], 1);
	for i, output := range importAction.GetOutputs() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[110], 1);
		outputID, err := createOutputKey(txID, i)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[112], 1);
			return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating output ID: %s", err)}
		}

		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[111], 1);err = v.addOutput(outputID, output, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[113], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[109], 1);return nil
}

// commitTransferAction is called for both transfer and redeem transactions
// Check the owner of each output to determine how to generate the key
func (v *Verifier) commitTransferAction(transferAction *token.PlainTransfer, txID string, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[114], 1);
	var outputID string
	var err error
	for i, output := range transferAction.GetOutputs() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[116], 1);
		if output.Owner != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[119], 1);
			outputID, err = createOutputKey(txID, i)
		} else{ _cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[120], 1);{
			outputID, err = createRedeemKey(txID, i)
		}}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[117], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[121], 1);
			return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating output ID: %s", err)}
		}

		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[118], 1);err = v.addOutput(outputID, output, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[122], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[115], 1);return v.markInputsSpent(txID, transferAction.GetInputs(), simulator)
}

func (v *Verifier) checkApproveAction(creator identity.PublicInfo, approveAction *token.PlainApprove, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[123], 1);
	outputType, outputSum, err := v.checkApproveOutputs(creator, approveAction.GetOutput(), approveAction.GetDelegatedOutputs(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[128], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[124], 1);inputType, inputSum, err := v.checkTransferInputs(creator, approveAction.GetInputs(), txID, simulator)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[129], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[125], 1);if outputType != inputType {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[130], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("token type mismatch in inputs and outputs for approve with ID %s (%s vs %s)", txID, outputType, inputType)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[126], 1);if outputSum != inputSum {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[131], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("token sum mismatch in inputs and outputs for approve with ID %s (%d vs %d)", txID, outputSum, inputSum)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[127], 1);return nil
}

func (v *Verifier) commitApproveAction(approveAction *token.PlainApprove, txID string, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[132], 1);
	if approveAction.GetOutput() != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[135], 1);
		outputID, err := createOutputKey(txID, 0)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[137], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[136], 1);err = v.addOutput(outputID, approveAction.GetOutput(), simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[138], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[133], 1);for i, delegatedOutput := range approveAction.GetDelegatedOutputs() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[139], 1);
		// createDelegatedOutputKey() error already checked in checkDelegatedOutputsDoesNotExist
		outputID, _ := createDelegatedOutputKey(txID, i)
		err := v.addDelegatedOutput(outputID, delegatedOutput, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[140], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[134], 1);return v.markInputsSpent(txID, approveAction.GetInputs(), simulator)
}

func (v *Verifier) checkApproveOutputs(creator identity.PublicInfo, output *token.PlainOutput, delegatedOutputs []*token.PlainDelegatedOutput, txID string, simulator ledger.LedgerReader) (string, uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[141], 1);
	tokenType := ""
	tokenSum := uint64(0)

	// output is optional in approve tx
	// check whether this tx contains an output
	if output != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[144], 1);
		// check that the owner is not an empty slice
		if !bytes.Equal(output.Owner, creator.Public()) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[150], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the owner of the output is not valid")}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[145], 1);tokenType = output.GetType()
		err := v.checkOutputDoesNotExist(0, txID, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[151], 1);
			return "", 0, err
		}
		// check that a spent key can be created for the output in the future
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[146], 1);spentKey, err := createSpentKey(txID, 0)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[152], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the output for approve txID '%s' is invalid: cannot create a spent key", txID)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[147], 1);spent, err := v.isSpent(spentKey, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[153], 1);
			return "", 0, errors.New(fmt.Sprintf("the output for approve txID '%s' is invalid: cannot check spent status", txID))
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[148], 1);if spent {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[154], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the output for approve txID '%s' is invalid: cannot create a spent key", txID)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[149], 1);tokenSum = output.GetQuantity()
	}

	// check consistency of delegated outputs
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[142], 1);for i, delegatedOutput := range delegatedOutputs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[155], 1);
		// check that delegated outputs have the creator as one of the owners
		if !bytes.Equal(delegatedOutput.Owner, creator.Public()) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[164], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the owner of the delegated output is invalid")}
		}
		// check consistency of type
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[156], 1);if tokenType == "" {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[165], 1);
			tokenType = delegatedOutput.GetType()
		} else{ _cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[166], 1);if tokenType != delegatedOutput.GetType() {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[167], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("multiple token types ('%s', '%s') in approve outputs for txID '%s'", tokenType, delegatedOutput.GetType(), txID)}
		}}
		// each delegated output should have one delegatees
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[157], 1);if len(delegatedOutput.Delegatees) != 1 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[168], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the number of delegates in approve txID '%s' is not 1, it is [%d]", txID, len(delegatedOutput.Delegatees))}
		}
		// check that the delegatee is not an empty slice
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[158], 1);if len(delegatedOutput.Delegatees[0]) == 0 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[169], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the delegated output for approve txID '%s' does not have a delegatee", txID)}
		}

		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[159], 1);err := v.checkDelegatedOutputDoesNotExist(i, txID, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[170], 1);
			return "", 0, errors.New(fmt.Sprintf("the delegated output for approve txID '%s' is invalid: the ID exists", txID))
		}
		// check that a spent key can be created for the delegate output in the future
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[160], 1);spentKey, err := createSpentDelegatedOutputKey(txID, int(i))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[171], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the delegated output for approve txID '%s' is invalid: cannot create a spent key", txID)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[161], 1);spent, err := v.isSpent(spentKey, simulator)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[172], 1);
			return "", 0, errors.New(fmt.Sprintf("the delegated output for approve txID '%s' is invalid: cannot check spent status", txID))
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[162], 1);if spent {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[173], 1);
			return "", 0, &customtx.InvalidTxError{Msg: fmt.Sprintf("the delegated output for approve txID '%s' is invalid: cannot create a spent key", txID)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[163], 1);tokenSum += delegatedOutput.GetQuantity()
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[143], 1);return tokenType, tokenSum, nil
}

func (v *Verifier) addOutput(outputID string, output *token.PlainOutput, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[174], 1);
	outputBytes := utils.MarshalOrPanic(output)

	return simulator.SetState(tokenNameSpace, outputID, outputBytes)
}

func (v *Verifier) addDelegatedOutput(outputID string, delegatedOutput *token.PlainDelegatedOutput, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[175], 1);
	outputBytes := utils.MarshalOrPanic(delegatedOutput)

	return simulator.SetState(tokenNameSpace, outputID, outputBytes)
}

func (v *Verifier) addTransaction(txID string, ttx *token.TokenTransaction, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[176], 1);
	ttxBytes := utils.MarshalOrPanic(ttx)

	ttxID, err := createTxKey(txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[178], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating txID: %s", err)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[177], 1);return simulator.SetState(tokenNameSpace, ttxID, ttxBytes)
}

var TokenInputSpentMarker = []byte{1}

func (v *Verifier) markInputsSpent(txID string, inputs []*token.InputId, simulator ledger.LedgerWriter) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[179], 1);
	for _, id := range inputs {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[181], 1);
		inputID, err := createSpentKey(id.TxId, int(id.Index))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[183], 1);
			return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating spent key: %s", err)}
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[182], 1);verifierLogger.Debugf("marking input '%s' as spent", inputID)
		err = simulator.SetState(tokenNameSpace, inputID, TokenInputSpentMarker)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[184], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[180], 1);return nil
}

func (v *Verifier) getOutput(outputID string, simulator ledger.LedgerReader) (*token.PlainOutput, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[185], 1);
	outputBytes, err := simulator.GetState(tokenNameSpace, outputID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[190], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[186], 1);if outputBytes == nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[191], 1);
		return nil, &customtx.InvalidTxError{Msg: fmt.Sprintf("input with ID %s for transfer does not exist", outputID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[187], 1);if len(outputBytes) == 0 {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[192], 1);
		return nil, &customtx.InvalidTxError{Msg: fmt.Sprintf("input with ID %s for transfer does not exist", outputID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[188], 1);output := &token.PlainOutput{}
	err = proto.Unmarshal(outputBytes, output)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[193], 1);
		return nil, &customtx.InvalidTxError{Msg: fmt.Sprintf("unmarshaling error: %s", err)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[189], 1);return output, nil
}

// isSpent checks whether an output token with identifier outputID has been spent.
func (v *Verifier) isSpent(spentKey string, simulator ledger.LedgerReader) (bool, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[194], 1);
	verifierLogger.Debugf("checking if input with ID '%s' has been spent", spentKey)
	result, err := simulator.GetState(tokenNameSpace, spentKey)
	return result != nil, err
}

// Create a ledger key for an individual output in a token transaction, as a function of
// the transaction ID, and the index of the output
func createOutputKey(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[195], 1);
	return createCompositeKey(tokenOutput, []string{txID, strconv.Itoa(index)})
}

// Create a ledger key for a redeem output in a token transaction, as a function of
// the transaction ID, and the index of the output
func createRedeemKey(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[196], 1);
	return createCompositeKey(tokenRedeem, []string{txID, strconv.Itoa(index)})
}

// Create a ledger key for a token transaction, as a function of the transaction ID
func createTxKey(txID string) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[197], 1);
	return createCompositeKey(tokenTx, []string{txID})
}

// Create a ledger key for a spent individual output in a token transaction, as a function of
// the transaction ID, and the index of the output
func createSpentKey(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[198], 1);
	return createCompositeKey("tokenInput", []string{txID, strconv.Itoa(index)})
}

// createCompositeKey and its related functions and consts copied from core/chaincode/shim/chaincode.go
func createCompositeKey(objectType string, attributes []string) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[199], 1);
	if err := validateCompositeKeyAttribute(objectType); err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[202], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[200], 1);ck := compositeKeyNamespace + objectType + string(minUnicodeRuneValue)
	for _, att := range attributes {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[203], 1);
		if err := validateCompositeKeyAttribute(att); err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[205], 1);
			return "", err
		}
		_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[204], 1);ck += att + string(minUnicodeRuneValue)
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[201], 1);return ck, nil
}

func validateCompositeKeyAttribute(str string) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[206], 1);
	if !utf8.ValidString(str) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[209], 1);
		return errors.Errorf("not a valid utf8 string: [%x]", str)
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[207], 1);for index, runeValue := range str {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[210], 1);
		if runeValue == minUnicodeRuneValue || runeValue == maxUnicodeRuneValue {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[211], 1);
			return errors.Errorf(`input contain unicode %#U starting at position [%d]. %#U and %#U are not allowed in the input attribute of a composite key`,
				runeValue, index, minUnicodeRuneValue, maxUnicodeRuneValue)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[208], 1);return nil
}

func parseCompositeKeyBytes(keyBytes []byte) string {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[212], 1);
	return string(keyBytes)
}

func getCompositeKeyBytes(compositeKey string) []byte {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[213], 1);
	return []byte(compositeKey)
}

// Create a ledger key for an individual delegated output in a token transaction, as a function of
// the transaction ID, and the index of the output
func createDelegatedOutputKey(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[214], 1);
	return createCompositeKey(tokenDelegatedOutput, []string{txID, strconv.Itoa(index)})
}

// Create a ledger key for a spent individual delegated output in a token transaction, as a function of
// the transaction ID, and the index of the delegated output
func createSpentDelegatedOutputKey(txID string, index int) (string, error) {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[215], 1);
	return createCompositeKey(tokenDelegatedInput, []string{txID, strconv.Itoa(index)})
}

func (v *Verifier) checkDelegatedOutputDoesNotExist(index int, txID string, simulator ledger.LedgerReader) error {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[216], 1);
	outputID, err := createDelegatedOutputKey(txID, index)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[220], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("error creating output ID: %s", err)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[217], 1);existingOutputBytes, err := simulator.GetState(tokenNameSpace, outputID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[221], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[218], 1);if existingOutputBytes != nil {_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[222], 1);
		return &customtx.InvalidTxError{Msg: fmt.Sprintf("output already exists: %s", outputID)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_376538356362393564346637.Count[219], 1);return nil
}

var GoCover_5_376538356362393564346637 = struct {
	Count     [223]uint32
	Pos       [3 * 223]uint32
	NumStmt   [223]uint16
} {
	Pos: [3 * 223]uint32{
		48, 51, 0x10008a, // [0]
		55, 57, 0x100002, // [1]
		61, 62, 0xc0002, // [2]
		51, 53, 0x30010, // [3]
		57, 60, 0x30010, // [4]
		65, 67, 0x13008d, // [5]
		71, 72, 0x100002, // [6]
		76, 77, 0x100002, // [7]
		80, 80, 0xc0002, // [8]
		67, 69, 0x30013, // [9]
		72, 74, 0x30010, // [10]
		77, 79, 0x30010, // [11]
		83, 84, 0x2b0094, // [12]
		85, 86, 0x4b002b, // [13]
		87, 88, 0x4f002d, // [14]
		89, 90, 0x4b002b, // [15]
		91, 92, 0x4d002c, // [16]
		93, 94, 0x5e000a, // [17]
		98, 100, 0x100096, // [18]
		103, 103, 0x390002, // [19]
		100, 102, 0x30010, // [20]
		106, 107, 0x170077, // [21]
		110, 110, 0x210002, // [22]
		120, 120, 0xc0002, // [23]
		107, 109, 0x30017, // [24]
		110, 112, 0x110021, // [25]
		116, 116, 0x1b0003, // [26]
		112, 114, 0x40011, // [27]
		116, 118, 0x4001b, // [28]
		123, 125, 0x10009c, // [29]
		128, 129, 0x100002, // [30]
		132, 132, 0x1d0002, // [31]
		135, 135, 0x1b0002, // [32]
		138, 138, 0xc0002, // [33]
		125, 127, 0x30010, // [34]
		129, 131, 0x30010, // [35]
		132, 134, 0x3001d, // [36]
		135, 137, 0x3001b, // [37]
		141, 144, 0x100098, // [38]
		150, 151, 0x160002, // [39]
		156, 156, 0x1d0002, // [40]
		161, 161, 0x4b0002, // [41]
		167, 167, 0xc0002, // [42]
		144, 146, 0x30010, // [43]
		151, 153, 0x30016, // [44]
		156, 158, 0x3001d, // [45]
		161, 165, 0x3004b, // [46]
		170, 172, 0x100069, // [47]
		176, 177, 0x100002, // [48]
		181, 181, 0x200002, // [49]
		184, 184, 0xc0002, // [50]
		172, 174, 0x30010, // [51]
		177, 179, 0x30010, // [52]
		181, 183, 0x30020, // [53]
		187, 190, 0x21008b, // [54]
		202, 202, 0x210002, // [55]
		190, 192, 0x110021, // [56]
		195, 195, 0x160003, // [57]
		200, 200, 0x230003, // [58]
		192, 194, 0x40011, // [59]
		195, 197, 0x40016, // [60]
		197, 197, 0x2b0009, // [61]
		197, 199, 0x4002b, // [62]
		205, 209, 0x1e00a4, // [63]
		244, 244, 0x210002, // [64]
		209, 211, 0x11001e, // [65]
		214, 215, 0x110003, // [66]
		218, 219, 0x110003, // [67]
		222, 222, 0x160003, // [68]
		227, 227, 0x1d0003, // [69]
		230, 233, 0x110003, // [70]
		236, 237, 0x110003, // [71]
		240, 240, 0xc0003, // [72]
		211, 213, 0x40011, // [73]
		215, 217, 0x40011, // [74]
		219, 221, 0x40011, // [75]
		222, 224, 0x40016, // [76]
		224, 224, 0x2a0009, // [77]
		224, 226, 0x4002a, // [78]
		227, 229, 0x4001d, // [79]
		233, 235, 0x40011, // [80]
		237, 239, 0x40011, // [81]
		240, 242, 0x4000c, // [82]
		247, 248, 0x310071, // [83]
		251, 251, 0xc0002, // [84]
		248, 250, 0x30031, // [85]
		254, 256, 0x10005a, // [86]
		260, 261, 0x100002, // [87]
		265, 265, 0x170002, // [88]
		268, 268, 0xc0002, // [89]
		256, 258, 0x30010, // [90]
		261, 263, 0x30010, // [91]
		265, 267, 0x30017, // [92]
		271, 272, 0x2c0075, // [93]
		278, 278, 0xc0002, // [94]
		272, 274, 0x11002c, // [95]
		274, 276, 0x40011, // [96]
		281, 284, 0x10008e, // [97]
		289, 291, 0x100002, // [98]
		296, 297, 0xc0002, // [99]
		284, 287, 0x30010, // [100]
		291, 294, 0x30010, // [101]
		300, 301, 0x2b007e, // [102]
		312, 312, 0x80002, // [103]
		302, 303, 0x42002b, // [104]
		304, 305, 0x46002d, // [105]
		306, 308, 0x44002b, // [106]
		309, 310, 0x44002c, // [107]
		315, 316, 0x33007a, // [108]
		327, 327, 0xc0002, // [109]
		316, 318, 0x110033, // [110]
		322, 323, 0x110003, // [111]
		318, 320, 0x40011, // [112]
		323, 325, 0x40011, // [113]
		332, 335, 0x350080, // [114]
		350, 350, 0x470002, // [115]
		335, 336, 0x1a0035, // [116]
		341, 341, 0x110003, // [117]
		345, 346, 0x110003, // [118]
		336, 338, 0x4001a, // [119]
		338, 340, 0x40009, // [120]
		341, 343, 0x40011, // [121]
		346, 348, 0x40011, // [122]
		353, 355, 0x100099, // [123]
		358, 359, 0x100002, // [124]
		362, 362, 0x1d0002, // [125]
		365, 365, 0x1b0002, // [126]
		368, 368, 0xc0002, // [127]
		355, 357, 0x30010, // [128]
		359, 361, 0x30010, // [129]
		362, 364, 0x3001d, // [130]
		365, 367, 0x3001b, // [131]
		371, 372, 0x26007d, // [132]
		382, 382, 0x460002, // [133]
		390, 390, 0x460002, // [134]
		372, 374, 0x110026, // [135]
		377, 378, 0x110003, // [136]
		374, 376, 0x40011, // [137]
		378, 380, 0x40011, // [138]
		382, 386, 0x110046, // [139]
		386, 388, 0x40011, // [140]
		393, 399, 0x1300d4, // [141]
		425, 425, 0x330002, // [142]
		464, 464, 0x210002, // [143]
		399, 401, 0x330013, // [144]
		404, 406, 0x110003, // [145]
		410, 411, 0x110003, // [146]
		414, 415, 0x110003, // [147]
		418, 418, 0xc0003, // [148]
		421, 421, 0x220003, // [149]
		401, 403, 0x40033, // [150]
		406, 408, 0x40011, // [151]
		411, 413, 0x40011, // [152]
		415, 417, 0x40011, // [153]
		418, 420, 0x4000c, // [154]
		425, 427, 0x3c0033, // [155]
		431, 431, 0x160003, // [156]
		437, 437, 0x2b0003, // [157]
		441, 441, 0x2e0003, // [158]
		445, 446, 0x110003, // [159]
		450, 451, 0x110003, // [160]
		454, 455, 0x110003, // [161]
		458, 458, 0xc0003, // [162]
		461, 461, 0x2c0003, // [163]
		427, 429, 0x4003c, // [164]
		431, 433, 0x40016, // [165]
		433, 433, 0x340009, // [166]
		433, 435, 0x40034, // [167]
		437, 439, 0x4002b, // [168]
		441, 443, 0x4002e, // [169]
		446, 448, 0x40011, // [170]
		451, 453, 0x40011, // [171]
		455, 457, 0x40011, // [172]
		458, 460, 0x4000c, // [173]
		467, 471, 0x2006f, // [174]
		473, 477, 0x2008a, // [175]
		479, 483, 0x100072, // [176]
		487, 487, 0x3c0002, // [177]
		483, 485, 0x30010, // [178]
		492, 493, 0x1c006f, // [179]
		504, 504, 0xc0002, // [180]
		493, 495, 0x11001c, // [181]
		498, 500, 0x110003, // [182]
		495, 497, 0x40011, // [183]
		500, 502, 0x40011, // [184]
		507, 509, 0x10006a, // [185]
		512, 512, 0x180002, // [186]
		515, 515, 0x1b0002, // [187]
		518, 520, 0x100002, // [188]
		523, 523, 0x140002, // [189]
		509, 511, 0x30010, // [190]
		512, 514, 0x30018, // [191]
		515, 517, 0x3001b, // [192]
		520, 522, 0x30010, // [193]
		527, 531, 0x2005a, // [194]
		535, 537, 0x2003e, // [195]
		541, 543, 0x2003e, // [196]
		546, 548, 0x2002f, // [197]
		552, 554, 0x2003d, // [198]
		557, 558, 0x420051, // [199]
		561, 562, 0x210002, // [200]
		568, 568, 0x100002, // [201]
		558, 560, 0x30042, // [202]
		562, 563, 0x3c0021, // [203]
		566, 566, 0x2a0003, // [204]
		563, 565, 0x4003c, // [205]
		571, 572, 0x1c0036, // [206]
		575, 575, 0x240002, // [207]
		581, 581, 0xc0002, // [208]
		572, 574, 0x3001c, // [209]
		575, 576, 0x4b0024, // [210]
		576, 579, 0x4004b, // [211]
		584, 586, 0x20035, // [212]
		588, 590, 0x20037, // [213]
		594, 596, 0x20047, // [214]
		600, 602, 0x2004c, // [215]
		604, 606, 0x100072, // [216]
		610, 611, 0x100002, // [217]
		615, 615, 0x200002, // [218]
		618, 618, 0xc0002, // [219]
		606, 608, 0x30010, // [220]
		611, 613, 0x30010, // [221]
		615, 617, 0x30020, // [222]
	},
	NumStmt: [223]uint16{
		3, // 0
		3, // 1
		2, // 2
		1, // 3
		2, // 4
		2, // 5
		2, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		1, // 28
		2, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		2, // 38
		2, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		3, // 46
		2, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		1, // 53
		3, // 54
		1, // 55
		2, // 56
		1, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		4, // 63
		1, // 64
		2, // 65
		2, // 66
		2, // 67
		1, // 68
		1, // 69
		4, // 70
		2, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		2, // 86
		2, // 87
		1, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		2, // 95
		1, // 96
		3, // 97
		3, // 98
		2, // 99
		2, // 100
		2, // 101
		1, // 102
		1, // 103
		1, // 104
		1, // 105
		1, // 106
		1, // 107
		1, // 108
		1, // 109
		2, // 110
		2, // 111
		1, // 112
		1, // 113
		3, // 114
		1, // 115
		1, // 116
		1, // 117
		2, // 118
		1, // 119
		1, // 120
		1, // 121
		1, // 122
		2, // 123
		2, // 124
		1, // 125
		1, // 126
		1, // 127
		1, // 128
		1, // 129
		1, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		2, // 135
		2, // 136
		1, // 137
		1, // 138
		3, // 139
		1, // 140
		3, // 141
		1, // 142
		1, // 143
		1, // 144
		3, // 145
		2, // 146
		2, // 147
		1, // 148
		1, // 149
		1, // 150
		1, // 151
		1, // 152
		1, // 153
		1, // 154
		1, // 155
		1, // 156
		1, // 157
		1, // 158
		2, // 159
		2, // 160
		2, // 161
		1, // 162
		1, // 163
		1, // 164
		1, // 165
		1, // 166
		1, // 167
		1, // 168
		1, // 169
		1, // 170
		1, // 171
		1, // 172
		1, // 173
		2, // 174
		2, // 175
		3, // 176
		1, // 177
		1, // 178
		1, // 179
		1, // 180
		2, // 181
		3, // 182
		1, // 183
		1, // 184
		2, // 185
		1, // 186
		1, // 187
		3, // 188
		1, // 189
		1, // 190
		1, // 191
		1, // 192
		1, // 193
		3, // 194
		1, // 195
		1, // 196
		1, // 197
		1, // 198
		1, // 199
		2, // 200
		1, // 201
		1, // 202
		1, // 203
		1, // 204
		1, // 205
		1, // 206
		1, // 207
		1, // 208
		1, // 209
		1, // 210
		1, // 211
		1, // 212
		1, // 213
		1, // 214
		1, // 215
		2, // 216
		2, // 217
		1, // 218
		1, // 219
		1, // 220
		1, // 221
		1, // 222
	},
}
var _ = _cover_atomic_.LoadUint32
