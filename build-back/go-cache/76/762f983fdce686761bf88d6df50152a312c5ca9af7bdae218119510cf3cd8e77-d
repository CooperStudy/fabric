//line /home/cooper/go/src/github.com/hyperledger/fabric/core/transientstore/store.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package transientstore; import _cover_atomic_ "sync/atomic"

import (
	"errors"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
	"github.com/hyperledger/fabric/protos/transientstore"
	"github.com/syndtr/goleveldb/leveldb/iterator"
)

var logger = flogging.MustGetLogger("transientstore")

var emptyValue = []byte{}
var nilByte = byte('\x00')

// ErrStoreEmpty is used to indicate that there are no entries in transient store
var ErrStoreEmpty = errors.New("Transient store is empty")

//////////////////////////////////////////////
// Interfaces and data types
/////////////////////////////////////////////

// StoreProvider provides an instance of a TransientStore
type StoreProvider interface {
	OpenStore(ledgerID string) (Store, error)
	Close()
}

// RWSetScanner provides an iterator for EndorserPvtSimulationResults
type RWSetScanner interface {
	// Next returns the next EndorserPvtSimulationResults from the RWSetScanner.
	// It may return nil, nil when it has no further data, and also may return an error
	// on failure
	Next() (*EndorserPvtSimulationResults, error)
	// NextWithConfig returns the next EndorserPvtSimulationResultsWithConfig from the RWSetScanner.
	// It may return nil, nil when it has no further data, and also may return an error
	// on failure
	// TODO: Once the related gossip changes are made as per FAB-5096, remove the above function
	// and rename the below function to Next form NextWithConfig.
	NextWithConfig() (*EndorserPvtSimulationResultsWithConfig, error)
	// Close frees the resources associated with this RWSetScanner
	Close()
}

// Store manages the storage of private write sets for a ledgerId.
// Ideally, a ledger can remove the data from this storage when it is committed to
// the permanent storage or the pruning of some data items is enforced by the policy
type Store interface {
	// Persist stores the private write set of a transaction in the transient store
	// based on txid and the block height the private data was received at
	Persist(txid string, blockHeight uint64, privateSimulationResults *rwset.TxPvtReadWriteSet) error
	// TODO: Once the related gossip changes are made as per FAB-5096, remove the above function
	// and rename the below function to Persist form PersistWithConfig.
	// PersistWithConfig stores the private write set of a transaction along with the collection config
	// in the transient store based on txid and the block height the private data was received at
	PersistWithConfig(txid string, blockHeight uint64, privateSimulationResultsWithConfig *transientstore.TxPvtReadWriteSetWithConfigInfo) error
	// GetTxPvtRWSetByTxid returns an iterator due to the fact that the txid may have multiple private
	// write sets persisted from different endorsers (via Gossip)
	GetTxPvtRWSetByTxid(txid string, filter ledger.PvtNsCollFilter) (RWSetScanner, error)
	// PurgeByTxids removes private write sets of a given set of transactions from the
	// transient store
	PurgeByTxids(txids []string) error
	// PurgeByHeight removes private write sets at block height lesser than
	// a given maxBlockNumToRetain. In other words, Purge only retains private write sets
	// that were persisted at block height of maxBlockNumToRetain or higher. Though the private
	// write sets stored in transient store is removed by coordinator using PurgebyTxids()
	// after successful block commit, PurgeByHeight() is still required to remove orphan entries (as
	// transaction that gets endorsed may not be submitted by the client for commit)
	PurgeByHeight(maxBlockNumToRetain uint64) error
	// GetMinTransientBlkHt returns the lowest block height remaining in transient store
	GetMinTransientBlkHt() (uint64, error)
	Shutdown()
}

// EndorserPvtSimulationResults captures the details of the simulation results specific to an endorser
// TODO: Once the related gossip changes are made as per FAB-5096, remove this struct
type EndorserPvtSimulationResults struct {
	ReceivedAtBlockHeight uint64
	PvtSimulationResults  *rwset.TxPvtReadWriteSet
}

// EndorserPvtSimulationResultsWithConfig captures the details of the simulation results specific to an endorser
type EndorserPvtSimulationResultsWithConfig struct {
	ReceivedAtBlockHeight          uint64
	PvtSimulationResultsWithConfig *transientstore.TxPvtReadWriteSetWithConfigInfo
}

//////////////////////////////////////////////
// Implementation
/////////////////////////////////////////////

// storeProvider encapsulates a leveldb provider which is used to store
// private write sets of simulated transactions, and implements TransientStoreProvider
// interface.
type storeProvider struct {
	dbProvider *leveldbhelper.Provider
}

// store holds an instance of a levelDB.
type store struct {
	db       *leveldbhelper.DBHandle
	ledgerID string
}

type RwsetScanner struct {
	txid   string
	dbItr  iterator.Iterator
	filter ledger.PvtNsCollFilter
}

// NewStoreProvider instantiates TransientStoreProvider
func NewStoreProvider() StoreProvider {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[0], 1);
	dbProvider := leveldbhelper.NewProvider(&leveldbhelper.Conf{DBPath: GetTransientStorePath()})
	return &storeProvider{dbProvider: dbProvider}
}

// OpenStore returns a handle to a ledgerId in Store
func (provider *storeProvider) OpenStore(ledgerID string) (Store, error) {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[1], 1);
	dbHandle := provider.dbProvider.GetDBHandle(ledgerID)
	return &store{db: dbHandle, ledgerID: ledgerID}, nil
}

// Close closes the TransientStoreProvider
func (provider *storeProvider) Close() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[2], 1);
	provider.dbProvider.Close()
}

// Persist stores the private write set of a transaction in the transient store
// based on txid and the block height the private data was received at
// TODO: Once the related gossip changes are made as per FAB-5096, remove this function.
func (s *store) Persist(txid string, blockHeight uint64,
	privateSimulationResults *rwset.TxPvtReadWriteSet) error {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[3], 1);

	logger.Debugf("Persisting private data to transient store for txid [%s] at block height [%d]", txid, blockHeight)

	dbBatch := leveldbhelper.NewUpdateBatch()

	// Create compositeKey with appropriate prefix, txid, uuid and blockHeight
	// Due to the fact that the txid may have multiple private write sets persisted from different
	// endorsers (via Gossip), we postfix an uuid with the txid to avoid collision.
	uuid := util.GenerateUUID()
	compositeKeyPvtRWSet := createCompositeKeyForPvtRWSet(txid, uuid, blockHeight)
	privateSimulationResultsBytes, err := proto.Marshal(privateSimulationResults)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[5], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[4], 1);dbBatch.Put(compositeKeyPvtRWSet, privateSimulationResultsBytes)

	// Create two index: (i) by txid, and (ii) by height

	// Create compositeKey for purge index by height with appropriate prefix, blockHeight,
	// txid, uuid and store the compositeKey (purge index) with a nil byte as value. Note that
	// the purge index is used to remove orphan entries in the transient store (which are not removed
	// by PurgeTxids()) using BTL policy by PurgeByHeight(). Note that orphan entries are due to transaction
	// that gets endorsed but not submitted by the client for commit)
	compositeKeyPurgeIndexByHeight := createCompositeKeyForPurgeIndexByHeight(blockHeight, txid, uuid)
	dbBatch.Put(compositeKeyPurgeIndexByHeight, emptyValue)

	// Create compositeKey for purge index by txid with appropriate prefix, txid, uuid,
	// blockHeight and store the compositeKey (purge index) with a nil byte as value.
	// Though compositeKeyPvtRWSet itself can be used to purge private write set by txid,
	// we create a separate composite key with a nil byte as value. The reason is that
	// if we use compositeKeyPvtRWSet, we unnecessarily read (potentially large) private write
	// set associated with the key from db. Note that this purge index is used to remove non-orphan
	// entries in the transient store and is used by PurgeTxids()
	// Note: We can create compositeKeyPurgeIndexByTxid by just replacing the prefix of compositeKeyPvtRWSet
	// with purgeIndexByTxidPrefix. For code readability and to be expressive, we use a
	// createCompositeKeyForPurgeIndexByTxid() instead.
	compositeKeyPurgeIndexByTxid := createCompositeKeyForPurgeIndexByTxid(txid, uuid, blockHeight)
	dbBatch.Put(compositeKeyPurgeIndexByTxid, emptyValue)

	return s.db.WriteBatch(dbBatch, true)
}

// PersistWithConfig stores the private write set of a transaction along with the collection config
// in the transient store based on txid and the block height the private data was received at
// TODO: Once the related gossip changes are made as per FAB-5096, rename this function to Persist
// form PersistWithConfig.
func (s *store) PersistWithConfig(txid string, blockHeight uint64,
	privateSimulationResultsWithConfig *transientstore.TxPvtReadWriteSetWithConfigInfo) error {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[6], 1);

	logger.Debugf("Persisting private data to transient store for txid [%s] at block height [%d]", txid, blockHeight)

	dbBatch := leveldbhelper.NewUpdateBatch()

	// Create compositeKey with appropriate prefix, txid, uuid and blockHeight
	// Due to the fact that the txid may have multiple private write sets persisted from different
	// endorsers (via Gossip), we postfix an uuid with the txid to avoid collision.
	uuid := util.GenerateUUID()
	compositeKeyPvtRWSet := createCompositeKeyForPvtRWSet(txid, uuid, blockHeight)
	privateSimulationResultsWithConfigBytes, err := proto.Marshal(privateSimulationResultsWithConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[8], 1);
		return err
	}

	// Note that some rwset.TxPvtReadWriteSet may exist in the transient store immediately after
	// upgrading the peer to v1.2. In order to differentiate between new proto and old proto while
	// retrieving, a nil byte is prepended to the new proto, i.e., privateSimulationResultsWithConfigBytes,
	// as a marshaled message can never start with a nil byte. In v1.3, we can avoid prepending the
	// nil byte.
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[7], 1);value := append([]byte{nilByte}, privateSimulationResultsWithConfigBytes...)
	dbBatch.Put(compositeKeyPvtRWSet, value)

	// Create two index: (i) by txid, and (ii) by height

	// Create compositeKey for purge index by height with appropriate prefix, blockHeight,
	// txid, uuid and store the compositeKey (purge index) with a nil byte as value. Note that
	// the purge index is used to remove orphan entries in the transient store (which are not removed
	// by PurgeTxids()) using BTL policy by PurgeByHeight(). Note that orphan entries are due to transaction
	// that gets endorsed but not submitted by the client for commit)
	compositeKeyPurgeIndexByHeight := createCompositeKeyForPurgeIndexByHeight(blockHeight, txid, uuid)
	dbBatch.Put(compositeKeyPurgeIndexByHeight, emptyValue)

	// Create compositeKey for purge index by txid with appropriate prefix, txid, uuid,
	// blockHeight and store the compositeKey (purge index) with a nil byte as value.
	// Though compositeKeyPvtRWSet itself can be used to purge private write set by txid,
	// we create a separate composite key with a nil byte as value. The reason is that
	// if we use compositeKeyPvtRWSet, we unnecessarily read (potentially large) private write
	// set associated with the key from db. Note that this purge index is used to remove non-orphan
	// entries in the transient store and is used by PurgeTxids()
	// Note: We can create compositeKeyPurgeIndexByTxid by just replacing the prefix of compositeKeyPvtRWSet
	// with purgeIndexByTxidPrefix. For code readability and to be expressive, we use a
	// createCompositeKeyForPurgeIndexByTxid() instead.
	compositeKeyPurgeIndexByTxid := createCompositeKeyForPurgeIndexByTxid(txid, uuid, blockHeight)
	dbBatch.Put(compositeKeyPurgeIndexByTxid, emptyValue)

	return s.db.WriteBatch(dbBatch, true)
}

// GetTxPvtRWSetByTxid returns an iterator due to the fact that the txid may have multiple private
// write sets persisted from different endorsers.
func (s *store) GetTxPvtRWSetByTxid(txid string, filter ledger.PvtNsCollFilter) (RWSetScanner, error) {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[9], 1);

	logger.Debugf("Getting private data from transient store for transaction %s", txid)

	// Construct startKey and endKey to do an range query
	startKey := createTxidRangeStartKey(txid)
	endKey := createTxidRangeEndKey(txid)

	iter := s.db.GetIterator(startKey, endKey)
	return &RwsetScanner{txid, iter, filter}, nil
}

// PurgeByTxids removes private write sets of a given set of transactions from the
// transient store. PurgeByTxids() is expected to be called by coordinator after
// committing a block to ledger.
func (s *store) PurgeByTxids(txids []string) error {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[10], 1);

	logger.Debug("Purging private data from transient store for committed txids")

	dbBatch := leveldbhelper.NewUpdateBatch()

	for _, txid := range txids {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[12], 1);
		// Construct startKey and endKey to do an range query
		startKey := createPurgeIndexByTxidRangeStartKey(txid)
		endKey := createPurgeIndexByTxidRangeEndKey(txid)

		iter := s.db.GetIterator(startKey, endKey)

		// Get all txid and uuid from above result and remove it from transient store (both
		// write set and the corresponding indexes.
		for iter.Next() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[14], 1);
			// For each entry, remove the private read-write set and correponding indexes

			// Remove private write set
			compositeKeyPurgeIndexByTxid := iter.Key()
			// Note: We can create compositeKeyPvtRWSet by just replacing the prefix of compositeKeyPurgeIndexByTxid
			// with  prwsetPrefix. For code readability and to be expressive, we split and create again.
			uuid, blockHeight := splitCompositeKeyOfPurgeIndexByTxid(compositeKeyPurgeIndexByTxid)
			compositeKeyPvtRWSet := createCompositeKeyForPvtRWSet(txid, uuid, blockHeight)
			dbBatch.Delete(compositeKeyPvtRWSet)

			// Remove purge index -- purgeIndexByHeight
			compositeKeyPurgeIndexByHeight := createCompositeKeyForPurgeIndexByHeight(blockHeight, txid, uuid)
			dbBatch.Delete(compositeKeyPurgeIndexByHeight)

			// Remove purge index -- purgeIndexByTxid
			dbBatch.Delete(compositeKeyPurgeIndexByTxid)
		}
		_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[13], 1);iter.Release()
	}
	// If peer fails before/while writing the batch to golevelDB, these entries will be
	// removed as per BTL policy later by PurgeByHeight()
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[11], 1);return s.db.WriteBatch(dbBatch, true)
}

// PurgeByHeight removes private write sets at block height lesser than
// a given maxBlockNumToRetain. In other words, Purge only retains private write sets
// that were persisted at block height of maxBlockNumToRetain or higher. Though the private
// write sets stored in transient store is removed by coordinator using PurgebyTxids()
// after successful block commit, PurgeByHeight() is still required to remove orphan entries (as
// transaction that gets endorsed may not be submitted by the client for commit)
func (s *store) PurgeByHeight(maxBlockNumToRetain uint64) error {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[15], 1);

	logger.Debugf("Purging orphaned private data from transient store received prior to block [%d]", maxBlockNumToRetain)

	// Do a range query with 0 as startKey and maxBlockNumToRetain-1 as endKey
	startKey := createPurgeIndexByHeightRangeStartKey(0)
	endKey := createPurgeIndexByHeightRangeEndKey(maxBlockNumToRetain - 1)
	iter := s.db.GetIterator(startKey, endKey)

	dbBatch := leveldbhelper.NewUpdateBatch()

	// Get all txid and uuid from above result and remove it from transient store (both
	// write set and the corresponding index.
	for iter.Next() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[17], 1);
		// For each entry, remove the private read-write set and correponding indexes

		// Remove private write set
		compositeKeyPurgeIndexByHeight := iter.Key()
		txid, uuid, blockHeight := splitCompositeKeyOfPurgeIndexByHeight(compositeKeyPurgeIndexByHeight)
		logger.Debugf("Purging from transient store private data simulated at block [%d]: txid [%s] uuid [%s]", blockHeight, txid, uuid)

		compositeKeyPvtRWSet := createCompositeKeyForPvtRWSet(txid, uuid, blockHeight)
		dbBatch.Delete(compositeKeyPvtRWSet)

		// Remove purge index -- purgeIndexByTxid
		compositeKeyPurgeIndexByTxid := createCompositeKeyForPurgeIndexByTxid(txid, uuid, blockHeight)
		dbBatch.Delete(compositeKeyPurgeIndexByTxid)

		// Remove purge index -- purgeIndexByHeight
		dbBatch.Delete(compositeKeyPurgeIndexByHeight)
	}
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[16], 1);iter.Release()

	return s.db.WriteBatch(dbBatch, true)
}

// GetMinTransientBlkHt returns the lowest block height remaining in transient store
func (s *store) GetMinTransientBlkHt() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[18], 1);
	// Current approach performs a range query on purgeIndex with startKey
	// as 0 (i.e., blockHeight) and returns the first key which denotes
	// the lowest block height remaining in transient store. An alternative approach
	// is to explicitly store the minBlockHeight in the transientStore.
	startKey := createPurgeIndexByHeightRangeStartKey(0)
	iter := s.db.GetIterator(startKey, nil)
	defer iter.Release()
	// Fetch the minimum transient block height
	if iter.Next() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[20], 1);
		dbKey := iter.Key()
		_, _, blockHeight := splitCompositeKeyOfPurgeIndexByHeight(dbKey)
		return blockHeight, nil
	}
	// Returning an error may not be the right thing to do here. May be
	// return a bool. -1 is not possible due to unsigned int as first
	// return value
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[19], 1);return 0, ErrStoreEmpty
}

func (s *store) Shutdown() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[21], 1);
	// do nothing because shared db is used
}

// Next moves the iterator to the next key/value pair.
// It returns whether the iterator is exhausted.
// TODO: Once the related gossip changes are made as per FAB-5096, remove this function
func (scanner *RwsetScanner) Next() (*EndorserPvtSimulationResults, error) {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[22], 1);
	if !scanner.dbItr.Next() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[25], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[23], 1);dbKey := scanner.dbItr.Key()
	dbVal := scanner.dbItr.Value()
	_, blockHeight := splitCompositeKeyOfPvtRWSet(dbKey)

	txPvtRWSet := &rwset.TxPvtReadWriteSet{}
	if err := proto.Unmarshal(dbVal, txPvtRWSet); err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[26], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[24], 1);filteredTxPvtRWSet := trimPvtWSet(txPvtRWSet, scanner.filter)

	return &EndorserPvtSimulationResults{
		ReceivedAtBlockHeight: blockHeight,
		PvtSimulationResults:  filteredTxPvtRWSet,
	}, nil
}

// Next moves the iterator to the next key/value pair.
// It returns whether the iterator is exhausted.
// TODO: Once the related gossip changes are made as per FAB-5096, rename this function to Next
func (scanner *RwsetScanner) NextWithConfig() (*EndorserPvtSimulationResultsWithConfig, error) {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[27], 1);
	if !scanner.dbItr.Next() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[30], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[28], 1);dbKey := scanner.dbItr.Key()
	dbVal := scanner.dbItr.Value()
	_, blockHeight := splitCompositeKeyOfPvtRWSet(dbKey)

	txPvtRWSet := &rwset.TxPvtReadWriteSet{}
	filteredTxPvtRWSet := &rwset.TxPvtReadWriteSet{}
	txPvtRWSetWithConfig := &transientstore.TxPvtReadWriteSetWithConfigInfo{}

	if dbVal[0] == nilByte {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[31], 1);
		// new proto, i.e., TxPvtReadWriteSetWithConfigInfo
		if err := proto.Unmarshal(dbVal[1:], txPvtRWSetWithConfig); err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[34], 1);
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[32], 1);filteredTxPvtRWSet = trimPvtWSet(txPvtRWSetWithConfig.GetPvtRwset(), scanner.filter)
		configs, err := trimPvtCollectionConfigs(txPvtRWSetWithConfig.CollectionConfigs, scanner.filter)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[35], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[33], 1);txPvtRWSetWithConfig.CollectionConfigs = configs
	} else{ _cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[36], 1);{
		// old proto, i.e., TxPvtReadWriteSet
		if err := proto.Unmarshal(dbVal, txPvtRWSet); err != nil {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[38], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[37], 1);filteredTxPvtRWSet = trimPvtWSet(txPvtRWSet, scanner.filter)
	}}

	_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[29], 1);txPvtRWSetWithConfig.PvtRwset = filteredTxPvtRWSet

	return &EndorserPvtSimulationResultsWithConfig{
		ReceivedAtBlockHeight:          blockHeight,
		PvtSimulationResultsWithConfig: txPvtRWSetWithConfig,
	}, nil
}

// Close releases resource held by the iterator
func (scanner *RwsetScanner) Close() {_cover_atomic_.AddUint32(&GoCover_0_646462646366376465656666.Count[39], 1);
	scanner.dbItr.Release()
}

var GoCover_0_646462646366376465656666 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		123, 126, 0x20027, // [0]
		129, 132, 0x2004a, // [1]
		135, 137, 0x20028, // [2]
		143, 155, 0x10003b, // [3]
		158, 183, 0x270002, // [4]
		155, 157, 0x30010, // [5]
		191, 203, 0x10005c, // [6]
		212, 238, 0x270002, // [7]
		203, 205, 0x30010, // [8]
		243, 253, 0x20067, // [9]
		258, 264, 0x1d0034, // [10]
		295, 295, 0x270002, // [11]
		264, 273, 0x13001d, // [12]
		291, 291, 0x110003, // [13]
		273, 290, 0x40013, // [14]
		304, 317, 0x120041, // [15]
		335, 337, 0x270002, // [16]
		317, 334, 0x30012, // [17]
		341, 350, 0x110038, // [18]
		358, 358, 0x190002, // [19]
		350, 354, 0x30011, // [20]
		361, 363, 0x2001d, // [21]
		368, 369, 0x1b004c, // [22]
		372, 377, 0x3b0002, // [23]
		380, 385, 0x80002, // [24]
		369, 371, 0x3001b, // [25]
		377, 379, 0x3003b, // [26]
		391, 392, 0x1b0060, // [27]
		395, 403, 0x190002, // [28]
		423, 428, 0x80002, // [29]
		392, 394, 0x3001b, // [30]
		403, 405, 0x4a0019, // [31]
		409, 411, 0x110003, // [32]
		414, 414, 0x330003, // [33]
		405, 407, 0x4004a, // [34]
		411, 413, 0x40011, // [35]
		415, 417, 0x3c0008, // [36]
		420, 420, 0x3f0003, // [37]
		417, 419, 0x4003c, // [38]
		432, 434, 0x20026, // [39]
	},
	NumStmt: [40]uint16{
		2, // 0
		2, // 1
		1, // 2
		6, // 3
		6, // 4
		1, // 5
		6, // 6
		7, // 7
		1, // 8
		5, // 9
		3, // 10
		1, // 11
		4, // 12
		1, // 13
		7, // 14
		6, // 15
		2, // 16
		8, // 17
		4, // 18
		1, // 19
		3, // 20
		0, // 21
		1, // 22
		5, // 23
		2, // 24
		1, // 25
		1, // 26
		1, // 27
		7, // 28
		2, // 29
		1, // 30
		1, // 31
		3, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
