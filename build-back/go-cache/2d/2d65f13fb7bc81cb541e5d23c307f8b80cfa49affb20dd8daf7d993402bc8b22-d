//line /home/cooper/go/src/github.com/hyperledger/fabric/common/mocks/policies/policies.go:1
/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package policies; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/policies"
	cb "github.com/hyperledger/fabric/protos/common"
)

// Policy is a mock implementation of the policies.Policy interface
type Policy struct {
	// Err is the error returned by Evaluate
	Err error
}

// Evaluate returns the Err set in Policy
func (p *Policy) Evaluate(signatureSet []*cb.SignedData) error {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[0], 1);
	return p.Err
}

// Manager is a mock implementation of the policies.Manager interface
type Manager struct {
	// Policy is returned as the output to GetPolicy if a Policy
	// for id is not in PolicyMap
	Policy *Policy

	// PolicyMap is returned is used to look up Policies in
	PolicyMap map[string]policies.Policy

	// SubManagers is used for the return value of Manager
	SubManagersMap map[string]*Manager
}

// Manager returns the Manager from SubManagers for the last component of the path
func (m *Manager) Manager(path []string) (policies.Manager, bool) {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[1], 1);
	if len(path) == 0 {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[3], 1);
		return m, true
	}
	_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[2], 1);manager, ok := m.SubManagersMap[path[len(path)-1]]
	return manager, ok
}

// GetPolicy returns the value of Manager.Policy and whether it was nil or not
func (m *Manager) GetPolicy(id string) (policies.Policy, bool) {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[4], 1);
	if m.PolicyMap != nil {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[6], 1);
		policy, ok := m.PolicyMap[id]
		if ok {_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[7], 1);
			return policy, true
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613731346133633439613033.Count[5], 1);return m.Policy, m.Policy != nil
}

var GoCover_0_613731346133633439613033 = struct {
	Count     [8]uint32
	Pos       [3 * 8]uint32
	NumStmt   [8]uint16
} {
	Pos: [3 * 8]uint32{
		31, 33, 0x20040, // [0]
		49, 50, 0x140043, // [1]
		53, 54, 0x140002, // [2]
		50, 52, 0x30014, // [3]
		58, 59, 0x180040, // [4]
		65, 65, 0x220002, // [5]
		59, 61, 0x90018, // [6]
		61, 63, 0x40009, // [7]
	},
	NumStmt: [8]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		2, // 6
		1, // 7
	},
}
var _ = _cover_atomic_.LoadUint32
