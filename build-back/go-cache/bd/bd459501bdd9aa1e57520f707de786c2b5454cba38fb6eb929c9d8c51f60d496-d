//line /home/cooper/go/src/github.com/hyperledger/fabric/peer/common/ordererenv.go:1
/*
Copyright IBM Corp. 2016-2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package common; import _cover_atomic_ "sync/atomic"

import (
	"os"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	OrderingEndpoint           string
	tlsEnabled                 bool
	clientAuth                 bool
	caFile                     string
	keyFile                    string
	certFile                   string
	ordererTLSHostnameOverride string
	connTimeout                time.Duration
)

// SetOrdererEnv adds orderer-specific settings to the global Viper environment
func SetOrdererEnv(cmd *cobra.Command, args []string) {_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[0], 1);
	// read in the legacy logging level settings and, if set,
	// notify users of the FABRIC_LOGGING_SPEC env variable
	var loggingLevel string
	if viper.GetString("logging_level") != "" {_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[3], 1);
		loggingLevel = viper.GetString("logging_level")
	} else{ _cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[4], 1);{
		loggingLevel = viper.GetString("logging.level")
	}}
	_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[1], 1);if loggingLevel != "" {_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[5], 1);
		mainLogger.Warning("CORE_LOGGING_LEVEL is no longer supported, please use the FABRIC_LOGGING_SPEC environment variable")
	}
	// need to init logging here as cobra does not currently support
	// chaining PersistentPreRun functions
	_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[2], 1);loggingSpec := os.Getenv("FABRIC_LOGGING_SPEC")
	flogging.InitFromSpec(loggingSpec)
	// set the orderer environment from flags
	viper.Set("orderer.tls.rootcert.file", caFile)
	viper.Set("orderer.tls.clientKey.file", keyFile)
	viper.Set("orderer.tls.clientCert.file", certFile)
	viper.Set("orderer.address", OrderingEndpoint)
	viper.Set("orderer.tls.serverhostoverride", ordererTLSHostnameOverride)
	viper.Set("orderer.tls.enabled", tlsEnabled)
	viper.Set("orderer.tls.clientAuthRequired", clientAuth)
	viper.Set("orderer.client.connTimeout", connTimeout)
}

// AddOrdererFlags adds flags for orderer-related commands
func AddOrdererFlags(cmd *cobra.Command) {_cover_atomic_.AddUint32(&GoCover_6_393466303334653164333865.Count[6], 1);
	flags := cmd.PersistentFlags()

	flags.StringVarP(&OrderingEndpoint, "orderer", "o", "", "Ordering service endpoint")
	flags.BoolVarP(&tlsEnabled, "tls", "", false, "Use TLS when communicating with the orderer endpoint")
	flags.BoolVarP(&clientAuth, "clientauth", "", false,
		"Use mutual TLS when communicating with the orderer endpoint")
	flags.StringVarP(&caFile, "cafile", "", "",
		"Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint")
	flags.StringVarP(&keyFile, "keyfile", "", "",
		"Path to file containing PEM-encoded private key to use for mutual TLS "+
			"communication with the orderer endpoint")
	flags.StringVarP(&certFile, "certfile", "", "",
		"Path to file containing PEM-encoded X509 public key to use for "+
			"mutual TLS communication with the orderer endpoint")
	flags.StringVarP(&ordererTLSHostnameOverride, "ordererTLSHostnameOverride",
		"", "", "The hostname override to use when validating the TLS connection to the orderer.")
	flags.DurationVarP(&connTimeout, "connTimeout",
		"", 3*time.Second, "Timeout for client to connect")
}

var GoCover_6_393466303334653164333865 = struct {
	Count     [7]uint32
	Pos       [3 * 7]uint32
	NumStmt   [7]uint16
} {
	Pos: [3 * 7]uint32{
		29, 33, 0x2c0037, // [0]
		38, 38, 0x180002, // [1]
		43, 53, 0x360002, // [2]
		33, 35, 0x3002c, // [3]
		35, 37, 0x30008, // [4]
		38, 40, 0x30018, // [5]
		57, 76, 0x2002a, // [6]
	},
	NumStmt: [7]uint16{
		2, // 0
		1, // 1
		10, // 2
		1, // 3
		1, // 4
		1, // 5
		9, // 6
	},
}
var _ = _cover_atomic_.LoadUint32
