//line /home/cooper/go/src/github.com/hyperledger/fabric/token/client/orderer_client.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package client; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"strings"

	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/pkg/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/status"
)

//go:generate counterfeiter -o mock/broadcast.go -fake-name Broadcast . Broadcast

// Broadcast defines the interface that abstracts grpc calls to broadcast transactions to orderer
type Broadcast interface {
	Send(m *common.Envelope) error
	Recv() (*ab.BroadcastResponse, error)
	CloseSend() error
}

//go:generate counterfeiter -o mock/orderer_client.go -fake-name OrdererClient . OrdererClient

// OrdererClient defines the interface to create a Broadcast
type OrdererClient interface {
	// NewBroadcast returns a Broadcast
	NewBroadcast(ctx context.Context, opts ...grpc.CallOption) (Broadcast, error)

	// Certificate returns tls certificate for the orderer client
	Certificate() *tls.Certificate
}

// ordererClient implements OrdererClient interface
type ordererClient struct {
	ordererAddr        string
	serverNameOverride string
	grpcClient         *comm.GRPCClient
	conn               *grpc.ClientConn
}

func NewOrdererClient(config *ClientConfig) (OrdererClient, error) {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[0], 1);
	grpcClient, err := createGrpcClient(&config.OrdererCfg, config.TlsEnabled)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[3], 1);
		err = errors.WithMessage(err, fmt.Sprintf("failed to create a GRPCClient to orderer %s", config.OrdererCfg.Address))
		logger.Errorf("%s", err)
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[1], 1);conn, err := grpcClient.NewConnection(config.OrdererCfg.Address, config.OrdererCfg.ServerNameOverride)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[4], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("failed to connect to orderer %s", config.OrdererCfg.Address))
	}

	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[2], 1);return &ordererClient{
		ordererAddr:        config.OrdererCfg.Address,
		serverNameOverride: config.OrdererCfg.ServerNameOverride,
		grpcClient:         grpcClient,
		conn:               conn,
	}, nil
}

// NewBroadcast creates a Broadcast
func (oc *ordererClient) NewBroadcast(ctx context.Context, opts ...grpc.CallOption) (Broadcast, error) {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[5], 1);
	// reuse the existing connection to create Broadcast client
	broadcast, err := ab.NewAtomicBroadcastClient(oc.conn).Broadcast(ctx)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[9], 1);
		return broadcast, nil
	}

	// error occurred with the existing connection, so create a new connection to orderer
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[6], 1);oc.conn, err = oc.grpcClient.NewConnection(oc.ordererAddr, oc.serverNameOverride)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[10], 1);
		return nil, errors.WithMessage(err, fmt.Sprintf("failed to connect to orderer %s", oc.ordererAddr))
	}

	// create a new Broadcast
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[7], 1);broadcast, err = ab.NewAtomicBroadcastClient(oc.conn).Broadcast(ctx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[11], 1);
		rpcStatus, _ := status.FromError(err)
		return nil, errors.Wrapf(err, "failed to new a broadcast, rpcStatus=%+v", rpcStatus)
	}
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[8], 1);return broadcast, nil
}

func (oc *ordererClient) Certificate() *tls.Certificate {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[12], 1);
	cert := oc.grpcClient.Certificate()
	return &cert
}

// broadcastSend sends transaction envelope to orderer service
func BroadcastSend(broadcast Broadcast, addr string, envelope *common.Envelope) error {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[13], 1);
	err := broadcast.Send(envelope)
	broadcast.CloseSend()

	if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[15], 1);
		return errors.Wrapf(err, "failed to send transaction to orderer %s", addr)
	}
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[14], 1);return nil
}

// broadReceive waits until it receives the response from broadcast stream
func BroadcastReceive(broadcast Broadcast, addr string, responses chan common.Status, errs chan error) {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[16], 1);
	logger.Infof("calling OrdererClient.broadcastReceive")
	for {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[17], 1);
		broadcastResponse, err := broadcast.Recv()
		if err == io.EOF {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[20], 1);
			close(responses)
			return
		}

		_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[18], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[21], 1);
			rpcStatus, _ := status.FromError(err)
			errs <- errors.Wrapf(err, "broadcast recv error from orderer %s, rpcStatus=%+v", addr, rpcStatus)
			close(responses)
			return
		}

		_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[19], 1);if broadcastResponse.Status == common.Status_SUCCESS {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[22], 1);
			responses <- broadcastResponse.Status
		} else{ _cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[23], 1);{
			errs <- errors.Errorf("broadcast response error %d from orderer %s", int32(broadcastResponse.Status), addr)
		}}
	}
}

// broadcastWaitForResponse reads from response and errs chans until responses chan is closed
func BroadcastWaitForResponse(responses chan common.Status, errs chan error) (common.Status, error) {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[24], 1);
	var status common.Status
	allErrs := make([]error, 0)

read:
	for {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[27], 1);
		select {
		case s, ok := <-responses:_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[28], 1);
			if !ok {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[31], 1);
				break read
			}
			_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[29], 1);status = s
		case e := <-errs:_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[30], 1);
			allErrs = append(allErrs, e)
		}
	}

	// drain remaining errors
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[25], 1);for i := 0; i < len(errs); i++ {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[32], 1);
		e := <-errs
		allErrs = append(allErrs, e)
	}
	// close errs channel since we have read all of them
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[26], 1);close(errs)
	return status, toError(allErrs)
}

// toError converts []error to error
func toError(errs []error) error {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[33], 1);
	if len(errs) == 0 {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[37], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[34], 1);if len(errs) == 1 {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[38], 1);
		return errs[0]
	}

	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[35], 1);errmsgs := []string{fmt.Sprint("Multiple errors occurred in order broadcast stream: ")}
	for _, err := range errs {_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[39], 1);
		errmsgs = append(errmsgs, err.Error())
	}
	_cover_atomic_.AddUint32(&GoCover_4_386238643262613636363863.Count[36], 1);return errors.New(strings.Join(errmsgs, "\n"))
}

var GoCover_4_386238643262613636363863 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		51, 53, 0x100044, // [0]
		58, 59, 0x100002, // [1]
		63, 68, 0x80002, // [2]
		53, 57, 0x30010, // [3]
		59, 61, 0x30010, // [4]
		72, 75, 0x100068, // [5]
		80, 81, 0x100002, // [6]
		86, 87, 0x100002, // [7]
		91, 91, 0x170002, // [8]
		75, 77, 0x30010, // [9]
		81, 83, 0x30010, // [10]
		87, 90, 0x30010, // [11]
		94, 97, 0x20039, // [12]
		100, 104, 0x100057, // [13]
		107, 107, 0xc0002, // [14]
		104, 106, 0x30010, // [15]
		111, 113, 0x60068, // [16]
		113, 115, 0x140006, // [17]
		120, 120, 0x110003, // [18]
		127, 127, 0x380003, // [19]
		115, 118, 0x40014, // [20]
		120, 125, 0x40011, // [21]
		127, 129, 0x40038, // [22]
		129, 131, 0x40009, // [23]
		136, 141, 0x60065, // [24]
		154, 154, 0x210002, // [25]
		159, 160, 0x210002, // [26]
		141, 142, 0xa0006, // [27]
		143, 144, 0xb001d, // [28]
		147, 147, 0xe0004, // [29]
		148, 149, 0x200014, // [30]
		144, 145, 0xf000b, // [31]
		154, 157, 0x30021, // [32]
		164, 165, 0x140022, // [33]
		168, 168, 0x140002, // [34]
		172, 173, 0x1b0002, // [35]
		176, 176, 0x300002, // [36]
		165, 167, 0x30014, // [37]
		168, 170, 0x30014, // [38]
		173, 175, 0x3001b, // [39]
	},
	NumStmt: [40]uint16{
		2, // 0
		2, // 1
		1, // 2
		3, // 3
		1, // 4
		2, // 5
		2, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		2, // 11
		2, // 12
		3, // 13
		1, // 14
		1, // 15
		2, // 16
		2, // 17
		1, // 18
		1, // 19
		2, // 20
		4, // 21
		1, // 22
		1, // 23
		3, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		2, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
