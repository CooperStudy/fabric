//line /home/cooper/go/src/github.com/hyperledger/fabric/idemix/weak-bb.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package idemix; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric-amcl/amcl"
	"github.com/hyperledger/fabric-amcl/amcl/FP256BN"
	"github.com/pkg/errors"
)

// WBBKeyGen creates a fresh weak-Boneh-Boyen signature key pair (http://ia.cr/2004/171)
func WBBKeyGen(rng *amcl.RAND) (*FP256BN.BIG, *FP256BN.ECP2) {_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[0], 1);
	// sample sk uniform from Zq
	sk := RandModOrder(rng)
	// set pk = g2^sk
	pk := GenG2.Mul(sk)
	return sk, pk
}

// WBBSign places a weak Boneh-Boyen signature on message m using secret key sk
func WBBSign(sk *FP256BN.BIG, m *FP256BN.BIG) *FP256BN.ECP {_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[1], 1);
	// compute exp = 1/(m + sk) mod q
	exp := Modadd(sk, m, GroupOrder)
	exp.Invmodp(GroupOrder)

	// return signature sig = g1^(1/(m + sk))
	return GenG1.Mul(exp)
}

// WBBVerify verifies a weak Boneh-Boyen signature sig on message m with public key pk
func WBBVerify(pk *FP256BN.ECP2, sig *FP256BN.ECP, m *FP256BN.BIG) error {_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[2], 1);
	if pk == nil || sig == nil || m == nil {_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[5], 1);
		return errors.Errorf("Weak-BB signature invalid: received nil input")
	}
	// Set P = pk * g2^m
	_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[3], 1);P := FP256BN.NewECP2()
	P.Copy(pk)
	P.Add(GenG2.Mul(m))
	P.Affine()
	// check that e(sig, pk * g2^m) = e(g1, g2)
	if !FP256BN.Fexp(FP256BN.Ate(P, sig)).Equals(GenGT) {_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[6], 1);
		return errors.Errorf("Weak-BB signature is invalid")
	}
	_cover_atomic_.AddUint32(&GoCover_10_633637303937343739336136.Count[4], 1);return nil
}

var GoCover_10_633637303937343739336136 = struct {
	Count     [7]uint32
	Pos       [3 * 7]uint32
	NumStmt   [7]uint16
} {
	Pos: [3 * 7]uint32{
		16, 22, 0x2003e, // [0]
		25, 32, 0x2003c, // [1]
		35, 36, 0x29004a, // [2]
		40, 45, 0x360002, // [3]
		48, 48, 0xc0002, // [4]
		36, 38, 0x30029, // [5]
		45, 47, 0x30036, // [6]
	},
	NumStmt: [7]uint16{
		3, // 0
		3, // 1
		1, // 2
		5, // 3
		1, // 4
		1, // 5
		1, // 6
	},
}
var _ = _cover_atomic_.LoadUint32
