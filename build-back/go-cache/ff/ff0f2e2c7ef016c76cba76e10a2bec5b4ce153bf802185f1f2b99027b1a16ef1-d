//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/ledgerconfig/ledger_config.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package ledgerconfig; import _cover_atomic_ "sync/atomic"

import (
	"path/filepath"

	"github.com/hyperledger/fabric/core/config"
	"github.com/spf13/viper"
)

//IsCouchDBEnabled exposes the useCouchDB variable
func IsCouchDBEnabled() bool {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[0], 1);
	stateDatabase := viper.GetString("ledger.state.stateDatabase")
	if stateDatabase == "CouchDB" {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[2], 1);
		return true
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[1], 1);return false
}

const confPeerFileSystemPath = "peer.fileSystemPath"
const confLedgersData = "ledgersData"
const confLedgerProvider = "ledgerProvider"
const confStateleveldb = "stateLeveldb"
const confHistoryLeveldb = "historyLeveldb"
const confBookkeeper = "bookkeeper"
const confConfigHistory = "configHistory"
const confChains = "chains"
const confPvtdataStore = "pvtdataStore"
const confTotalQueryLimit = "ledger.state.totalQueryLimit"
const confInternalQueryLimit = "ledger.state.couchDBConfig.internalQueryLimit"
const confEnableHistoryDatabase = "ledger.history.enableHistoryDatabase"
const confMaxBatchSize = "ledger.state.couchDBConfig.maxBatchUpdateSize"
const confAutoWarmIndexes = "ledger.state.couchDBConfig.autoWarmIndexes"
const confWarmIndexesAfterNBlocks = "ledger.state.couchDBConfig.warmIndexesAfterNBlocks"

var confCollElgProcMaxDbBatchSize = &conf{"ledger.pvtdataStore.collElgProcMaxDbBatchSize", 5000}
var confCollElgProcDbBatchesInterval = &conf{"ledger.pvtdataStore.collElgProcDbBatchesInterval", 1000}

// GetRootPath returns the filesystem path.
// All ledger related contents are expected to be stored under this path
func GetRootPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[3], 1);
	sysPath := config.GetPath(confPeerFileSystemPath)
	return filepath.Join(sysPath, confLedgersData)
}

// GetLedgerProviderPath returns the filesystem path for storing ledger ledgerProvider contents
func GetLedgerProviderPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[4], 1);
	return filepath.Join(GetRootPath(), confLedgerProvider)
}

// GetStateLevelDBPath returns the filesystem path that is used to maintain the state level db
func GetStateLevelDBPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[5], 1);
	return filepath.Join(GetRootPath(), confStateleveldb)
}

// GetHistoryLevelDBPath returns the filesystem path that is used to maintain the history level db
func GetHistoryLevelDBPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[6], 1);
	return filepath.Join(GetRootPath(), confHistoryLeveldb)
}

// GetBlockStorePath returns the filesystem path that is used for the chain block stores
func GetBlockStorePath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[7], 1);
	return filepath.Join(GetRootPath(), confChains)
}

// GetPvtdataStorePath returns the filesystem path that is used for permanent storage of private write-sets
func GetPvtdataStorePath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[8], 1);
	return filepath.Join(GetRootPath(), confPvtdataStore)
}

// GetInternalBookkeeperPath returns the filesystem path that is used for bookkeeping the internal stuff by by KVledger (such as expiration time for pvt)
func GetInternalBookkeeperPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[9], 1);
	return filepath.Join(GetRootPath(), confBookkeeper)
}

// GetConfigHistoryPath returns the filesystem path that is used for maintaining history of chaincodes collection configurations
func GetConfigHistoryPath() string {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[10], 1);
	return filepath.Join(GetRootPath(), confConfigHistory)
}

// GetMaxBlockfileSize returns maximum size of the block file
func GetMaxBlockfileSize() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[11], 1);
	return 64 * 1024 * 1024
}

// GetTotalQueryLimit exposes the totalLimit variable
func GetTotalQueryLimit() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[12], 1);
	totalQueryLimit := viper.GetInt(confTotalQueryLimit)
	// if queryLimit was unset, default to 10000
	if !viper.IsSet(confTotalQueryLimit) {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[14], 1);
		totalQueryLimit = 10000
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[13], 1);return totalQueryLimit
}

// GetInternalQueryLimit exposes the queryLimit variable
func GetInternalQueryLimit() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[15], 1);
	internalQueryLimit := viper.GetInt(confInternalQueryLimit)
	// if queryLimit was unset, default to 1000
	if !viper.IsSet(confInternalQueryLimit) {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[17], 1);
		internalQueryLimit = 1000
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[16], 1);return internalQueryLimit
}

//GetMaxBatchUpdateSize exposes the maxBatchUpdateSize variable
func GetMaxBatchUpdateSize() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[18], 1);
	maxBatchUpdateSize := viper.GetInt(confMaxBatchSize)
	// if maxBatchUpdateSize was unset, default to 500
	if !viper.IsSet(confMaxBatchSize) {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[20], 1);
		maxBatchUpdateSize = 500
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[19], 1);return maxBatchUpdateSize
}

// GetPvtdataStorePurgeInterval returns the interval in the terms of number of blocks
// when the purge for the expired data would be performed
func GetPvtdataStorePurgeInterval() uint64 {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[21], 1);
	purgeInterval := viper.GetInt("ledger.pvtdataStore.purgeInterval")
	if purgeInterval <= 0 {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[23], 1);
		purgeInterval = 100
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[22], 1);return uint64(purgeInterval)
}

// GetPvtdataStoreCollElgProcMaxDbBatchSize returns the maximum db batch size for converting
// the ineligible missing data entries to eligible missing data entries
func GetPvtdataStoreCollElgProcMaxDbBatchSize() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[24], 1);
	collElgProcMaxDbBatchSize := viper.GetInt(confCollElgProcMaxDbBatchSize.Name)
	if collElgProcMaxDbBatchSize <= 0 {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[26], 1);
		collElgProcMaxDbBatchSize = confCollElgProcMaxDbBatchSize.DefaultVal
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[25], 1);return collElgProcMaxDbBatchSize
}

// GetPvtdataStoreCollElgProcDbBatchesInterval returns the minimum duration (in milliseconds) between writing
// two consecutive db batches for converting the ineligible missing data entries to eligible missing data entries
func GetPvtdataStoreCollElgProcDbBatchesInterval() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[27], 1);
	collElgProcDbBatchesInterval := viper.GetInt(confCollElgProcDbBatchesInterval.Name)
	if collElgProcDbBatchesInterval <= 0 {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[29], 1);
		collElgProcDbBatchesInterval = confCollElgProcDbBatchesInterval.DefaultVal
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[28], 1);return collElgProcDbBatchesInterval
}

//IsHistoryDBEnabled exposes the historyDatabase variable
func IsHistoryDBEnabled() bool {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[30], 1);
	return viper.GetBool(confEnableHistoryDatabase)
}

// IsQueryReadsHashingEnabled enables or disables computing of hash
// of range query results for phantom item validation
func IsQueryReadsHashingEnabled() bool {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[31], 1);
	return true
}

// GetMaxDegreeQueryReadsHashing return the maximum degree of the merkle tree for hashes of
// of range query results for phantom item validation
// For more details - see description in kvledger/txmgmt/rwset/query_results_helper.go
func GetMaxDegreeQueryReadsHashing() uint32 {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[32], 1);
	return 50
}

//IsAutoWarmIndexesEnabled exposes the autoWarmIndexes variable
func IsAutoWarmIndexesEnabled() bool {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[33], 1);
	//Return the value set in core.yaml, if not set, the return true
	if viper.IsSet(confAutoWarmIndexes) {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[35], 1);
		return viper.GetBool(confAutoWarmIndexes)
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[34], 1);return true

}

//GetWarmIndexesAfterNBlocks exposes the warmIndexesAfterNBlocks variable
func GetWarmIndexesAfterNBlocks() int {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[36], 1);
	warmAfterNBlocks := viper.GetInt(confWarmIndexesAfterNBlocks)
	// if warmIndexesAfterNBlocks was unset, default to 1
	if !viper.IsSet(confWarmIndexesAfterNBlocks) {_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[38], 1);
		warmAfterNBlocks = 1
	}
	_cover_atomic_.AddUint32(&GoCover_0_323936323766313337343638.Count[37], 1);return warmAfterNBlocks
}

type conf struct {
	Name       string
	DefaultVal int
}

var GoCover_0_323936323766313337343638 = struct {
	Count     [39]uint32
	Pos       [3 * 39]uint32
	NumStmt   [39]uint16
} {
	Pos: [3 * 39]uint32{
		17, 19, 0x20001e, // [0]
		22, 22, 0xe0002, // [1]
		19, 21, 0x30020, // [2]
		46, 49, 0x2001b, // [3]
		52, 54, 0x20025, // [4]
		57, 59, 0x20023, // [5]
		62, 64, 0x20025, // [6]
		67, 69, 0x20021, // [7]
		72, 74, 0x20023, // [8]
		77, 79, 0x20029, // [9]
		82, 84, 0x20024, // [10]
		87, 89, 0x20020, // [11]
		92, 95, 0x27001f, // [12]
		98, 98, 0x180002, // [13]
		95, 97, 0x30027, // [14]
		102, 105, 0x2a0022, // [15]
		108, 108, 0x1b0002, // [16]
		105, 107, 0x3002a, // [17]
		112, 115, 0x240022, // [18]
		118, 118, 0x1b0002, // [19]
		115, 117, 0x30024, // [20]
		123, 125, 0x18002c, // [21]
		128, 128, 0x1e0002, // [22]
		125, 127, 0x30018, // [23]
		133, 135, 0x240035, // [24]
		138, 138, 0x220002, // [25]
		135, 137, 0x30024, // [26]
		143, 145, 0x270038, // [27]
		148, 148, 0x250002, // [28]
		145, 147, 0x30027, // [29]
		152, 154, 0x20020, // [30]
		158, 160, 0x20028, // [31]
		165, 167, 0x2002d, // [32]
		170, 172, 0x260026, // [33]
		175, 175, 0xd0002, // [34]
		172, 174, 0x30026, // [35]
		180, 183, 0x2f0027, // [36]
		186, 186, 0x190002, // [37]
		183, 185, 0x3002f, // [38]
	},
	NumStmt: [39]uint16{
		2, // 0
		1, // 1
		1, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		1, // 20
		2, // 21
		1, // 22
		1, // 23
		2, // 24
		1, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		2, // 36
		1, // 37
		1, // 38
	},
}
var _ = _cover_atomic_.LoadUint32
