//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/queryutil/iterator_combiner.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package queryutil; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	commonledger "github.com/hyperledger/fabric/common/ledger"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/protos/ledger/queryresult"
)

type itrCombiner struct {
	namespace string
	holders   []*itrHolder
}

func newItrCombiner(namespace string, baseIterators []statedb.ResultsIterator) (*itrCombiner, error) {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[0], 1);
	var holders []*itrHolder
	for _, itr := range baseIterators {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[2], 1);
		res, err := itr.Next()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[4], 1);
			for _, holder := range holders {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[6], 1);
				holder.itr.Close()
			}
			_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[5], 1);return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[3], 1);if res != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[7], 1);
			holders = append(holders, &itrHolder{itr, res.(*statedb.VersionedKV)})
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[1], 1);return &itrCombiner{namespace, holders}, nil
}

// Next returns the next eligible item from the underlying iterators.
// This function evaluates the underlying iterators, and picks the one which is
// gives the lexicographically smallest key. Then, it saves that value, and advances the chosen iterator.
// If the chosen iterator is out of elements, then that iterator is closed, and removed from the list of iterators.
func (combiner *itrCombiner) Next() (commonledger.QueryResult, error) {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[8], 1);
	logger.Debugf("Iterators position at beginning: %s", combiner.holders)
	if len(combiner.holders) == 0 {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[12], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[9], 1);smallestHolderIndex := 0
	for i := 1; i < len(combiner.holders); i++ {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[13], 1);
		smallestKey, holderKey := combiner.keyAt(smallestHolderIndex), combiner.keyAt(i)
		switch {
		case holderKey == smallestKey:_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[14], 1); // we found the same key in the lower order iterator (stale value of the key);
			// we already have the latest value for this key (in smallestHolder). Ignore this value and move the iterator
			// to next item (to a greater key) so that for next round of key selection, we do not consider this key again
			removed, err := combiner.moveItrAndRemoveIfExhausted(i)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[18], 1);
				return nil, err
			}
			_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[15], 1);if removed {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[19], 1); // if the current iterator is exhaused and hence removed, decrement the index
				// because indexes of the remaining iterators are decremented by one
				i--
			}
		case holderKey < smallestKey:_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[16], 1);
			smallestHolderIndex = i
		default:_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[17], 1);
			// the current key under evaluation is greater than the smallestKey - do nothing
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[10], 1);kv := combiner.kvAt(smallestHolderIndex)
	combiner.moveItrAndRemoveIfExhausted(smallestHolderIndex)
	if kv.IsDelete() {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[20], 1);
		return combiner.Next()
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[11], 1);logger.Debugf("Key [%s] selected from iterator at index [%d]", kv.Key, smallestHolderIndex)
	logger.Debugf("Iterators position at end: %s", combiner.holders)
	return &queryresult.KV{Namespace: combiner.namespace, Key: kv.Key, Value: kv.Value}, nil
}

// moveItrAndRemoveIfExhausted moves the iterator at index i to the next item. If the iterator gets exhausted
// then the iterator is removed from the underlying slice
func (combiner *itrCombiner) moveItrAndRemoveIfExhausted(i int) (removed bool, err error) {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[21], 1);
	holder := combiner.holders[i]
	exhausted, err := holder.moveToNext()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[24], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[22], 1);if exhausted {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[25], 1);
		combiner.holders[i].itr.Close()
		combiner.holders = append(combiner.holders[:i], combiner.holders[i+1:]...)

	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[23], 1);return exhausted, nil
}

// kvAt returns the kv available from iterator at index i
func (combiner *itrCombiner) kvAt(i int) *statedb.VersionedKV {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[26], 1);
	return combiner.holders[i].kv
}

// keyAt returns the key available from iterator at index i
func (combiner *itrCombiner) keyAt(i int) string {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[27], 1);
	return combiner.kvAt(i).Key
}

// Close closes all the underlying iterators
func (combiner *itrCombiner) Close() {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[28], 1);
	for _, holder := range combiner.holders {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[29], 1);
		holder.itr.Close()
	}
}

// itrHolder encloses an iterator and keeps the next item available from the iterator in the buffer
type itrHolder struct {
	itr statedb.ResultsIterator
	kv  *statedb.VersionedKV
}

// moveToNext fetches the next item to keep in buffer and returns true if the iterator is exhausted
func (holder *itrHolder) moveToNext() (exhausted bool, err error) {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[30], 1);
	var res statedb.QueryResult
	if res, err = holder.itr.Next(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[33], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[31], 1);if res != nil {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[34], 1);
		holder.kv = res.(*statedb.VersionedKV)
	}
	_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[32], 1);return res == nil, nil
}

// String returns the key that the holder has in the buffer for serving as a next key
func (holder *itrHolder) String() string {_cover_atomic_.AddUint32(&GoCover_0_613064386665656166663361.Count[35], 1);
	return fmt.Sprintf("{%s}", holder.kv.Key)
}

var GoCover_0_613064386665656166663361 = struct {
	Count     [36]uint32
	Pos       [3 * 36]uint32
	NumStmt   [36]uint16
} {
	Pos: [3 * 36]uint32{
		22, 24, 0x240066, // [0]
		36, 36, 0x2e0002, // [1]
		24, 26, 0x110024, // [2]
		32, 32, 0x110003, // [3]
		26, 27, 0x230011, // [4]
		30, 30, 0x130004, // [5]
		27, 29, 0x50023, // [6]
		32, 34, 0x40011, // [7]
		43, 45, 0x200047, // [8]
		48, 49, 0x2d0002, // [9]
		69, 71, 0x130002, // [10]
		74, 76, 0x5a0002, // [11]
		45, 47, 0x30020, // [12]
		49, 51, 0xa002d, // [13]
		52, 56, 0x120021, // [14]
		59, 59, 0xf0004, // [15]
		63, 64, 0x1b0020, // [16]
		65, 65, 0xb000b, // [17]
		56, 58, 0x50012, // [18]
		59, 62, 0x5000f, // [19]
		71, 73, 0x30013, // [20]
		81, 84, 0x10005b, // [21]
		87, 87, 0xf0002, // [22]
		92, 92, 0x170002, // [23]
		84, 86, 0x30010, // [24]
		87, 91, 0x3000f, // [25]
		96, 98, 0x2003f, // [26]
		101, 103, 0x20032, // [27]
		106, 107, 0x2a0026, // [28]
		107, 109, 0x3002a, // [29]
		119, 121, 0x2e0043, // [30]
		124, 124, 0x100002, // [31]
		127, 127, 0x180002, // [32]
		121, 123, 0x3002e, // [33]
		124, 126, 0x30010, // [34]
		131, 133, 0x2002a, // [35]
	},
	NumStmt: [36]uint16{
		2, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		2, // 8
		2, // 9
		3, // 10
		3, // 11
		1, // 12
		2, // 13
		2, // 14
		1, // 15
		1, // 16
		0, // 17
		1, // 18
		1, // 19
		1, // 20
		3, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
	},
}
var _ = _cover_atomic_.LoadUint32
