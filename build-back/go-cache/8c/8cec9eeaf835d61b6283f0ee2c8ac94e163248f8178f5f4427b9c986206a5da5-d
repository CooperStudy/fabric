//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/validator/statebasedval/state_based_validator.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package statebasedval; import _cover_atomic_ "sync/atomic"

import (
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/statedb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/validator/internal"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/version"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
	"github.com/hyperledger/fabric/protos/peer"
)

var logger = flogging.MustGetLogger("statebasedval")

// Validator validates a tx against the latest committed state
// and preceding valid transactions with in the same block
type Validator struct {
	db privacyenabledstate.DB
}

// NewValidator constructs StateValidator
func NewValidator(db privacyenabledstate.DB) *Validator {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[0], 1);
	return &Validator{db}
}

// preLoadCommittedVersionOfRSet loads committed version of all keys in each
// transaction's read set into a cache.
func (v *Validator) preLoadCommittedVersionOfRSet(block *internal.Block) error {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[1], 1);

	// Collect both public and hashed keys in read sets of all transactions in a given block
	var pubKeys []*statedb.CompositeKey
	var hashedKeys []*privacyenabledstate.HashedCompositeKey

	// pubKeysMap and hashedKeysMap are used to avoid duplicate entries in the
	// pubKeys and hashedKeys. Though map alone can be used to collect keys in
	// read sets and pass as an argument in LoadCommittedVersionOfPubAndHashedKeys(),
	// array is used for better code readability. On the negative side, this approach
	// might use some extra memory.
	pubKeysMap := make(map[statedb.CompositeKey]interface{})
	hashedKeysMap := make(map[privacyenabledstate.HashedCompositeKey]interface{})

	for _, tx := range block.Txs {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[4], 1);
		for _, nsRWSet := range tx.RWSet.NsRwSets {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[5], 1);
			for _, kvRead := range nsRWSet.KvRwSet.Reads {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[7], 1);
				compositeKey := statedb.CompositeKey{
					Namespace: nsRWSet.NameSpace,
					Key:       kvRead.Key,
				}
				if _, ok := pubKeysMap[compositeKey]; !ok {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[8], 1);
					pubKeysMap[compositeKey] = nil
					pubKeys = append(pubKeys, &compositeKey)
				}

			}
			_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[6], 1);for _, colHashedRwSet := range nsRWSet.CollHashedRwSets {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[9], 1);
				for _, kvHashedRead := range colHashedRwSet.HashedRwSet.HashedReads {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[10], 1);
					hashedCompositeKey := privacyenabledstate.HashedCompositeKey{
						Namespace:      nsRWSet.NameSpace,
						CollectionName: colHashedRwSet.CollectionName,
						KeyHash:        string(kvHashedRead.KeyHash),
					}
					if _, ok := hashedKeysMap[hashedCompositeKey]; !ok {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[11], 1);
						hashedKeysMap[hashedCompositeKey] = nil
						hashedKeys = append(hashedKeys, &hashedCompositeKey)
					}
				}
			}
		}
	}

	// Load committed version of all keys into a cache
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[2], 1);if len(pubKeys) > 0 || len(hashedKeys) > 0 {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[12], 1);
		err := v.db.LoadCommittedVersionsOfPubAndHashedKeys(pubKeys, hashedKeys)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[13], 1);
			return err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[3], 1);return nil
}

// ValidateAndPrepareBatch implements method in Validator interface
func (v *Validator) ValidateAndPrepareBatch(block *internal.Block, doMVCCValidation bool) (*internal.PubAndHashUpdates, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[14], 1);
	// Check whether statedb implements BulkOptimizable interface. For now,
	// only CouchDB implements BulkOptimizable to reduce the number of REST
	// API calls from peer to CouchDB instance.
	if v.db.IsBulkOptimizable() {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[17], 1);
		err := v.preLoadCommittedVersionOfRSet(block)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[18], 1);
			return nil, err
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[15], 1);updates := internal.NewPubAndHashUpdates()
	for _, tx := range block.Txs {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[19], 1);
		var validationCode peer.TxValidationCode
		var err error
		if validationCode, err = v.validateEndorserTX(tx.RWSet, doMVCCValidation, updates); err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[21], 1);
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[20], 1);tx.ValidationCode = validationCode
		if validationCode == peer.TxValidationCode_VALID {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[22], 1);
			logger.Debugf("Block [%d] Transaction index [%d] TxId [%s] marked as valid by state validator", block.Num, tx.IndexInBlock, tx.ID)
			committingTxHeight := version.NewHeight(block.Num, uint64(tx.IndexInBlock))
			updates.ApplyWriteSet(tx.RWSet, committingTxHeight, v.db)
		} else{ _cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[23], 1);{
			logger.Warningf("Block [%d] Transaction index [%d] TxId [%s] marked as invalid by state validator. Reason code [%s]",
				block.Num, tx.IndexInBlock, tx.ID, validationCode.String())
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[16], 1);return updates, nil
}

// validateEndorserTX validates endorser transaction
func (v *Validator) validateEndorserTX(
	txRWSet *rwsetutil.TxRwSet,
	doMVCCValidation bool,
	updates *internal.PubAndHashUpdates) (peer.TxValidationCode, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[24], 1);

	var validationCode = peer.TxValidationCode_VALID
	var err error
	//mvccvalidation, may invalidate transaction
	if doMVCCValidation {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[26], 1);
		validationCode, err = v.validateTx(txRWSet, updates)
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[25], 1);return validationCode, err
}

func (v *Validator) validateTx(txRWSet *rwsetutil.TxRwSet, updates *internal.PubAndHashUpdates) (peer.TxValidationCode, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[27], 1);
	// Uncomment the following only for local debugging. Don't want to print data in the logs in production
	//logger.Debugf("validateTx - validating txRWSet: %s", spew.Sdump(txRWSet))
	for _, nsRWSet := range txRWSet.NsRwSets {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[29], 1);
		ns := nsRWSet.NameSpace
		// Validate public reads
		if valid, err := v.validateReadSet(ns, nsRWSet.KvRwSet.Reads, updates.PubUpdates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[32], 1);
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[34], 1);
				return peer.TxValidationCode(-1), err
			}
			_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[33], 1);return peer.TxValidationCode_MVCC_READ_CONFLICT, nil
		}
		// Validate range queries for phantom items
		_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[30], 1);if valid, err := v.validateRangeQueries(ns, nsRWSet.KvRwSet.RangeQueriesInfo, updates.PubUpdates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[35], 1);
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[37], 1);
				return peer.TxValidationCode(-1), err
			}
			_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[36], 1);return peer.TxValidationCode_PHANTOM_READ_CONFLICT, nil
		}
		// Validate hashes for private reads
		_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[31], 1);if valid, err := v.validateNsHashedReadSets(ns, nsRWSet.CollHashedRwSets, updates.HashUpdates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[38], 1);
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[40], 1);
				return peer.TxValidationCode(-1), err
			}
			_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[39], 1);return peer.TxValidationCode_MVCC_READ_CONFLICT, nil
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[28], 1);return peer.TxValidationCode_VALID, nil
}

////////////////////////////////////////////////////////////////////////////////
/////                 Validation of public read-set
////////////////////////////////////////////////////////////////////////////////
func (v *Validator) validateReadSet(ns string, kvReads []*kvrwset.KVRead, updates *privacyenabledstate.PubUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[41], 1);
	for _, kvRead := range kvReads {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[43], 1);
		if valid, err := v.validateKVRead(ns, kvRead, updates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[44], 1);
			return valid, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[42], 1);return true, nil
}

// validateKVRead performs mvcc check for a key read during transaction simulation.
// i.e., it checks whether a key/version combination is already updated in the statedb (by an already committed block)
// or in the updates (by a preceding valid transaction in the current block)
func (v *Validator) validateKVRead(ns string, kvRead *kvrwset.KVRead, updates *privacyenabledstate.PubUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[45], 1);
	if updates.Exists(ns, kvRead.Key) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[49], 1);
		return false, nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[46], 1);committedVersion, err := v.db.GetVersion(ns, kvRead.Key)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[50], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[47], 1);logger.Debugf("Comparing versions for key [%s]: committed version=%#v and read version=%#v",
		kvRead.Key, committedVersion, rwsetutil.NewVersion(kvRead.Version))
	if !version.AreSame(committedVersion, rwsetutil.NewVersion(kvRead.Version)) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[51], 1);
		logger.Debugf("Version mismatch for key [%s:%s]. Committed version = [%#v], Version in readSet [%#v]",
			ns, kvRead.Key, committedVersion, kvRead.Version)
		return false, nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[48], 1);return true, nil
}

////////////////////////////////////////////////////////////////////////////////
/////                 Validation of range queries
////////////////////////////////////////////////////////////////////////////////
func (v *Validator) validateRangeQueries(ns string, rangeQueriesInfo []*kvrwset.RangeQueryInfo, updates *privacyenabledstate.PubUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[52], 1);
	for _, rqi := range rangeQueriesInfo {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[54], 1);
		if valid, err := v.validateRangeQuery(ns, rqi, updates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[55], 1);
			return valid, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[53], 1);return true, nil
}

// validateRangeQuery performs a phantom read check i.e., it
// checks whether the results of the range query are still the same when executed on the
// statedb (latest state as of last committed block) + updates (prepared by the writes of preceding valid transactions
// in the current block and yet to be committed as part of group commit at the end of the validation of the block)
func (v *Validator) validateRangeQuery(ns string, rangeQueryInfo *kvrwset.RangeQueryInfo, updates *privacyenabledstate.PubUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[56], 1);
	logger.Debugf("validateRangeQuery: ns=%s, rangeQueryInfo=%s", ns, rangeQueryInfo)

	// If during simulation, the caller had not exhausted the iterator so
	// rangeQueryInfo.EndKey is not actual endKey given by the caller in the range query
	// but rather it is the last key seen by the caller and hence the combinedItr should include the endKey in the results.
	includeEndKey := !rangeQueryInfo.ItrExhausted

	combinedItr, err := newCombinedIterator(v.db, updates.UpdateBatch,
		ns, rangeQueryInfo.StartKey, rangeQueryInfo.EndKey, includeEndKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[59], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[57], 1);defer combinedItr.Close()
	var validator rangeQueryValidator
	if rangeQueryInfo.GetReadsMerkleHashes() != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[60], 1);
		logger.Debug(`Hashing results are present in the range query info hence, initiating hashing based validation`)
		validator = &rangeQueryHashValidator{}
	} else{ _cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[61], 1);{
		logger.Debug(`Hashing results are not present in the range query info hence, initiating raw KVReads based validation`)
		validator = &rangeQueryResultsValidator{}
	}}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[58], 1);validator.init(rangeQueryInfo, combinedItr)
	return validator.validate()
}

////////////////////////////////////////////////////////////////////////////////
/////                 Validation of hashed read-set
////////////////////////////////////////////////////////////////////////////////
func (v *Validator) validateNsHashedReadSets(ns string, collHashedRWSets []*rwsetutil.CollHashedRwSet,
	updates *privacyenabledstate.HashedUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[62], 1);
	for _, collHashedRWSet := range collHashedRWSets {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[64], 1);
		if valid, err := v.validateCollHashedReadSet(ns, collHashedRWSet.CollectionName, collHashedRWSet.HashedRwSet.HashedReads, updates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[65], 1);
			return valid, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[63], 1);return true, nil
}

func (v *Validator) validateCollHashedReadSet(ns, coll string, kvReadHashes []*kvrwset.KVReadHash,
	updates *privacyenabledstate.HashedUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[66], 1);
	for _, kvReadHash := range kvReadHashes {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[68], 1);
		if valid, err := v.validateKVReadHash(ns, coll, kvReadHash, updates); !valid || err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[69], 1);
			return valid, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[67], 1);return true, nil
}

// validateKVReadHash performs mvcc check for a hash of a key that is present in the private data space
// i.e., it checks whether a key/version combination is already updated in the statedb (by an already committed block)
// or in the updates (by a preceding valid transaction in the current block)
func (v *Validator) validateKVReadHash(ns, coll string, kvReadHash *kvrwset.KVReadHash,
	updates *privacyenabledstate.HashedUpdateBatch) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[70], 1);
	if updates.Contains(ns, coll, kvReadHash.KeyHash) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[74], 1);
		return false, nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[71], 1);committedVersion, err := v.db.GetKeyHashVersion(ns, coll, kvReadHash.KeyHash)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[75], 1);
		return false, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[72], 1);if !version.AreSame(committedVersion, rwsetutil.NewVersion(kvReadHash.Version)) {_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[76], 1);
		logger.Debugf("Version mismatch for key hash [%s:%s:%#v]. Committed version = [%s], Version in hashedReadSet [%s]",
			ns, coll, kvReadHash.KeyHash, committedVersion, kvReadHash.Version)
		return false, nil
	}
	_cover_atomic_.AddUint32(&GoCover_2_616464313537613636643832.Count[73], 1);return true, nil
}

var GoCover_2_616464313537613636643832 = struct {
	Count     [77]uint32
	Pos       [3 * 77]uint32
	NumStmt   [77]uint16
} {
	Pos: [3 * 77]uint32{
		28, 30, 0x20039, // [0]
		34, 48, 0x1f0050, // [1]
		78, 78, 0x2d0002, // [2]
		85, 85, 0xc0002, // [3]
		48, 49, 0x2d001f, // [4]
		49, 50, 0x31002d, // [5]
		61, 61, 0x3c0004, // [6]
		50, 55, 0x2f0031, // [7]
		55, 58, 0x6002f, // [8]
		61, 62, 0x49003c, // [9]
		62, 68, 0x390049, // [10]
		68, 71, 0x70039, // [11]
		78, 80, 0x11002d, // [12]
		80, 82, 0x40011, // [13]
		89, 93, 0x1e0080, // [14]
		100, 101, 0x1f0002, // [15]
		118, 118, 0x150002, // [16]
		93, 95, 0x11001e, // [17]
		95, 97, 0x40011, // [18]
		101, 104, 0x62001f, // [19]
		108, 109, 0x340003, // [20]
		104, 106, 0x40062, // [21]
		109, 113, 0x40034, // [22]
		113, 116, 0x40009, // [23]
		125, 130, 0x160046, // [24]
		133, 133, 0x1c0002, // [25]
		130, 132, 0x30016, // [26]
		136, 139, 0x2b0080, // [27]
		163, 163, 0x290002, // [28]
		139, 142, 0x6b002b, // [29]
		149, 149, 0x7b0003, // [30]
		156, 156, 0x780003, // [31]
		142, 143, 0x12006b, // [32]
		146, 146, 0x380004, // [33]
		143, 145, 0x50012, // [34]
		149, 150, 0x12007b, // [35]
		153, 153, 0x3b0004, // [36]
		150, 152, 0x50012, // [37]
		156, 157, 0x120078, // [38]
		160, 160, 0x380004, // [39]
		157, 159, 0x50012, // [40]
		169, 170, 0x210086, // [41]
		175, 175, 0x120002, // [42]
		170, 171, 0x500021, // [43]
		171, 173, 0x40050, // [44]
		181, 182, 0x240082, // [45]
		185, 186, 0x100002, // [46]
		190, 192, 0x4e0002, // [47]
		197, 197, 0x120002, // [48]
		182, 184, 0x30024, // [49]
		186, 188, 0x30010, // [50]
		192, 196, 0x3004e, // [51]
		203, 204, 0x27009c, // [52]
		209, 209, 0x120002, // [53]
		204, 205, 0x510027, // [54]
		205, 207, 0x40051, // [55]
		216, 226, 0x100096, // [56]
		229, 231, 0x320002, // [57]
		238, 239, 0x1d0002, // [58]
		226, 228, 0x30010, // [59]
		231, 234, 0x30032, // [60]
		234, 237, 0x30008, // [61]
		246, 247, 0x330040, // [62]
		252, 252, 0x120002, // [63]
		247, 248, 0x9c0033, // [64]
		248, 250, 0x4009c, // [65]
		256, 257, 0x2a0040, // [66]
		262, 262, 0x120002, // [67]
		257, 258, 0x5e002a, // [68]
		258, 260, 0x4005e, // [69]
		269, 270, 0x340040, // [70]
		273, 274, 0x100002, // [71]
		278, 278, 0x520002, // [72]
		283, 283, 0x120002, // [73]
		270, 272, 0x30034, // [74]
		274, 276, 0x30010, // [75]
		278, 282, 0x30052, // [76]
	},
	NumStmt: [77]uint16{
		1, // 0
		5, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		2, // 10
		2, // 11
		2, // 12
		1, // 13
		1, // 14
		2, // 15
		1, // 16
		2, // 17
		1, // 18
		3, // 19
		2, // 20
		1, // 21
		3, // 22
		1, // 23
		3, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		2, // 46
		2, // 47
		1, // 48
		1, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		4, // 56
		3, // 57
		2, // 58
		1, // 59
		2, // 60
		2, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		2, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		2, // 76
	},
}
var _ = _cover_atomic_.LoadUint32
