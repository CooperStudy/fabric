//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/msgprocessor/expiration.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package msgprocessor; import _cover_atomic_ "sync/atomic"

import (
	"time"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

type resources interface {
	// OrdererConfig returns the config.Orderer for the channel
	// and whether the Orderer config exists
	OrdererConfig() (channelconfig.Orderer, bool)
}

// NewExpirationRejectRule returns a rule that rejects messages signed by identities
// who's identities have expired, given the capability is active
func NewExpirationRejectRule(filterSupport resources) Rule {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[0], 1);
	return &expirationRejectRule{filterSupport: filterSupport}
}

type expirationRejectRule struct {
	filterSupport resources
}

// Apply checks whether the identity that created the envelope has expired
func (exp *expirationRejectRule) Apply(message *common.Envelope) error {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[1], 1);
	ordererConf, ok := exp.filterSupport.OrdererConfig()
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[6], 1);
		logger.Panic("Programming error: orderer config not found")
	}
	_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[2], 1);if !ordererConf.Capabilities().ExpirationCheck() {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[7], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[3], 1);signedData, err := message.AsSignedData()

	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[8], 1);
		return errors.Errorf("could not convert message to signedData: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[4], 1);expirationTime := crypto.ExpiresAt(signedData[0].Identity)
	// Identity cannot expire, or identity has not expired yet
	if expirationTime.IsZero() || time.Now().Before(expirationTime) {_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[9], 1);
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_646330373837303238396264.Count[5], 1);return errors.New("identity expired")
}

var GoCover_0_646330373837303238396264 = struct {
	Count     [10]uint32
	Pos       [3 * 10]uint32
	NumStmt   [10]uint16
} {
	Pos: [3 * 10]uint32{
		26, 28, 0x2003c, // [0]
		35, 37, 0x90048, // [1]
		40, 40, 0x330002, // [2]
		43, 45, 0x100002, // [3]
		48, 50, 0x420002, // [4]
		53, 53, 0x270002, // [5]
		37, 39, 0x30009, // [6]
		40, 42, 0x30033, // [7]
		45, 47, 0x30010, // [8]
		50, 52, 0x30042, // [9]
	},
	NumStmt: [10]uint16{
		1, // 0
		2, // 1
		1, // 2
		2, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
	},
}
var _ = _cover_atomic_.LoadUint32
