//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/confighistory/db_helper.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package confighistory; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/binary"
	"math"

	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/pkg/errors"
)

const (
	keyPrefix     = "s"
	separatorByte = byte(0)
)

type compositeKey struct {
	ns, key  string
	blockNum uint64
}

type compositeKV struct {
	*compositeKey
	value []byte
}

type dbProvider struct {
	*leveldbhelper.Provider
}

type db struct {
	*leveldbhelper.DBHandle
}

type batch struct {
	*leveldbhelper.UpdateBatch
}

func newDBProvider(dbPath string) *dbProvider {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[0], 1);
	logger.Debugf("Opening db for config history: db path = %s", dbPath)
	return &dbProvider{leveldbhelper.NewProvider(&leveldbhelper.Conf{DBPath: dbPath})}
}

func newBatch() *batch {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[1], 1);
	return &batch{leveldbhelper.NewUpdateBatch()}
}

func (p *dbProvider) getDB(id string) *db {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[2], 1);
	return &db{p.GetDBHandle(id)}
}

func (b *batch) add(ns, key string, blockNum uint64, value []byte) {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[3], 1);
	logger.Debugf("add() - {%s, %s, %d}", ns, key, blockNum)
	k, v := encodeCompositeKey(ns, key, blockNum), value
	b.Put(k, v)
}

func (d *db) writeBatch(batch *batch, sync bool) error {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[4], 1);
	return d.WriteBatch(batch.UpdateBatch, sync)
}

func (d *db) mostRecentEntryBelow(blockNum uint64, ns, key string) (*compositeKV, error) {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[5], 1);
	logger.Debugf("mostRecentEntryBelow() - {%s, %s, %d}", ns, key, blockNum)
	if blockNum == 0 {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[8], 1);
		return nil, errors.New("blockNum should be greater than 0")
	}
	_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[6], 1);startKey := encodeCompositeKey(ns, key, blockNum-1)
	itr := d.GetIterator(startKey, nil)
	defer itr.Release()
	if !itr.Next() {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[9], 1);
		logger.Debugf("Key no entry found. Returning nil")
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[7], 1);k, v := decodeCompositeKey(itr.Key()), itr.Value()
	return &compositeKV{k, v}, nil
}

func (d *db) entryAt(blockNum uint64, ns, key string) (*compositeKV, error) {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[10], 1);
	logger.Debugf("entryAt() - {%s, %s, %d}", ns, key, blockNum)
	keyBytes := encodeCompositeKey(ns, key, blockNum)
	valBytes, err := d.Get(keyBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[13], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[11], 1);if valBytes == nil {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[14], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[12], 1);k, v := decodeCompositeKey(keyBytes), valBytes
	return &compositeKV{k, v}, nil
}

func encodeCompositeKey(ns, key string, blockNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[15], 1);
	b := []byte(keyPrefix + ns)
	b = append(b, separatorByte)
	b = append(b, []byte(key)...)
	return append(b, encodeBlockNum(blockNum)...)
}

func decodeCompositeKey(b []byte) *compositeKey {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[16], 1);
	blockNumStartIndex := len(b) - 8
	nsKeyBytes, blockNumBytes := b[1:blockNumStartIndex], b[blockNumStartIndex:]
	separatorIndex := bytes.Index(nsKeyBytes, []byte{separatorByte})
	ns, key := nsKeyBytes[0:separatorIndex], nsKeyBytes[separatorIndex+1:]
	return &compositeKey{string(ns), string(key), decodeBlockNum(blockNumBytes)}
}

func encodeBlockNum(blockNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[17], 1);
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, math.MaxUint64-blockNum)
	return b
}

func decodeBlockNum(blockNumBytes []byte) uint64 {_cover_atomic_.AddUint32(&GoCover_0_633363383730643239393737.Count[18], 1);
	return math.MaxUint64 - binary.BigEndian.Uint64(blockNumBytes)
}

var GoCover_0_633363383730643239393737 = struct {
	Count     [19]uint32
	Pos       [3 * 19]uint32
	NumStmt   [19]uint16
} {
	Pos: [3 * 19]uint32{
		45, 48, 0x2002f, // [0]
		50, 52, 0x20018, // [1]
		54, 56, 0x2002b, // [2]
		58, 62, 0x20044, // [3]
		64, 66, 0x20038, // [4]
		68, 70, 0x13005a, // [5]
		73, 76, 0x110002, // [6]
		80, 81, 0x200002, // [7]
		70, 72, 0x30013, // [8]
		76, 79, 0x30011, // [9]
		84, 88, 0x10004d, // [10]
		91, 91, 0x150002, // [11]
		94, 95, 0x200002, // [12]
		88, 90, 0x30010, // [13]
		91, 93, 0x30015, // [14]
		98, 103, 0x20041, // [15]
		105, 111, 0x20031, // [16]
		113, 117, 0x2002d, // [17]
		119, 121, 0x20032, // [18]
	},
	NumStmt: [19]uint16{
		2, // 0
		1, // 1
		1, // 2
		3, // 3
		1, // 4
		2, // 5
		4, // 6
		2, // 7
		1, // 8
		2, // 9
		4, // 10
		1, // 11
		2, // 12
		1, // 13
		1, // 14
		4, // 15
		5, // 16
		3, // 17
		1, // 18
	},
}
var _ = _cover_atomic_.LoadUint32
