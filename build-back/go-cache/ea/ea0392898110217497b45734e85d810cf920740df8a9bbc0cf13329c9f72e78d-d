//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/tests/env.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package tests; import _cover_atomic_ "sync/atomic"

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/hyperledger/fabric/common/metrics/disabled"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/msp/mgmt"
	"github.com/hyperledger/fabric/protos/common"

	"github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage"
	"github.com/hyperledger/fabric/common/ledger/util"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/ledgermgmt"
	"github.com/hyperledger/fabric/core/peer"
	"github.com/hyperledger/fabric/core/scc/lscc"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
)

type config map[string]interface{}
type rebuildable uint8

const (
	rebuildableStatedb       rebuildable = 1
	rebuildableBlockIndex    rebuildable = 2
	rebuildableConfigHistory rebuildable = 4
	rebuildableHistoryDB     rebuildable = 8
)

var (
	defaultConfig = config{
		"peer.fileSystemPath":        "/tmp/fabric/ledgertests",
		"ledger.state.stateDatabase": "goleveldb",
	}
)

type env struct {
	assert *assert.Assertions
}

func newEnv(conf config, t *testing.T) *env {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[0], 1);
	setupConfigs(conf)
	env := &env{assert.New(t)}
	initLedgerMgmt()
	return env
}

func (e *env) cleanup() {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[1], 1);
	closeLedgerMgmt()
	e.assert.NoError(os.RemoveAll(getLedgerRootPath()))
}

func (e *env) closeAllLedgersAndDrop(flags rebuildable) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[2], 1);
	closeLedgerMgmt()
	defer initLedgerMgmt()

	if flags&rebuildableBlockIndex == rebuildableBlockIndex {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[5], 1);
		indexPath := getBlockIndexDBPath()
		logger.Infof("Deleting blockstore indexdb path [%s]", indexPath)
		e.verifyNonEmptyDirExists(indexPath)
		e.assert.NoError(os.RemoveAll(indexPath))
	}

	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[3], 1);if flags&rebuildableStatedb == rebuildableStatedb {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[6], 1);
		statedbPath := getLevelstateDBPath()
		logger.Infof("Deleting statedb path [%s]", statedbPath)
		e.verifyNonEmptyDirExists(statedbPath)
		e.assert.NoError(os.RemoveAll(statedbPath))
	}

	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[4], 1);if flags&rebuildableConfigHistory == rebuildableConfigHistory {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[7], 1);
		configHistory := getConfigHistoryDBPath()
		logger.Infof("Deleting configHistory db path [%s]", configHistory)
		e.verifyNonEmptyDirExists(configHistory)
		e.assert.NoError(os.RemoveAll(configHistory))
	}
}

func (e *env) verifyRebuilablesExist(flags rebuildable) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[8], 1);
	if flags&rebuildableStatedb == rebuildableBlockIndex {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[11], 1);
		e.verifyNonEmptyDirExists(getBlockIndexDBPath())
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[9], 1);if flags&rebuildableBlockIndex == rebuildableStatedb {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[12], 1);
		e.verifyNonEmptyDirExists(getLevelstateDBPath())
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[10], 1);if flags&rebuildableConfigHistory == rebuildableConfigHistory {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[13], 1);
		e.verifyNonEmptyDirExists(getConfigHistoryDBPath())
	}
}

func (e *env) verifyRebuilableDoesNotExist(flags rebuildable) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[14], 1);
	if flags&rebuildableStatedb == rebuildableStatedb {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[17], 1);
		e.verifyDirDoesNotExist(getLevelstateDBPath())
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[15], 1);if flags&rebuildableStatedb == rebuildableBlockIndex {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[18], 1);
		e.verifyDirDoesNotExist(getBlockIndexDBPath())
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[16], 1);if flags&rebuildableConfigHistory == rebuildableConfigHistory {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[19], 1);
		e.verifyDirDoesNotExist(getConfigHistoryDBPath())
	}
}

func (e *env) verifyNonEmptyDirExists(path string) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[20], 1);
	empty, err := util.DirEmpty(path)
	e.assert.NoError(err)
	e.assert.False(empty)
}

func (e *env) verifyDirDoesNotExist(path string) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[21], 1);
	exists, _, err := util.FileExists(path)
	e.assert.NoError(err)
	e.assert.False(exists)
}

// ########################### ledgermgmt and ledgerconfig related functions wrappers #############################
// In the current code, ledgermgmt and ledgerconfigs are packaged scope APIs and hence so are the following
// wrapper APIs. As a TODO, both the ledgermgmt and ledgerconfig can be refactored as separate objects and then
// the instances of these two would be wrapped inside the `env` struct above.
// #################################################################################################################
func setupConfigs(conf config) {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[22], 1);
	for c, v := range conf {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[23], 1);
		viper.Set(c, v)
	}
}

func initLedgerMgmt() {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[24], 1);
	identityDeserializerFactory := func(chainID string) msp.IdentityDeserializer {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[26], 1);
		return mgmt.GetManagerForChain(chainID)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[25], 1);membershipInfoProvider := privdata.NewMembershipInfoProvider(createSelfSignedData(), identityDeserializerFactory)

	ledgermgmt.InitializeExistingTestEnvWithInitializer(
		&ledgermgmt.Initializer{
			CustomTxProcessors:            peer.ConfigTxProcessors,
			DeployedChaincodeInfoProvider: &lscc.DeployedCCInfoProvider{},
			MembershipInfoProvider:        membershipInfoProvider,
			MetricsProvider:               &disabled.Provider{},
		},
	)
}

func createSelfSignedData() common.SignedData {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[27], 1);
	sID := mgmt.GetLocalSigningIdentityOrPanic()
	msg := make([]byte, 32)
	sig, err := sID.Sign(msg)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[30], 1);
		logger.Panicf("Failed creating self signed data because message signing failed: %v", err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[28], 1);peerIdentity, err := sID.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[31], 1);
		logger.Panicf("Failed creating self signed data because peer identity couldn't be serialized: %v", err)
	}
	_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[29], 1);return common.SignedData{
		Data:      msg,
		Signature: sig,
		Identity:  peerIdentity,
	}
}

func closeLedgerMgmt() {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[32], 1);
	ledgermgmt.Close()
}

func getLedgerRootPath() string {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[33], 1);
	return ledgerconfig.GetRootPath()
}

func getLevelstateDBPath() string {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[34], 1);
	return ledgerconfig.GetStateLevelDBPath()
}

func getBlockIndexDBPath() string {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[35], 1);
	return filepath.Join(ledgerconfig.GetBlockStorePath(), fsblkstorage.IndexDir)
}

func getConfigHistoryDBPath() string {_cover_atomic_.AddUint32(&GoCover_2_363234376562373564353161.Count[36], 1);
	return ledgerconfig.GetConfigHistoryPath()
}

var GoCover_2_363234376562373564353161 = struct {
	Count     [37]uint32
	Pos       [3 * 37]uint32
	NumStmt   [37]uint16
} {
	Pos: [3 * 37]uint32{
		51, 56, 0x2002d, // [0]
		58, 61, 0x20019, // [1]
		63, 67, 0x3a0039, // [2]
		74, 74, 0x340002, // [3]
		81, 81, 0x400002, // [4]
		67, 72, 0x3003a, // [5]
		74, 79, 0x30034, // [6]
		81, 86, 0x30040, // [7]
		89, 90, 0x370039, // [8]
		93, 93, 0x370002, // [9]
		96, 96, 0x400002, // [10]
		90, 92, 0x30037, // [11]
		93, 95, 0x30037, // [12]
		96, 98, 0x30040, // [13]
		101, 102, 0x34003f, // [14]
		105, 105, 0x370002, // [15]
		108, 108, 0x400002, // [16]
		102, 104, 0x30034, // [17]
		105, 107, 0x30037, // [18]
		108, 110, 0x30040, // [19]
		113, 117, 0x20034, // [20]
		119, 123, 0x20032, // [21]
		130, 131, 0x190020, // [22]
		131, 133, 0x30019, // [23]
		136, 137, 0x4f0017, // [24]
		140, 149, 0x30002, // [25]
		137, 139, 0x3004f, // [26]
		152, 156, 0x10002f, // [27]
		159, 160, 0x100002, // [28]
		163, 167, 0x30002, // [29]
		156, 158, 0x30010, // [30]
		160, 162, 0x30010, // [31]
		170, 172, 0x20018, // [32]
		174, 176, 0x20021, // [33]
		178, 180, 0x20023, // [34]
		182, 184, 0x20023, // [35]
		186, 188, 0x20026, // [36]
	},
	NumStmt: [37]uint16{
		4, // 0
		2, // 1
		3, // 2
		1, // 3
		1, // 4
		4, // 5
		4, // 6
		4, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		3, // 20
		3, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		1, // 26
		4, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
	},
}
var _ = _cover_atomic_.LoadUint32
