//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/accesscontrol/access.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package accesscontrol; import _cover_atomic_ "sync/atomic"

import (
	"errors"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/crypto/tlsgen"
	"github.com/hyperledger/fabric/common/flogging"
	pb "github.com/hyperledger/fabric/protos/peer"
	"google.golang.org/grpc"
)

var logger = flogging.MustGetLogger("chaincode.accesscontrol")

// CertAndPrivKeyPair contains a certificate
// and its corresponding private key in base64 format
type CertAndPrivKeyPair struct {
	// Cert - an x509 certificate encoded in base64
	Cert string
	// Key  - a private key of the corresponding certificate
	Key string
}

type Authenticator struct {
	mapper *certMapper
}

func (auth *Authenticator) Wrap(srv pb.ChaincodeSupportServer) pb.ChaincodeSupportServer {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[0], 1);
	return newInterceptor(srv, auth.authenticate)
}

// NewAuthenticator returns a new authenticator that can wrap a chaincode service
func NewAuthenticator(ca tlsgen.CA) *Authenticator {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[1], 1);
	return &Authenticator{
		mapper: newCertMapper(ca.NewClientCertKeyPair),
	}
}

// Generate returns a pair of certificate and private key,
// and associates the hash of the certificate with the given
// chaincode name
func (ac *Authenticator) Generate(ccName string) (*CertAndPrivKeyPair, error) {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[2], 1);
	cert, err := ac.mapper.genCert(ccName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[4], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[3], 1);return &CertAndPrivKeyPair{
		Key:  cert.PrivKeyString(),
		Cert: cert.PubKeyString(),
	}, nil
}

func (ac *Authenticator) authenticate(msg *pb.ChaincodeMessage, stream grpc.ServerStream) error {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[5], 1);
	if msg.Type != pb.ChaincodeMessage_REGISTER {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[11], 1);
		logger.Warning("Got message", msg, "but expected a ChaincodeMessage_REGISTER message")
		return errors.New("First message needs to be a register")
	}

	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[6], 1);chaincodeID := &pb.ChaincodeID{}
	err := proto.Unmarshal(msg.Payload, chaincodeID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[12], 1);
		logger.Warning("Failed unmarshaling message:", err)
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[7], 1);ccName := chaincodeID.Name
	// Obtain certificate from stream
	hash := extractCertificateHashFromContext(stream.Context())
	if len(hash) == 0 {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[13], 1);
		errMsg := fmt.Sprintf("TLS is active but chaincode %s didn't send certificate", ccName)
		logger.Warning(errMsg)
		return errors.New(errMsg)
	}
	// Look it up in the mapper
	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[8], 1);registeredName := ac.mapper.lookup(certHash(hash))
	if registeredName == "" {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[14], 1);
		errMsg := fmt.Sprintf("Chaincode %s with given certificate hash %v not found in registry", ccName, hash)
		logger.Warning(errMsg)
		return errors.New(errMsg)
	}
	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[9], 1);if registeredName != ccName {_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[15], 1);
		errMsg := fmt.Sprintf("Chaincode %s with given certificate hash %v belongs to a different chaincode", ccName, hash)
		logger.Warning(errMsg)
		return fmt.Errorf(errMsg)
	}

	_cover_atomic_.AddUint32(&GoCover_0_373330356164386336643838.Count[10], 1);logger.Debug("Chaincode", ccName, "'s authentication is authorized")
	return nil
}

var GoCover_0_373330356164386336643838 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		35, 37, 0x2005a, // [0]
		40, 44, 0x20034, // [1]
		49, 51, 0x10004f, // [2]
		54, 57, 0x80002, // [3]
		51, 53, 0x30010, // [4]
		60, 61, 0x2e0061, // [5]
		66, 68, 0x100002, // [6]
		72, 75, 0x140002, // [7]
		81, 82, 0x1a0002, // [8]
		87, 87, 0x1e0002, // [9]
		93, 94, 0xc0002, // [10]
		61, 64, 0x3002e, // [11]
		68, 71, 0x30010, // [12]
		75, 79, 0x30014, // [13]
		82, 86, 0x3001a, // [14]
		87, 91, 0x3001e, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		1, // 1
		2, // 2
		1, // 3
		1, // 4
		1, // 5
		3, // 6
		3, // 7
		2, // 8
		1, // 9
		2, // 10
		2, // 11
		2, // 12
		3, // 13
		3, // 14
		3, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
