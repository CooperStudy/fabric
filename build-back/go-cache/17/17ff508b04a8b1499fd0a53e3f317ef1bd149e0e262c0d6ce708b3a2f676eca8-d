//line /home/cooper/go/src/github.com/hyperledger/fabric/orderer/common/server/main.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package server; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	_ "net/http/pprof" // This is essentially the main package for the orderer
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/crypto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/grpclogging"
	"github.com/hyperledger/fabric/common/grpcmetrics"
	"github.com/hyperledger/fabric/common/ledger/blockledger"
	"github.com/hyperledger/fabric/common/localmsp"
	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/metrics/disabled"
	"github.com/hyperledger/fabric/common/tools/configtxgen/encoder"
	genesisconfig "github.com/hyperledger/fabric/common/tools/configtxgen/localconfig"
	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/comm"
	"github.com/hyperledger/fabric/core/operations"
	"github.com/hyperledger/fabric/msp"
	mspmgmt "github.com/hyperledger/fabric/msp/mgmt"
	"github.com/hyperledger/fabric/orderer/common/bootstrap/file"
	"github.com/hyperledger/fabric/orderer/common/cluster"
	"github.com/hyperledger/fabric/orderer/common/localconfig"
	"github.com/hyperledger/fabric/orderer/common/metadata"
	"github.com/hyperledger/fabric/orderer/common/multichannel"
	"github.com/hyperledger/fabric/orderer/consensus"
	"github.com/hyperledger/fabric/orderer/consensus/etcdraft"
	"github.com/hyperledger/fabric/orderer/consensus/kafka"
	"github.com/hyperledger/fabric/orderer/consensus/solo"
	cb "github.com/hyperledger/fabric/protos/common"
	ab "github.com/hyperledger/fabric/protos/orderer"
	"github.com/hyperledger/fabric/protos/utils"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"gopkg.in/alecthomas/kingpin.v2"
)

var logger = flogging.MustGetLogger("orderer.common.server")

//command line flags
var (
	app = kingpin.New("orderer", "Hyperledger Fabric orderer node")

	start     = app.Command("start", "Start the orderer node").Default()
	version   = app.Command("version", "Show version information")
	benchmark = app.Command("benchmark", "Run orderer in benchmark mode")

	clusterTypes = map[string]struct{}{"etcdraft": {}}
)

// Main is the entry point of orderer process
func Main() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[0], 1);
	fullCmd := kingpin.MustParse(app.Parse(os.Args[1:]))

	// "version" command
	if fullCmd == version.FullCommand() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[3], 1);
		fmt.Println(metadata.GetVersionInfo())
		return
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[1], 1);conf, err := localconfig.Load()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[4], 1);
		logger.Error("failed to parse config: ", err)
		os.Exit(1)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[2], 1);initializeLogging()
	initializeLocalMsp(conf)

	prettyPrintStruct(conf)
	Start(fullCmd, conf)
}

// Start provides a layer of abstraction for benchmark test
func Start(cmd string, conf *localconfig.TopLevel) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[5], 1);
	bootstrapBlock := extractBootstrapBlock(conf)
	clusterType := isClusterType(bootstrapBlock)
	signer := localmsp.NewSigner()

	lf, _ := createLedgerFactory(conf)

	clusterDialer := &cluster.PredicateDialer{}
	clusterConfig := initializeClusterConfig(conf)
	clusterDialer.SetConfig(clusterConfig)

	// Only clusters that are equipped with a recent config block can replicate.
	if clusterType && conf.General.GenesisMethod == "file" {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[10], 1);
		r := &replicationInitiator{
			logger:         logger,
			secOpts:        clusterConfig.SecOpts,
			bootstrapBlock: bootstrapBlock,
			conf:           conf,
			lf:             &ledgerFactory{lf},
			signer:         signer,
		}
		r.replicateIfNeeded()
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[6], 1);opsSystem := newOperationsSystem(conf.Operations, conf.Metrics)
	err := opsSystem.Start()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[11], 1);
		logger.Panicf("failed to initialize operations subsystem: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[7], 1);defer opsSystem.Stop()
	metricsProvider := opsSystem.Provider

	serverConfig := initializeServerConfig(conf, metricsProvider)
	grpcServer := initializeGrpcServer(conf, serverConfig)
	caSupport := &comm.CASupport{
		AppRootCAsByChain:     make(map[string][][]byte),
		OrdererRootCAsByChain: make(map[string][][]byte),
		ClientRootCAs:         serverConfig.SecOpts.ClientRootCAs,
	}

	tlsCallback := func(bundle *channelconfig.Bundle) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[12], 1);
		// only need to do this if mutual TLS is required or if the orderer node is part of a cluster
		if grpcServer.MutualTLSRequired() || clusterType {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[13], 1);
			logger.Debug("Executing callback to update root CAs")
			updateTrustedRoots(grpcServer, caSupport, bundle)
			if clusterType {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[14], 1);
				updateClusterDialer(caSupport, clusterDialer, clusterConfig.SecOpts.ServerRootCAs)
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[8], 1);manager := initializeMultichannelRegistrar(bootstrapBlock, clusterDialer, serverConfig, grpcServer, conf, signer, metricsProvider, lf, tlsCallback)
	mutualTLS := serverConfig.SecOpts.UseTLS && serverConfig.SecOpts.RequireClientCert
	server := NewServer(manager, metricsProvider, &conf.Debug, conf.General.Authentication.TimeWindow, mutualTLS)

	logger.Infof("Starting %s", metadata.GetVersionInfo())
	go handleSignals(addPlatformSignals(map[os.Signal]func(){
		syscall.SIGTERM: func() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[15], 1); grpcServer.Stop() },
	}))
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[9], 1);initializeProfilingService(conf)
	ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)
	logger.Info("Beginning to serve requests")
	grpcServer.Start()
}

func initializeLogging() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[16], 1);
	loggingSpec := os.Getenv("FABRIC_LOGGING_SPEC")
	loggingFormat := os.Getenv("FABRIC_LOGGING_FORMAT")
	flogging.Init(flogging.Config{
		Format:  loggingFormat,
		Writer:  os.Stderr,
		LogSpec: loggingSpec,
	})
}

// Start the profiling service if enabled.
func initializeProfilingService(conf *localconfig.TopLevel) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[17], 1);
	if conf.General.Profile.Enabled {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[18], 1);
		go func() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[19], 1);
			logger.Info("Starting Go pprof profiling service on:", conf.General.Profile.Address)
			// The ListenAndServe() call does not return unless an error occurs.
			logger.Panic("Go pprof service failed:", http.ListenAndServe(conf.General.Profile.Address, nil))
		}()
	}
}

func handleSignals(handlers map[os.Signal]func()) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[20], 1);
	var signals []os.Signal
	for sig := range handlers {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[22], 1);
		signals = append(signals, sig)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[21], 1);signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, signals...)

	for sig := range signalChan {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[23], 1);
		logger.Infof("Received signal: %d (%s)", sig, sig)
		handlers[sig]()
	}
}

func initializeClusterConfig(conf *localconfig.TopLevel) comm.ClientConfig {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[24], 1);
	cc := comm.ClientConfig{
		AsyncConnect: true,
		KaOpts:       comm.DefaultKeepaliveOptions,
		Timeout:      conf.General.Cluster.DialTimeout,
		SecOpts:      &comm.SecureOptions{},
	}

	if (!conf.General.TLS.Enabled) || conf.General.Cluster.ClientCertificate == "" {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[29], 1);
		return cc
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[25], 1);certFile := conf.General.Cluster.ClientCertificate
	certBytes, err := ioutil.ReadFile(certFile)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[30], 1);
		logger.Fatalf("Failed to load client TLS certificate file '%s' (%s)", certFile, err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[26], 1);keyFile := conf.General.Cluster.ClientPrivateKey
	keyBytes, err := ioutil.ReadFile(keyFile)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[31], 1);
		logger.Fatalf("Failed to load client TLS key file '%s' (%s)", keyFile, err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[27], 1);var serverRootCAs [][]byte
	for _, serverRoot := range conf.General.Cluster.RootCAs {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[32], 1);
		rootCACert, err := ioutil.ReadFile(serverRoot)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[34], 1);
			logger.Fatalf("Failed to load ServerRootCAs file '%s' (%s)",
				err, serverRoot)
		}
		_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[33], 1);serverRootCAs = append(serverRootCAs, rootCACert)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[28], 1);cc.SecOpts = &comm.SecureOptions{
		RequireClientCert: true,
		CipherSuites:      comm.DefaultTLSCipherSuites,
		ServerRootCAs:     serverRootCAs,
		Certificate:       certBytes,
		Key:               keyBytes,
		UseTLS:            true,
	}

	return cc
}

func initializeServerConfig(conf *localconfig.TopLevel, metricsProvider metrics.Provider) comm.ServerConfig {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[35], 1);
	// secure server config
	secureOpts := &comm.SecureOptions{
		UseTLS:            conf.General.TLS.Enabled,
		RequireClientCert: conf.General.TLS.ClientAuthRequired,
	}
	// check to see if TLS is enabled
	if secureOpts.UseTLS {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[39], 1);
		msg := "TLS"
		// load crypto material from files
		serverCertificate, err := ioutil.ReadFile(conf.General.TLS.Certificate)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[44], 1);
			logger.Fatalf("Failed to load server Certificate file '%s' (%s)",
				conf.General.TLS.Certificate, err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[40], 1);serverKey, err := ioutil.ReadFile(conf.General.TLS.PrivateKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[45], 1);
			logger.Fatalf("Failed to load PrivateKey file '%s' (%s)",
				conf.General.TLS.PrivateKey, err)
		}
		_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[41], 1);var serverRootCAs, clientRootCAs [][]byte
		for _, serverRoot := range conf.General.TLS.RootCAs {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[46], 1);
			root, err := ioutil.ReadFile(serverRoot)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[48], 1);
				logger.Fatalf("Failed to load ServerRootCAs file '%s' (%s)",
					err, serverRoot)
			}
			_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[47], 1);serverRootCAs = append(serverRootCAs, root)
		}
		_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[42], 1);if secureOpts.RequireClientCert {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[49], 1);
			for _, clientRoot := range conf.General.TLS.ClientRootCAs {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[51], 1);
				root, err := ioutil.ReadFile(clientRoot)
				if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[53], 1);
					logger.Fatalf("Failed to load ClientRootCAs file '%s' (%s)",
						err, clientRoot)
				}
				_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[52], 1);clientRootCAs = append(clientRootCAs, root)
			}
			_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[50], 1);msg = "mutual TLS"
		}
		_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[43], 1);secureOpts.Key = serverKey
		secureOpts.Certificate = serverCertificate
		secureOpts.ClientRootCAs = clientRootCAs
		logger.Infof("Starting orderer with %s enabled", msg)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[36], 1);kaOpts := comm.DefaultKeepaliveOptions
	// keepalive settings
	// ServerMinInterval must be greater than 0
	if conf.General.Keepalive.ServerMinInterval > time.Duration(0) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[54], 1);
		kaOpts.ServerMinInterval = conf.General.Keepalive.ServerMinInterval
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[37], 1);kaOpts.ServerInterval = conf.General.Keepalive.ServerInterval
	kaOpts.ServerTimeout = conf.General.Keepalive.ServerTimeout

	commLogger := flogging.MustGetLogger("core.comm").With("server", "Orderer")
	if metricsProvider == nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[55], 1);
		metricsProvider = &disabled.Provider{}
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[38], 1);return comm.ServerConfig{
		SecOpts:         secureOpts,
		KaOpts:          kaOpts,
		Logger:          commLogger,
		MetricsProvider: metricsProvider,
		StreamInterceptors: []grpc.StreamServerInterceptor{
			grpcmetrics.StreamServerInterceptor(grpcmetrics.NewStreamMetrics(metricsProvider)),
			grpclogging.StreamServerInterceptor(flogging.MustGetLogger("comm.grpc.server").Zap()),
		},
		UnaryInterceptors: []grpc.UnaryServerInterceptor{
			grpcmetrics.UnaryServerInterceptor(grpcmetrics.NewUnaryMetrics(metricsProvider)),
			grpclogging.UnaryServerInterceptor(
				flogging.MustGetLogger("comm.grpc.server").Zap(),
				grpclogging.WithLeveler(grpclogging.LevelerFunc(grpcLeveler)),
			),
		},
	}
}

func grpcLeveler(ctx context.Context, fullMethod string) zapcore.Level {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[56], 1);
	switch fullMethod {
	case "/orderer.Cluster/Step":_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[57], 1);
		return flogging.DisabledLevel
	default:_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[58], 1);
		return zapcore.InfoLevel
	}
}

func extractBootstrapBlock(conf *localconfig.TopLevel) *cb.Block {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[59], 1);
	var bootstrapBlock *cb.Block

	// Select the bootstrapping mechanism
	switch conf.General.GenesisMethod {
	case "provisional":_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[61], 1);
		bootstrapBlock = encoder.New(genesisconfig.Load(conf.General.GenesisProfile)).GenesisBlockForChannel(conf.General.SystemChannel)
	case "file":_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[62], 1);
		bootstrapBlock = file.New(conf.General.GenesisFile).GenesisBlock()
	default:_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[63], 1);
		logger.Panic("Unknown genesis method:", conf.General.GenesisMethod)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[60], 1);return bootstrapBlock
}

func initializeBootstrapChannel(genesisBlock *cb.Block, lf blockledger.Factory) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[64], 1);
	chainID, err := utils.GetChainIDFromBlock(genesisBlock)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[67], 1);
		logger.Fatal("Failed to parse chain ID from genesis block:", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[65], 1);gl, err := lf.GetOrCreate(chainID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[68], 1);
		logger.Fatal("Failed to create the system chain:", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[66], 1);if err := gl.Append(genesisBlock); err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[69], 1);
		logger.Fatal("Could not write genesis block to ledger:", err)
	}
}

func isClusterType(_ *cb.Block) bool {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[70], 1);
	return false
}

func initializeGrpcServer(conf *localconfig.TopLevel, serverConfig comm.ServerConfig) *comm.GRPCServer {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[71], 1);
	lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", conf.General.ListenAddress, conf.General.ListenPort))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[74], 1);
		logger.Fatal("Failed to listen:", err)
	}

	// Create GRPC server - return if an error occurs
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[72], 1);grpcServer, err := comm.NewGRPCServerFromListener(lis, serverConfig)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[75], 1);
		logger.Fatal("Failed to return new GRPC server:", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[73], 1);return grpcServer
}

func initializeLocalMsp(conf *localconfig.TopLevel) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[76], 1);
	// Load local MSP
	err := mspmgmt.LoadLocalMsp(conf.General.LocalMSPDir, conf.General.BCCSP, conf.General.LocalMSPID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[77], 1); // Handle errors reading the config file
		logger.Fatal("Failed to initialize local MSP:", err)
	}
}

func initializeMultichannelRegistrar(bootstrapBlock *cb.Block,
	clusterDialer *cluster.PredicateDialer,
	srvConf comm.ServerConfig,
	srv *comm.GRPCServer,
	conf *localconfig.TopLevel,
	signer crypto.LocalSigner,
	metricsProvider metrics.Provider,
	lf blockledger.Factory,
	callbacks ...func(bundle *channelconfig.Bundle)) *multichannel.Registrar {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[78], 1);
	genesisBlock := extractBootstrapBlock(conf)
	// Are we bootstrapping?
	if len(lf.ChainIDs()) == 0 {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[81], 1);
		initializeBootstrapChannel(genesisBlock, lf)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[82], 1);{
		logger.Info("Not bootstrapping because of existing chains")
	}}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[79], 1);consenters := make(map[string]consensus.Consenter)

	registrar := multichannel.NewRegistrar(lf, signer, metricsProvider, callbacks...)

	consenters["solo"] = solo.New()
	var kafkaMetrics *kafka.Metrics
	consenters["kafka"], kafkaMetrics = kafka.New(conf.Kafka, metricsProvider)
	// Note, we pass a 'nil' channel here, we could pass a channel that
	// closes if we wished to cleanup this routine on exit.
	go kafkaMetrics.PollGoMetricsUntilStop(time.Minute, nil)
	if isClusterType(bootstrapBlock) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[83], 1);
		raftConsenter := etcdraft.New(clusterDialer, conf, srvConf, srv, registrar)
		consenters["etcdraft"] = raftConsenter
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[80], 1);registrar.Initialize(consenters)
	return registrar
}

func newOperationsSystem(ops localconfig.Operations, metrics localconfig.Metrics) *operations.System {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[84], 1);
	return operations.NewSystem(operations.Options{
		Logger:        flogging.MustGetLogger("orderer.operations"),
		ListenAddress: ops.ListenAddress,
		Metrics: operations.MetricsOptions{
			Provider: metrics.Provider,
			Statsd: &operations.Statsd{
				Network:       metrics.Statsd.Network,
				Address:       metrics.Statsd.Address,
				WriteInterval: metrics.Statsd.WriteInterval,
				Prefix:        metrics.Statsd.Prefix,
			},
		},
		TLS: operations.TLS{
			Enabled:            ops.TLS.Enabled,
			CertFile:           ops.TLS.Certificate,
			KeyFile:            ops.TLS.PrivateKey,
			ClientCertRequired: ops.TLS.ClientAuthRequired,
			ClientCACertFiles:  ops.TLS.ClientRootCAs,
		},
		Version: metadata.Version,
	})
}

func updateTrustedRoots(srv *comm.GRPCServer, rootCASupport *comm.CASupport,
	cm channelconfig.Resources) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[85], 1);
	rootCASupport.Lock()
	defer rootCASupport.Unlock()

	appRootCAs := [][]byte{}
	ordererRootCAs := [][]byte{}
	appOrgMSPs := make(map[string]struct{})
	ordOrgMSPs := make(map[string]struct{})

	if ac, ok := cm.ApplicationConfig(); ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[94], 1);
		//loop through app orgs and build map of MSPIDs
		for _, appOrg := range ac.Organizations() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[95], 1);
			appOrgMSPs[appOrg.MSPID()] = struct{}{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[86], 1);if ac, ok := cm.OrdererConfig(); ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[96], 1);
		//loop through orderer orgs and build map of MSPIDs
		for _, ordOrg := range ac.Organizations() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[97], 1);
			ordOrgMSPs[ordOrg.MSPID()] = struct{}{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[87], 1);if cc, ok := cm.ConsortiumsConfig(); ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[98], 1);
		for _, consortium := range cc.Consortiums() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[99], 1);
			//loop through consortium orgs and build map of MSPIDs
			for _, consortiumOrg := range consortium.Organizations() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[100], 1);
				appOrgMSPs[consortiumOrg.MSPID()] = struct{}{}
			}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[88], 1);cid := cm.ConfigtxValidator().ChainID()
	logger.Debugf("updating root CAs for channel [%s]", cid)
	msps, err := cm.MSPManager().GetMSPs()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[101], 1);
		logger.Errorf("Error getting root CAs for channel %s (%s)", cid, err)
		return
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[89], 1);for k, v := range msps {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[102], 1);
		// check to see if this is a FABRIC MSP
		if v.GetType() == msp.FABRIC {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[103], 1);
			for _, root := range v.GetTLSRootCerts() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[105], 1);
				// check to see of this is an app org MSP
				if _, ok := appOrgMSPs[k]; ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[107], 1);
					logger.Debugf("adding app root CAs for MSP [%s]", k)
					appRootCAs = append(appRootCAs, root)
				}
				// check to see of this is an orderer org MSP
				_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[106], 1);if _, ok := ordOrgMSPs[k]; ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[108], 1);
					logger.Debugf("adding orderer root CAs for MSP [%s]", k)
					ordererRootCAs = append(ordererRootCAs, root)
				}
			}
			_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[104], 1);for _, intermediate := range v.GetTLSIntermediateCerts() {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[109], 1);
				// check to see of this is an app org MSP
				if _, ok := appOrgMSPs[k]; ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[111], 1);
					logger.Debugf("adding app root CAs for MSP [%s]", k)
					appRootCAs = append(appRootCAs, intermediate)
				}
				// check to see of this is an orderer org MSP
				_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[110], 1);if _, ok := ordOrgMSPs[k]; ok {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[112], 1);
					logger.Debugf("adding orderer root CAs for MSP [%s]", k)
					ordererRootCAs = append(ordererRootCAs, intermediate)
				}
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[90], 1);rootCASupport.AppRootCAsByChain[cid] = appRootCAs
	rootCASupport.OrdererRootCAsByChain[cid] = ordererRootCAs

	// now iterate over all roots for all app and orderer chains
	trustedRoots := [][]byte{}
	for _, roots := range rootCASupport.AppRootCAsByChain {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[113], 1);
		trustedRoots = append(trustedRoots, roots...)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[91], 1);for _, roots := range rootCASupport.OrdererRootCAsByChain {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[114], 1);
		trustedRoots = append(trustedRoots, roots...)
	}
	// also need to append statically configured root certs
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[92], 1);if len(rootCASupport.ClientRootCAs) > 0 {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[115], 1);
		trustedRoots = append(trustedRoots, rootCASupport.ClientRootCAs...)
	}

	// now update the client roots for the gRPC server
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[93], 1);err = srv.SetClientRootCAs(trustedRoots)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[116], 1);
		msg := "Failed to update trusted roots for orderer from latest config " +
			"block.  This orderer may not be able to communicate " +
			"with members of channel %s (%s)"
		logger.Warningf(msg, cm.ConfigtxValidator().ChainID(), err)
	}
}

func updateClusterDialer(rootCASupport *comm.CASupport, clusterDialer *cluster.PredicateDialer, localClusterRootCAs [][]byte) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[117], 1);
	rootCASupport.Lock()
	defer rootCASupport.Unlock()

	// Iterate over all orderer root CAs for all chains and add them
	// to the root CAs
	var clusterRootCAs [][]byte
	for _, roots := range rootCASupport.OrdererRootCAsByChain {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[119], 1);
		clusterRootCAs = append(clusterRootCAs, roots...)
	}

	// Add the local root CAs too
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[118], 1);clusterRootCAs = append(clusterRootCAs, localClusterRootCAs...)
	// Update the cluster config with the new root CAs
	clusterConfig := clusterDialer.Config.Load().(comm.ClientConfig)
	clusterConfig.SecOpts.ServerRootCAs = clusterRootCAs
	clusterDialer.SetConfig(clusterConfig)
}

func prettyPrintStruct(i interface{}) {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[120], 1);
	params := util.Flatten(i)
	var buffer bytes.Buffer
	for i := range params {_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[122], 1);
		buffer.WriteString("\n\t")
		buffer.WriteString(params[i])
	}
	_cover_atomic_.AddUint32(&GoCover_0_333331623039636261656262.Count[121], 1);logger.Infof("Orderer config values:%s\n", buffer.String())
}

var GoCover_0_333331623039636261656262 = struct {
	Count     [123]uint32
	Pos       [3 * 123]uint32
	NumStmt   [123]uint16
} {
	Pos: [3 * 123]uint32{
		69, 73, 0x26000d, // [0]
		78, 79, 0x100002, // [1]
		83, 87, 0x160002, // [2]
		73, 76, 0x30026, // [3]
		79, 82, 0x30010, // [4]
		91, 103, 0x390034, // [5]
		115, 117, 0x100002, // [6]
		120, 131, 0x340002, // [7]
		142, 148, 0x1b0002, // [8]
		150, 153, 0x140002, // [9]
		103, 113, 0x30039, // [10]
		117, 119, 0x30010, // [11]
		131, 133, 0x340034, // [12]
		133, 136, 0x130034, // [13]
		136, 138, 0x50013, // [14]
		148, 148, 0x30001b, // [15]
		156, 164, 0x2001a, // [16]
		167, 168, 0x22003d, // [17]
		168, 169, 0xd0022, // [18]
		169, 173, 0x4000d, // [19]
		177, 179, 0x1c0033, // [20]
		183, 186, 0x1e0002, // [21]
		179, 181, 0x3001c, // [22]
		186, 189, 0x3001e, // [23]
		192, 200, 0x51004c, // [24]
		204, 206, 0x100002, // [25]
		210, 212, 0x100002, // [26]
		216, 217, 0x3a0002, // [27]
		226, 235, 0xb0002, // [28]
		200, 202, 0x30051, // [29]
		206, 208, 0x30010, // [30]
		212, 214, 0x30010, // [31]
		217, 219, 0x11003a, // [32]
		223, 223, 0x340003, // [33]
		219, 222, 0x40011, // [34]
		238, 245, 0x17006d, // [35]
		283, 286, 0x410002, // [36]
		289, 293, 0x1c0002, // [37]
		297, 313, 0x30002, // [38]
		245, 249, 0x110017, // [39]
		253, 254, 0x110003, // [40]
		258, 259, 0x370003, // [41]
		267, 267, 0x230003, // [42]
		278, 281, 0x380003, // [43]
		249, 252, 0x40011, // [44]
		254, 257, 0x40011, // [45]
		259, 261, 0x120037, // [46]
		265, 265, 0x2f0004, // [47]
		261, 264, 0x50012, // [48]
		267, 268, 0x3e0023, // [49]
		276, 276, 0x160004, // [50]
		268, 270, 0x13003e, // [51]
		274, 274, 0x300005, // [52]
		270, 273, 0x60013, // [53]
		286, 288, 0x30041, // [54]
		293, 295, 0x3001c, // [55]
		316, 317, 0x140048, // [56]
		318, 319, 0x20001f, // [57]
		320, 321, 0x1b000a, // [58]
		325, 329, 0x240042, // [59]
		338, 338, 0x170002, // [60]
		330, 331, 0x830015, // [61]
		332, 333, 0x45000e, // [62]
		334, 335, 0x46000a, // [63]
		341, 343, 0x100051, // [64]
		346, 347, 0x100002, // [65]
		351, 351, 0x300002, // [66]
		343, 345, 0x30010, // [67]
		347, 349, 0x30010, // [68]
		351, 353, 0x30030, // [69]
		356, 358, 0x20026, // [70]
		360, 362, 0x100068, // [71]
		367, 368, 0x100002, // [72]
		372, 372, 0x130002, // [73]
		362, 364, 0x30010, // [74]
		368, 370, 0x30010, // [75]
		375, 378, 0x100035, // [76]
		378, 380, 0x30010, // [77]
		391, 394, 0x1d004b, // [78]
		400, 410, 0x230002, // [79]
		414, 415, 0x120002, // [80]
		394, 396, 0x3001d, // [81]
		396, 398, 0x30008, // [82]
		410, 413, 0x30023, // [83]
		418, 440, 0x20066, // [84]
		443, 452, 0x2a001e, // [85]
		459, 459, 0x260002, // [86]
		466, 466, 0x2a0002, // [87]
		475, 478, 0x100002, // [88]
		482, 482, 0x190002, // [89]
		511, 516, 0x380002, // [90]
		519, 519, 0x3c0002, // [91]
		523, 523, 0x2a0002, // [92]
		528, 529, 0x100002, // [93]
		452, 454, 0x2d002a, // [94]
		454, 456, 0x4002d, // [95]
		459, 461, 0x2d0026, // [96]
		461, 463, 0x4002d, // [97]
		466, 467, 0x2f002a, // [98]
		467, 469, 0x3d002f, // [99]
		469, 471, 0x5003d, // [100]
		478, 481, 0x30010, // [101]
		482, 484, 0x200019, // [102]
		484, 485, 0x2d0020, // [103]
		497, 497, 0x3d0004, // [104]
		485, 487, 0x23002d, // [105]
		492, 492, 0x230005, // [106]
		487, 490, 0x60023, // [107]
		492, 495, 0x60023, // [108]
		497, 499, 0x23003d, // [109]
		504, 504, 0x230005, // [110]
		499, 502, 0x60023, // [111]
		504, 507, 0x60023, // [112]
		516, 518, 0x30038, // [113]
		519, 521, 0x3003c, // [114]
		523, 525, 0x3002a, // [115]
		529, 534, 0x30010, // [116]
		537, 544, 0x3c007f, // [117]
		549, 553, 0x280002, // [118]
		544, 546, 0x3003c, // [119]
		556, 559, 0x180027, // [120]
		563, 563, 0x3d0002, // [121]
		559, 562, 0x30018, // [122]
	},
	NumStmt: [123]uint16{
		2, // 0
		2, // 1
		4, // 2
		2, // 3
		2, // 4
		8, // 5
		3, // 6
		6, // 7
		5, // 8
		4, // 9
		2, // 10
		1, // 11
		1, // 12
		3, // 13
		1, // 14
		1, // 15
		3, // 16
		1, // 17
		1, // 18
		2, // 19
		2, // 20
		3, // 21
		1, // 22
		2, // 23
		2, // 24
		3, // 25
		3, // 26
		2, // 27
		2, // 28
		1, // 29
		1, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		2, // 35
		2, // 36
		4, // 37
		1, // 38
		3, // 39
		2, // 40
		2, // 41
		1, // 42
		4, // 43
		1, // 44
		1, // 45
		2, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		2, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		2, // 64
		2, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		2, // 71
		2, // 72
		1, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		2, // 78
		7, // 79
		2, // 80
		1, // 81
		1, // 82
		2, // 83
		1, // 84
		7, // 85
		1, // 86
		1, // 87
		4, // 88
		1, // 89
		4, // 90
		1, // 91
		1, // 92
		2, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		1, // 98
		1, // 99
		1, // 100
		2, // 101
		1, // 102
		1, // 103
		1, // 104
		1, // 105
		1, // 106
		2, // 107
		2, // 108
		1, // 109
		1, // 110
		2, // 111
		2, // 112
		1, // 113
		1, // 114
		1, // 115
		2, // 116
		4, // 117
		4, // 118
		1, // 119
		3, // 120
		1, // 121
		2, // 122
	},
}
var _ = _cover_atomic_.LoadUint32
