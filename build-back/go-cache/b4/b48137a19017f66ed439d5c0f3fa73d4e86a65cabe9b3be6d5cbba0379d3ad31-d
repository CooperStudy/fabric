//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/utils/blockutils.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package utils; import _cover_atomic_ "sync/atomic"

import (
	"github.com/golang/protobuf/proto"
	cb "github.com/hyperledger/fabric/protos/common"
	"github.com/pkg/errors"
)

// GetChainIDFromBlockBytes returns chain ID given byte array which represents
// the block
func GetChainIDFromBlockBytes(bytes []byte) (string, error) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[0], 1);
	block, err := GetBlockFromBlockBytes(bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[2], 1);
		return "", err
	}

	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[1], 1);return GetChainIDFromBlock(block)
}

// GetChainIDFromBlock returns chain ID in the block
func GetChainIDFromBlock(block *cb.Block) (string, error) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[3], 1);
	if block == nil || block.Data == nil || block.Data.Data == nil || len(block.Data.Data) == 0 {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[9], 1);
		return "", errors.Errorf("failed to retrieve channel id - block is empty")
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[4], 1);var err error
	envelope, err := GetEnvelopeFromBlock(block.Data.Data[0])
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[10], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[5], 1);payload, err := GetPayload(envelope)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[11], 1);
		return "", err
	}

	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[6], 1);if payload.Header == nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[12], 1);
		return "", errors.Errorf("failed to retrieve channel id - payload header is empty")
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[7], 1);chdr, err := UnmarshalChannelHeader(payload.Header.ChannelHeader)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[13], 1);
		return "", err
	}

	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[8], 1);return chdr.ChannelId, nil
}

// GetMetadataFromBlock retrieves metadata at the specified index.
func GetMetadataFromBlock(block *cb.Block, index cb.BlockMetadataIndex) (*cb.Metadata, error) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[14], 1);
	md := &cb.Metadata{}
	err := proto.Unmarshal(block.Metadata.Metadata[index], md)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[16], 1);
		return nil, errors.Wrapf(err, "error unmarshaling metadata from block at index [%s]", index)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[15], 1);return md, nil
}

// GetMetadataFromBlockOrPanic retrieves metadata at the specified index, or
// panics on error
func GetMetadataFromBlockOrPanic(block *cb.Block, index cb.BlockMetadataIndex) *cb.Metadata {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[17], 1);
	md, err := GetMetadataFromBlock(block, index)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[19], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[18], 1);return md
}

// GetLastConfigIndexFromBlock retrieves the index of the last config block as
// encoded in the block metadata
func GetLastConfigIndexFromBlock(block *cb.Block) (uint64, error) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[20], 1);
	md, err := GetMetadataFromBlock(block, cb.BlockMetadataIndex_LAST_CONFIG)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[23], 1);
		return 0, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[21], 1);lc := &cb.LastConfig{}
	err = proto.Unmarshal(md.Value, lc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[24], 1);
		return 0, errors.Wrap(err, "error unmarshaling LastConfig")
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[22], 1);return lc.Index, nil
}

// GetLastConfigIndexFromBlockOrPanic retrieves the index of the last config
// block as encoded in the block metadata, or panics on error
func GetLastConfigIndexFromBlockOrPanic(block *cb.Block) uint64 {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[25], 1);
	index, err := GetLastConfigIndexFromBlock(block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[27], 1);
		panic(err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[26], 1);return index
}

// GetBlockFromBlockBytes marshals the bytes into Block
func GetBlockFromBlockBytes(blockBytes []byte) (*cb.Block, error) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[28], 1);
	block := &cb.Block{}
	err := proto.Unmarshal(blockBytes, block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[30], 1);
		return block, errors.Wrap(err, "error unmarshaling block")
	}
	_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[29], 1);return block, nil
}

// CopyBlockMetadata copies metadata from one block into another
func CopyBlockMetadata(src *cb.Block, dst *cb.Block) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[31], 1);
	dst.Metadata = src.Metadata
	// Once copied initialize with rest of the
	// required metadata positions.
	InitBlockMetadata(dst)
}

// InitBlockMetadata copies metadata from one block into another
func InitBlockMetadata(block *cb.Block) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[32], 1);
	if block.Metadata == nil {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[33], 1);
		block.Metadata = &cb.BlockMetadata{Metadata: [][]byte{{}, {}, {}}}
	} else{ _cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[34], 1);if len(block.Metadata.Metadata) < int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER+1) {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[35], 1);
		for i := int(len(block.Metadata.Metadata)); i <= int(cb.BlockMetadataIndex_TRANSACTIONS_FILTER); i++ {_cover_atomic_.AddUint32(&GoCover_0_333834643165316261363934.Count[36], 1);
			block.Metadata.Metadata = append(block.Metadata.Metadata, []byte{})
		}
	}}
}

var GoCover_0_333834643165316261363934 = struct {
	Count     [37]uint32
	Pos       [3 * 37]uint32
	NumStmt   [37]uint16
} {
	Pos: [3 * 37]uint32{
		17, 19, 0x10003d, // [0]
		23, 23, 0x230002, // [1]
		19, 21, 0x30010, // [2]
		27, 28, 0x5e003b, // [3]
		31, 33, 0x100002, // [4]
		36, 37, 0x100002, // [5]
		41, 41, 0x1b0002, // [6]
		44, 45, 0x100002, // [7]
		49, 49, 0x1c0002, // [8]
		28, 30, 0x3005e, // [9]
		33, 35, 0x30010, // [10]
		37, 39, 0x30010, // [11]
		41, 43, 0x3001b, // [12]
		45, 47, 0x30010, // [13]
		53, 56, 0x10005f, // [14]
		59, 59, 0x100002, // [15]
		56, 58, 0x30010, // [16]
		64, 66, 0x10005d, // [17]
		69, 69, 0xb0002, // [18]
		66, 67, 0xd0010, // [19]
		74, 76, 0x100043, // [20]
		79, 81, 0x100002, // [21]
		84, 84, 0x160002, // [22]
		76, 78, 0x30010, // [23]
		81, 83, 0x30010, // [24]
		89, 91, 0x100041, // [25]
		94, 94, 0xe0002, // [26]
		91, 92, 0xd0010, // [27]
		98, 101, 0x100043, // [28]
		104, 104, 0x130002, // [29]
		101, 103, 0x30010, // [30]
		108, 113, 0x20036, // [31]
		116, 117, 0x1b0029, // [32]
		117, 119, 0x3001b, // [33]
		119, 119, 0x5c0008, // [34]
		119, 120, 0x68005c, // [35]
		120, 122, 0x40068, // [36]
	},
	NumStmt: [37]uint16{
		2, // 0
		1, // 1
		1, // 2
		1, // 3
		3, // 4
		2, // 5
		1, // 6
		2, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		3, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		2, // 20
		3, // 21
		1, // 22
		1, // 23
		1, // 24
		2, // 25
		1, // 26
		1, // 27
		3, // 28
		1, // 29
		1, // 30
		2, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
	},
}
var _ = _cover_atomic_.LoadUint32
