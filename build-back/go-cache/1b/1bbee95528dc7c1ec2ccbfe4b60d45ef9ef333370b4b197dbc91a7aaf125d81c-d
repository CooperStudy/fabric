//line /home/cooper/go/src/github.com/hyperledger/fabric/core/chaincode/shim/ext/entities/message.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package entities; import _cover_atomic_ "sync/atomic"

import (
	"encoding/json"

	"github.com/pkg/errors"
)

// SignedMessage is a simple struct that contains space
// for a payload and a signature over it, and convenience
// functions to sign, verify, marshal and unmarshal
type SignedMessage struct {
	// ID contains a description of the entity signing this message
	ID []byte `json:"id"`

	// Payload contains the message that is signed
	Payload []byte `json:"payload"`

	// Sig contains a signature over ID and Payload
	Sig []byte `json:"sig"`
}

// Sign signs the SignedMessage and stores the signature in the Sig field
func (m *SignedMessage) Sign(signer Signer) error {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[0], 1);
	if signer == nil {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[4], 1);
		return errors.New("nil signer")
	}

	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[1], 1);m.Sig = nil
	bytes, err := json.Marshal(m)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[5], 1);
		return errors.Wrap(err, "sign error: json.Marshal returned")
	}
	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[2], 1);sig, err := signer.Sign(bytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[6], 1);
		return errors.WithMessage(err, "sign error: signer.Sign returned")
	}
	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[3], 1);m.Sig = sig

	return nil
}

// Verify verifies the signature over Payload stored in Sig
func (m *SignedMessage) Verify(verifier Signer) (bool, error) {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[7], 1);
	if verifier == nil {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[11], 1);
		return false, errors.New("nil verifier")
	}

	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[8], 1);sig := m.Sig
	m.Sig = nil
	defer func() {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[12], 1);
		m.Sig = sig
	}()

	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[9], 1);bytes, err := json.Marshal(m)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[13], 1);
		return false, errors.Wrap(err, "sign error: json.Marshal returned")
	}

	_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[10], 1);return verifier.Verify(sig, bytes)
}

// ToBytes serializes the intance to bytes
func (m *SignedMessage) ToBytes() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[14], 1);
	return json.Marshal(m)
}

// FromBytes populates the instance from the supplied byte array
func (m *SignedMessage) FromBytes(d []byte) error {_cover_atomic_.AddUint32(&GoCover_2_336436626366316266366632.Count[15], 1);
	return json.Unmarshal(d, m)
}

var GoCover_2_336436626366316266366632 = struct {
	Count     [16]uint32
	Pos       [3 * 16]uint32
	NumStmt   [16]uint16
} {
	Pos: [3 * 16]uint32{
		30, 31, 0x130033, // [0]
		35, 37, 0x100002, // [1]
		40, 41, 0x100002, // [2]
		44, 46, 0xc0002, // [3]
		31, 33, 0x30013, // [4]
		37, 39, 0x30010, // [5]
		41, 43, 0x30010, // [6]
		50, 51, 0x15003f, // [7]
		55, 57, 0xf0002, // [8]
		61, 62, 0x100002, // [9]
		66, 66, 0x240002, // [10]
		51, 53, 0x30015, // [11]
		57, 59, 0x3000f, // [12]
		62, 64, 0x30010, // [13]
		70, 72, 0x20033, // [14]
		75, 77, 0x20033, // [15]
	},
	NumStmt: [16]uint16{
		1, // 0
		3, // 1
		2, // 2
		2, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		3, // 8
		2, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
	},
}
var _ = _cover_atomic_.LoadUint32
