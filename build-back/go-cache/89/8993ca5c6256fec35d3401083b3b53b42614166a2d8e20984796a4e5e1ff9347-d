//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/blockindex.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fsblkstorage; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/ledger/blkstorage"
	"github.com/hyperledger/fabric/common/ledger/util"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	ledgerUtil "github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/pkg/errors"
)

const (
	blockNumIdxKeyPrefix           = 'n'
	blockHashIdxKeyPrefix          = 'h'
	txIDIdxKeyPrefix               = 't'
	blockNumTranNumIdxKeyPrefix    = 'a'
	blockTxIDIdxKeyPrefix          = 'b'
	txValidationResultIdxKeyPrefix = 'v'
	indexCheckpointKeyStr          = "indexCheckpointKey"
)

var indexCheckpointKey = []byte(indexCheckpointKeyStr)
var errIndexEmpty = errors.New("NoBlockIndexed")

type index interface {
	getLastBlockIndexed() (uint64, error)
	indexBlock(blockIdxInfo *blockIdxInfo) error
	getBlockLocByHash(blockHash []byte) (*fileLocPointer, error)
	getBlockLocByBlockNum(blockNum uint64) (*fileLocPointer, error)
	getTxLoc(txID string) (*fileLocPointer, error)
	getTXLocByBlockNumTranNum(blockNum uint64, tranNum uint64) (*fileLocPointer, error)
	getBlockLocByTxID(txID string) (*fileLocPointer, error)
	getTxValidationCodeByTxID(txID string) (peer.TxValidationCode, error)
}

type blockIdxInfo struct {
	blockNum  uint64
	blockHash []byte
	flp       *fileLocPointer
	txOffsets []*txindexInfo
	metadata  *common.BlockMetadata
}

type blockIndex struct {
	indexItemsMap map[blkstorage.IndexableAttr]bool
	db            *leveldbhelper.DBHandle
}

func newBlockIndex(indexConfig *blkstorage.IndexConfig, db *leveldbhelper.DBHandle) (*blockIndex, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[0], 1);
	indexItems := indexConfig.AttrsToIndex
	logger.Debugf("newBlockIndex() - indexItems:[%s]", indexItems)
	indexItemsMap := make(map[blkstorage.IndexableAttr]bool)
	for _, indexItem := range indexItems {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[3], 1);
		indexItemsMap[indexItem] = true
	}
	// This dependency is needed because the index 'IndexableAttrTxID' is used for detecting the duplicate txid
	// and the results are reused in the other two indexes. Ideally, all three index should be merged into one
	// for efficiency purpose - [FAB-10587]
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[1], 1);if (indexItemsMap[blkstorage.IndexableAttrTxValidationCode] || indexItemsMap[blkstorage.IndexableAttrBlockTxID]) &&
		!indexItemsMap[blkstorage.IndexableAttrTxID] {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[4], 1);
		return nil, errors.Errorf("dependent index [%s] is not enabled for [%s] or [%s]",
			blkstorage.IndexableAttrTxID, blkstorage.IndexableAttrTxValidationCode, blkstorage.IndexableAttrBlockTxID)
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[2], 1);return &blockIndex{indexItemsMap, db}, nil
}

func (index *blockIndex) getLastBlockIndexed() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[5], 1);
	var blockNumBytes []byte
	var err error
	if blockNumBytes, err = index.db.Get(indexCheckpointKey); err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[8], 1);
		return 0, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[6], 1);if blockNumBytes == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[9], 1);
		return 0, errIndexEmpty
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[7], 1);return decodeBlockNum(blockNumBytes), nil
}

func (index *blockIndex) indexBlock(blockIdxInfo *blockIdxInfo) error {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[10], 1);
	// do not index anything
	if len(index.indexItemsMap) == 0 {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[20], 1);
		logger.Debug("Not indexing block... as nothing to index")
		return nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[11], 1);logger.Debugf("Indexing block [%s]", blockIdxInfo)
	flp := blockIdxInfo.flp
	txOffsets := blockIdxInfo.txOffsets
	txsfltr := ledgerUtil.TxValidationFlags(blockIdxInfo.metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])
	batch := leveldbhelper.NewUpdateBatch()
	flpBytes, err := flp.marshal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[21], 1);
		return err
	}

	//Index1
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[12], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockHash]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[22], 1);
		batch.Put(constructBlockHashKey(blockIdxInfo.blockHash), flpBytes)
	}

	//Index2
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[13], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockNum]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[23], 1);
		batch.Put(constructBlockNumKey(blockIdxInfo.blockNum), flpBytes)
	}

	//Index3 Used to find a transaction by it's transaction id
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[14], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrTxID]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[24], 1);
		if err = index.markDuplicateTxids(blockIdxInfo); err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[26], 1);
			logger.Errorf("error detecting duplicate txids: %s", err)
			return errors.WithMessage(err, "error detecting duplicate txids")
		}
		_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[25], 1);for _, txoffset := range txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[27], 1);
			if txoffset.isDuplicate {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[30], 1); // do not overwrite txid entry in the index - FAB-8557
				logger.Debugf("txid [%s] is a duplicate of a previous tx. Not indexing in txid-index", txoffset.txID)
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[28], 1);txFlp := newFileLocationPointer(flp.fileSuffixNum, flp.offset, txoffset.loc)
			logger.Debugf("Adding txLoc [%s] for tx ID: [%s] to txid-index", txFlp, txoffset.txID)
			txFlpBytes, marshalErr := txFlp.marshal()
			if marshalErr != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[31], 1);
				return marshalErr
			}
			_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[29], 1);batch.Put(constructTxIDKey(txoffset.txID), txFlpBytes)
		}
	}

	//Index4 - Store BlockNumTranNum will be used to query history data
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[15], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockNumTranNum]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[32], 1);
		for txIterator, txoffset := range txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[33], 1);
			txFlp := newFileLocationPointer(flp.fileSuffixNum, flp.offset, txoffset.loc)
			logger.Debugf("Adding txLoc [%s] for tx number:[%d] ID: [%s] to blockNumTranNum index", txFlp, txIterator, txoffset.txID)
			txFlpBytes, marshalErr := txFlp.marshal()
			if marshalErr != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[35], 1);
				return marshalErr
			}
			_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[34], 1);batch.Put(constructBlockNumTranNumKey(blockIdxInfo.blockNum, uint64(txIterator)), txFlpBytes)
		}
	}

	// Index5 - Store BlockNumber will be used to find block by transaction id
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[16], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockTxID]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[36], 1);
		for _, txoffset := range txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[37], 1);
			if txoffset.isDuplicate {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[39], 1); // do not overwrite txid entry in the index - FAB-8557
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[38], 1);batch.Put(constructBlockTxIDKey(txoffset.txID), flpBytes)
		}
	}

	// Index6 - Store transaction validation result by transaction id
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[17], 1);if _, ok := index.indexItemsMap[blkstorage.IndexableAttrTxValidationCode]; ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[40], 1);
		for idx, txoffset := range txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[41], 1);
			if txoffset.isDuplicate {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[43], 1); // do not overwrite txid entry in the index - FAB-8557
				continue
			}
			_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[42], 1);batch.Put(constructTxValidationCodeIDKey(txoffset.txID), []byte{byte(txsfltr.Flag(idx))})
		}
	}

	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[18], 1);batch.Put(indexCheckpointKey, encodeBlockNum(blockIdxInfo.blockNum))
	// Setting snyc to true as a precaution, false may be an ok optimization after further testing.
	if err := index.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[44], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[19], 1);return nil
}

func (index *blockIndex) markDuplicateTxids(blockIdxInfo *blockIdxInfo) error {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[45], 1);
	uniqueTxids := make(map[string]bool)
	for _, txIdxInfo := range blockIdxInfo.txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[47], 1);
		txid := txIdxInfo.txID
		if uniqueTxids[txid] {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[51], 1); // txid is duplicate of a previous tx in the block
			txIdxInfo.isDuplicate = true
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[48], 1);loc, err := index.getTxLoc(txid)
		if loc != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[52], 1); // txid is duplicate of a previous tx in the index
			txIdxInfo.isDuplicate = true
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[49], 1);if err != blkstorage.ErrNotFoundInIndex {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[53], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[50], 1);uniqueTxids[txid] = true
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[46], 1);return nil
}

func (index *blockIndex) getBlockLocByHash(blockHash []byte) (*fileLocPointer, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[54], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockHash]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[58], 1);
		return nil, blkstorage.ErrAttrNotIndexed
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[55], 1);b, err := index.db.Get(constructBlockHashKey(blockHash))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[59], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[56], 1);if b == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[60], 1);
		return nil, blkstorage.ErrNotFoundInIndex
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[57], 1);blkLoc := &fileLocPointer{}
	blkLoc.unmarshal(b)
	return blkLoc, nil
}

func (index *blockIndex) getBlockLocByBlockNum(blockNum uint64) (*fileLocPointer, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[61], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockNum]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[65], 1);
		return nil, blkstorage.ErrAttrNotIndexed
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[62], 1);b, err := index.db.Get(constructBlockNumKey(blockNum))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[66], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[63], 1);if b == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[67], 1);
		return nil, blkstorage.ErrNotFoundInIndex
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[64], 1);blkLoc := &fileLocPointer{}
	blkLoc.unmarshal(b)
	return blkLoc, nil
}

func (index *blockIndex) getTxLoc(txID string) (*fileLocPointer, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[68], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrTxID]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[72], 1);
		return nil, blkstorage.ErrAttrNotIndexed
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[69], 1);b, err := index.db.Get(constructTxIDKey(txID))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[73], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[70], 1);if b == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[74], 1);
		return nil, blkstorage.ErrNotFoundInIndex
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[71], 1);txFLP := &fileLocPointer{}
	txFLP.unmarshal(b)
	return txFLP, nil
}

func (index *blockIndex) getBlockLocByTxID(txID string) (*fileLocPointer, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[75], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockTxID]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[79], 1);
		return nil, blkstorage.ErrAttrNotIndexed
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[76], 1);b, err := index.db.Get(constructBlockTxIDKey(txID))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[80], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[77], 1);if b == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[81], 1);
		return nil, blkstorage.ErrNotFoundInIndex
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[78], 1);txFLP := &fileLocPointer{}
	txFLP.unmarshal(b)
	return txFLP, nil
}

func (index *blockIndex) getTXLocByBlockNumTranNum(blockNum uint64, tranNum uint64) (*fileLocPointer, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[82], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrBlockNumTranNum]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[86], 1);
		return nil, blkstorage.ErrAttrNotIndexed
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[83], 1);b, err := index.db.Get(constructBlockNumTranNumKey(blockNum, tranNum))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[87], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[84], 1);if b == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[88], 1);
		return nil, blkstorage.ErrNotFoundInIndex
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[85], 1);txFLP := &fileLocPointer{}
	txFLP.unmarshal(b)
	return txFLP, nil
}

func (index *blockIndex) getTxValidationCodeByTxID(txID string) (peer.TxValidationCode, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[89], 1);
	if _, ok := index.indexItemsMap[blkstorage.IndexableAttrTxValidationCode]; !ok {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[92], 1);
		return peer.TxValidationCode(-1), blkstorage.ErrAttrNotIndexed
	}

	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[90], 1);raw, err := index.db.Get(constructTxValidationCodeIDKey(txID))

	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[93], 1);
		return peer.TxValidationCode(-1), err
	} else{ _cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[94], 1);if raw == nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[95], 1);
		return peer.TxValidationCode(-1), blkstorage.ErrNotFoundInIndex
	} else{ _cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[96], 1);if len(raw) != 1 {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[97], 1);
		return peer.TxValidationCode(-1), errors.New("invalid value in indexItems")
	}}}

	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[91], 1);result := peer.TxValidationCode(int32(raw[0]))

	return result, nil
}

func constructBlockNumKey(blockNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[98], 1);
	blkNumBytes := util.EncodeOrderPreservingVarUint64(blockNum)
	return append([]byte{blockNumIdxKeyPrefix}, blkNumBytes...)
}

func constructBlockHashKey(blockHash []byte) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[99], 1);
	return append([]byte{blockHashIdxKeyPrefix}, blockHash...)
}

func constructTxIDKey(txID string) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[100], 1);
	return append([]byte{txIDIdxKeyPrefix}, []byte(txID)...)
}

func constructBlockTxIDKey(txID string) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[101], 1);
	return append([]byte{blockTxIDIdxKeyPrefix}, []byte(txID)...)
}

func constructTxValidationCodeIDKey(txID string) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[102], 1);
	return append([]byte{txValidationResultIdxKeyPrefix}, []byte(txID)...)
}

func constructBlockNumTranNumKey(blockNum uint64, txNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[103], 1);
	blkNumBytes := util.EncodeOrderPreservingVarUint64(blockNum)
	tranNumBytes := util.EncodeOrderPreservingVarUint64(txNum)
	key := append(blkNumBytes, tranNumBytes...)
	return append([]byte{blockNumTranNumIdxKeyPrefix}, key...)
}

func encodeBlockNum(blockNum uint64) []byte {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[104], 1);
	return proto.EncodeVarint(blockNum)
}

func decodeBlockNum(blockNumBytes []byte) uint64 {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[105], 1);
	blockNum, _ := proto.DecodeVarint(blockNumBytes)
	return blockNum
}

type locPointer struct {
	offset      int
	bytesLength int
}

func (lp *locPointer) String() string {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[106], 1);
	return fmt.Sprintf("offset=%d, bytesLength=%d",
		lp.offset, lp.bytesLength)
}

// fileLocPointer
type fileLocPointer struct {
	fileSuffixNum int
	locPointer
}

func newFileLocationPointer(fileSuffixNum int, beginningOffset int, relativeLP *locPointer) *fileLocPointer {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[107], 1);
	flp := &fileLocPointer{fileSuffixNum: fileSuffixNum}
	flp.offset = beginningOffset + relativeLP.offset
	flp.bytesLength = relativeLP.bytesLength
	return flp
}

func (flp *fileLocPointer) marshal() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[108], 1);
	buffer := proto.NewBuffer([]byte{})
	e := buffer.EncodeVarint(uint64(flp.fileSuffixNum))
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[112], 1);
		return nil, e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[109], 1);e = buffer.EncodeVarint(uint64(flp.offset))
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[113], 1);
		return nil, e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[110], 1);e = buffer.EncodeVarint(uint64(flp.bytesLength))
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[114], 1);
		return nil, e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[111], 1);return buffer.Bytes(), nil
}

func (flp *fileLocPointer) unmarshal(b []byte) error {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[115], 1);
	buffer := proto.NewBuffer(b)
	i, e := buffer.DecodeVarint()
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[119], 1);
		return e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[116], 1);flp.fileSuffixNum = int(i)

	i, e = buffer.DecodeVarint()
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[120], 1);
		return e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[117], 1);flp.offset = int(i)
	i, e = buffer.DecodeVarint()
	if e != nil {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[121], 1);
		return e
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[118], 1);flp.bytesLength = int(i)
	return nil
}

func (flp *fileLocPointer) String() string {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[122], 1);
	return fmt.Sprintf("fileSuffixNum=%d, %s", flp.fileSuffixNum, flp.locPointer.String())
}

func (blockIdxInfo *blockIdxInfo) String() string {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[123], 1);

	var buffer bytes.Buffer
	for _, txOffset := range blockIdxInfo.txOffsets {_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[125], 1);
		buffer.WriteString("txId=")
		buffer.WriteString(txOffset.txID)
		buffer.WriteString(" locPointer=")
		buffer.WriteString(txOffset.loc.String())
		buffer.WriteString("\n")
	}
	_cover_atomic_.AddUint32(&GoCover_5_386431356532613230373239.Count[124], 1);txOffsetsString := buffer.String()

	return fmt.Sprintf("blockNum=%d, blockHash=%#v txOffsets=\n%s", blockIdxInfo.blockNum, blockIdxInfo.blockHash, txOffsetsString)
}

var GoCover_5_386431356532613230373239 = struct {
	Count     [126]uint32
	Pos       [3 * 126]uint32
	NumStmt   [126]uint16
} {
	Pos: [3 * 126]uint32{
		60, 64, 0x27006a, // [0]
		70, 71, 0x300002, // [1]
		75, 75, 0x2c0002, // [2]
		64, 66, 0x30027, // [3]
		71, 74, 0x30030, // [4]
		78, 81, 0x470040, // [5]
		84, 84, 0x1a0002, // [6]
		87, 87, 0x2b0002, // [7]
		81, 83, 0x30047, // [8]
		84, 86, 0x3001a, // [9]
		90, 92, 0x230047, // [10]
		96, 102, 0x100002, // [11]
		107, 107, 0x490002, // [12]
		112, 112, 0x480002, // [13]
		117, 117, 0x440002, // [14]
		138, 138, 0x4f0002, // [15]
		151, 151, 0x490002, // [16]
		161, 161, 0x500002, // [17]
		170, 172, 0x390002, // [18]
		175, 175, 0xc0002, // [19]
		92, 95, 0x30023, // [20]
		102, 104, 0x30010, // [21]
		107, 109, 0x30049, // [22]
		112, 114, 0x30048, // [23]
		117, 118, 0x3f0044, // [24]
		122, 122, 0x260003, // [25]
		118, 121, 0x4003f, // [26]
		122, 123, 0x1c0026, // [27]
		127, 130, 0x190004, // [28]
		133, 133, 0x3a0004, // [29]
		123, 125, 0xd001c, // [30]
		130, 132, 0x50019, // [31]
		138, 139, 0x2f004f, // [32]
		139, 143, 0x19002f, // [33]
		146, 146, 0x610004, // [34]
		143, 145, 0x50019, // [35]
		151, 152, 0x260049, // [36]
		152, 153, 0x1c0026, // [37]
		156, 156, 0x3d0004, // [38]
		153, 154, 0xd001c, // [39]
		161, 162, 0x280050, // [40]
		162, 163, 0x1c0028, // [41]
		166, 166, 0x5d0004, // [42]
		163, 164, 0xd001c, // [43]
		172, 174, 0x30039, // [44]
		178, 180, 0x33004f, // [45]
		197, 197, 0xc0002, // [46]
		180, 182, 0x180033, // [47]
		187, 188, 0x110003, // [48]
		192, 192, 0x2b0003, // [49]
		195, 195, 0x1b0003, // [50]
		182, 184, 0xc0018, // [51]
		188, 190, 0xc0011, // [52]
		192, 194, 0x4002b, // [53]
		200, 201, 0x4a0057, // [54]
		204, 205, 0x100002, // [55]
		208, 208, 0xe0002, // [56]
		211, 213, 0x140002, // [57]
		201, 203, 0x3004a, // [58]
		205, 207, 0x30010, // [59]
		208, 210, 0x3000e, // [60]
		216, 217, 0x49005a, // [61]
		220, 221, 0x100002, // [62]
		224, 224, 0xe0002, // [63]
		227, 229, 0x140002, // [64]
		217, 219, 0x30049, // [65]
		221, 223, 0x30010, // [66]
		224, 226, 0x3000e, // [67]
		232, 233, 0x450049, // [68]
		236, 237, 0x100002, // [69]
		240, 240, 0xe0002, // [70]
		243, 245, 0x130002, // [71]
		233, 235, 0x30045, // [72]
		237, 239, 0x30010, // [73]
		240, 242, 0x3000e, // [74]
		248, 249, 0x4a0052, // [75]
		252, 253, 0x100002, // [76]
		256, 256, 0xe0002, // [77]
		259, 261, 0x130002, // [78]
		249, 251, 0x3004a, // [79]
		253, 255, 0x30010, // [80]
		256, 258, 0x3000e, // [81]
		264, 265, 0x50006e, // [82]
		268, 269, 0x100002, // [83]
		272, 272, 0xe0002, // [84]
		275, 277, 0x130002, // [85]
		265, 267, 0x30050, // [86]
		269, 271, 0x30010, // [87]
		272, 274, 0x3000e, // [88]
		280, 281, 0x510060, // [89]
		285, 287, 0x100002, // [90]
		295, 297, 0x140002, // [91]
		281, 283, 0x30051, // [92]
		287, 289, 0x30010, // [93]
		289, 289, 0x170008, // [94]
		289, 291, 0x30017, // [95]
		291, 291, 0x1a0008, // [96]
		291, 293, 0x3001a, // [97]
		300, 303, 0x20033, // [98]
		305, 307, 0x20035, // [99]
		309, 311, 0x2002b, // [100]
		313, 315, 0x20030, // [101]
		317, 319, 0x20039, // [102]
		321, 326, 0x20048, // [103]
		328, 330, 0x2002d, // [104]
		332, 335, 0x20032, // [105]
		342, 345, 0x20027, // [106]
		353, 358, 0x2006d, // [107]
		360, 363, 0xe0036, // [108]
		366, 367, 0xe0002, // [109]
		370, 371, 0xe0002, // [110]
		374, 374, 0x1c0002, // [111]
		363, 365, 0x3000e, // [112]
		367, 369, 0x3000e, // [113]
		371, 373, 0x3000e, // [114]
		377, 380, 0xe0036, // [115]
		383, 386, 0xe0002, // [116]
		389, 391, 0xe0002, // [117]
		394, 395, 0xc0002, // [118]
		380, 382, 0x3000e, // [119]
		386, 388, 0x3000e, // [120]
		391, 393, 0x3000e, // [121]
		398, 400, 0x2002c, // [122]
		402, 405, 0x320033, // [123]
		412, 414, 0x810002, // [124]
		405, 411, 0x30032, // [125]
	},
	NumStmt: [126]uint16{
		4, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		3, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		7, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		2, // 18
		1, // 19
		2, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		1, // 27
		4, // 28
		1, // 29
		2, // 30
		1, // 31
		1, // 32
		4, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		2, // 45
		1, // 46
		2, // 47
		2, // 48
		1, // 49
		1, // 50
		2, // 51
		2, // 52
		1, // 53
		1, // 54
		2, // 55
		1, // 56
		3, // 57
		1, // 58
		1, // 59
		1, // 60
		1, // 61
		2, // 62
		1, // 63
		3, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		2, // 69
		1, // 70
		3, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		2, // 76
		1, // 77
		3, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		2, // 83
		1, // 84
		3, // 85
		1, // 86
		1, // 87
		1, // 88
		1, // 89
		2, // 90
		2, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		1, // 97
		2, // 98
		1, // 99
		1, // 100
		1, // 101
		1, // 102
		4, // 103
		1, // 104
		2, // 105
		1, // 106
		4, // 107
		3, // 108
		2, // 109
		2, // 110
		1, // 111
		1, // 112
		1, // 113
		1, // 114
		3, // 115
		3, // 116
		3, // 117
		2, // 118
		1, // 119
		1, // 120
		1, // 121
		1, // 122
		2, // 123
		2, // 124
		5, // 125
	},
}
var _ = _cover_atomic_.LoadUint32
