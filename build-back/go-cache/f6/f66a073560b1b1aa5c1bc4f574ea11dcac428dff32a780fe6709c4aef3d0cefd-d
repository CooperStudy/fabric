//line /home/cooper/go/src/github.com/hyperledger/fabric/common/tools/configtxgen/main.go:1
/*
Copyright IBM Corp. 2017 All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package main; import _cover_atomic_ "sync/atomic"

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/hyperledger/fabric/bccsp/factory"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/tools/configtxgen/encoder"
	genesisconfig "github.com/hyperledger/fabric/common/tools/configtxgen/localconfig"
	"github.com/hyperledger/fabric/common/tools/configtxgen/metadata"
	"github.com/hyperledger/fabric/common/tools/protolator"
	cb "github.com/hyperledger/fabric/protos/common"
	pb "github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var exitCode = 0

var logger = flogging.MustGetLogger("common.tools.configtxgen")

func doOutputBlock(config *genesisconfig.Profile, channelID string, outputBlock string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[0], 1);
	pgen := encoder.New(config)
	logger.Info("Generating genesis block")
	if config.Consortiums == nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[3], 1);
		logger.Warning("Genesis block does not contain a consortiums group definition.  This block cannot be used for orderer bootstrap.")
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[1], 1);genesisBlock := pgen.GenesisBlockForChannel(channelID)
	logger.Info("Writing genesis block")
	err := ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[4], 1);
		return fmt.Errorf("Error writing genesis block: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[2], 1);return nil
}

func doOutputChannelCreateTx(conf *genesisconfig.Profile, channelID string, outputChannelCreateTx string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[5], 1);
	logger.Info("Generating new channel configtx")

	configtx, err := encoder.MakeChannelCreationTransaction(channelID, nil, conf)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[8], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[6], 1);logger.Info("Writing new channel tx")
	err = ioutil.WriteFile(outputChannelCreateTx, utils.MarshalOrPanic(configtx), 0644)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[9], 1);
		return fmt.Errorf("Error writing channel create tx: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[7], 1);return nil
}

func doOutputAnchorPeersUpdate(conf *genesisconfig.Profile, channelID string, outputAnchorPeersUpdate string, asOrg string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[10], 1);
	logger.Info("Generating anchor peer update")
	if asOrg == "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[17], 1);
		return fmt.Errorf("Must specify an organization to update the anchor peer for")
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[11], 1);if conf.Application == nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[18], 1);
		return fmt.Errorf("Cannot update anchor peers without an application section")
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[12], 1);var org *genesisconfig.Organization
	for _, iorg := range conf.Application.Organizations {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[19], 1);
		if iorg.Name == asOrg {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[20], 1);
			org = iorg
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[13], 1);if org == nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[21], 1);
		return fmt.Errorf("No organization name matching: %s", asOrg)
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[14], 1);anchorPeers := make([]*pb.AnchorPeer, len(org.AnchorPeers))
	for i, anchorPeer := range org.AnchorPeers {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[22], 1);
		anchorPeers[i] = &pb.AnchorPeer{
			Host: anchorPeer.Host,
			Port: int32(anchorPeer.Port),
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[15], 1);configUpdate := &cb.ConfigUpdate{
		ChannelId: channelID,
		WriteSet:  cb.NewConfigGroup(),
		ReadSet:   cb.NewConfigGroup(),
	}

	// Add all the existing config to the readset
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey] = cb.NewConfigGroup()
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Version = 1
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].ModPolicy = channelconfig.AdminsPolicyKey
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name] = cb.NewConfigGroup()
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Values[channelconfig.MSPKey] = &cb.ConfigValue{}
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.ReadersPolicyKey] = &cb.ConfigPolicy{}
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.WritersPolicyKey] = &cb.ConfigPolicy{}
	configUpdate.ReadSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.AdminsPolicyKey] = &cb.ConfigPolicy{}

	// Add all the existing at the same versions to the writeset
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey] = cb.NewConfigGroup()
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Version = 1
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].ModPolicy = channelconfig.AdminsPolicyKey
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name] = cb.NewConfigGroup()
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Version = 1
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].ModPolicy = channelconfig.AdminsPolicyKey
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Values[channelconfig.MSPKey] = &cb.ConfigValue{}
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.ReadersPolicyKey] = &cb.ConfigPolicy{}
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.WritersPolicyKey] = &cb.ConfigPolicy{}
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Policies[channelconfig.AdminsPolicyKey] = &cb.ConfigPolicy{}
	configUpdate.WriteSet.Groups[channelconfig.ApplicationGroupKey].Groups[org.Name].Values[channelconfig.AnchorPeersKey] = &cb.ConfigValue{
		Value:     utils.MarshalOrPanic(channelconfig.AnchorPeersValue(anchorPeers).Value()),
		ModPolicy: channelconfig.AdminsPolicyKey,
	}

	configUpdateEnvelope := &cb.ConfigUpdateEnvelope{
		ConfigUpdate: utils.MarshalOrPanic(configUpdate),
	}

	update := &cb.Envelope{
		Payload: utils.MarshalOrPanic(&cb.Payload{
			Header: &cb.Header{
				ChannelHeader: utils.MarshalOrPanic(&cb.ChannelHeader{
					ChannelId: channelID,
					Type:      int32(cb.HeaderType_CONFIG_UPDATE),
				}),
			},
			Data: utils.MarshalOrPanic(configUpdateEnvelope),
		}),
	}

	logger.Info("Writing anchor peer update")
	err := ioutil.WriteFile(outputAnchorPeersUpdate, utils.MarshalOrPanic(update), 0644)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[23], 1);
		return fmt.Errorf("Error writing channel anchor peer update: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[16], 1);return nil
}

func doInspectBlock(inspectBlock string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[24], 1);
	logger.Info("Inspecting block")
	data, err := ioutil.ReadFile(inspectBlock)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[28], 1);
		return fmt.Errorf("Could not read block %s", inspectBlock)
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[25], 1);logger.Info("Parsing genesis block")
	block, err := utils.UnmarshalBlock(data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[29], 1);
		return fmt.Errorf("error unmarshaling to block: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[26], 1);err = protolator.DeepMarshalJSON(os.Stdout, block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[30], 1);
		return fmt.Errorf("malformed block contents: %s", err)
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[27], 1);return nil
}

func doInspectChannelCreateTx(inspectChannelCreateTx string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[31], 1);
	logger.Info("Inspecting transaction")
	data, err := ioutil.ReadFile(inspectChannelCreateTx)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[35], 1);
		return fmt.Errorf("could not read channel create tx: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[32], 1);logger.Info("Parsing transaction")
	env, err := utils.UnmarshalEnvelope(data)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[36], 1);
		return fmt.Errorf("Error unmarshaling envelope: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[33], 1);err = protolator.DeepMarshalJSON(os.Stdout, env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[37], 1);
		return fmt.Errorf("malformed transaction contents: %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[34], 1);return nil
}

func doPrintOrg(t *genesisconfig.TopLevel, printOrg string) error {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[38], 1);
	for _, org := range t.Organizations {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[40], 1);
		if org.Name == printOrg {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[41], 1);
			og, err := encoder.NewOrdererOrgGroup(org)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[44], 1);
				return errors.Wrapf(err, "bad org definition for org %s", org.Name)
			}

			_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[42], 1);if err := protolator.DeepMarshalJSON(os.Stdout, &cb.DynamicConsortiumOrgGroup{ConfigGroup: og}); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[45], 1);
				return errors.Wrapf(err, "malformed org definition for org: %s", org.Name)
			}
			_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[43], 1);return nil
		}
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[39], 1);return errors.Errorf("organization %s not found", printOrg)
}

func main() {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[46], 1);
	var outputBlock, outputChannelCreateTx, profile, configPath, channelID, inspectBlock, inspectChannelCreateTx, outputAnchorPeersUpdate, asOrg, printOrg string

	flag.StringVar(&outputBlock, "outputBlock", "", "The path to write the genesis block to (if set)")
	flag.StringVar(&channelID, "channelID", "", "The channel ID to use in the configtx")
	flag.StringVar(&outputChannelCreateTx, "outputCreateChannelTx", "", "The path to write a channel creation configtx to (if set)")
	flag.StringVar(&profile, "profile", genesisconfig.SampleInsecureSoloProfile, "The profile from configtx.yaml to use for generation.")
	flag.StringVar(&configPath, "configPath", "", "The path containing the configuration to use (if set)")
	flag.StringVar(&inspectBlock, "inspectBlock", "", "Prints the configuration contained in the block at the specified path")
	flag.StringVar(&inspectChannelCreateTx, "inspectChannelCreateTx", "", "Prints the configuration contained in the transaction at the specified path")
	flag.StringVar(&outputAnchorPeersUpdate, "outputAnchorPeersUpdate", "", "Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)")
	flag.StringVar(&asOrg, "asOrg", "", "Performs the config generation as a particular organization (by name), only including values in the write set that org (likely) has privilege to set")
	flag.StringVar(&printOrg, "printOrg", "", "Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)")

	version := flag.Bool("version", false, "Show version information")

	flag.Parse()

	if channelID == "" && (outputBlock != "" || outputChannelCreateTx != "" || outputAnchorPeersUpdate != "") {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[57], 1);
		channelID = genesisconfig.TestChainID
		logger.Warningf("Omitting the channel ID for configtxgen for output operations is deprecated.  Explicitly passing the channel ID will be required in the future, defaulting to '%s'.", channelID)
	}

	// show version
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[47], 1);if *version {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[58], 1);
		printVersion()
		os.Exit(exitCode)
	}

	// don't need to panic when running via command line
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[48], 1);defer func() {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[59], 1);
		if err := recover(); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[60], 1);
			if strings.Contains(fmt.Sprint(err), "Error reading configuration: Unsupported Config Type") {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[63], 1);
				logger.Error("Could not find configtx.yaml. " +
					"Please make sure that FABRIC_CFG_PATH or -configPath is set to a path " +
					"which contains configtx.yaml")
				os.Exit(1)
			}
			_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[61], 1);if strings.Contains(fmt.Sprint(err), "Could not find profile") {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[64], 1);
				logger.Error(fmt.Sprint(err) + ". " +
					"Please make sure that FABRIC_CFG_PATH or -configPath is set to a path " +
					"which contains configtx.yaml with the specified profile")
				os.Exit(1)
			}
			_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[62], 1);logger.Panic(err)
		}
	}()

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[49], 1);logger.Info("Loading configuration")
	factory.InitFactories(nil)
	var profileConfig *genesisconfig.Profile
	if outputBlock != "" || outputChannelCreateTx != "" || outputAnchorPeersUpdate != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[65], 1);
		if configPath != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[66], 1);
			profileConfig = genesisconfig.Load(profile, configPath)
		} else{ _cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[67], 1);{
			profileConfig = genesisconfig.Load(profile)
		}}
	}
	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[50], 1);var topLevelConfig *genesisconfig.TopLevel
	if configPath != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[68], 1);
		topLevelConfig = genesisconfig.LoadTopLevel(configPath)
	} else{ _cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[69], 1);{
		topLevelConfig = genesisconfig.LoadTopLevel()
	}}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[51], 1);if outputBlock != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[70], 1);
		if err := doOutputBlock(profileConfig, channelID, outputBlock); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[71], 1);
			logger.Fatalf("Error on outputBlock: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[52], 1);if outputChannelCreateTx != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[72], 1);
		if err := doOutputChannelCreateTx(profileConfig, channelID, outputChannelCreateTx); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[73], 1);
			logger.Fatalf("Error on outputChannelCreateTx: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[53], 1);if inspectBlock != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[74], 1);
		if err := doInspectBlock(inspectBlock); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[75], 1);
			logger.Fatalf("Error on inspectBlock: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[54], 1);if inspectChannelCreateTx != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[76], 1);
		if err := doInspectChannelCreateTx(inspectChannelCreateTx); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[77], 1);
			logger.Fatalf("Error on inspectChannelCreateTx: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[55], 1);if outputAnchorPeersUpdate != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[78], 1);
		if err := doOutputAnchorPeersUpdate(profileConfig, channelID, outputAnchorPeersUpdate, asOrg); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[79], 1);
			logger.Fatalf("Error on inspectChannelCreateTx: %s", err)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[56], 1);if printOrg != "" {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[80], 1);
		if err := doPrintOrg(topLevelConfig, printOrg); err != nil {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[81], 1);
			logger.Fatalf("Error on printOrg: %s", err)
		}
	}
}

func printVersion() {_cover_atomic_.AddUint32(&GoCover_0_363335626333333461636631.Count[82], 1);
	fmt.Println(metadata.GetVersionInfo())
}

var GoCover_0_363335626333333461636631 = struct {
	Count     [83]uint32
	Pos       [3 * 83]uint32
	NumStmt   [83]uint16
} {
	Pos: [3 * 83]uint32{
		33, 36, 0x1f005f, // [0]
		39, 42, 0x100002, // [1]
		45, 45, 0xc0002, // [2]
		36, 38, 0x3001f, // [3]
		42, 44, 0x30010, // [4]
		48, 52, 0x100071, // [5]
		56, 58, 0x100002, // [6]
		61, 61, 0xc0002, // [7]
		52, 54, 0x30010, // [8]
		58, 60, 0x30010, // [9]
		64, 66, 0x110083, // [10]
		70, 70, 0x1d0002, // [11]
		74, 75, 0x360002, // [12]
		81, 81, 0x100002, // [13]
		85, 86, 0x2d0002, // [14]
		93, 143, 0x100002, // [15]
		146, 146, 0xc0002, // [16]
		66, 68, 0x30011, // [17]
		70, 72, 0x3001d, // [18]
		75, 76, 0x190036, // [19]
		76, 78, 0x40019, // [20]
		81, 83, 0x30010, // [21]
		86, 91, 0x3002d, // [22]
		143, 145, 0x30010, // [23]
		149, 152, 0x100030, // [24]
		156, 158, 0x100002, // [25]
		161, 162, 0x100002, // [26]
		165, 165, 0xc0002, // [27]
		152, 154, 0x30010, // [28]
		158, 160, 0x30010, // [29]
		162, 164, 0x30010, // [30]
		168, 171, 0x100044, // [31]
		175, 177, 0x100002, // [32]
		181, 182, 0x100002, // [33]
		186, 186, 0xc0002, // [34]
		171, 173, 0x30010, // [35]
		177, 179, 0x30010, // [36]
		182, 184, 0x30010, // [37]
		189, 190, 0x260043, // [38]
		203, 203, 0x3d0002, // [39]
		190, 191, 0x1b0026, // [40]
		191, 193, 0x12001b, // [41]
		197, 197, 0x700004, // [42]
		200, 200, 0xe0004, // [43]
		193, 195, 0x50012, // [44]
		197, 199, 0x50070, // [45]
		206, 224, 0x6c000d, // [46]
		230, 230, 0xe0002, // [47]
		236, 236, 0xf0002, // [48]
		254, 257, 0x570002, // [49]
		264, 265, 0x160002, // [50]
		271, 271, 0x170002, // [51]
		277, 277, 0x210002, // [52]
		283, 283, 0x180002, // [53]
		289, 289, 0x220002, // [54]
		295, 295, 0x230002, // [55]
		301, 301, 0x140002, // [56]
		224, 227, 0x3006c, // [57]
		230, 233, 0x3000e, // [58]
		236, 237, 0x23000f, // [59]
		237, 238, 0x610023, // [60]
		244, 244, 0x430004, // [61]
		250, 250, 0x150004, // [62]
		238, 243, 0x50061, // [63]
		244, 249, 0x50043, // [64]
		257, 258, 0x170057, // [65]
		258, 260, 0x40017, // [66]
		260, 262, 0x40009, // [67]
		265, 267, 0x30016, // [68]
		267, 269, 0x30008, // [69]
		271, 272, 0x4e0017, // [70]
		272, 274, 0x4004e, // [71]
		277, 278, 0x620021, // [72]
		278, 280, 0x40062, // [73]
		283, 284, 0x360018, // [74]
		284, 286, 0x40036, // [75]
		289, 290, 0x4a0022, // [76]
		290, 292, 0x4004a, // [77]
		295, 296, 0x6d0023, // [78]
		296, 298, 0x4006d, // [79]
		301, 302, 0x3e0014, // [80]
		302, 304, 0x4003e, // [81]
		308, 310, 0x20015, // [82]
	},
	NumStmt: [83]uint16{
		3, // 0
		4, // 1
		1, // 2
		1, // 3
		1, // 4
		3, // 5
		3, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		1, // 11
		2, // 12
		1, // 13
		2, // 14
		25, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		3, // 24
		3, // 25
		2, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		3, // 31
		3, // 32
		2, // 33
		1, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		14, // 46
		1, // 47
		1, // 48
		4, // 49
		2, // 50
		1, // 51
		1, // 52
		1, // 53
		1, // 54
		1, // 55
		1, // 56
		2, // 57
		2, // 58
		1, // 59
		1, // 60
		1, // 61
		1, // 62
		2, // 63
		2, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
	},
}
var _ = _cover_atomic_.LoadUint32
