//line /home/cooper/go/src/github.com/hyperledger/fabric/core/endorser/pvtrwset_assembler.go:1
/*
 *
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 * /
 *
 */

package endorser; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/common/privdata"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
	"github.com/hyperledger/fabric/protos/transientstore"
	"github.com/pkg/errors"
)

// PvtRWSetAssembler assembles private read write set for distribution
// augments with additional information if needed
type PvtRWSetAssembler interface {
	// AssemblePvtRWSet prepares TxPvtReadWriteSet for distribution
	// augmenting it into TxPvtReadWriteSetWithConfigInfo adding
	// information about collections config available related
	// to private read-write set
	AssemblePvtRWSet(privData *rwset.TxPvtReadWriteSet, txsim CollectionConfigRetriever) (*transientstore.TxPvtReadWriteSetWithConfigInfo, error)
}

// CollectionConfigRetriever encapsulates sub-functionality of ledger.TxSimulator
// to abstract minimum required functions set
type CollectionConfigRetriever interface {
	// GetState gets the value for given namespace and key. For a chaincode, the namespace corresponds to the chaincodeId
	GetState(namespace string, key string) ([]byte, error)
}

type rwSetAssembler struct {
}

// AssemblePvtRWSet prepares TxPvtReadWriteSet for distribution
// augmenting it into TxPvtReadWriteSetWithConfigInfo adding
// information about collections config available related
// to private read-write set
func (as *rwSetAssembler) AssemblePvtRWSet(privData *rwset.TxPvtReadWriteSet, txsim CollectionConfigRetriever) (*transientstore.TxPvtReadWriteSetWithConfigInfo, error) {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[0], 1);
	txPvtRwSetWithConfig := &transientstore.TxPvtReadWriteSetWithConfigInfo{
		PvtRwset:          privData,
		CollectionConfigs: make(map[string]*common.CollectionConfigPackage),
	}

	for _, pvtRwset := range privData.NsPvtRwset {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[2], 1);
		namespace := pvtRwset.Namespace
		if _, found := txPvtRwSetWithConfig.CollectionConfigs[namespace]; !found {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[3], 1);
			cb, err := txsim.GetState("lscc", privdata.BuildCollectionKVSKey(namespace))
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[7], 1);
				return nil, errors.WithMessage(err, fmt.Sprintf("error while retrieving collection config for chaincode %#v", namespace))
			}
			_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[4], 1);if cb == nil {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[8], 1);
				return nil, errors.New(fmt.Sprintf("no collection config for chaincode %#v", namespace))
			}

			_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[5], 1);colCP := &common.CollectionConfigPackage{}
			err = proto.Unmarshal(cb, colCP)
			if err != nil {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[9], 1);
				return nil, errors.Wrapf(err, "invalid configuration for collection criteria %#v", namespace)
			}

			_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[6], 1);txPvtRwSetWithConfig.CollectionConfigs[namespace] = colCP
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[1], 1);as.trimCollectionConfigs(txPvtRwSetWithConfig)
	return txPvtRwSetWithConfig, nil
}

func (as *rwSetAssembler) trimCollectionConfigs(pvtData *transientstore.TxPvtReadWriteSetWithConfigInfo) {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[10], 1);
	flags := make(map[string]map[string]struct{})
	for _, pvtRWset := range pvtData.PvtRwset.NsPvtRwset {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[13], 1);
		namespace := pvtRWset.Namespace
		for _, col := range pvtRWset.CollectionPvtRwset {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[14], 1);
			if _, found := flags[namespace]; !found {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[16], 1);
				flags[namespace] = make(map[string]struct{})
			}
			_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[15], 1);flags[namespace][col.CollectionName] = struct{}{}
		}
	}

	_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[11], 1);filteredConfigs := make(map[string]*common.CollectionConfigPackage)
	for namespace, configs := range pvtData.CollectionConfigs {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[17], 1);
		filteredConfigs[namespace] = &common.CollectionConfigPackage{}
		for _, conf := range configs.Config {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[18], 1);
			if colConf := conf.GetStaticCollectionConfig(); colConf != nil {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[19], 1);
				if _, found := flags[namespace][colConf.Name]; found {_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[20], 1);
					filteredConfigs[namespace].Config = append(filteredConfigs[namespace].Config, conf)
				}
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_306432633236306362313365.Count[12], 1);pvtData.CollectionConfigs = filteredConfigs
}

var GoCover_2_306432633236306362313365 = struct {
	Count     [21]uint32
	Pos       [3 * 21]uint32
	NumStmt   [21]uint16
} {
	Pos: [3 * 21]uint32{
		47, 53, 0x2f00a9, // [0]
		73, 74, 0x220002, // [1]
		53, 55, 0x4c002f, // [2]
		55, 57, 0x12004c, // [3]
		60, 60, 0x110004, // [4]
		64, 66, 0x120004, // [5]
		70, 70, 0x3d0004, // [6]
		57, 59, 0x50012, // [7]
		60, 62, 0x50011, // [8]
		66, 68, 0x50012, // [9]
		77, 79, 0x37006a, // [10]
		89, 90, 0x3c0002, // [11]
		100, 100, 0x2d0002, // [12]
		79, 81, 0x330037, // [13]
		81, 82, 0x2c0033, // [14]
		85, 85, 0x350004, // [15]
		82, 84, 0x5002c, // [16]
		90, 92, 0x27003c, // [17]
		92, 93, 0x430027, // [18]
		93, 94, 0x3a0043, // [19]
		94, 96, 0x6003a, // [20]
	},
	NumStmt: [21]uint16{
		2, // 0
		2, // 1
		2, // 2
		2, // 3
		1, // 4
		3, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		2, // 10
		2, // 11
		1, // 12
		2, // 13
		1, // 14
		1, // 15
		1, // 16
		2, // 17
		1, // 18
		1, // 19
		1, // 20
	},
}
var _ = _cover_atomic_.LoadUint32
