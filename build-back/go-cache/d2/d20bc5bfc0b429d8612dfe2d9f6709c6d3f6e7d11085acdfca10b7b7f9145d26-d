//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/metrics.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package kvledger; import _cover_atomic_ "sync/atomic"

import (
	"time"

	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/txmgr"
)

type stats struct {
	blockchainHeight       metrics.Gauge
	blockProcessingTime    metrics.Histogram
	blockstorageCommitTime metrics.Histogram
	statedbCommitTime      metrics.Histogram
	transactionsCount      metrics.Counter
}

func newStats(metricsProvider metrics.Provider) *stats {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[0], 1);
	stats := &stats{}
	stats.blockchainHeight = metricsProvider.NewGauge(blockchainHeightOpts)
	stats.blockProcessingTime = metricsProvider.NewHistogram(blockProcessingTimeOpts)
	stats.blockstorageCommitTime = metricsProvider.NewHistogram(blockstorageCommitTimeOpts)
	stats.statedbCommitTime = metricsProvider.NewHistogram(statedbCommitTimeOpts)
	stats.transactionsCount = metricsProvider.NewCounter(transactionCountOpts)
	return stats
}

type ledgerStats struct {
	stats    *stats
	ledgerid string
}

func (s *stats) ledgerStats(ledgerid string) *ledgerStats {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[1], 1);
	return &ledgerStats{
		s, ledgerid,
	}
}

func (s *ledgerStats) updateBlockchainHeight(height uint64) {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[2], 1);
	// casting uint64 to float64 guarentees precision for the numbers upto 9,007,199,254,740,992 (1<<53)
	// since, we are not expecting the blockchains of this scale anytime soon, we go ahead with this for now.
	s.stats.blockchainHeight.With("channel", s.ledgerid).Set(float64(height))
}

func (s *ledgerStats) updateBlockProcessingTime(timeTaken time.Duration) {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[3], 1);
	s.stats.blockProcessingTime.With("channel", s.ledgerid).Observe(timeTaken.Seconds())
}

func (s *ledgerStats) updateBlockstorageCommitTime(timeTaken time.Duration) {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[4], 1);
	s.stats.blockstorageCommitTime.With("channel", s.ledgerid).Observe(timeTaken.Seconds())
}

func (s *ledgerStats) updateStatedbCommitTime(timeTaken time.Duration) {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[5], 1);
	s.stats.statedbCommitTime.With("channel", s.ledgerid).Observe(timeTaken.Seconds())
}

func (s *ledgerStats) updateTransactionsStats(
	txstatsInfo []*txmgr.TxStatInfo,
) {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[6], 1);
	for _, txstat := range txstatsInfo {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[7], 1);
		transactionTypeStr := "unknown"
		if txstat.TxType != -1 {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[10], 1);
			transactionTypeStr = txstat.TxType.String()
		}

		_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[8], 1);chaincodeName := "unknown"
		if txstat.ChaincodeID != nil {_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[11], 1);
			chaincodeName = txstat.ChaincodeID.Name + ":" + txstat.ChaincodeID.Version
		}

		_cover_atomic_.AddUint32(&GoCover_4_653063666537353930343531.Count[9], 1);s.stats.transactionsCount.With(
			"channel", s.ledgerid,
			"transaction_type", transactionTypeStr,
			"chaincode", chaincodeName,
			"validation_code", txstat.ValidationCode.String(),
		).Add(1)
	}
}

var (
	blockchainHeightOpts = metrics.GaugeOpts{
		Namespace:    "ledger",
		Subsystem:    "",
		Name:         "blockchain_height",
		Help:         "Height of the chain in blocks.",
		LabelNames:   []string{"channel"},
		StatsdFormat: "%{#fqname}.%{channel}",
	}

	blockProcessingTimeOpts = metrics.HistogramOpts{
		Namespace:    "ledger",
		Subsystem:    "",
		Name:         "block_processing_time",
		Help:         "Time taken in seconds for ledger block processing.",
		LabelNames:   []string{"channel"},
		StatsdFormat: "%{#fqname}.%{channel}",
		Buckets:      []float64{0.005, 0.01, 0.015, 0.05, 0.1, 1, 10},
	}

	blockstorageCommitTimeOpts = metrics.HistogramOpts{
		Namespace:    "ledger",
		Subsystem:    "",
		Name:         "blockstorage_commit_time",
		Help:         "Time taken in seconds for committing the block and private data to storage.",
		LabelNames:   []string{"channel"},
		StatsdFormat: "%{#fqname}.%{channel}",
		Buckets:      []float64{0.005, 0.01, 0.015, 0.05, 0.1, 1, 10},
	}

	statedbCommitTimeOpts = metrics.HistogramOpts{
		Namespace:    "ledger",
		Subsystem:    "",
		Name:         "statedb_commit_time",
		Help:         "Time taken in seconds for committing block changes to state db.",
		LabelNames:   []string{"channel"},
		StatsdFormat: "%{#fqname}.%{channel}",
		Buckets:      []float64{0.005, 0.01, 0.015, 0.05, 0.1, 1, 10},
	}

	transactionCountOpts = metrics.CounterOpts{
		Namespace:    "ledger",
		Subsystem:    "",
		Name:         "transaction_count",
		Help:         "Number of transactions processed.",
		LabelNames:   []string{"channel", "transaction_type", "chaincode", "validation_code"},
		StatsdFormat: "%{#fqname}.%{channel}.%{transaction_type}.%{chaincode}.%{validation_code}",
	}
)

var GoCover_4_653063666537353930343531 = struct {
	Count     [12]uint32
	Pos       [3 * 12]uint32
	NumStmt   [12]uint16
} {
	Pos: [3 * 12]uint32{
		23, 31, 0x20038, // [0]
		38, 42, 0x2003b, // [1]
		44, 48, 0x2003d, // [2]
		50, 52, 0x2004a, // [3]
		54, 56, 0x2004d, // [4]
		58, 60, 0x20048, // [5]
		64, 65, 0x250003, // [6]
		65, 67, 0x1a0025, // [7]
		71, 72, 0x200003, // [8]
		76, 81, 0xb0003, // [9]
		67, 69, 0x4001a, // [10]
		72, 74, 0x40020, // [11]
	},
	NumStmt: [12]uint16{
		7, // 0
		1, // 1
		1, // 2
		1, // 3
		1, // 4
		1, // 5
		1, // 6
		2, // 7
		2, // 8
		1, // 9
		1, // 10
		1, // 11
	},
}
var _ = _cover_atomic_.LoadUint32
