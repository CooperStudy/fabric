//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/pvtdatastorage/store_impl.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package pvtdatastorage; import _cover_atomic_ "sync/atomic"

import (
	"fmt"
	"sort"
	"sync"
	"sync/atomic"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/pvtdatapolicy"
	"github.com/hyperledger/fabric/protos/ledger/rwset"
	"github.com/willf/bitset"
)

var logger = flogging.MustGetLogger("pvtdatastorage")

type provider struct {
	dbProvider *leveldbhelper.Provider
}

type store struct {
	db        *leveldbhelper.DBHandle
	ledgerid  string
	btlPolicy pvtdatapolicy.BTLPolicy

	isEmpty            bool
	lastCommittedBlock uint64
	batchPending       bool
	purgerLock         sync.Mutex
	collElgProcSync    *collElgProcSync
	// After committing the pvtdata of old blocks,
	// the `isLastUpdatedOldBlocksSet` is set to true.
	// Once the stateDB is updated with these pvtdata,
	// the `isLastUpdatedOldBlocksSet` is set to false.
	// isLastUpdatedOldBlocksSet is mainly used during the
	// recovery process. During the peer startup, if the
	// isLastUpdatedOldBlocksSet is set to true, the pvtdata
	// in the stateDB needs to be updated before finishing the
	// recovery operation.
	isLastUpdatedOldBlocksSet bool
}

type blkTranNumKey []byte

type dataEntry struct {
	key   *dataKey
	value *rwset.CollectionPvtReadWriteSet
}

type expiryEntry struct {
	key   *expiryKey
	value *ExpiryData
}

type expiryKey struct {
	expiringBlk   uint64
	committingBlk uint64
}

type nsCollBlk struct {
	ns, coll string
	blkNum   uint64
}

type dataKey struct {
	nsCollBlk
	txNum uint64
}

type missingDataKey struct {
	nsCollBlk
	isEligible bool
}

type storeEntries struct {
	dataEntries        []*dataEntry
	expiryEntries      []*expiryEntry
	missingDataEntries map[missingDataKey]*bitset.BitSet
}

// lastUpdatedOldBlocksList keeps the list of last updated blocks
// and is stored as the value of lastUpdatedOldBlocksKey (defined in kv_encoding.go)
type lastUpdatedOldBlocksList []uint64

type entriesForPvtDataOfOldBlocks struct {
	// for each <ns, coll, blkNum, txNum>, store the dataEntry, i.e., pvtData
	dataEntries map[dataKey]*rwset.CollectionPvtReadWriteSet
	// store the retrieved (& updated) expiryData in expiryEntries
	expiryEntries map[expiryKey]*ExpiryData
	// for each <ns, coll, blkNum>, store the retrieved (& updated) bitmap in the missingDataEntries
	missingDataEntries map[nsCollBlk]*bitset.BitSet
}

//////// Provider functions  /////////////
//////////////////////////////////////////

// NewProvider instantiates a StoreProvider
func NewProvider() Provider {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[0], 1);
	dbPath := ledgerconfig.GetPvtdataStorePath()
	dbProvider := leveldbhelper.NewProvider(&leveldbhelper.Conf{DBPath: dbPath})
	return &provider{dbProvider: dbProvider}
}

// OpenStore returns a handle to a store
func (p *provider) OpenStore(ledgerid string) (Store, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[1], 1);
	dbHandle := p.dbProvider.GetDBHandle(ledgerid)
	s := &store{db: dbHandle, ledgerid: ledgerid,
		collElgProcSync: &collElgProcSync{
			notification: make(chan bool, 1),
			procComplete: make(chan bool, 1),
		},
	}
	if err := s.initState(); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[3], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[2], 1);s.launchCollElgProc()
	logger.Debugf("Pvtdata store opened. Initial state: isEmpty [%t], lastCommittedBlock [%d], batchPending [%t]",
		s.isEmpty, s.lastCommittedBlock, s.batchPending)
	return s, nil
}

// Close closes the store
func (p *provider) Close() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[4], 1);
	p.dbProvider.Close()
}

//////// store functions  ////////////////
//////////////////////////////////////////

func (s *store) initState() error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[5], 1);
	var err error
	var blist lastUpdatedOldBlocksList
	if s.isEmpty, s.lastCommittedBlock, err = s.getLastCommittedBlockNum(); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[10], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[6], 1);if s.batchPending, err = s.hasPendingCommit(); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[11], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[7], 1);if blist, err = s.getLastUpdatedOldBlocksList(); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[12], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[8], 1);if len(blist) > 0 {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[13], 1);
		s.isLastUpdatedOldBlocksSet = true
	} // false if not set

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[9], 1);return nil
}

func (s *store) Init(btlPolicy pvtdatapolicy.BTLPolicy) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[14], 1);
	s.btlPolicy = btlPolicy
}

// Prepare implements the function in the interface `Store`
func (s *store) Prepare(blockNum uint64, pvtData []*ledger.TxPvtData, missingPvtData ledger.TxMissingPvtDataMap) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[15], 1);
	if s.batchPending {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[23], 1);
		return &ErrIllegalCall{`A pending batch exists as as result of last invoke to "Prepare" call.
			 Invoke "Commit" or "Rollback" on the pending batch before invoking "Prepare" function`}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[16], 1);expectedBlockNum := s.nextBlockNum()
	if expectedBlockNum != blockNum {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[24], 1);
		return &ErrIllegalArgs{fmt.Sprintf("Expected block number=%d, recived block number=%d", expectedBlockNum, blockNum)}
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[17], 1);batch := leveldbhelper.NewUpdateBatch()
	var err error
	var keyBytes, valBytes []byte

	storeEntries, err := prepareStoreEntries(blockNum, pvtData, s.btlPolicy, missingPvtData)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[25], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[18], 1);for _, dataEntry := range storeEntries.dataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[26], 1);
		keyBytes = encodeDataKey(dataEntry.key)
		if valBytes, err = encodeDataValue(dataEntry.value); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[28], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[27], 1);batch.Put(keyBytes, valBytes)
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[19], 1);for _, expiryEntry := range storeEntries.expiryEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[29], 1);
		keyBytes = encodeExpiryKey(expiryEntry.key)
		if valBytes, err = encodeExpiryValue(expiryEntry.value); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[31], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[30], 1);batch.Put(keyBytes, valBytes)
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[20], 1);for missingDataKey, missingDataValue := range storeEntries.missingDataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[32], 1);
		keyBytes = encodeMissingDataKey(&missingDataKey)
		if valBytes, err = encodeMissingDataValue(missingDataValue); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[34], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[33], 1);batch.Put(keyBytes, valBytes)
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[21], 1);batch.Put(pendingCommitKey, emptyValue)
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[35], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[22], 1);s.batchPending = true
	logger.Debugf("Saved %d private data write sets for block [%d]", len(pvtData), blockNum)
	return nil
}

// Commit implements the function in the interface `Store`
func (s *store) Commit() error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[36], 1);
	if !s.batchPending {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[39], 1);
		return &ErrIllegalCall{"No pending batch to commit"}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[37], 1);committingBlockNum := s.nextBlockNum()
	logger.Debugf("Committing private data for block [%d]", committingBlockNum)
	batch := leveldbhelper.NewUpdateBatch()
	batch.Delete(pendingCommitKey)
	batch.Put(lastCommittedBlkkey, encodeLastCommittedBlockVal(committingBlockNum))
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[40], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[38], 1);s.batchPending = false
	s.isEmpty = false
	s.lastCommittedBlock = committingBlockNum
	logger.Debugf("Committed private data for block [%d]", committingBlockNum)
	s.performPurgeIfScheduled(committingBlockNum)
	return nil
}

// Rollback implements the function in the interface `Store`
// This deletes the existing data entries and eligible missing data entries.
// However, this does not delete ineligible missing data entires as the next try
// would have exact same entries and will overwrite those. This also leaves the
// existing expiry entires as is because, most likely they will also get overwritten
// per new data entries. Even if some of the expiry entries does not get overwritten,
// (beacuse of some data may be missing next time), the additional expiry entries are just
// a Noop
func (s *store) Rollback() error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[41], 1);
	if !s.batchPending {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[46], 1);
		return &ErrIllegalCall{"No pending batch to rollback"}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[42], 1);blkNum := s.nextBlockNum()
	batch := leveldbhelper.NewUpdateBatch()
	itr := s.db.GetIterator(datakeyRange(blkNum))
	for itr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[47], 1);
		batch.Delete(itr.Key())
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[43], 1);itr.Release()
	itr = s.db.GetIterator(eligibleMissingdatakeyRange(blkNum))
	for itr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[48], 1);
		batch.Delete(itr.Key())
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[44], 1);itr.Release()
	batch.Delete(pendingCommitKey)
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[49], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[45], 1);s.batchPending = false
	return nil
}

// CommitPvtDataOfOldBlocks commits the pvtData (i.e., previously missing data) of old blocks.
// The parameter `blocksPvtData` refers a list of old block's pvtdata which are missing in the pvtstore.
// Given a list of old block's pvtData, `CommitPvtDataOfOldBlocks` performs the following four
// operations
// (1) construct dataEntries for all pvtData
// (2) construct update entries (i.e., dataEntries, expiryEntries, missingDataEntries, and
//     lastUpdatedOldBlocksList) from the above created data entries
// (3) create a db update batch from the update entries
// (4) commit the update entries to the pvtStore
func (s *store) CommitPvtDataOfOldBlocks(blocksPvtData map[uint64][]*ledger.TxPvtData) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[50], 1);
	if s.isLastUpdatedOldBlocksSet {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[55], 1);
		return &ErrIllegalCall{`The lastUpdatedOldBlocksList is set. It means that the
		stateDB may not be in sync with the pvtStore`}
	}

	// (1) construct dataEntries for all pvtData
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[51], 1);dataEntries := constructDataEntriesFromBlocksPvtData(blocksPvtData)

	// (2) construct update entries (i.e., dataEntries, expiryEntries, missingDataEntries) from the above created data entries
	logger.Debugf("Constructing pvtdatastore entries for pvtData of [%d] old blocks", len(blocksPvtData))
	updateEntries, err := s.constructUpdateEntriesFromDataEntries(dataEntries)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[56], 1);
		return err
	}

	// (3) create a db update batch from the update entries
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[52], 1);logger.Debug("Constructing update batch from pvtdatastore entries")
	batch, err := constructUpdateBatchFromUpdateEntries(updateEntries)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[57], 1);
		return err
	}

	// (4) commit the update entries to the pvtStore
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[53], 1);logger.Debug("Committing the update batch to pvtdatastore")
	if err := s.commitBatch(batch); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[58], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[54], 1);s.isLastUpdatedOldBlocksSet = true

	return nil
}

func constructDataEntriesFromBlocksPvtData(blocksPvtData map[uint64][]*ledger.TxPvtData) []*dataEntry {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[59], 1);
	// construct dataEntries for all pvtData
	var dataEntries []*dataEntry
	for blkNum, pvtData := range blocksPvtData {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[61], 1);
		// prepare the dataEntries for the pvtData
		dataEntries = append(dataEntries, prepareDataEntries(blkNum, pvtData)...)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[60], 1);return dataEntries
}

func (s *store) constructUpdateEntriesFromDataEntries(dataEntries []*dataEntry) (*entriesForPvtDataOfOldBlocks, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[62], 1);
	updateEntries := &entriesForPvtDataOfOldBlocks{
		dataEntries:        make(map[dataKey]*rwset.CollectionPvtReadWriteSet),
		expiryEntries:      make(map[expiryKey]*ExpiryData),
		missingDataEntries: make(map[nsCollBlk]*bitset.BitSet)}

	// for each data entry, first, get the expiryData and missingData from the pvtStore.
	// Second, update the expiryData and missingData as per the data entry. Finally, add
	// the data entry along with the updated expiryData and missingData to the update entries
	for _, dataEntry := range dataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[64], 1);
		// get the expiryBlk number to construct the expiryKey
		expiryKey, err := s.constructExpiryKeyFromDataEntry(dataEntry)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[70], 1);
			return nil, err
		}

		// get the existing expiryData ntry
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[65], 1);var expiryData *ExpiryData
		if !neverExpires(expiryKey.expiringBlk) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[71], 1);
			if expiryData, err = s.getExpiryDataFromUpdateEntriesOrStore(updateEntries, expiryKey); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[73], 1);
				return nil, err
			}
			_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[72], 1);if expiryData == nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[74], 1);
				// data entry is already expired
				// and purged (a rare scenario)
				continue
			}
		}

		// get the existing missingData entry
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[66], 1);var missingData *bitset.BitSet
		nsCollBlk := dataEntry.key.nsCollBlk
		if missingData, err = s.getMissingDataFromUpdateEntriesOrStore(updateEntries, nsCollBlk); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[75], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[67], 1);if missingData == nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[76], 1);
			// data entry is already expired
			// and purged (a rare scenario)
			continue
		}

		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[68], 1);updateEntries.addDataEntry(dataEntry)
		if expiryData != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[77], 1); // would be nill for the never expiring entry
			expiryEntry := &expiryEntry{&expiryKey, expiryData}
			updateEntries.updateAndAddExpiryEntry(expiryEntry, dataEntry.key)
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[69], 1);updateEntries.updateAndAddMissingDataEntry(missingData, dataEntry.key)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[63], 1);return updateEntries, nil
}

func (s *store) constructExpiryKeyFromDataEntry(dataEntry *dataEntry) (expiryKey, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[78], 1);
	// get the expiryBlk number to construct the expiryKey
	nsCollBlk := dataEntry.key.nsCollBlk
	expiringBlk, err := s.btlPolicy.GetExpiringBlock(nsCollBlk.ns, nsCollBlk.coll, nsCollBlk.blkNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[80], 1);
		return expiryKey{}, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[79], 1);return expiryKey{expiringBlk, nsCollBlk.blkNum}, nil
}

func (s *store) getExpiryDataFromUpdateEntriesOrStore(updateEntries *entriesForPvtDataOfOldBlocks, expiryKey expiryKey) (*ExpiryData, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[81], 1);
	expiryData, ok := updateEntries.expiryEntries[expiryKey]
	if !ok {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[83], 1);
		var err error
		expiryData, err = s.getExpiryDataOfExpiryKey(&expiryKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[84], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[82], 1);return expiryData, nil
}

func (s *store) getMissingDataFromUpdateEntriesOrStore(updateEntries *entriesForPvtDataOfOldBlocks, nsCollBlk nsCollBlk) (*bitset.BitSet, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[85], 1);
	missingData, ok := updateEntries.missingDataEntries[nsCollBlk]
	if !ok {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[87], 1);
		var err error
		missingDataKey := &missingDataKey{nsCollBlk, true}
		missingData, err = s.getBitmapOfMissingDataKey(missingDataKey)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[88], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[86], 1);return missingData, nil
}

func (updateEntries *entriesForPvtDataOfOldBlocks) addDataEntry(dataEntry *dataEntry) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[89], 1);
	dataKey := dataKey{dataEntry.key.nsCollBlk, dataEntry.key.txNum}
	updateEntries.dataEntries[dataKey] = dataEntry.value
}

func (updateEntries *entriesForPvtDataOfOldBlocks) updateAndAddExpiryEntry(expiryEntry *expiryEntry, dataKey *dataKey) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[90], 1);
	txNum := dataKey.txNum
	nsCollBlk := dataKey.nsCollBlk
	// update
	expiryEntry.value.addPresentData(nsCollBlk.ns, nsCollBlk.coll, txNum)
	// we cannot delete entries from MissingDataMap as
	// we keep only one entry per missing <ns-col>
	// irrespective of the number of txNum.

	// add
	expiryKey := expiryKey{expiryEntry.key.expiringBlk, expiryEntry.key.committingBlk}
	updateEntries.expiryEntries[expiryKey] = expiryEntry.value
}

func (updateEntries *entriesForPvtDataOfOldBlocks) updateAndAddMissingDataEntry(missingData *bitset.BitSet, dataKey *dataKey) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[91], 1);

	txNum := dataKey.txNum
	nsCollBlk := dataKey.nsCollBlk
	// update
	missingData.Clear(uint(txNum))
	// add
	updateEntries.missingDataEntries[nsCollBlk] = missingData
}

func constructUpdateBatchFromUpdateEntries(updateEntries *entriesForPvtDataOfOldBlocks) (*leveldbhelper.UpdateBatch, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[92], 1);
	batch := leveldbhelper.NewUpdateBatch()

	// add the following four types of entries to the update batch: (1) new data entries
	// (i.e., pvtData), (2) updated expiry entries, (3) updated missing data entries, and
	// (4) updated block list

	// (1) add new data entries to the batch
	if err := addNewDataEntriesToUpdateBatch(batch, updateEntries); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[96], 1);
		return nil, err
	}

	// (2) add updated expiryEntry to the batch
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[93], 1);if err := addUpdatedExpiryEntriesToUpdateBatch(batch, updateEntries); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[97], 1);
		return nil, err
	}

	// (3) add updated missingData to the batch
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[94], 1);if err := addUpdatedMissingDataEntriesToUpdateBatch(batch, updateEntries); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[98], 1);
		return nil, err
	}

	// (4) add lastUpdatedOldBlocksList to the batch
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[95], 1);addLastUpdatedOldBlocksList(batch, updateEntries)

	return batch, nil
}

func addNewDataEntriesToUpdateBatch(batch *leveldbhelper.UpdateBatch, entries *entriesForPvtDataOfOldBlocks) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[99], 1);
	var keyBytes, valBytes []byte
	var err error
	for dataKey, pvtData := range entries.dataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[101], 1);
		keyBytes = encodeDataKey(&dataKey)
		if valBytes, err = encodeDataValue(pvtData); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[103], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[102], 1);batch.Put(keyBytes, valBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[100], 1);return nil
}

func addUpdatedExpiryEntriesToUpdateBatch(batch *leveldbhelper.UpdateBatch, entries *entriesForPvtDataOfOldBlocks) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[104], 1);
	var keyBytes, valBytes []byte
	var err error
	for expiryKey, expiryData := range entries.expiryEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[106], 1);
		keyBytes = encodeExpiryKey(&expiryKey)
		if valBytes, err = encodeExpiryValue(expiryData); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[108], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[107], 1);batch.Put(keyBytes, valBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[105], 1);return nil
}

func addUpdatedMissingDataEntriesToUpdateBatch(batch *leveldbhelper.UpdateBatch, entries *entriesForPvtDataOfOldBlocks) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[109], 1);
	var keyBytes, valBytes []byte
	var err error
	for nsCollBlk, missingData := range entries.missingDataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[111], 1);
		keyBytes = encodeMissingDataKey(&missingDataKey{nsCollBlk, true})
		// if the missingData is empty, we need to delete the missingDataKey
		if missingData.None() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[114], 1);
			batch.Delete(keyBytes)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[112], 1);if valBytes, err = encodeMissingDataValue(missingData); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[115], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[113], 1);batch.Put(keyBytes, valBytes)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[110], 1);return nil
}

func addLastUpdatedOldBlocksList(batch *leveldbhelper.UpdateBatch, entries *entriesForPvtDataOfOldBlocks) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[116], 1);
	// create a list of blocks' pvtData which are being stored. If this list is
	// found during the recovery, the stateDB may not be in sync with the pvtData
	// and needs recovery. In a normal flow, once the stateDB is synced, the
	// block list would be deleted.
	updatedBlksListMap := make(map[uint64]bool)

	for dataKey := range entries.dataEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[121], 1);
		updatedBlksListMap[dataKey.blkNum] = true
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[117], 1);var updatedBlksList lastUpdatedOldBlocksList
	for blkNum := range updatedBlksListMap {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[122], 1);
		updatedBlksList = append(updatedBlksList, blkNum)
	}

	// better to store as sorted list
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[118], 1);sort.SliceStable(updatedBlksList, func(i, j int) bool {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[123], 1);
		return updatedBlksList[i] < updatedBlksList[j]
	})

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[119], 1);buf := proto.NewBuffer(nil)
	buf.EncodeVarint(uint64(len(updatedBlksList)))
	for _, blkNum := range updatedBlksList {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[124], 1);
		buf.EncodeVarint(blkNum)
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[120], 1);batch.Put(lastUpdatedOldBlocksKey, buf.Bytes())
}

func (s *store) commitBatch(batch *leveldbhelper.UpdateBatch) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[125], 1);
	// commit the batch to the store
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[127], 1);
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[126], 1);return nil
}

// GetLastUpdatedOldBlocksPvtData implements the function in the interface `Store`
func (s *store) GetLastUpdatedOldBlocksPvtData() (map[uint64][]*ledger.TxPvtData, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[128], 1);
	if !s.isLastUpdatedOldBlocksSet {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[132], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[129], 1);updatedBlksList, err := s.getLastUpdatedOldBlocksList()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[133], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[130], 1);blksPvtData := make(map[uint64][]*ledger.TxPvtData)
	for _, blkNum := range updatedBlksList {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[134], 1);
		if blksPvtData[blkNum], err = s.GetPvtDataByBlockNum(blkNum, nil); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[135], 1);
			return nil, err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[131], 1);return blksPvtData, nil
}

func (s *store) getLastUpdatedOldBlocksList() ([]uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[136], 1);
	var v []byte
	var err error
	if v, err = s.db.Get(lastUpdatedOldBlocksKey); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[141], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[137], 1);if v == nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[142], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[138], 1);var updatedBlksList []uint64
	buf := proto.NewBuffer(v)
	numBlks, err := buf.DecodeVarint()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[143], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[139], 1);for i := 0; i < int(numBlks); i++ {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[144], 1);
		blkNum, err := buf.DecodeVarint()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[146], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[145], 1);updatedBlksList = append(updatedBlksList, blkNum)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[140], 1);return updatedBlksList, nil
}

// ResetLastUpdatedOldBlocksList implements the function in the interface `Store`
func (s *store) ResetLastUpdatedOldBlocksList() error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[147], 1);
	batch := leveldbhelper.NewUpdateBatch()
	batch.Delete(lastUpdatedOldBlocksKey)
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[149], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[148], 1);s.isLastUpdatedOldBlocksSet = false
	return nil
}

// GetPvtDataByBlockNum implements the function in the interface `Store`.
// If the store is empty or the last committed block number is smaller then the
// requested block number, an 'ErrOutOfRange' is thrown
func (s *store) GetPvtDataByBlockNum(blockNum uint64, filter ledger.PvtNsCollFilter) ([]*ledger.TxPvtData, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[150], 1);
	logger.Debugf("Get private data for block [%d], filter=%#v", blockNum, filter)
	if s.isEmpty {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[155], 1);
		return nil, &ErrOutOfRange{"The store is empty"}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[151], 1);if blockNum > s.lastCommittedBlock {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[156], 1);
		return nil, &ErrOutOfRange{fmt.Sprintf("Last committed block=%d, block requested=%d", s.lastCommittedBlock, blockNum)}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[152], 1);startKey, endKey := getDataKeysForRangeScanByBlockNum(blockNum)
	logger.Debugf("Querying private data storage for write sets using startKey=%#v, endKey=%#v", startKey, endKey)
	itr := s.db.GetIterator(startKey, endKey)
	defer itr.Release()

	var blockPvtdata []*ledger.TxPvtData
	var currentTxNum uint64
	var currentTxWsetAssember *txPvtdataAssembler
	firstItr := true

	for itr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[157], 1);
		dataKeyBytes := itr.Key()
		if v11Format(dataKeyBytes) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[164], 1);
			return v11RetrievePvtdata(itr, filter)
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[158], 1);dataValueBytes := itr.Value()
		dataKey := decodeDatakey(dataKeyBytes)
		expired, err := isExpired(dataKey.nsCollBlk, s.btlPolicy, s.lastCommittedBlock)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[165], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[159], 1);if expired || !passesFilter(dataKey, filter) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[166], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[160], 1);dataValue, err := decodeDataValue(dataValueBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[167], 1);
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[161], 1);if firstItr {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[168], 1);
			currentTxNum = dataKey.txNum
			currentTxWsetAssember = newTxPvtdataAssembler(blockNum, currentTxNum)
			firstItr = false
		}

		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[162], 1);if dataKey.txNum != currentTxNum {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[169], 1);
			blockPvtdata = append(blockPvtdata, currentTxWsetAssember.getTxPvtdata())
			currentTxNum = dataKey.txNum
			currentTxWsetAssember = newTxPvtdataAssembler(blockNum, currentTxNum)
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[163], 1);currentTxWsetAssember.add(dataKey.ns, dataValue)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[153], 1);if currentTxWsetAssember != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[170], 1);
		blockPvtdata = append(blockPvtdata, currentTxWsetAssember.getTxPvtdata())
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[154], 1);return blockPvtdata, nil
}

// InitLastCommittedBlock implements the function in the interface `Store`
func (s *store) InitLastCommittedBlock(blockNum uint64) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[171], 1);
	if !(s.isEmpty && !s.batchPending) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[174], 1);
		return &ErrIllegalCall{"The private data store is not empty. InitLastCommittedBlock() function call is not allowed"}
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[172], 1);batch := leveldbhelper.NewUpdateBatch()
	batch.Put(lastCommittedBlkkey, encodeLastCommittedBlockVal(blockNum))
	if err := s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[175], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[173], 1);s.isEmpty = false
	s.lastCommittedBlock = blockNum
	logger.Debugf("InitLastCommittedBlock set to block [%d]", blockNum)
	return nil
}

// GetMissingPvtDataInfoForMostRecentBlocks implements the function in the interface `Store`
func (s *store) GetMissingPvtDataInfoForMostRecentBlocks(maxBlock int) (ledger.MissingPvtDataInfo, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[176], 1);
	// we assume that this function would be called by the gossip only after processing the
	// last retrieved missing pvtdata info and committing the same.
	if maxBlock < 1 {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[179], 1);
		return nil, nil
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[177], 1);missingPvtDataInfo := make(ledger.MissingPvtDataInfo)
	numberOfBlockProcessed := 0
	lastProcessedBlock := uint64(0)
	isMaxBlockLimitReached := false
	// as we are not acquiring a read lock, new blocks can get committed while we
	// construct the MissingPvtDataInfo. As a result, lastCommittedBlock can get
	// changed. To ensure consistency, we atomically load the lastCommittedBlock value
	lastCommittedBlock := atomic.LoadUint64(&s.lastCommittedBlock)

	startKey, endKey := createRangeScanKeysForEligibleMissingDataEntries(lastCommittedBlock)
	dbItr := s.db.GetIterator(startKey, endKey)
	defer dbItr.Release()

	for dbItr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[180], 1);
		missingDataKeyBytes := dbItr.Key()
		missingDataKey := decodeMissingDataKey(missingDataKeyBytes)

		if isMaxBlockLimitReached && (missingDataKey.blkNum != lastProcessedBlock) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[186], 1);
			// esnures that exactly maxBlock number
			// of blocks' entries are processed
			break
		}

		// check whether the entry is expired. If so, move to the next item.
		// As we may use the old lastCommittedBlock value, there is a possibility that
		// this missing data is actually expired but we may get the stale information.
		// Though it may leads to extra work of pulling the expired data, it will not
		// affect the correctness. Further, as we try to fetch the most recent missing
		// data (less possibility of expiring now), such scenario would be rare. In the
		// best case, we can load the latest lastCommittedBlock value here atomically to
		// make this scenario very rare.
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[181], 1);lastCommittedBlock = atomic.LoadUint64(&s.lastCommittedBlock)
		expired, err := isExpired(missingDataKey.nsCollBlk, s.btlPolicy, lastCommittedBlock)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[187], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[182], 1);if expired {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[188], 1);
			continue
		}

		// check for an existing entry for the blkNum in the MissingPvtDataInfo.
		// If no such entry exists, create one. Also, keep track of the number of
		// processed block due to maxBlock limit.
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[183], 1);if _, ok := missingPvtDataInfo[missingDataKey.blkNum]; !ok {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[189], 1);
			numberOfBlockProcessed++
			if numberOfBlockProcessed == maxBlock {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[190], 1);
				isMaxBlockLimitReached = true
				// as there can be more than one entry for this block,
				// we cannot `break` here
				lastProcessedBlock = missingDataKey.blkNum
			}
		}

		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[184], 1);valueBytes := dbItr.Value()
		bitmap, err := decodeMissingDataValue(valueBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[191], 1);
			return nil, err
		}

		// for each transaction which misses private data, make an entry in missingBlockPvtDataInfo
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[185], 1);for index, isSet := bitmap.NextSet(0); isSet; index, isSet = bitmap.NextSet(index + 1) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[192], 1);
			txNum := uint64(index)
			missingPvtDataInfo.Add(missingDataKey.blkNum, txNum, missingDataKey.ns, missingDataKey.coll)
		}
	}

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[178], 1);return missingPvtDataInfo, nil
}

// ProcessCollsEligibilityEnabled implements the function in the interface `Store`
func (s *store) ProcessCollsEligibilityEnabled(committingBlk uint64, nsCollMap map[string][]string) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[193], 1);
	key := encodeCollElgKey(committingBlk)
	m := newCollElgInfo(nsCollMap)
	val, err := encodeCollElgVal(m)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[196], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[194], 1);batch := leveldbhelper.NewUpdateBatch()
	batch.Put(key, val)
	if err = s.db.WriteBatch(batch, true); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[197], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[195], 1);s.collElgProcSync.notify()
	return nil
}

func (s *store) performPurgeIfScheduled(latestCommittedBlk uint64) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[198], 1);
	if latestCommittedBlk%ledgerconfig.GetPvtdataStorePurgeInterval() != 0 {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[200], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[199], 1);go func() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[201], 1);
		s.purgerLock.Lock()
		logger.Debugf("Purger started: Purging expired private data till block number [%d]", latestCommittedBlk)
		defer s.purgerLock.Unlock()
		err := s.purgeExpiredData(0, latestCommittedBlk)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[203], 1);
			logger.Warningf("Could not purge data from pvtdata store:%s", err)
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[202], 1);logger.Debug("Purger finished")
	}()
}

func (s *store) purgeExpiredData(minBlkNum, maxBlkNum uint64) error {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[204], 1);
	batch := leveldbhelper.NewUpdateBatch()
	expiryEntries, err := s.retrieveExpiryEntries(minBlkNum, maxBlkNum)
	if err != nil || len(expiryEntries) == 0 {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[207], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[205], 1);for _, expiryEntry := range expiryEntries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[208], 1);
		// this encoding could have been saved if the function retrieveExpiryEntries also returns the encoded expiry keys.
		// However, keeping it for better readability
		batch.Delete(encodeExpiryKey(expiryEntry.key))
		dataKeys, missingDataKeys := deriveKeys(expiryEntry)
		for _, dataKey := range dataKeys {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[211], 1);
			batch.Delete(encodeDataKey(dataKey))
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[209], 1);for _, missingDataKey := range missingDataKeys {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[212], 1);
			batch.Delete(encodeMissingDataKey(missingDataKey))
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[210], 1);s.db.WriteBatch(batch, false)
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[206], 1);logger.Infof("[%s] - [%d] Entries purged from private data storage till block number [%d]", s.ledgerid, len(expiryEntries), maxBlkNum)
	return nil
}

func (s *store) retrieveExpiryEntries(minBlkNum, maxBlkNum uint64) ([]*expiryEntry, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[213], 1);
	startKey, endKey := getExpiryKeysForRangeScan(minBlkNum, maxBlkNum)
	logger.Debugf("retrieveExpiryEntries(): startKey=%#v, endKey=%#v", startKey, endKey)
	itr := s.db.GetIterator(startKey, endKey)
	defer itr.Release()

	var expiryEntries []*expiryEntry
	for itr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[215], 1);
		expiryKeyBytes := itr.Key()
		expiryValueBytes := itr.Value()
		expiryKey := decodeExpiryKey(expiryKeyBytes)
		expiryValue, err := decodeExpiryValue(expiryValueBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[217], 1);
			return nil, err
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[216], 1);expiryEntries = append(expiryEntries, &expiryEntry{key: expiryKey, value: expiryValue})
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[214], 1);return expiryEntries, nil
}

func (s *store) launchCollElgProc() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[218], 1);
	maxBatchSize := ledgerconfig.GetPvtdataStoreCollElgProcMaxDbBatchSize()
	batchesInterval := ledgerconfig.GetPvtdataStoreCollElgProcDbBatchesInterval()
	go func() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[219], 1);
		s.processCollElgEvents(maxBatchSize, batchesInterval) // process collection eligibility events when store is opened - in case there is an unprocessed events from previous run
		for {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[220], 1);
			logger.Debugf("Waiting for collection eligibility event")
			s.collElgProcSync.waitForNotification()
			s.processCollElgEvents(maxBatchSize, batchesInterval)
			s.collElgProcSync.done()
		}
	}()
}

func (s *store) processCollElgEvents(maxBatchSize, batchesInterval int) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[221], 1);
	logger.Debugf("Starting to process collection eligibility events")
	s.purgerLock.Lock()
	defer s.purgerLock.Unlock()
	collElgStartKey, collElgEndKey := createRangeScanKeysForCollElg()
	eventItr := s.db.GetIterator(collElgStartKey, collElgEndKey)
	defer eventItr.Release()
	batch := leveldbhelper.NewUpdateBatch()
	totalEntriesConverted := 0

	for eventItr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[223], 1);
		collElgKey, collElgVal := eventItr.Key(), eventItr.Value()
		blkNum := decodeCollElgKey(collElgKey)
		CollElgInfo, err := decodeCollElgVal(collElgVal)
		logger.Debugf("Processing collection eligibility event [blkNum=%d], CollElgInfo=%s", blkNum, CollElgInfo)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[226], 1);
			logger.Errorf("This error is not expected %s", err)
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[224], 1);for ns, colls := range CollElgInfo.NsCollMap {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[227], 1);
			var coll string
			for _, coll = range colls.Entries {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[228], 1);
				logger.Infof("Converting missing data entries from ineligible to eligible for [ns=%s, coll=%s]", ns, coll)
				startKey, endKey := createRangeScanKeysForIneligibleMissingData(blkNum, ns, coll)
				collItr := s.db.GetIterator(startKey, endKey)
				collEntriesConverted := 0

				for collItr.Next() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[230], 1); // each entry
					originalKey, originalVal := collItr.Key(), collItr.Value()
					modifiedKey := decodeMissingDataKey(originalKey)
					modifiedKey.isEligible = true
					batch.Delete(originalKey)
					copyVal := make([]byte, len(originalVal))
					copy(copyVal, originalVal)
					batch.Put(encodeMissingDataKey(modifiedKey), copyVal)
					collEntriesConverted++
					if batch.Len() > maxBatchSize {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[231], 1);
						s.db.WriteBatch(batch, true)
						batch = leveldbhelper.NewUpdateBatch()
						sleepTime := time.Duration(batchesInterval)
						logger.Infof("Going to sleep for %d milliseconds between batches. Entries for [ns=%s, coll=%s] converted so far = %d",
							sleepTime, ns, coll, collEntriesConverted)
						s.purgerLock.Unlock()
						time.Sleep(sleepTime * time.Millisecond)
						s.purgerLock.Lock()
					}
				} // entry loop

				_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[229], 1);collItr.Release()
				logger.Infof("Converted all [%d] entries for [ns=%s, coll=%s]", collEntriesConverted, ns, coll)
				totalEntriesConverted += collEntriesConverted
			} // coll loop
		} // ns loop
		_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[225], 1);batch.Delete(collElgKey) // delete the collection eligibility event key as well
	} // event loop

	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[222], 1);s.db.WriteBatch(batch, true)
	logger.Debugf("Converted [%d] inelligible mising data entries to elligible", totalEntriesConverted)
}

// LastCommittedBlockHeight implements the function in the interface `Store`
func (s *store) LastCommittedBlockHeight() (uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[232], 1);
	if s.isEmpty {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[234], 1);
		return 0, nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[233], 1);return s.lastCommittedBlock + 1, nil
}

// HasPendingBatch implements the function in the interface `Store`
func (s *store) HasPendingBatch() (bool, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[235], 1);
	return s.batchPending, nil
}

// IsEmpty implements the function in the interface `Store`
func (s *store) IsEmpty() (bool, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[236], 1);
	return s.isEmpty, nil
}

// Shutdown implements the function in the interface `Store`
func (s *store) Shutdown() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[237], 1);
	// do nothing
}

func (s *store) nextBlockNum() uint64 {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[238], 1);
	if s.isEmpty {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[240], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[239], 1);return s.lastCommittedBlock + 1
}

func (s *store) hasPendingCommit() (bool, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[241], 1);
	var v []byte
	var err error
	if v, err = s.db.Get(pendingCommitKey); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[243], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[242], 1);return v != nil, nil
}

func (s *store) getLastCommittedBlockNum() (bool, uint64, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[244], 1);
	var v []byte
	var err error
	if v, err = s.db.Get(lastCommittedBlkkey); v == nil || err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[246], 1);
		return true, 0, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[245], 1);return false, decodeLastCommittedBlockVal(v), nil
}

type collElgProcSync struct {
	notification, procComplete chan bool
}

func (sync *collElgProcSync) notify() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[247], 1);
	select {
	case sync.notification <- true:_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[248], 1);
		logger.Debugf("Signaled to collection eligibility processing routine")
	default:_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[249], 1); //noop
		logger.Debugf("Previous signal still pending. Skipping new signal")
	}
}

func (sync *collElgProcSync) waitForNotification() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[250], 1);
	<-sync.notification
}

func (sync *collElgProcSync) done() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[251], 1);
	select {
	case sync.procComplete <- true:_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[252], 1);
	default:_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[253], 1);
	}
}

func (sync *collElgProcSync) waitForDone() {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[254], 1);
	<-sync.procComplete
}

func (s *store) getBitmapOfMissingDataKey(missingDataKey *missingDataKey) (*bitset.BitSet, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[255], 1);
	var v []byte
	var err error
	if v, err = s.db.Get(encodeMissingDataKey(missingDataKey)); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[258], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[256], 1);if v == nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[259], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[257], 1);return decodeMissingDataValue(v)
}

func (s *store) getExpiryDataOfExpiryKey(expiryKey *expiryKey) (*ExpiryData, error) {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[260], 1);
	var v []byte
	var err error
	if v, err = s.db.Get(encodeExpiryKey(expiryKey)); err != nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[263], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[261], 1);if v == nil {_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[264], 1);
		return nil, nil
	}
	_cover_atomic_.AddUint32(&GoCover_5_653833333066373334656466.Count[262], 1);return decodeExpiryValue(v)
}

var GoCover_5_653833333066373334656466 = struct {
	Count     [265]uint32
	Pos       [3 * 265]uint32
	NumStmt   [265]uint16
} {
	Pos: [3 * 265]uint32{
		109, 113, 0x2001d, // [0]
		116, 124, 0x26003e, // [1]
		127, 130, 0xf0002, // [2]
		124, 126, 0x30026, // [3]
		134, 136, 0x2001c, // [4]
		141, 144, 0x550023, // [5]
		147, 147, 0x3c0002, // [6]
		150, 150, 0x3e0002, // [7]
		153, 153, 0x140002, // [8]
		157, 157, 0xc0002, // [9]
		144, 146, 0x30055, // [10]
		147, 149, 0x3003c, // [11]
		150, 152, 0x3003e, // [12]
		153, 155, 0x30014, // [13]
		160, 162, 0x20039, // [14]
		165, 166, 0x140078, // [15]
		170, 171, 0x220002, // [16]
		175, 180, 0x100002, // [17]
		184, 184, 0x350002, // [18]
		192, 192, 0x390002, // [19]
		200, 200, 0x500002, // [20]
		208, 209, 0x350002, // [21]
		212, 214, 0xc0002, // [22]
		166, 169, 0x30014, // [23]
		171, 173, 0x30022, // [24]
		180, 182, 0x30010, // [25]
		184, 186, 0x430035, // [26]
		189, 189, 0x200003, // [27]
		186, 188, 0x40043, // [28]
		192, 194, 0x470039, // [29]
		197, 197, 0x200003, // [30]
		194, 196, 0x40047, // [31]
		200, 202, 0x4b0050, // [32]
		205, 205, 0x200003, // [33]
		202, 204, 0x4004b, // [34]
		209, 211, 0x30035, // [35]
		218, 219, 0x150020, // [36]
		222, 227, 0x350002, // [37]
		230, 235, 0xc0002, // [38]
		219, 221, 0x30015, // [39]
		227, 229, 0x30035, // [40]
		246, 247, 0x150022, // [41]
		250, 253, 0x110002, // [42]
		256, 258, 0x110002, // [43]
		261, 263, 0x350002, // [44]
		266, 267, 0xc0002, // [45]
		247, 249, 0x30015, // [46]
		253, 255, 0x30011, // [47]
		258, 260, 0x30011, // [48]
		263, 265, 0x30035, // [49]
		279, 280, 0x21005e, // [50]
		286, 291, 0x100002, // [51]
		296, 298, 0x100002, // [52]
		303, 304, 0x2d0002, // [53]
		307, 309, 0xc0002, // [54]
		280, 283, 0x30021, // [55]
		291, 293, 0x30010, // [56]
		298, 300, 0x30010, // [57]
		304, 306, 0x3002d, // [58]
		312, 315, 0x2d0067, // [59]
		319, 319, 0x140002, // [60]
		315, 318, 0x3002d, // [61]
		322, 331, 0x280078, // [62]
		370, 370, 0x1b0002, // [63]
		331, 334, 0x110028, // [64]
		339, 340, 0x2b0003, // [65]
		352, 354, 0x680003, // [66]
		357, 357, 0x190003, // [67]
		363, 364, 0x180003, // [68]
		368, 368, 0x490003, // [69]
		334, 336, 0x40011, // [70]
		340, 341, 0x67002b, // [71]
		344, 344, 0x190004, // [72]
		341, 343, 0x50067, // [73]
		344, 347, 0xd0019, // [74]
		354, 356, 0x40068, // [75]
		357, 360, 0xc0019, // [76]
		364, 367, 0x40018, // [77]
		373, 377, 0x10005a, // [78]
		380, 380, 0x360002, // [79]
		377, 379, 0x30010, // [80]
		383, 385, 0x9008e, // [81]
		392, 392, 0x180002, // [82]
		385, 388, 0x110009, // [83]
		388, 390, 0x40011, // [84]
		395, 397, 0x90092, // [85]
		405, 405, 0x190002, // [86]
		397, 401, 0x110009, // [87]
		401, 403, 0x40011, // [88]
		408, 411, 0x20057, // [89]
		413, 425, 0x20078, // [90]
		427, 435, 0x2007f, // [91]
		437, 445, 0x4d007d, // [92]
		450, 450, 0x530002, // [93]
		455, 455, 0x580002, // [94]
		460, 462, 0x130002, // [95]
		445, 447, 0x3004d, // [96]
		450, 452, 0x30053, // [97]
		455, 457, 0x30058, // [98]
		465, 468, 0x340074, // [99]
		475, 475, 0xc0002, // [100]
		468, 470, 0x3b0034, // [101]
		473, 473, 0x200003, // [102]
		470, 472, 0x4003b, // [103]
		478, 481, 0x3b007a, // [104]
		488, 488, 0xc0002, // [105]
		481, 483, 0x40003b, // [106]
		486, 486, 0x200003, // [107]
		483, 485, 0x40040, // [108]
		491, 494, 0x41007f, // [109]
		506, 506, 0xc0002, // [110]
		494, 497, 0x190041, // [111]
		501, 501, 0x460003, // [112]
		504, 504, 0x200003, // [113]
		497, 499, 0xc0019, // [114]
		501, 503, 0x40046, // [115]
		509, 516, 0x2b006b, // [116]
		520, 521, 0x290002, // [117]
		526, 526, 0x380002, // [118]
		530, 532, 0x290002, // [119]
		536, 536, 0x310002, // [120]
		516, 518, 0x3002b, // [121]
		521, 523, 0x30029, // [122]
		526, 528, 0x30038, // [123]
		532, 534, 0x30029, // [124]
		539, 541, 0x350045, // [125]
		545, 545, 0xc0002, // [126]
		541, 543, 0x30035, // [127]
		549, 550, 0x22005a, // [128]
		554, 555, 0x100002, // [129]
		559, 560, 0x290002, // [130]
		565, 565, 0x190002, // [131]
		550, 552, 0x30022, // [132]
		555, 557, 0x30010, // [133]
		560, 561, 0x510029, // [134]
		561, 563, 0x40051, // [135]
		568, 571, 0x3c0041, // [136]
		574, 574, 0xe0002, // [137]
		578, 581, 0x100002, // [138]
		584, 584, 0x240002, // [139]
		591, 591, 0x1d0002, // [140]
		571, 573, 0x3003c, // [141]
		574, 576, 0x3000e, // [142]
		581, 583, 0x30010, // [143]
		584, 586, 0x110024, // [144]
		589, 589, 0x340003, // [145]
		586, 588, 0x40011, // [146]
		595, 598, 0x350037, // [147]
		601, 602, 0xc0002, // [148]
		598, 600, 0x30035, // [149]
		608, 610, 0xf0073, // [150]
		613, 613, 0x250002, // [151]
		616, 626, 0x110002, // [152]
		658, 658, 0x220002, // [153]
		661, 661, 0x1a0002, // [154]
		610, 612, 0x3000f, // [155]
		613, 615, 0x30025, // [156]
		626, 628, 0x1e0011, // [157]
		631, 634, 0x110003, // [158]
		637, 637, 0x300003, // [159]
		640, 641, 0x110003, // [160]
		645, 645, 0xf0003, // [161]
		651, 651, 0x240003, // [162]
		656, 656, 0x330003, // [163]
		628, 630, 0x4001e, // [164]
		634, 636, 0x40011, // [165]
		637, 638, 0xc0030, // [166]
		641, 643, 0x40011, // [167]
		645, 649, 0x4000f, // [168]
		651, 655, 0x40024, // [169]
		658, 660, 0x30022, // [170]
		665, 666, 0x25003f, // [171]
		669, 671, 0x350002, // [172]
		674, 677, 0xc0002, // [173]
		666, 668, 0x30025, // [174]
		671, 673, 0x30035, // [175]
		681, 684, 0x12006b, // [176]
		688, 701, 0x130002, // [177]
		754, 754, 0x200002, // [178]
		684, 686, 0x30012, // [179]
		701, 705, 0x4e0013, // [180]
		719, 721, 0x110003, // [181]
		724, 724, 0xe0003, // [182]
		731, 731, 0x3e0003, // [183]
		741, 743, 0x110003, // [184]
		748, 748, 0x5a0003, // [185]
		705, 708, 0x9004e, // [186]
		721, 723, 0x40011, // [187]
		724, 725, 0xc000e, // [188]
		731, 733, 0x2a003e, // [189]
		733, 738, 0x5002a, // [190]
		743, 745, 0x40011, // [191]
		748, 751, 0x4005a, // [192]
		758, 762, 0x10006b, // [193]
		765, 767, 0x340002, // [194]
		770, 771, 0xc0002, // [195]
		762, 764, 0x30010, // [196]
		767, 769, 0x30034, // [197]
		774, 775, 0x490044, // [198]
		778, 778, 0xc0002, // [199]
		775, 777, 0x30049, // [200]
		778, 783, 0x11000c, // [201]
		786, 786, 0x220003, // [202]
		783, 785, 0x40011, // [203]
		790, 793, 0x2b0045, // [204]
		796, 796, 0x2c0002, // [205]
		809, 810, 0xc0002, // [206]
		793, 795, 0x3002b, // [207]
		796, 801, 0x24002c, // [208]
		804, 804, 0x320003, // [209]
		807, 807, 0x200003, // [210]
		801, 803, 0x40024, // [211]
		804, 806, 0x40032, // [212]
		813, 820, 0x11005c, // [213]
		830, 830, 0x1b0002, // [214]
		820, 825, 0x110011, // [215]
		828, 828, 0x5a0003, // [216]
		825, 827, 0x40011, // [217]
		833, 836, 0xc0025, // [218]
		836, 838, 0x7000c, // [219]
		838, 843, 0x40007, // [220]
		847, 857, 0x160049, // [221]
		903, 904, 0x650002, // [222]
		857, 862, 0x110016, // [223]
		866, 866, 0x300003, // [224]
		900, 900, 0x1b0003, // [225]
		862, 864, 0xc0011, // [226]
		866, 868, 0x260030, // [227]
		868, 874, 0x180026, // [228]
		895, 897, 0x320005, // [229]
		874, 883, 0x240018, // [230]
		883, 892, 0x70024, // [231]
		908, 909, 0xf003c, // [232]
		912, 912, 0x260002, // [233]
		909, 911, 0x3000f, // [234]
		916, 918, 0x20031, // [235]
		921, 923, 0x20029, // [236]
		926, 928, 0x2001d, // [237]
		930, 931, 0xf0027, // [238]
		934, 934, 0x210002, // [239]
		931, 933, 0x3000f, // [240]
		937, 940, 0x350032, // [241]
		943, 943, 0x160002, // [242]
		940, 942, 0x30035, // [243]
		946, 949, 0x440042, // [244]
		952, 952, 0x330002, // [245]
		949, 951, 0x30044, // [246]
		959, 960, 0x90027, // [247]
		961, 962, 0x490021, // [248]
		963, 964, 0x46000a, // [249]
		968, 970, 0x20034, // [250]
		972, 973, 0x90025, // [251]
		974, 974, 0x210021, // [252]
		975, 975, 0xa000a, // [253]
		979, 981, 0x2002c, // [254]
		983, 986, 0x490063, // [255]
		989, 989, 0xe0002, // [256]
		992, 992, 0x220002, // [257]
		986, 988, 0x30049, // [258]
		989, 991, 0x3000e, // [259]
		995, 998, 0x3f0055, // [260]
		1001, 1001, 0xe0002, // [261]
		1004, 1004, 0x1d0002, // [262]
		998, 1000, 0x3003f, // [263]
		1001, 1003, 0x3000e, // [264]
	},
	NumStmt: [265]uint16{
		3, // 0
		3, // 1
		3, // 2
		1, // 3
		1, // 4
		3, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		2, // 16
		5, // 17
		1, // 18
		1, // 19
		1, // 20
		2, // 21
		3, // 22
		1, // 23
		1, // 24
		1, // 25
		2, // 26
		1, // 27
		1, // 28
		2, // 29
		1, // 30
		1, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		6, // 37
		6, // 38
		1, // 39
		1, // 40
		1, // 41
		4, // 42
		3, // 43
		3, // 44
		2, // 45
		1, // 46
		1, // 47
		1, // 48
		1, // 49
		1, // 50
		4, // 51
		3, // 52
		2, // 53
		2, // 54
		1, // 55
		1, // 56
		1, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		2, // 62
		1, // 63
		2, // 64
		2, // 65
		3, // 66
		1, // 67
		2, // 68
		1, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		1, // 74
		1, // 75
		1, // 76
		2, // 77
		3, // 78
		1, // 79
		1, // 80
		2, // 81
		1, // 82
		3, // 83
		1, // 84
		2, // 85
		1, // 86
		4, // 87
		1, // 88
		2, // 89
		5, // 90
		4, // 91
		2, // 92
		1, // 93
		1, // 94
		2, // 95
		1, // 96
		1, // 97
		1, // 98
		3, // 99
		1, // 100
		2, // 101
		1, // 102
		1, // 103
		3, // 104
		1, // 105
		2, // 106
		1, // 107
		1, // 108
		3, // 109
		1, // 110
		2, // 111
		1, // 112
		1, // 113
		2, // 114
		1, // 115
		2, // 116
		2, // 117
		1, // 118
		3, // 119
		1, // 120
		1, // 121
		1, // 122
		1, // 123
		1, // 124
		1, // 125
		1, // 126
		1, // 127
		1, // 128
		2, // 129
		2, // 130
		1, // 131
		1, // 132
		1, // 133
		1, // 134
		1, // 135
		3, // 136
		1, // 137
		4, // 138
		1, // 139
		1, // 140
		1, // 141
		1, // 142
		1, // 143
		2, // 144
		1, // 145
		1, // 146
		3, // 147
		2, // 148
		1, // 149
		2, // 150
		1, // 151
		9, // 152
		1, // 153
		1, // 154
		1, // 155
		1, // 156
		2, // 157
		4, // 158
		1, // 159
		2, // 160
		1, // 161
		1, // 162
		1, // 163
		1, // 164
		1, // 165
		1, // 166
		1, // 167
		3, // 168
		3, // 169
		1, // 170
		1, // 171
		3, // 172
		4, // 173
		1, // 174
		1, // 175
		1, // 176
		9, // 177
		1, // 178
		1, // 179
		3, // 180
		3, // 181
		1, // 182
		1, // 183
		3, // 184
		1, // 185
		1, // 186
		1, // 187
		1, // 188
		2, // 189
		2, // 190
		1, // 191
		2, // 192
		4, // 193
		3, // 194
		2, // 195
		1, // 196
		1, // 197
		1, // 198
		1, // 199
		1, // 200
		5, // 201
		1, // 202
		1, // 203
		3, // 204
		1, // 205
		2, // 206
		1, // 207
		3, // 208
		1, // 209
		1, // 210
		1, // 211
		1, // 212
		6, // 213
		1, // 214
		5, // 215
		1, // 216
		1, // 217
		3, // 218
		2, // 219
		4, // 220
		9, // 221
		2, // 222
		5, // 223
		1, // 224
		1, // 225
		2, // 226
		2, // 227
		5, // 228
		3, // 229
		9, // 230
		7, // 231
		1, // 232
		1, // 233
		1, // 234
		1, // 235
		1, // 236
		0, // 237
		1, // 238
		1, // 239
		1, // 240
		3, // 241
		1, // 242
		1, // 243
		3, // 244
		1, // 245
		1, // 246
		1, // 247
		1, // 248
		1, // 249
		1, // 250
		1, // 251
		0, // 252
		0, // 253
		1, // 254
		3, // 255
		1, // 256
		1, // 257
		1, // 258
		1, // 259
		3, // 260
		1, // 261
		1, // 262
		1, // 263
		1, // 264
	},
}
var _ = _cover_atomic_.LoadUint32
