//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/tests/verifier.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package tests; import _cover_atomic_ "sync/atomic"

import (
	"testing"

	"github.com/davecgh/go-spew/spew"
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/ledger"
	lgrutil "github.com/hyperledger/fabric/core/ledger/util"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
	protopeer "github.com/hyperledger/fabric/protos/peer"
	"github.com/stretchr/testify/assert"
)

// verifier provides functions that help tests with less verbose code for querying the ledger
// and verifying the actual results with the expected results
// For the straight forward functions, tests can call them directly on the ledger
type verifier struct {
	lgr    ledger.PeerLedger
	assert *assert.Assertions
	t      *testing.T
}

func newVerifier(lgr ledger.PeerLedger, t *testing.T) *verifier {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[0], 1);
	return &verifier{lgr, assert.New(t), t}
}

func (v *verifier) verifyLedgerHeight(expectedHt uint64) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[1], 1);
	info, err := v.lgr.GetBlockchainInfo()
	v.assert.NoError(err)
	v.assert.Equal(expectedHt, info.Height)
}

func (v *verifier) verifyPubState(ns, key string, expectedVal string) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[2], 1);
	qe, err := v.lgr.NewQueryExecutor()
	v.assert.NoError(err)
	defer qe.Done()
	committedVal, err := qe.GetState(ns, key)
	v.assert.NoError(err)
	v.t.Logf("val=%s", committedVal)
	var expectedValBytes []byte
	if expectedVal != "" {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[4], 1);
		expectedValBytes = []byte(expectedVal)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[3], 1);v.assert.Equal(expectedValBytes, committedVal)
}

func (v *verifier) verifyPvtState(ns, coll, key string, expectedVal string) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[5], 1);
	qe, err := v.lgr.NewQueryExecutor()
	v.assert.NoError(err)
	defer qe.Done()
	committedVal, err := qe.GetPrivateData(ns, coll, key)
	v.assert.NoError(err)
	v.t.Logf("val=%s", committedVal)
	var expectedValBytes []byte
	if expectedVal != "" {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[7], 1);
		expectedValBytes = []byte(expectedVal)
	}
	_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[6], 1);v.assert.Equal(expectedValBytes, committedVal)
}

func (v *verifier) verifyMostRecentCollectionConfigBelow(blockNum uint64, chaincodeName string, expectOut *expectedCollConfInfo) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[8], 1);
	configHistory, err := v.lgr.GetConfigHistoryRetriever()
	v.assert.NoError(err)
	actualCollectionConfigInfo, err := configHistory.MostRecentCollectionConfigBelow(blockNum, chaincodeName)
	v.assert.NoError(err)
	if expectOut == nil {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[10], 1);
		v.assert.Nil(actualCollectionConfigInfo)
		return
	}
	_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[9], 1);v.t.Logf("Retrieved CollectionConfigInfo=%s", spew.Sdump(actualCollectionConfigInfo))
	actualCommittingBlockNum := actualCollectionConfigInfo.CommittingBlockNum
	actualCollConf := convertFromCollConfigProto(actualCollectionConfigInfo.CollectionConfig)
	v.assert.Equal(expectOut.committingBlockNum, actualCommittingBlockNum)
	v.assert.Equal(expectOut.collConfs, actualCollConf)
}

func (v *verifier) verifyBlockAndPvtData(blockNum uint64, filter ledger.PvtNsCollFilter, verifyLogic func(r *retrievedBlockAndPvtdata)) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[11], 1);
	out, err := v.lgr.GetPvtDataAndBlockByNum(blockNum, filter)
	v.assert.NoError(err)
	v.t.Logf("Retrieved Block = %s, pvtdata = %s", spew.Sdump(out.Block), spew.Sdump(out.PvtData))
	verifyLogic(&retrievedBlockAndPvtdata{out, v.assert})
}

func (v *verifier) verifyBlockAndPvtDataSameAs(blockNum uint64, expectedOut *ledger.BlockAndPvtData) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[12], 1);
	v.verifyBlockAndPvtData(blockNum, nil, func(r *retrievedBlockAndPvtdata) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[13], 1);
		r.sameAs(expectedOut)
	})
}

func (v *verifier) verifyGetTransactionByID(txid string, expectedOut *protopeer.ProcessedTransaction) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[14], 1);
	tran, err := v.lgr.GetTransactionByID(txid)
	v.assert.NoError(err)
	envelopEqual := proto.Equal(expectedOut.TransactionEnvelope, tran.TransactionEnvelope)
	v.assert.True(envelopEqual)
	v.assert.Equal(expectedOut.ValidationCode, tran.ValidationCode)
}

func (v *verifier) verifyTxValidationCode(txid string, expectedCode protopeer.TxValidationCode) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[15], 1);
	tran, err := v.lgr.GetTransactionByID(txid)
	v.assert.NoError(err)
	v.assert.Equal(int32(expectedCode), tran.ValidationCode)
}

////////////  structs used by verifier  //////////////////////////////////////////////////////////////
type expectedCollConfInfo struct {
	committingBlockNum uint64
	collConfs          []*collConf
}

type retrievedBlockAndPvtdata struct {
	*ledger.BlockAndPvtData
	assert *assert.Assertions
}

func (r *retrievedBlockAndPvtdata) sameAs(expectedBlockAndPvtdata *ledger.BlockAndPvtData) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[16], 1);
	r.samePvtdata(expectedBlockAndPvtdata.PvtData)
	r.sameBlockHeaderAndData(expectedBlockAndPvtdata.Block)
	r.sameMetadata(expectedBlockAndPvtdata.Block)
}

func (r *retrievedBlockAndPvtdata) hasNumTx(numTx int) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[17], 1);
	r.assert.Len(r.Block.Data.Data, numTx)
}

func (r *retrievedBlockAndPvtdata) hasNoPvtdata() {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[18], 1);
	r.assert.Len(r.PvtData, 0)
}

func (r *retrievedBlockAndPvtdata) pvtdataShouldContain(txSeq int, ns, coll, key, value string) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[19], 1);
	txPvtData := r.BlockAndPvtData.PvtData[uint64(txSeq)]
	for _, nsdata := range txPvtData.WriteSet.NsPvtRwset {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[21], 1);
		if nsdata.Namespace == ns {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[22], 1);
			for _, colldata := range nsdata.CollectionPvtRwset {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[23], 1);
				if colldata.CollectionName == coll {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[24], 1);
					rwset := &kvrwset.KVRWSet{}
					r.assert.NoError(proto.Unmarshal(colldata.Rwset, rwset))
					for _, w := range rwset.Writes {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[25], 1);
						if w.Key == key {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[26], 1);
							r.assert.Equal([]byte(value), w.Value)
							return
						}
					}
				}
			}
		}
	}
	_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[20], 1);r.assert.FailNow("Requested kv not found")
}

func (r *retrievedBlockAndPvtdata) pvtdataShouldNotContain(ns, coll string) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[27], 1);
	allTxPvtData := r.BlockAndPvtData.PvtData
	for _, txPvtData := range allTxPvtData {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[28], 1);
		r.assert.False(txPvtData.Has(ns, coll))
	}
}

func (r *retrievedBlockAndPvtdata) sameBlockHeaderAndData(expectedBlock *common.Block) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[29], 1);
	r.assert.True(proto.Equal(expectedBlock.Data, r.BlockAndPvtData.Block.Data))
	r.assert.True(proto.Equal(expectedBlock.Header, r.BlockAndPvtData.Block.Header))
}

func (r *retrievedBlockAndPvtdata) sameMetadata(expectedBlock *common.Block) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[30], 1);
	// marshalling/unmarshalling treats a nil byte and empty byte interchangeably (based on which scheme is chosen proto vs gob)
	// so explicitly comparing each metadata
	retrievedMetadata := r.Block.Metadata.Metadata
	expectedMetadata := expectedBlock.Metadata.Metadata
	r.assert.Equal(len(expectedMetadata), len(retrievedMetadata))
	for i := 0; i < len(retrievedMetadata); i++ {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[31], 1);
		if len(expectedMetadata[i])+len(retrievedMetadata[i]) != 0 {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[32], 1);
			r.assert.Equal(expectedMetadata[i], retrievedMetadata[i])
		}
	}
}

func (r *retrievedBlockAndPvtdata) containsValidationCode(txSeq int, validationCode protopeer.TxValidationCode) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[33], 1);
	var txFilter lgrutil.TxValidationFlags
	txFilter = r.BlockAndPvtData.Block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER]
	r.assert.Equal(validationCode, txFilter.Flag(txSeq))
}

func (r *retrievedBlockAndPvtdata) samePvtdata(expectedPvtdata map[uint64]*ledger.TxPvtData) {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[34], 1);
	r.assert.Equal(len(expectedPvtdata), len(r.BlockAndPvtData.PvtData))
	for txNum, pvtData := range expectedPvtdata {_cover_atomic_.AddUint32(&GoCover_6_363234376562373564353161.Count[35], 1);
		actualPvtData := r.BlockAndPvtData.PvtData[txNum]
		r.assert.Equal(pvtData.SeqInBlock, actualPvtData.SeqInBlock)
		r.assert.True(proto.Equal(pvtData.WriteSet, actualPvtData.WriteSet))
	}
}

var GoCover_6_363234376562373564353161 = struct {
	Count     [36]uint32
	Pos       [3 * 36]uint32
	NumStmt   [36]uint16
} {
	Pos: [3 * 36]uint32{
		31, 33, 0x20041, // [0]
		35, 39, 0x2003a, // [1]
		41, 49, 0x170047, // [2]
		52, 52, 0x300002, // [3]
		49, 51, 0x30017, // [4]
		55, 63, 0x17004d, // [5]
		66, 66, 0x300002, // [6]
		63, 65, 0x30017, // [7]
		69, 74, 0x160082, // [8]
		78, 82, 0x350002, // [9]
		74, 77, 0x30016, // [10]
		85, 90, 0x20089, // [11]
		92, 93, 0x4b0066, // [12]
		93, 95, 0x3004b, // [13]
		98, 104, 0x20067, // [14]
		106, 110, 0x20061, // [15]
		123, 127, 0x2005c, // [16]
		129, 131, 0x20038, // [17]
		133, 135, 0x20033, // [18]
		137, 139, 0x370061, // [19]
		155, 155, 0x2c0002, // [20]
		139, 140, 0x1d0037, // [21]
		140, 141, 0x37001d, // [22]
		141, 142, 0x280037, // [23]
		142, 145, 0x250028, // [24]
		145, 146, 0x170025, // [25]
		146, 149, 0x80017, // [26]
		158, 160, 0x29004d, // [27]
		160, 162, 0x30029, // [28]
		165, 168, 0x20058, // [29]
		170, 176, 0x2e004e, // [30]
		176, 177, 0x3e002e, // [31]
		177, 179, 0x4003e, // [32]
		183, 187, 0x20071, // [33]
		189, 191, 0x2e005e, // [34]
		191, 195, 0x3002e, // [35]
	},
	NumStmt: [36]uint16{
		1, // 0
		3, // 1
		8, // 2
		1, // 3
		1, // 4
		8, // 5
		1, // 6
		1, // 7
		5, // 8
		5, // 9
		2, // 10
		4, // 11
		1, // 12
		1, // 13
		5, // 14
		3, // 15
		3, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		3, // 24
		1, // 25
		2, // 26
		2, // 27
		1, // 28
		2, // 29
		4, // 30
		1, // 31
		1, // 32
		3, // 33
		2, // 34
		3, // 35
	},
}
var _ = _cover_atomic_.LoadUint32
