//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/util/couchdb/couchdbutil.go:1
/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package couchdb; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"encoding/hex"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hyperledger/fabric/common/metrics"
	"github.com/hyperledger/fabric/common/util"
	"github.com/pkg/errors"
)

var expectedDatabaseNamePattern = `[a-z][a-z0-9.$_()+-]*`
var maxLength = 238

// To restrict the length of couchDB database name to the
// allowed length of 249 chars, the string length limit
// for chain/channel name, namespace/chaincode name, and
// collection name, which constitutes the database name,
// is defined.
var chainNameAllowedLength = 50
var namespaceNameAllowedLength = 50
var collectionNameAllowedLength = 50

//CreateCouchInstance creates a CouchDB instance
func CreateCouchInstance(couchDBConnectURL, id, pw string, maxRetries,
	maxRetriesOnStartup int, connectionTimeout time.Duration, createGlobalChangesDB bool, metricsProvider metrics.Provider) (*CouchInstance, error) {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[0], 1);

	couchConf, err := CreateConnectionDefinition(couchDBConnectURL,
		id, pw, maxRetries, maxRetriesOnStartup, connectionTimeout, createGlobalChangesDB)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[5], 1);
		logger.Errorf("Error calling CouchDB CreateConnectionDefinition(): %s", err)
		return nil, err
	}

	// Create the http client once
	// Clients and Transports are safe for concurrent use by multiple goroutines
	// and for efficiency should only be created once and re-used.
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[1], 1);client := &http.Client{Timeout: couchConf.RequestTimeout}

	transport := &http.Transport{Proxy: http.ProxyFromEnvironment}
	transport.DisableCompression = false
	client.Transport = transport

	//Create the CouchDB instance
	couchInstance := &CouchInstance{conf: *couchConf, client: client}
	couchInstance.stats = newStats(metricsProvider)
	connectInfo, retVal, verifyErr := couchInstance.VerifyCouchConfig()
	if verifyErr != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[6], 1);
		return nil, verifyErr
	}

	//return an error if the http return value is not 200
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[2], 1);if retVal.StatusCode != 200 {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[7], 1);
		return nil, errors.Errorf("CouchDB connection error, expecting return code of 200, received %v", retVal.StatusCode)
	}

	//check the CouchDB version number, return an error if the version is not at least 2.0.0
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[3], 1);errVersion := checkCouchDBVersion(connectInfo.Version)
	if errVersion != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[8], 1);
		return nil, errVersion
	}

	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[4], 1);return couchInstance, nil
}

//checkCouchDBVersion verifies CouchDB is at least 2.0.0
func checkCouchDBVersion(version string) error {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[9], 1);

	//split the version into parts
	majorVersion := strings.Split(version, ".")

	//check to see that the major version number is at least 2
	majorVersionInt, _ := strconv.Atoi(majorVersion[0])
	if majorVersionInt < 2 {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[11], 1);
		return errors.Errorf("CouchDB must be at least version 2.0.0. Detected version %s", version)
	}

	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[10], 1);return nil
}

//CreateCouchDatabase creates a CouchDB database object, as well as the underlying database if it does not exist
func CreateCouchDatabase(couchInstance *CouchInstance, dbName string) (*CouchDatabase, error) {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[12], 1);

	databaseName, err := mapAndValidateDatabaseName(dbName)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[15], 1);
		logger.Errorf("Error calling CouchDB CreateDatabaseIfNotExist() for dbName: %s, error: %s", dbName, err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[13], 1);couchDBDatabase := CouchDatabase{CouchInstance: couchInstance, DBName: databaseName, IndexWarmCounter: 1}

	// Create CouchDB database upon ledger startup, if it doesn't already exist
	err = couchDBDatabase.CreateDatabaseIfNotExist()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[16], 1);
		logger.Errorf("Error calling CouchDB CreateDatabaseIfNotExist() for dbName: %s, error: %s", dbName, err)
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[14], 1);return &couchDBDatabase, nil
}

//CreateSystemDatabasesIfNotExist - creates the system databases if they do not exist
func CreateSystemDatabasesIfNotExist(couchInstance *CouchInstance) error {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[17], 1);

	dbName := "_users"
	systemCouchDBDatabase := CouchDatabase{CouchInstance: couchInstance, DBName: dbName, IndexWarmCounter: 1}
	err := systemCouchDBDatabase.CreateDatabaseIfNotExist()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[21], 1);
		logger.Errorf("Error calling CouchDB CreateDatabaseIfNotExist() for system dbName: %s, error: %s", dbName, err)
		return err
	}

	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[18], 1);dbName = "_replicator"
	systemCouchDBDatabase = CouchDatabase{CouchInstance: couchInstance, DBName: dbName, IndexWarmCounter: 1}
	err = systemCouchDBDatabase.CreateDatabaseIfNotExist()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[22], 1);
		logger.Errorf("Error calling CouchDB CreateDatabaseIfNotExist() for system dbName: %s, error: %s", dbName, err)
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[19], 1);if couchInstance.conf.CreateGlobalChangesDB {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[23], 1);
		dbName = "_global_changes"
		systemCouchDBDatabase = CouchDatabase{CouchInstance: couchInstance, DBName: dbName, IndexWarmCounter: 1}
		err = systemCouchDBDatabase.CreateDatabaseIfNotExist()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[24], 1);
			logger.Errorf("Error calling CouchDB CreateDatabaseIfNotExist() for system dbName: %s, error: %s", dbName, err)
			return err
		}
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[20], 1);return nil

}

// constructCouchDBUrl constructs a couchDB url with encoding for the database name
// and all path elements
func constructCouchDBUrl(connectURL *url.URL, dbName string, pathElements ...string) *url.URL {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[25], 1);
	var buffer bytes.Buffer
	buffer.WriteString(connectURL.String())
	if dbName != "" {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[28], 1);
		buffer.WriteString("/")
		buffer.WriteString(encodePathElement(dbName))
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[26], 1);for _, pathElement := range pathElements {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[29], 1);
		buffer.WriteString("/")
		buffer.WriteString(encodePathElement(pathElement))
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[27], 1);return &url.URL{Opaque: buffer.String()}
}

// ConstructMetadataDBName truncates the db name to couchdb allowed length to
// construct the metadataDBName
func ConstructMetadataDBName(dbName string) string {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[30], 1);
	if len(dbName) > maxLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[32], 1);
		untruncatedDBName := dbName
		// Truncate the name if the length violates the allowed limit
		// As the passed dbName is same as chain/channel name, truncate using chainNameAllowedLength
		dbName = dbName[:chainNameAllowedLength]
		// For metadataDB (i.e., chain/channel DB), the dbName contains <first 50 chars
		// (i.e., chainNameAllowedLength) of chainName> + (SHA256 hash of actual chainName)
		dbName = dbName + "(" + hex.EncodeToString(util.ComputeSHA256([]byte(untruncatedDBName))) + ")"
		// 50 chars for dbName + 1 char for ( + 64 chars for sha256 + 1 char for ) = 116 chars
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[31], 1);return dbName + "_"
}

// ConstructNamespaceDBName truncates db name to couchdb allowed length to
// construct the namespaceDBName
func ConstructNamespaceDBName(chainName, namespace string) string {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[33], 1);
	// replace upper-case in namespace with a escape sequence '$' and the respective lower-case letter
	escapedNamespace := escapeUpperCase(namespace)
	namespaceDBName := chainName + "_" + escapedNamespace

	// For namespaceDBName of form 'chainName_namespace', on length limit violation, the truncated
	// namespaceDBName would contain <first 50 chars (i.e., chainNameAllowedLength) of chainName> + "_" +
	// <first 50 chars (i.e., namespaceNameAllowedLength) chars of namespace> +
	// (<SHA256 hash of [chainName_namespace]>)
	//
	// For namespaceDBName of form 'chainName_namespace$$collection', on length limit violation, the truncated
	// namespaceDBName would contain <first 50 chars (i.e., chainNameAllowedLength) of chainName> + "_" +
	// <first 50 chars (i.e., namespaceNameAllowedLength) of namespace> + "$$" + <first 50 chars
	// (i.e., collectionNameAllowedLength) of collection> + (<SHA256 hash of [chainName_namespace$$pcollection]>)

	if len(namespaceDBName) > maxLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[35], 1);
		// Compute the hash of untruncated namespaceDBName that needs to be appended to
		// truncated namespaceDBName for maintaining uniqueness
		hashOfNamespaceDBName := hex.EncodeToString(util.ComputeSHA256([]byte(chainName + "_" + namespace)))

		// As truncated namespaceDBName is of form 'chainName_escapedNamespace', both chainName
		// and escapedNamespace need to be truncated to defined allowed length.
		if len(chainName) > chainNameAllowedLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[39], 1);
			// Truncate chainName to chainNameAllowedLength
			chainName = chainName[0:chainNameAllowedLength]
		}
		// As escapedNamespace can be of either 'namespace' or 'namespace$$collectionName',
		// both 'namespace' and 'collectionName' need to be truncated to defined allowed length.
		// '$$' is used as joiner between namespace and collection name.
		// Split the escapedNamespace into escaped namespace and escaped collection name if exist.
		_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[36], 1);names := strings.Split(escapedNamespace, "$$")
		namespace := names[0]
		if len(namespace) > namespaceNameAllowedLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[40], 1);
			// Truncate the namespace
			namespace = namespace[0:namespaceNameAllowedLength]
		}

		_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[37], 1);escapedNamespace = namespace

		// Check and truncate the length of collection name if exist
		if len(names) == 2 {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[41], 1);
			collection := names[1]
			if len(collection) > collectionNameAllowedLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[43], 1);
				// Truncate the escaped collection name
				collection = collection[0:collectionNameAllowedLength]
			}
			// Append truncated collection name to escapedNamespace
			_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[42], 1);escapedNamespace = escapedNamespace + "$$" + collection
		}
		// Construct and return the namespaceDBName
		// 50 chars for chainName + 1 char for '_' + 102 chars for escaped namespace + 1 char for '(' + 64 chars
		// for sha256 hash + 1 char for ')' = 219 chars
		_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[38], 1);return chainName + "_" + escapedNamespace + "(" + hashOfNamespaceDBName + ")"
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[34], 1);return namespaceDBName
}

//mapAndValidateDatabaseName checks to see if the database name contains illegal characters
//CouchDB Rules: Only lowercase characters (a-z), digits (0-9), and any of the characters
//_, $, (, ), +, -, and / are allowed. Must begin with a letter.
//
//Restictions have already been applied to the database name from Orderer based on
//restrictions required by Kafka and couchDB (except a '.' char). The databaseName
// passed in here is expected to follow `[a-z][a-z0-9.$_-]*` pattern.
//
//This validation will simply check whether the database name matches the above pattern and will replace
// all occurence of '.' by '$'. This will not cause collisions in the transformed named
func mapAndValidateDatabaseName(databaseName string) (string, error) {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[44], 1);
	// test Length
	if len(databaseName) <= 0 {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[49], 1);
		return "", errors.Errorf("database name is illegal, cannot be empty")
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[45], 1);if len(databaseName) > maxLength {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[50], 1);
		return "", errors.Errorf("database name is illegal, cannot be longer than %d", maxLength)
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[46], 1);re, err := regexp.Compile(expectedDatabaseNamePattern)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[51], 1);
		return "", errors.Wrapf(err, "error compiling regexp: %s", expectedDatabaseNamePattern)
	}
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[47], 1);matched := re.FindString(databaseName)
	if len(matched) != len(databaseName) {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[52], 1);
		return "", errors.Errorf("databaseName '%s' does not match pattern '%s'", databaseName, expectedDatabaseNamePattern)
	}
	// replace all '.' to '$'. The databaseName passed in will never contain an '$'.
	// So, this translation will not cause collisions
	_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[48], 1);databaseName = strings.Replace(databaseName, ".", "$", -1)
	return databaseName, nil
}

// escapeUpperCase replaces every upper case letter with a '$' and the respective
// lower-case letter
func escapeUpperCase(dbName string) string {_cover_atomic_.AddUint32(&GoCover_2_646532663132623064613838.Count[53], 1);
	re := regexp.MustCompile(`([A-Z])`)
	dbName = re.ReplaceAllString(dbName, "$$"+"$1")
	return strings.ToLower(dbName)
}

var GoCover_2_646532663132623064613838 = struct {
	Count     [54]uint32
	Pos       [3 * 54]uint32
	NumStmt   [54]uint16
} {
	Pos: [3 * 54]uint32{
		37, 41, 0x100092, // [0]
		49, 59, 0x160002, // [1]
		64, 64, 0x1e0002, // [2]
		69, 70, 0x170002, // [3]
		74, 74, 0x1b0002, // [4]
		41, 44, 0x30010, // [5]
		59, 61, 0x30016, // [6]
		64, 66, 0x3001e, // [7]
		70, 72, 0x30017, // [8]
		78, 85, 0x190030, // [9]
		89, 89, 0xc0002, // [10]
		85, 87, 0x30019, // [11]
		93, 96, 0x10005f, // [12]
		101, 105, 0x100002, // [13]
		110, 110, 0x1e0002, // [14]
		96, 99, 0x30010, // [15]
		105, 108, 0x30010, // [16]
		114, 119, 0x10004a, // [17]
		124, 127, 0x100002, // [18]
		131, 131, 0x2e0002, // [19]
		140, 140, 0xc0002, // [20]
		119, 122, 0x30010, // [21]
		127, 130, 0x30010, // [22]
		131, 135, 0x11002e, // [23]
		135, 138, 0x40011, // [24]
		146, 149, 0x12005f, // [25]
		153, 153, 0x2b0002, // [26]
		157, 157, 0x2a0002, // [27]
		149, 152, 0x30012, // [28]
		153, 156, 0x3002b, // [29]
		162, 163, 0x1d0034, // [30]
		173, 173, 0x150002, // [31]
		163, 172, 0x3001d, // [32]
		178, 193, 0x260043, // [33]
		232, 232, 0x180002, // [34]
		193, 200, 0x2e0026, // [35]
		208, 210, 0x320003, // [36]
		215, 218, 0x160003, // [37]
		230, 230, 0x500003, // [38]
		200, 203, 0x4002e, // [39]
		210, 213, 0x40032, // [40]
		218, 220, 0x350016, // [41]
		225, 225, 0x3b0004, // [42]
		220, 223, 0x50035, // [43]
		245, 247, 0x1c0046, // [44]
		250, 250, 0x230002, // [45]
		253, 254, 0x100002, // [46]
		257, 258, 0x270002, // [47]
		263, 264, 0x1a0002, // [48]
		247, 249, 0x3001c, // [49]
		250, 252, 0x30023, // [50]
		254, 256, 0x30010, // [51]
		258, 260, 0x30027, // [52]
		269, 273, 0x2002c, // [53]
	},
	NumStmt: [54]uint16{
		2, // 0
		8, // 1
		1, // 2
		2, // 3
		1, // 4
		2, // 5
		1, // 6
		1, // 7
		1, // 8
		3, // 9
		1, // 10
		1, // 11
		2, // 12
		3, // 13
		1, // 14
		2, // 15
		2, // 16
		4, // 17
		4, // 18
		1, // 19
		1, // 20
		2, // 21
		2, // 22
		4, // 23
		2, // 24
		3, // 25
		1, // 26
		1, // 27
		2, // 28
		2, // 29
		1, // 30
		1, // 31
		3, // 32
		3, // 33
		1, // 34
		2, // 35
		3, // 36
		2, // 37
		1, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		2, // 46
		2, // 47
		2, // 48
		1, // 49
		1, // 50
		1, // 51
		1, // 52
		3, // 53
	},
}
var _ = _cover_atomic_.LoadUint32
