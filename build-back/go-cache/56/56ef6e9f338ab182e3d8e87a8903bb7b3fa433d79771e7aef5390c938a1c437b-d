//line /home/cooper/go/src/github.com/hyperledger/fabric/core/common/ccpackage/ccpackage.go:1
/*
Copyright IBM Corp. 2016-2017 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ccpackage; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/msp"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	"github.com/hyperledger/fabric/protos/utils"
)

// ExtractSignedCCDepSpec extracts the messages from the envelope
func ExtractSignedCCDepSpec(env *common.Envelope) (*common.ChannelHeader, *peer.SignedChaincodeDeploymentSpec, error) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[0], 1);
	p := &common.Payload{}
	err := proto.Unmarshal(env.Payload, p)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[5], 1);
		return nil, nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[1], 1);if p.Header == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[6], 1);
		return nil, nil, errors.New("channel header cannot be nil")
	}
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[2], 1);ch := &common.ChannelHeader{}
	err = proto.Unmarshal(p.Header.ChannelHeader, ch)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[7], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[3], 1);sp := &peer.SignedChaincodeDeploymentSpec{}
	err = proto.Unmarshal(p.Data, sp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[8], 1);
		return nil, nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[4], 1);return ch, sp, nil
}

// This file provides functions for helping with the chaincode install
// package workflow. In particular
//     OwnerCreateSignedCCDepSpec - each owner creates signs the package using the same deploy
//     CreateSignedCCDepSpecForInstall - an admin or owner creates the package to be installed
//                                       using the packages from OwnerCreateSignedCCDepSpec

// ValidateCip validate the endorsed package against the base package
func ValidateCip(baseCip, otherCip *peer.SignedChaincodeDeploymentSpec) error {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[9], 1);
	if baseCip == nil || otherCip == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[16], 1);
		panic("do not call with nil parameters")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[10], 1);if (baseCip.OwnerEndorsements == nil && otherCip.OwnerEndorsements != nil) || (baseCip.OwnerEndorsements != nil && otherCip.OwnerEndorsements == nil) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[17], 1);
		return fmt.Errorf("endorsements should either be both nil or not nil")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[11], 1);bN := len(baseCip.OwnerEndorsements)
	oN := len(otherCip.OwnerEndorsements)
	if bN > 1 || oN > 1 {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[18], 1);
		return fmt.Errorf("expect utmost 1 endorsement from a owner")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[12], 1);if bN != oN {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[19], 1);
		return fmt.Errorf("Rule-all packages should be endorsed or none should be endorsed failed for (%d, %d)", bN, oN)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[13], 1);if !bytes.Equal(baseCip.ChaincodeDeploymentSpec, otherCip.ChaincodeDeploymentSpec) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[20], 1);
		return fmt.Errorf("Rule-all deployment specs should match(%d, %d)", len(baseCip.ChaincodeDeploymentSpec), len(otherCip.ChaincodeDeploymentSpec))
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[14], 1);if !bytes.Equal(baseCip.InstantiationPolicy, otherCip.InstantiationPolicy) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[21], 1);
		return fmt.Errorf("Rule-all instantiation policies should match(%d, %d)", len(baseCip.InstantiationPolicy), len(otherCip.InstantiationPolicy))
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[15], 1);return nil
}

func createSignedCCDepSpec(cdsbytes []byte, instpolicybytes []byte, endorsements []*peer.Endorsement) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[22], 1);
	if cdsbytes == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[26], 1);
		return nil, fmt.Errorf("nil chaincode deployment spec")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[23], 1);if instpolicybytes == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[27], 1);
		return nil, fmt.Errorf("nil instantiation policy")
	}

	// create SignedChaincodeDeploymentSpec...
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[24], 1);cip := &peer.SignedChaincodeDeploymentSpec{ChaincodeDeploymentSpec: cdsbytes, InstantiationPolicy: instpolicybytes, OwnerEndorsements: endorsements}

	//...and marshal it
	cipbytes := utils.MarshalOrPanic(cip)

	//use defaults (this is definitely ok for install package)
	msgVersion := int32(0)
	epoch := uint64(0)
	chdr := utils.MakeChannelHeader(common.HeaderType_CHAINCODE_PACKAGE, msgVersion, "", epoch)

	// create the payload
	payl := &common.Payload{Header: &common.Header{ChannelHeader: utils.MarshalOrPanic(chdr)}, Data: cipbytes}
	paylBytes, err := utils.GetBytesPayload(payl)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[28], 1);
		return nil, err
	}

	// here's the unsigned  envelope. The install package is endorsed if signingEntity != nil
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[25], 1);return &common.Envelope{Payload: paylBytes}, nil
}

// CreateSignedCCDepSpecForInstall creates the final package from a set of packages signed by
// owners.  This is similar to how the SDK assembles a TX from various proposal
// responses from the signatures.
func CreateSignedCCDepSpecForInstall(pack []*common.Envelope) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[29], 1);
	if len(pack) == 0 {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[32], 1);
		return nil, errors.New("no packages provided to collate")
	}

	//rules...
	//   all packages must be endorsed or all packages should not be endorsed
	//   the chaincode deployment spec should be same
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[30], 1);var baseCip *peer.SignedChaincodeDeploymentSpec
	var err error
	var endorsementExists bool
	var endorsements []*peer.Endorsement
	for n, r := range pack {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[33], 1);
		p := &common.Payload{}
		if err = proto.Unmarshal(r.Payload, p); err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[37], 1);
			return nil, err
		}

		_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[34], 1);cip := &peer.SignedChaincodeDeploymentSpec{}
		if err = proto.Unmarshal(p.Data, cip); err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[38], 1);
			return nil, err
		}

		//if its the first element, check if it has endorsement so we can
		//enforce endorsement rules
		_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[35], 1);if n == 0 {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[39], 1);
			baseCip = cip
			//if it has endorsement, all other owners should have signed too
			if len(cip.OwnerEndorsements) > 0 {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[40], 1);
				endorsements = make([]*peer.Endorsement, len(pack))
			}

		} else{ _cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[41], 1);if err = ValidateCip(baseCip, cip); err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[42], 1);
			return nil, err
		}}

		_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[36], 1);if endorsementExists {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[43], 1);
			endorsements[n] = cip.OwnerEndorsements[0]
		}
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[31], 1);return createSignedCCDepSpec(baseCip.ChaincodeDeploymentSpec, baseCip.InstantiationPolicy, endorsements)
}

// OwnerCreateSignedCCDepSpec creates a package from a ChaincodeDeploymentSpec and
// optionally endorses it
func OwnerCreateSignedCCDepSpec(cds *peer.ChaincodeDeploymentSpec, instPolicy *common.SignaturePolicyEnvelope, owner msp.SigningIdentity) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[44], 1);
	if cds == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[48], 1);
		return nil, fmt.Errorf("invalid chaincode deployment spec")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[45], 1);if instPolicy == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[49], 1);
		return nil, fmt.Errorf("must provide an instantiation policy")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[46], 1);cdsbytes := utils.MarshalOrPanic(cds)

	instpolicybytes := utils.MarshalOrPanic(instPolicy)

	var endorsements []*peer.Endorsement
	//it is not mandatory (at this utils level) to have a signature
	//this is especially convenient during dev/test
	//it may be necessary to enforce it via a policy at a higher level
	if owner != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[50], 1);
		// serialize the signing identity
		endorser, err := owner.Serialize()
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[53], 1);
			return nil, fmt.Errorf("Could not serialize the signing identity for %s, err %s", owner.GetIdentifier(), err)
		}

		// sign the concatenation of cds, instpolicy and the serialized endorser identity with this endorser's key
		_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[51], 1);signature, err := owner.Sign(append(cdsbytes, append(instpolicybytes, endorser...)...))
		if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[54], 1);
			return nil, fmt.Errorf("Could not sign the ccpackage, err %s", err)
		}

		// each owner starts off the endorsements with one element. All such endorsed
		// packages will be collected in a final package by CreateSignedCCDepSpecForInstall
		// when endorsements will have all the entries
		_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[52], 1);endorsements = make([]*peer.Endorsement, 1)

		endorsements[0] = &peer.Endorsement{Signature: signature, Endorser: endorser}
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[47], 1);return createSignedCCDepSpec(cdsbytes, instpolicybytes, endorsements)
}

// SignExistingPackage adds a signature to a signed package.
func SignExistingPackage(env *common.Envelope, owner msp.SigningIdentity) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[55], 1);
	if owner == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[62], 1);
		return nil, fmt.Errorf("owner not provided")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[56], 1);ch, sdepspec, err := ExtractSignedCCDepSpec(env)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[63], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[57], 1);if ch == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[64], 1);
		return nil, fmt.Errorf("channel header not found in the envelope")
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[58], 1);if sdepspec == nil || sdepspec.ChaincodeDeploymentSpec == nil || sdepspec.InstantiationPolicy == nil || sdepspec.OwnerEndorsements == nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[65], 1);
		return nil, fmt.Errorf("invalid signed deployment spec")
	}

	// serialize the signing identity
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[59], 1);endorser, err := owner.Serialize()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[66], 1);
		return nil, fmt.Errorf("Could not serialize the signing identity for %s, err %s", owner.GetIdentifier(), err)
	}

	// sign the concatenation of cds, instpolicy and the serialized endorser identity with this endorser's key
	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[60], 1);signature, err := owner.Sign(append(sdepspec.ChaincodeDeploymentSpec, append(sdepspec.InstantiationPolicy, endorser...)...))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[67], 1);
		return nil, fmt.Errorf("Could not sign the ccpackage, err %s", err)
	}

	_cover_atomic_.AddUint32(&GoCover_0_626638363333343334633936.Count[61], 1);endorsements := append(sdepspec.OwnerEndorsements, &peer.Endorsement{Signature: signature, Endorser: endorser})

	return createSignedCCDepSpec(sdepspec.ChaincodeDeploymentSpec, sdepspec.InstantiationPolicy, endorsements)
}

var GoCover_0_626638363333343334633936 = struct {
	Count     [68]uint32
	Pos       [3 * 68]uint32
	NumStmt   [68]uint16
} {
	Pos: [3 * 68]uint32{
		32, 35, 0x100077, // [0]
		38, 38, 0x150002, // [1]
		41, 43, 0x100002, // [2]
		47, 49, 0x100002, // [3]
		53, 53, 0x140002, // [4]
		35, 37, 0x30010, // [5]
		38, 40, 0x30015, // [6]
		43, 45, 0x30010, // [7]
		49, 51, 0x30010, // [8]
		63, 64, 0x27004f, // [9]
		68, 68, 0x980002, // [10]
		72, 74, 0x160002, // [11]
		78, 78, 0xe0002, // [12]
		82, 82, 0x550002, // [13]
		86, 86, 0x4d0002, // [14]
		90, 90, 0xc0002, // [15]
		64, 65, 0x2b0027, // [16]
		68, 70, 0x30098, // [17]
		74, 76, 0x30016, // [18]
		78, 80, 0x3000e, // [19]
		82, 84, 0x30055, // [20]
		86, 88, 0x3004d, // [21]
		93, 94, 0x150081, // [22]
		98, 98, 0x1c0002, // [23]
		103, 116, 0x100002, // [24]
		121, 121, 0x320002, // [25]
		94, 96, 0x30015, // [26]
		98, 100, 0x3001c, // [27]
		116, 118, 0x30010, // [28]
		127, 128, 0x140059, // [29]
		135, 139, 0x190002, // [30]
		168, 168, 0x6a0002, // [31]
		128, 130, 0x30014, // [32]
		139, 141, 0x360019, // [33]
		145, 146, 0x350003, // [34]
		152, 152, 0xd0003, // [35]
		163, 163, 0x180003, // [36]
		141, 143, 0x40036, // [37]
		146, 148, 0x40035, // [38]
		152, 155, 0x26000d, // [39]
		155, 157, 0x50026, // [40]
		159, 159, 0x390009, // [41]
		159, 161, 0x40039, // [42]
		163, 165, 0x40018, // [43]
		173, 174, 0x1000a5, // [44]
		178, 178, 0x170002, // [45]
		182, 190, 0x120002, // [46]
		211, 211, 0x470002, // [47]
		174, 176, 0x30010, // [48]
		178, 180, 0x30017, // [49]
		190, 193, 0x110012, // [50]
		198, 199, 0x110003, // [51]
		206, 208, 0x500003, // [52]
		193, 195, 0x40011, // [53]
		199, 201, 0x40011, // [54]
		215, 216, 0x120065, // [55]
		220, 221, 0x100002, // [56]
		225, 225, 0xf0002, // [57]
		229, 229, 0x8c0002, // [58]
		234, 235, 0x100002, // [59]
		240, 241, 0x100002, // [60]
		245, 247, 0x6c0002, // [61]
		216, 218, 0x30012, // [62]
		221, 223, 0x30010, // [63]
		225, 227, 0x3000f, // [64]
		229, 231, 0x3008c, // [65]
		235, 237, 0x30010, // [66]
		241, 243, 0x30010, // [67]
	},
	NumStmt: [68]uint16{
		3, // 0
		1, // 1
		3, // 2
		3, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		3, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		8, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		5, // 30
		1, // 31
		1, // 32
		2, // 33
		2, // 34
		1, // 35
		1, // 36
		1, // 37
		1, // 38
		2, // 39
		1, // 40
		1, // 41
		1, // 42
		1, // 43
		1, // 44
		1, // 45
		4, // 46
		1, // 47
		1, // 48
		1, // 49
		2, // 50
		2, // 51
		2, // 52
		1, // 53
		1, // 54
		1, // 55
		2, // 56
		1, // 57
		1, // 58
		2, // 59
		2, // 60
		2, // 61
		1, // 62
		1, // 63
		1, // 64
		1, // 65
		1, // 66
		1, // 67
	},
}
var _ = _cover_atomic_.LoadUint32
