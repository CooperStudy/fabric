//line /home/cooper/go/src/github.com/hyperledger/fabric/protos/ledger/rwset/rwset.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/
package rwset; import _cover_atomic_ "sync/atomic"

import (
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/protos/ledger/rwset/kvrwset"
)

func (txrws *TxReadWriteSet) DynamicSliceFields() []string {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[0], 1);
	if txrws.DataModel != TxReadWriteSet_KV {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[2], 1);
		// We only know how to handle TxReadWriteSet_KV types
		return []string{}
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[1], 1);return []string{"ns_rwset"}
}

func (txrws *TxReadWriteSet) DynamicSliceFieldProto(name string, index int, base proto.Message) (proto.Message, error) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[3], 1);
	if name != txrws.DynamicSliceFields()[0] {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[6], 1);
		return nil, fmt.Errorf("Not a dynamic field: %s", name)
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[4], 1);nsrw, ok := base.(*NsReadWriteSet)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[7], 1);
		return nil, fmt.Errorf("TxReadWriteSet must embed a NsReadWriteSet its dynamic field")
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[5], 1);return &DynamicNsReadWriteSet{
		NsReadWriteSet: nsrw,
		DataModel:      txrws.DataModel,
	}, nil
}

type DynamicNsReadWriteSet struct {
	*NsReadWriteSet
	DataModel TxReadWriteSet_DataModel
}

func (dnrws *DynamicNsReadWriteSet) Underlying() proto.Message {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[8], 1);
	return dnrws.NsReadWriteSet
}

func (dnrws *DynamicNsReadWriteSet) StaticallyOpaqueFields() []string {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[9], 1);
	return []string{"rwset"}
}

func (dnrws *DynamicNsReadWriteSet) StaticallyOpaqueFieldProto(name string) (proto.Message, error) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[10], 1);
	switch name {
	case "rwset":_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[11], 1);
		switch dnrws.DataModel {
		case TxReadWriteSet_KV:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[13], 1);
			return &kvrwset.KVRWSet{}, nil
		default:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[14], 1);
			return nil, fmt.Errorf("unknown data model type: %v", dnrws.DataModel)
		}
	default:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[12], 1);
		return nil, fmt.Errorf("not a marshaled field: %s", name)
	}
}

func (dnrws *DynamicNsReadWriteSet) DynamicSliceFields() []string {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[15], 1);
	if dnrws.DataModel != TxReadWriteSet_KV {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[17], 1);
		// We only know how to handle TxReadWriteSet_KV types
		return []string{}
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[16], 1);return []string{"collection_hashed_rwset"}
}

func (dnrws *DynamicNsReadWriteSet) DynamicSliceFieldProto(name string, index int, base proto.Message) (proto.Message, error) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[18], 1);
	if name != dnrws.DynamicSliceFields()[0] {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[21], 1);
		return nil, fmt.Errorf("Not a dynamic field: %s", name)
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[19], 1);chrws, ok := base.(*CollectionHashedReadWriteSet)
	if !ok {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[22], 1);
		return nil, fmt.Errorf("NsReadWriteSet must embed a *CollectionHashedReadWriteSet its dynamic field")
	}

	_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[20], 1);return &DynamicCollectionHashedReadWriteSet{
		CollectionHashedReadWriteSet: chrws,
		DataModel:                    dnrws.DataModel,
	}, nil
}

type DynamicCollectionHashedReadWriteSet struct {
	*CollectionHashedReadWriteSet
	DataModel TxReadWriteSet_DataModel
}

func (dchrws *DynamicCollectionHashedReadWriteSet) Underlying() proto.Message {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[23], 1);
	return dchrws.CollectionHashedReadWriteSet
}

func (dchrws *DynamicCollectionHashedReadWriteSet) StaticallyOpaqueFields() []string {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[24], 1);
	return []string{"rwset"}
}

func (dchrws *DynamicCollectionHashedReadWriteSet) StaticallyOpaqueFieldProto(name string) (proto.Message, error) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[25], 1);
	switch name {
	case "rwset":_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[26], 1);
		switch dchrws.DataModel {
		case TxReadWriteSet_KV:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[28], 1);
			return &kvrwset.HashedRWSet{}, nil
		default:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[29], 1);
			return nil, fmt.Errorf("unknown data model type: %v", dchrws.DataModel)
		}
	default:_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[27], 1);
		return nil, fmt.Errorf("not a marshaled field: %s", name)
	}
}

// Remove removes the rwset for the given <ns, coll> tuple. If after this removal,
// there are no more collection in the namespace <ns>, the whole namespace entry is removed
func (p *TxPvtReadWriteSet) Remove(ns, coll string) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[30], 1);
	for i := 0; i < len(p.NsPvtRwset); i++ {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[31], 1);
		n := p.NsPvtRwset[i]
		if n.Namespace != ns {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[34], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[32], 1);n.remove(coll)
		if len(n.CollectionPvtRwset) == 0 {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[35], 1);
			p.NsPvtRwset = append(p.NsPvtRwset[:i], p.NsPvtRwset[i+1:]...)
		}
		_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[33], 1);return
	}
}

func (n *NsPvtReadWriteSet) remove(collName string) {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[36], 1);
	for i := 0; i < len(n.CollectionPvtRwset); i++ {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[37], 1);
		c := n.CollectionPvtRwset[i]
		if c.CollectionName != collName {_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[39], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_0_616133346331663038343931.Count[38], 1);n.CollectionPvtRwset = append(n.CollectionPvtRwset[:i], n.CollectionPvtRwset[i+1:]...)
		return
	}
}

var GoCover_0_616133346331663038343931 = struct {
	Count     [40]uint32
	Pos       [3 * 40]uint32
	NumStmt   [40]uint16
} {
	Pos: [3 * 40]uint32{
		15, 16, 0x2a003c, // [0]
		21, 21, 0x1d0002, // [1]
		16, 19, 0x3002a, // [2]
		24, 25, 0x2b0078, // [3]
		29, 30, 0x90002, // [4]
		34, 37, 0x80002, // [5]
		25, 27, 0x3002b, // [6]
		30, 32, 0x30009, // [7]
		45, 47, 0x20040, // [8]
		49, 51, 0x20047, // [9]
		53, 54, 0xe0064, // [10]
		55, 56, 0x1a000f, // [11]
		62, 63, 0x3c000a, // [12]
		57, 58, 0x22001a, // [13]
		59, 60, 0x4a000b, // [14]
		67, 68, 0x2a0043, // [15]
		73, 73, 0x2c0002, // [16]
		68, 71, 0x3002a, // [17]
		76, 77, 0x2b007f, // [18]
		81, 82, 0x90002, // [19]
		86, 89, 0x80002, // [20]
		77, 79, 0x3002b, // [21]
		82, 84, 0x30009, // [22]
		97, 99, 0x2004f, // [23]
		101, 103, 0x20056, // [24]
		105, 106, 0xe0073, // [25]
		107, 108, 0x1b000f, // [26]
		114, 115, 0x3c000a, // [27]
		109, 110, 0x26001a, // [28]
		111, 112, 0x4b000b, // [29]
		121, 122, 0x290035, // [30]
		122, 124, 0x180029, // [31]
		127, 128, 0x250003, // [32]
		131, 131, 0x90003, // [33]
		124, 125, 0xc0018, // [34]
		128, 130, 0x40025, // [35]
		135, 136, 0x310035, // [36]
		136, 138, 0x230031, // [37]
		141, 142, 0x90003, // [38]
		138, 139, 0xc0023, // [39]
	},
	NumStmt: [40]uint16{
		1, // 0
		1, // 1
		1, // 2
		1, // 3
		2, // 4
		1, // 5
		1, // 6
		1, // 7
		1, // 8
		1, // 9
		1, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		2, // 19
		1, // 20
		1, // 21
		1, // 22
		1, // 23
		1, // 24
		1, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		2, // 31
		2, // 32
		1, // 33
		1, // 34
		1, // 35
		1, // 36
		2, // 37
		2, // 38
		1, // 39
	},
}
var _ = _cover_atomic_.LoadUint32
