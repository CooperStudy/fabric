//line /home/cooper/go/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/blockfile_mgr.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package fsblkstorage; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"
	"math"
	"sync"
	"sync/atomic"

	"github.com/davecgh/go-spew/spew"
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/common/ledger/blkstorage"
	"github.com/hyperledger/fabric/common/ledger/util"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/peer"
	putil "github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
)

var logger = flogging.MustGetLogger("fsblkstorage")

const (
	blockfilePrefix = "blockfile_"
)

var (
	blkMgrInfoKey = []byte("blkMgrInfo")
)

type blockfileMgr struct {
	rootDir           string
	conf              *Conf
	db                *leveldbhelper.DBHandle
	index             index
	cpInfo            *checkpointInfo
	cpInfoCond        *sync.Cond
	currentFileWriter *blockfileWriter
	bcInfo            atomic.Value
}

/*
Creates a new manager that will manage the files used for block persistence.
This manager manages the file system FS including
  -- the directory where the files are stored
  -- the individual files where the blocks are stored
  -- the checkpoint which tracks the latest file being persisted to
  -- the index which tracks what block and transaction is in what file
When a new blockfile manager is started (i.e. only on start-up), it checks
if this start-up is the first time the system is coming up or is this a restart
of the system.

The blockfile manager stores blocks of data into a file system.  That file
storage is done by creating sequentially numbered files of a configured size
i.e blockfile_000000, blockfile_000001, etc..

Each transaction in a block is stored with information about the number of
bytes in that transaction
 Adding txLoc [fileSuffixNum=0, offset=3, bytesLength=104] for tx [1:0] to index
 Adding txLoc [fileSuffixNum=0, offset=107, bytesLength=104] for tx [1:1] to index
Each block is stored with the total encoded length of that block as well as the
tx location offsets.

Remember that these steps are only done once at start-up of the system.
At start up a new manager:
  *) Checks if the directory for storing files exists, if not creates the dir
  *) Checks if the key value database exists, if not creates one
       (will create a db dir)
  *) Determines the checkpoint information (cpinfo) used for storage
		-- Loads from db if exist, if not instantiate a new cpinfo
		-- If cpinfo was loaded from db, compares to FS
		-- If cpinfo and file system are not in sync, syncs cpInfo from FS
  *) Starts a new file writer
		-- truncates file per cpinfo to remove any excess past last block
  *) Determines the index information used to find tx and blocks in
  the file blkstorage
		-- Instantiates a new blockIdxInfo
		-- Loads the index from the db if exists
		-- syncIndex comparing the last block indexed to what is in the FS
		-- If index and file system are not in sync, syncs index from the FS
  *)  Updates blockchain info used by the APIs
*/
func newBlockfileMgr(id string, conf *Conf, indexConfig *blkstorage.IndexConfig, indexStore *leveldbhelper.DBHandle) *blockfileMgr {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[0], 1);
	logger.Debugf("newBlockfileMgr() initializing file-based block storage for ledger: %s ", id)
	//Determine the root directory for the blockfile storage, if it does not exist create it
	rootDir := conf.getLedgerBlockDir(id)
	_, err := util.CreateDirIfMissing(rootDir)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[9], 1);
		panic(fmt.Sprintf("Error creating block storage root dir [%s]: %s", rootDir, err))
	}
	// Instantiate the manager, i.e. blockFileMgr structure
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[1], 1);mgr := &blockfileMgr{rootDir: rootDir, conf: conf, db: indexStore}

	// cp = checkpointInfo, retrieve from the database the file suffix or number of where blocks were stored.
	// It also retrieves the current size of that file and the last block number that was written to that file.
	// At init checkpointInfo:latestFileChunkSuffixNum=[0], latestFileChunksize=[0], lastBlockNumber=[0]
	cpInfo, err := mgr.loadCurrentInfo()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[10], 1);
		panic(fmt.Sprintf("Could not get block file info for current block file from db: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[2], 1);if cpInfo == nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[11], 1);
		logger.Info(`Getting block information from block storage`)
		if cpInfo, err = constructCheckpointInfoFromBlockFiles(rootDir); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[13], 1);
			panic(fmt.Sprintf("Could not build checkpoint info from block files: %s", err))
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[12], 1);logger.Debugf("Info constructed by scanning the blocks dir = %s", spew.Sdump(cpInfo))
	} else{ _cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[14], 1);{
		logger.Debug(`Synching block information from block storage (if needed)`)
		syncCPInfoFromFS(rootDir, cpInfo)
	}}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[3], 1);err = mgr.saveCurrentInfo(cpInfo, true)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[15], 1);
		panic(fmt.Sprintf("Could not save next block file info to db: %s", err))
	}

	//Open a writer to the file identified by the number and truncate it to only contain the latest block
	// that was completely saved (file system, index, cpinfo, etc)
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[4], 1);currentFileWriter, err := newBlockfileWriter(deriveBlockfilePath(rootDir, cpInfo.latestFileChunkSuffixNum))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[16], 1);
		panic(fmt.Sprintf("Could not open writer to current file: %s", err))
	}
	//Truncate the file to remove excess past last block
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[5], 1);err = currentFileWriter.truncateFile(cpInfo.latestFileChunksize)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[17], 1);
		panic(fmt.Sprintf("Could not truncate current file to known size in db: %s", err))
	}

	// Create a new KeyValue store database handler for the blocks index in the keyvalue database
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[6], 1);if mgr.index, err = newBlockIndex(indexConfig, indexStore); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[18], 1);
		panic(fmt.Sprintf("error in block index: %s", err))
	}

	// Update the manager with the checkpoint info and the file writer
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[7], 1);mgr.cpInfo = cpInfo
	mgr.currentFileWriter = currentFileWriter
	// Create a checkpoint condition (event) variable, for the  goroutine waiting for
	// or announcing the occurrence of an event.
	mgr.cpInfoCond = sync.NewCond(&sync.Mutex{})

	// init BlockchainInfo for external API's
	bcInfo := &common.BlockchainInfo{
		Height:            0,
		CurrentBlockHash:  nil,
		PreviousBlockHash: nil}

	if !cpInfo.isChainEmpty {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[19], 1);
		//If start up is a restart of an existing storage, sync the index from block storage and update BlockchainInfo for external API's
		mgr.syncIndex()
		lastBlockHeader, err := mgr.retrieveBlockHeaderByNumber(cpInfo.lastBlockNumber)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[21], 1);
			panic(fmt.Sprintf("Could not retrieve header of the last block form file: %s", err))
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[20], 1);lastBlockHash := lastBlockHeader.Hash()
		previousBlockHash := lastBlockHeader.PreviousHash
		bcInfo = &common.BlockchainInfo{
			Height:            cpInfo.lastBlockNumber + 1,
			CurrentBlockHash:  lastBlockHash,
			PreviousBlockHash: previousBlockHash}
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[8], 1);mgr.bcInfo.Store(bcInfo)
	return mgr
}

//cp = checkpointInfo, from the database gets the file suffix and the size of
// the file of where the last block was written.  Also retrieves contains the
// last block number that was written.  At init
//checkpointInfo:latestFileChunkSuffixNum=[0], latestFileChunksize=[0], lastBlockNumber=[0]
func syncCPInfoFromFS(rootDir string, cpInfo *checkpointInfo) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[22], 1);
	logger.Debugf("Starting checkpoint=%s", cpInfo)
	//Checks if the file suffix of where the last block was written exists
	filePath := deriveBlockfilePath(rootDir, cpInfo.latestFileChunkSuffixNum)
	exists, size, err := util.FileExists(filePath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[28], 1);
		panic(fmt.Sprintf("Error in checking whether file [%s] exists: %s", filePath, err))
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[23], 1);logger.Debugf("status of file [%s]: exists=[%t], size=[%d]", filePath, exists, size)
	//Test is !exists because when file number is first used the file does not exist yet
	//checks that the file exists and that the size of the file is what is stored in cpinfo
	//status of file [/tmp/tests/ledger/blkstorage/fsblkstorage/blocks/blockfile_000000]: exists=[false], size=[0]
	if !exists || int(size) == cpInfo.latestFileChunksize {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[29], 1);
		// check point info is in sync with the file on disk
		return
	}
	//Scan the file system to verify that the checkpoint info stored in db is correct
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[24], 1);_, endOffsetLastBlock, numBlocks, err := scanForLastCompleteBlock(
		rootDir, cpInfo.latestFileChunkSuffixNum, int64(cpInfo.latestFileChunksize))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[30], 1);
		panic(fmt.Sprintf("Could not open current file for detecting last block in the file: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[25], 1);cpInfo.latestFileChunksize = int(endOffsetLastBlock)
	if numBlocks == 0 {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[31], 1);
		return
	}
	//Updates the checkpoint info for the actual last block number stored and it's end location
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[26], 1);if cpInfo.isChainEmpty {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[32], 1);
		cpInfo.lastBlockNumber = uint64(numBlocks - 1)
	} else{ _cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[33], 1);{
		cpInfo.lastBlockNumber += uint64(numBlocks)
	}}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[27], 1);cpInfo.isChainEmpty = false
	logger.Debugf("Checkpoint after updates by scanning the last file segment:%s", cpInfo)
}

func deriveBlockfilePath(rootDir string, suffixNum int) string {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[34], 1);
	return rootDir + "/" + blockfilePrefix + fmt.Sprintf("%06d", suffixNum)
}

func (mgr *blockfileMgr) close() {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[35], 1);
	mgr.currentFileWriter.close()
}

func (mgr *blockfileMgr) moveToNextFile() {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[36], 1);
	cpInfo := &checkpointInfo{
		latestFileChunkSuffixNum: mgr.cpInfo.latestFileChunkSuffixNum + 1,
		latestFileChunksize:      0,
		lastBlockNumber:          mgr.cpInfo.lastBlockNumber}

	nextFileWriter, err := newBlockfileWriter(
		deriveBlockfilePath(mgr.rootDir, cpInfo.latestFileChunkSuffixNum))

	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[39], 1);
		panic(fmt.Sprintf("Could not open writer to next file: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[37], 1);mgr.currentFileWriter.close()
	err = mgr.saveCurrentInfo(cpInfo, true)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[40], 1);
		panic(fmt.Sprintf("Could not save next block file info to db: %s", err))
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[38], 1);mgr.currentFileWriter = nextFileWriter
	mgr.updateCheckpoint(cpInfo)
}

func (mgr *blockfileMgr) addBlock(block *common.Block) error {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[41], 1);
	bcInfo := mgr.getBlockchainInfo()
	if block.Header.Number != bcInfo.Height {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[51], 1);
		return errors.Errorf(
			"block number should have been %d but was %d",
			mgr.getBlockchainInfo().Height, block.Header.Number,
		)
	}

	// Add the previous hash check - Though, not essential but may not be a bad idea to
	// verify the field `block.Header.PreviousHash` present in the block.
	// This check is a simple bytes comparison and hence does not cause any observable performance penalty
	// and may help in detecting a rare scenario if there is any bug in the ordering service.
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[42], 1);if !bytes.Equal(block.Header.PreviousHash, bcInfo.CurrentBlockHash) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[52], 1);
		return errors.Errorf(
			"unexpected Previous block hash. Expected PreviousHash = [%x], PreviousHash referred in the latest block= [%x]",
			bcInfo.CurrentBlockHash, block.Header.PreviousHash,
		)
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[43], 1);blockBytes, info, err := serializeBlock(block)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[53], 1);
		return errors.WithMessage(err, "error serializing block")
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[44], 1);blockHash := block.Header.Hash()
	//Get the location / offset where each transaction starts in the block and where the block ends
	txOffsets := info.txOffsets
	currentOffset := mgr.cpInfo.latestFileChunksize

	blockBytesLen := len(blockBytes)
	blockBytesEncodedLen := proto.EncodeVarint(uint64(blockBytesLen))
	totalBytesToAppend := blockBytesLen + len(blockBytesEncodedLen)

	//Determine if we need to start a new file since the size of this block
	//exceeds the amount of space left in the current file
	if currentOffset+totalBytesToAppend > mgr.conf.maxBlockfileSize {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[54], 1);
		mgr.moveToNextFile()
		currentOffset = 0
	}
	//append blockBytesEncodedLen to the file
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[45], 1);err = mgr.currentFileWriter.append(blockBytesEncodedLen, false)
	if err == nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[55], 1);
		//append the actual block bytes to the file
		err = mgr.currentFileWriter.append(blockBytes, true)
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[46], 1);if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[56], 1);
		truncateErr := mgr.currentFileWriter.truncateFile(mgr.cpInfo.latestFileChunksize)
		if truncateErr != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[58], 1);
			panic(fmt.Sprintf("Could not truncate current file to known size after an error during block append: %s", err))
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[57], 1);return errors.WithMessage(err, "error appending block to file")
	}

	//Update the checkpoint info with the results of adding the new block
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[47], 1);currentCPInfo := mgr.cpInfo
	newCPInfo := &checkpointInfo{
		latestFileChunkSuffixNum: currentCPInfo.latestFileChunkSuffixNum,
		latestFileChunksize:      currentCPInfo.latestFileChunksize + totalBytesToAppend,
		isChainEmpty:             false,
		lastBlockNumber:          block.Header.Number}
	//save the checkpoint information in the database
	if err = mgr.saveCurrentInfo(newCPInfo, false); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[59], 1);
		truncateErr := mgr.currentFileWriter.truncateFile(currentCPInfo.latestFileChunksize)
		if truncateErr != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[61], 1);
			panic(fmt.Sprintf("Error in truncating current file to known size after an error in saving checkpoint info: %s", err))
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[60], 1);return errors.WithMessage(err, "error saving current file info to db")
	}

	//Index block file location pointer updated with file suffex and offset for the new block
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[48], 1);blockFLP := &fileLocPointer{fileSuffixNum: newCPInfo.latestFileChunkSuffixNum}
	blockFLP.offset = currentOffset
	// shift the txoffset because we prepend length of bytes before block bytes
	for _, txOffset := range txOffsets {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[62], 1);
		txOffset.loc.offset += len(blockBytesEncodedLen)
	}
	//save the index in the database
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[49], 1);if err = mgr.index.indexBlock(&blockIdxInfo{
		blockNum: block.Header.Number, blockHash: blockHash,
		flp: blockFLP, txOffsets: txOffsets, metadata: block.Metadata}); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[63], 1);
		return err
	}

	//update the checkpoint info (for storage) and the blockchain info (for APIs) in the manager
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[50], 1);mgr.updateCheckpoint(newCPInfo)
	mgr.updateBlockchainInfo(blockHash, block)
	return nil
}

func (mgr *blockfileMgr) syncIndex() error {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[64], 1);
	var lastBlockIndexed uint64
	var indexEmpty bool
	var err error
	//from the database, get the last block that was indexed
	if lastBlockIndexed, err = mgr.index.getLastBlockIndexed(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[70], 1);
		if err != errIndexEmpty {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[72], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[71], 1);indexEmpty = true
	}

	//initialize index to file number:zero, offset:zero and blockNum:0
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[65], 1);startFileNum := 0
	startOffset := 0
	skipFirstBlock := false
	//get the last file that blocks were added to using the checkpoint info
	endFileNum := mgr.cpInfo.latestFileChunkSuffixNum
	startingBlockNum := uint64(0)

	//if the index stored in the db has value, update the index information with those values
	if !indexEmpty {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[73], 1);
		if lastBlockIndexed == mgr.cpInfo.lastBlockNumber {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[76], 1);
			logger.Debug("Both the block files and indices are in sync.")
			return nil
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[74], 1);logger.Debugf("Last block indexed [%d], Last block present in block files [%d]", lastBlockIndexed, mgr.cpInfo.lastBlockNumber)
		var flp *fileLocPointer
		if flp, err = mgr.index.getBlockLocByBlockNum(lastBlockIndexed); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[77], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[75], 1);startFileNum = flp.fileSuffixNum
		startOffset = flp.locPointer.offset
		skipFirstBlock = true
		startingBlockNum = lastBlockIndexed + 1
	} else{ _cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[78], 1);{
		logger.Debugf("No block indexed, Last block present in block files=[%d]", mgr.cpInfo.lastBlockNumber)
	}}

	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[66], 1);logger.Infof("Start building index from block [%d] to last block [%d]", startingBlockNum, mgr.cpInfo.lastBlockNumber)

	//open a blockstream to the file location that was stored in the index
	var stream *blockStream
	if stream, err = newBlockStream(mgr.rootDir, startFileNum, int64(startOffset), endFileNum); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[79], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[67], 1);var blockBytes []byte
	var blockPlacementInfo *blockPlacementInfo

	if skipFirstBlock {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[80], 1);
		if blockBytes, _, err = stream.nextBlockBytesAndPlacementInfo(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[82], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[81], 1);if blockBytes == nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[83], 1);
			return errors.Errorf("block bytes for block num = [%d] should not be nil here. The indexes for the block are already present",
				lastBlockIndexed)
		}
	}

	//Should be at the last block already, but go ahead and loop looking for next blockBytes.
	//If there is another block, add it to the index.
	//This will ensure block indexes are correct, for example if peer had crashed before indexes got updated.
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[68], 1);blockIdxInfo := &blockIdxInfo{}
	for {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[84], 1);
		if blockBytes, blockPlacementInfo, err = stream.nextBlockBytesAndPlacementInfo(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[90], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[85], 1);if blockBytes == nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[91], 1);
			break
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[86], 1);info, err := extractSerializedBlockInfo(blockBytes)
		if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[92], 1);
			return err
		}

		//The blockStartOffset will get applied to the txOffsets prior to indexing within indexBlock(),
		//therefore just shift by the difference between blockBytesOffset and blockStartOffset
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[87], 1);numBytesToShift := int(blockPlacementInfo.blockBytesOffset - blockPlacementInfo.blockStartOffset)
		for _, offset := range info.txOffsets {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[93], 1);
			offset.loc.offset += numBytesToShift
		}

		//Update the blockIndexInfo with what was actually stored in file system
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[88], 1);blockIdxInfo.blockHash = info.blockHeader.Hash()
		blockIdxInfo.blockNum = info.blockHeader.Number
		blockIdxInfo.flp = &fileLocPointer{fileSuffixNum: blockPlacementInfo.fileNum,
			locPointer: locPointer{offset: int(blockPlacementInfo.blockStartOffset)}}
		blockIdxInfo.txOffsets = info.txOffsets
		blockIdxInfo.metadata = info.metadata

		logger.Debugf("syncIndex() indexing block [%d]", blockIdxInfo.blockNum)
		if err = mgr.index.indexBlock(blockIdxInfo); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[94], 1);
			return err
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[89], 1);if blockIdxInfo.blockNum%10000 == 0 {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[95], 1);
			logger.Infof("Indexed block number [%d]", blockIdxInfo.blockNum)
		}
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[69], 1);logger.Infof("Finished building index. Last block indexed [%d]", blockIdxInfo.blockNum)
	return nil
}

func (mgr *blockfileMgr) getBlockchainInfo() *common.BlockchainInfo {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[96], 1);
	return mgr.bcInfo.Load().(*common.BlockchainInfo)
}

func (mgr *blockfileMgr) updateCheckpoint(cpInfo *checkpointInfo) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[97], 1);
	mgr.cpInfoCond.L.Lock()
	defer mgr.cpInfoCond.L.Unlock()
	mgr.cpInfo = cpInfo
	logger.Debugf("Broadcasting about update checkpointInfo: %s", cpInfo)
	mgr.cpInfoCond.Broadcast()
}

func (mgr *blockfileMgr) updateBlockchainInfo(latestBlockHash []byte, latestBlock *common.Block) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[98], 1);
	currentBCInfo := mgr.getBlockchainInfo()
	newBCInfo := &common.BlockchainInfo{
		Height:            currentBCInfo.Height + 1,
		CurrentBlockHash:  latestBlockHash,
		PreviousBlockHash: latestBlock.Header.PreviousHash}

	mgr.bcInfo.Store(newBCInfo)
}

func (mgr *blockfileMgr) retrieveBlockByHash(blockHash []byte) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[99], 1);
	logger.Debugf("retrieveBlockByHash() - blockHash = [%#v]", blockHash)
	loc, err := mgr.index.getBlockLocByHash(blockHash)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[101], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[100], 1);return mgr.fetchBlock(loc)
}

func (mgr *blockfileMgr) retrieveBlockByNumber(blockNum uint64) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[102], 1);
	logger.Debugf("retrieveBlockByNumber() - blockNum = [%d]", blockNum)

	// interpret math.MaxUint64 as a request for last block
	if blockNum == math.MaxUint64 {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[105], 1);
		blockNum = mgr.getBlockchainInfo().Height - 1
	}

	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[103], 1);loc, err := mgr.index.getBlockLocByBlockNum(blockNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[106], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[104], 1);return mgr.fetchBlock(loc)
}

func (mgr *blockfileMgr) retrieveBlockByTxID(txID string) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[107], 1);
	logger.Debugf("retrieveBlockByTxID() - txID = [%s]", txID)

	loc, err := mgr.index.getBlockLocByTxID(txID)

	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[109], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[108], 1);return mgr.fetchBlock(loc)
}

func (mgr *blockfileMgr) retrieveTxValidationCodeByTxID(txID string) (peer.TxValidationCode, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[110], 1);
	logger.Debugf("retrieveTxValidationCodeByTxID() - txID = [%s]", txID)
	return mgr.index.getTxValidationCodeByTxID(txID)
}

func (mgr *blockfileMgr) retrieveBlockHeaderByNumber(blockNum uint64) (*common.BlockHeader, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[111], 1);
	logger.Debugf("retrieveBlockHeaderByNumber() - blockNum = [%d]", blockNum)
	loc, err := mgr.index.getBlockLocByBlockNum(blockNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[115], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[112], 1);blockBytes, err := mgr.fetchBlockBytes(loc)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[116], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[113], 1);info, err := extractSerializedBlockInfo(blockBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[117], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[114], 1);return info.blockHeader, nil
}

func (mgr *blockfileMgr) retrieveBlocks(startNum uint64) (*blocksItr, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[118], 1);
	return newBlockItr(mgr, startNum), nil
}

func (mgr *blockfileMgr) retrieveTransactionByID(txID string) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[119], 1);
	logger.Debugf("retrieveTransactionByID() - txId = [%s]", txID)
	loc, err := mgr.index.getTxLoc(txID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[121], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[120], 1);return mgr.fetchTransactionEnvelope(loc)
}

func (mgr *blockfileMgr) retrieveTransactionByBlockNumTranNum(blockNum uint64, tranNum uint64) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[122], 1);
	logger.Debugf("retrieveTransactionByBlockNumTranNum() - blockNum = [%d], tranNum = [%d]", blockNum, tranNum)
	loc, err := mgr.index.getTXLocByBlockNumTranNum(blockNum, tranNum)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[124], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[123], 1);return mgr.fetchTransactionEnvelope(loc)
}

func (mgr *blockfileMgr) fetchBlock(lp *fileLocPointer) (*common.Block, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[125], 1);
	blockBytes, err := mgr.fetchBlockBytes(lp)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[128], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[126], 1);block, err := deserializeBlock(blockBytes)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[129], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[127], 1);return block, nil
}

func (mgr *blockfileMgr) fetchTransactionEnvelope(lp *fileLocPointer) (*common.Envelope, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[130], 1);
	logger.Debugf("Entering fetchTransactionEnvelope() %v\n", lp)
	var err error
	var txEnvelopeBytes []byte
	if txEnvelopeBytes, err = mgr.fetchRawBytes(lp); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[132], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[131], 1);_, n := proto.DecodeVarint(txEnvelopeBytes)
	return putil.GetEnvelopeFromBlock(txEnvelopeBytes[n:])
}

func (mgr *blockfileMgr) fetchBlockBytes(lp *fileLocPointer) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[133], 1);
	stream, err := newBlockfileStream(mgr.rootDir, lp.fileSuffixNum, int64(lp.offset))
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[136], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[134], 1);defer stream.close()
	b, err := stream.nextBlockBytes()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[137], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[135], 1);return b, nil
}

func (mgr *blockfileMgr) fetchRawBytes(lp *fileLocPointer) ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[138], 1);
	filePath := deriveBlockfilePath(mgr.rootDir, lp.fileSuffixNum)
	reader, err := newBlockfileReader(filePath)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[141], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[139], 1);defer reader.close()
	b, err := reader.read(lp.offset, lp.bytesLength)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[142], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[140], 1);return b, nil
}

//Get the current checkpoint information that is stored in the database
func (mgr *blockfileMgr) loadCurrentInfo() (*checkpointInfo, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[143], 1);
	var b []byte
	var err error
	if b, err = mgr.db.Get(blkMgrInfoKey); b == nil || err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[146], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[144], 1);i := &checkpointInfo{}
	if err = i.unmarshal(b); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[147], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[145], 1);logger.Debugf("loaded checkpointInfo:%s", i)
	return i, nil
}

func (mgr *blockfileMgr) saveCurrentInfo(i *checkpointInfo, sync bool) error {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[148], 1);
	b, err := i.marshal()
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[151], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[149], 1);if err = mgr.db.Put(blkMgrInfoKey, b, sync); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[152], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[150], 1);return nil
}

// scanForLastCompleteBlock scan a given block file and detects the last offset in the file
// after which there may lie a block partially written (towards the end of the file in a crash scenario).
func scanForLastCompleteBlock(rootDir string, fileNum int, startingOffset int64) ([]byte, int64, int, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[153], 1);
	//scan the passed file number suffix starting from the passed offset to find the last completed block
	numBlocks := 0
	var lastBlockBytes []byte
	blockStream, errOpen := newBlockfileStream(rootDir, fileNum, startingOffset)
	if errOpen != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[157], 1);
		return nil, 0, 0, errOpen
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[154], 1);defer blockStream.close()
	var errRead error
	var blockBytes []byte
	for {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[158], 1);
		blockBytes, errRead = blockStream.nextBlockBytes()
		if blockBytes == nil || errRead != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[160], 1);
			break
		}
		_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[159], 1);lastBlockBytes = blockBytes
		numBlocks++
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[155], 1);if errRead == ErrUnexpectedEndOfBlockfile {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[161], 1);
		logger.Debugf(`Error:%s
		The error may happen if a crash has happened during block appending.
		Resetting error to nil and returning current offset as a last complete block's end offset`, errRead)
		errRead = nil
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[156], 1);logger.Debugf("scanForLastCompleteBlock(): last complete block ends at offset=[%d]", blockStream.currentOffset)
	return lastBlockBytes, blockStream.currentOffset, numBlocks, errRead
}

// checkpointInfo
type checkpointInfo struct {
	latestFileChunkSuffixNum int
	latestFileChunksize      int
	isChainEmpty             bool
	lastBlockNumber          uint64
}

func (i *checkpointInfo) marshal() ([]byte, error) {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[162], 1);
	buffer := proto.NewBuffer([]byte{})
	var err error
	if err = buffer.EncodeVarint(uint64(i.latestFileChunkSuffixNum)); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[168], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[163], 1);if err = buffer.EncodeVarint(uint64(i.latestFileChunksize)); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[169], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[164], 1);if err = buffer.EncodeVarint(i.lastBlockNumber); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[170], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[165], 1);var chainEmptyMarker uint64
	if i.isChainEmpty {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[171], 1);
		chainEmptyMarker = 1
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[166], 1);if err = buffer.EncodeVarint(chainEmptyMarker); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[172], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[167], 1);return buffer.Bytes(), nil
}

func (i *checkpointInfo) unmarshal(b []byte) error {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[173], 1);
	buffer := proto.NewBuffer(b)
	var val uint64
	var chainEmptyMarker uint64
	var err error

	if val, err = buffer.DecodeVarint(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[178], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[174], 1);i.latestFileChunkSuffixNum = int(val)

	if val, err = buffer.DecodeVarint(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[179], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[175], 1);i.latestFileChunksize = int(val)

	if val, err = buffer.DecodeVarint(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[180], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[176], 1);i.lastBlockNumber = val
	if chainEmptyMarker, err = buffer.DecodeVarint(); err != nil {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[181], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[177], 1);i.isChainEmpty = chainEmptyMarker == 1
	return nil
}

func (i *checkpointInfo) String() string {_cover_atomic_.AddUint32(&GoCover_3_386431356532613230373239.Count[182], 1);
	return fmt.Sprintf("latestFileChunkSuffixNum=[%d], latestFileChunksize=[%d], isChainEmpty=[%t], lastBlockNumber=[%d]",
		i.latestFileChunkSuffixNum, i.latestFileChunksize, i.isChainEmpty, i.lastBlockNumber)
}

var GoCover_3_386431356532613230373239 = struct {
	Count     [183]uint32
	Pos       [3 * 183]uint32
	NumStmt   [183]uint16
} {
	Pos: [3 * 183]uint32{
		90, 95, 0x100084, // [0]
		99, 105, 0x100002, // [1]
		108, 108, 0x130002, // [2]
		118, 119, 0x100002, // [3]
		125, 126, 0x100002, // [4]
		130, 131, 0x100002, // [5]
		136, 136, 0x490002, // [6]
		141, 153, 0x1a0002, // [7]
		167, 168, 0xc0002, // [8]
		95, 96, 0x550010, // [9]
		105, 106, 0x5e0010, // [10]
		108, 110, 0x4f0013, // [11]
		113, 113, 0x580003, // [12]
		110, 111, 0x53004f, // [13]
		114, 117, 0x30008, // [14]
		119, 120, 0x4b0010, // [15]
		126, 127, 0x470010, // [16]
		131, 132, 0x550010, // [17]
		136, 137, 0x360049, // [18]
		153, 157, 0x11001a, // [19]
		160, 165, 0x290003, // [20]
		157, 158, 0x580011, // [21]
		175, 180, 0x10003f, // [22]
		183, 187, 0x380002, // [23]
		192, 194, 0x100002, // [24]
		197, 198, 0x140002, // [25]
		202, 202, 0x190002, // [26]
		207, 208, 0x580002, // [27]
		180, 181, 0x560010, // [28]
		187, 190, 0x30038, // [29]
		194, 195, 0x620010, // [30]
		198, 200, 0x30014, // [31]
		202, 204, 0x30019, // [32]
		204, 206, 0x30008, // [33]
		211, 213, 0x20040, // [34]
		215, 217, 0x20022, // [35]
		219, 228, 0x10002b, // [36]
		231, 233, 0x100002, // [37]
		236, 237, 0x1e0002, // [38]
		228, 229, 0x440010, // [39]
		233, 234, 0x4b0010, // [40]
		240, 242, 0x2a003e, // [41]
		253, 253, 0x460002, // [42]
		259, 260, 0x100002, // [43]
		263, 274, 0x420002, // [44]
		279, 280, 0x100002, // [45]
		284, 284, 0x100002, // [46]
		293, 300, 0x3d0002, // [47]
		309, 312, 0x250002, // [48]
		316, 318, 0x4f0002, // [49]
		323, 325, 0xc0002, // [50]
		242, 247, 0x3002a, // [51]
		253, 258, 0x30046, // [52]
		260, 262, 0x30010, // [53]
		274, 277, 0x30042, // [54]
		280, 283, 0x30010, // [55]
		284, 286, 0x190010, // [56]
		289, 289, 0x420003, // [57]
		286, 287, 0x730019, // [58]
		300, 302, 0x19003d, // [59]
		305, 305, 0x490003, // [60]
		302, 303, 0x7a0019, // [61]
		312, 314, 0x30025, // [62]
		318, 320, 0x3004f, // [63]
		328, 333, 0x49002c, // [64]
		341, 349, 0x110002, // [65]
		367, 371, 0x690002, // [66]
		374, 377, 0x140002, // [67]
		390, 391, 0x60002, // [68]
		426, 427, 0xc0002, // [69]
		333, 334, 0x1b0049, // [70]
		337, 337, 0x140003, // [71]
		334, 336, 0x4001b, // [72]
		349, 350, 0x350011, // [73]
		354, 356, 0x4f0003, // [74]
		359, 362, 0x2a0003, // [75]
		350, 353, 0x40035, // [76]
		356, 358, 0x4004f, // [77]
		363, 365, 0x30008, // [78]
		371, 373, 0x30069, // [79]
		377, 378, 0x4f0014, // [80]
		381, 381, 0x180003, // [81]
		378, 380, 0x4004f, // [82]
		381, 384, 0x40018, // [83]
		391, 392, 0x600006, // [84]
		395, 395, 0x180003, // [85]
		398, 399, 0x110003, // [86]
		405, 406, 0x290003, // [87]
		411, 419, 0x3b0003, // [88]
		422, 422, 0x270003, // [89]
		392, 394, 0x40060, // [90]
		395, 396, 0x90018, // [91]
		399, 401, 0x40011, // [92]
		406, 408, 0x40029, // [93]
		419, 421, 0x4003b, // [94]
		422, 424, 0x40027, // [95]
		430, 432, 0x20045, // [96]
		434, 440, 0x20043, // [97]
		442, 450, 0x20062, // [98]
		452, 455, 0x100057, // [99]
		458, 458, 0x1c0002, // [100]
		455, 457, 0x30010, // [101]
		461, 465, 0x200058, // [102]
		469, 470, 0x100002, // [103]
		473, 473, 0x1c0002, // [104]
		465, 467, 0x30020, // [105]
		470, 472, 0x30010, // [106]
		476, 481, 0x100052, // [107]
		484, 484, 0x1c0002, // [108]
		481, 483, 0x30010, // [109]
		487, 490, 0x20065, // [110]
		492, 495, 0x100064, // [111]
		498, 499, 0x100002, // [112]
		502, 503, 0x100002, // [113]
		506, 506, 0x1e0002, // [114]
		495, 497, 0x30010, // [115]
		499, 501, 0x30010, // [116]
		503, 505, 0x30010, // [117]
		509, 511, 0x2004e, // [118]
		513, 516, 0x100059, // [119]
		519, 519, 0x2a0002, // [120]
		516, 518, 0x30010, // [121]
		522, 525, 0x10007a, // [122]
		528, 528, 0x2a0002, // [123]
		525, 527, 0x30010, // [124]
		531, 533, 0x100050, // [125]
		536, 537, 0x100002, // [126]
		540, 540, 0x130002, // [127]
		533, 535, 0x30010, // [128]
		537, 539, 0x30010, // [129]
		543, 547, 0x3e0061, // [130]
		550, 551, 0x380002, // [131]
		547, 549, 0x3003e, // [132]
		554, 556, 0x10004e, // [133]
		559, 561, 0x100002, // [134]
		564, 564, 0xf0002, // [135]
		556, 558, 0x30010, // [136]
		561, 563, 0x30010, // [137]
		567, 570, 0x10004c, // [138]
		573, 575, 0x100002, // [139]
		578, 578, 0xf0002, // [140]
		570, 572, 0x30010, // [141]
		575, 577, 0x30010, // [142]
		582, 585, 0x400045, // [143]
		588, 589, 0x260002, // [144]
		592, 593, 0xf0002, // [145]
		585, 587, 0x30040, // [146]
		589, 591, 0x30026, // [147]
		596, 598, 0x10004e, // [148]
		601, 601, 0x3a0002, // [149]
		604, 604, 0xc0002, // [150]
		598, 600, 0x30010, // [151]
		601, 603, 0x3003a, // [152]
		609, 614, 0x14006e, // [153]
		617, 620, 0x60002, // [154]
		628, 628, 0x2c0002, // [155]
		634, 635, 0x460002, // [156]
		614, 616, 0x30014, // [157]
		620, 622, 0x2a0006, // [158]
		625, 626, 0xe0003, // [159]
		622, 623, 0x9002a, // [160]
		628, 633, 0x3002c, // [161]
		646, 649, 0x4f0034, // [162]
		652, 652, 0x4a0002, // [163]
		655, 655, 0x3e0002, // [164]
		658, 659, 0x140002, // [165]
		662, 662, 0x3d0002, // [166]
		665, 665, 0x1c0002, // [167]
		649, 651, 0x3004f, // [168]
		652, 654, 0x3004a, // [169]
		655, 657, 0x3003e, // [170]
		659, 661, 0x30014, // [171]
		662, 664, 0x3003d, // [172]
		668, 674, 0x320034, // [173]
		677, 679, 0x320002, // [174]
		682, 684, 0x320002, // [175]
		687, 688, 0x3f0002, // [176]
		691, 692, 0xc0002, // [177]
		674, 676, 0x30032, // [178]
		679, 681, 0x30032, // [179]
		684, 686, 0x30032, // [180]
		688, 690, 0x3003f, // [181]
		695, 698, 0x2002a, // [182]
	},
	NumStmt: [183]uint16{
		4, // 0
		3, // 1
		1, // 2
		2, // 3
		2, // 4
		2, // 5
		1, // 6
		5, // 7
		2, // 8
		1, // 9
		1, // 10
		2, // 11
		1, // 12
		1, // 13
		2, // 14
		1, // 15
		1, // 16
		1, // 17
		1, // 18
		3, // 19
		3, // 20
		1, // 21
		4, // 22
		2, // 23
		2, // 24
		2, // 25
		1, // 26
		2, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		1, // 33
		1, // 34
		1, // 35
		3, // 36
		3, // 37
		2, // 38
		1, // 39
		1, // 40
		2, // 41
		1, // 42
		2, // 43
		7, // 44
		2, // 45
		1, // 46
		3, // 47
		3, // 48
		1, // 49
		3, // 50
		1, // 51
		1, // 52
		1, // 53
		2, // 54
		1, // 55
		2, // 56
		1, // 57
		1, // 58
		2, // 59
		1, // 60
		1, // 61
		1, // 62
		1, // 63
		4, // 64
		6, // 65
		3, // 66
		3, // 67
		2, // 68
		2, // 69
		1, // 70
		1, // 71
		1, // 72
		1, // 73
		3, // 74
		4, // 75
		2, // 76
		1, // 77
		1, // 78
		1, // 79
		1, // 80
		1, // 81
		1, // 82
		1, // 83
		1, // 84
		1, // 85
		2, // 86
		2, // 87
		7, // 88
		1, // 89
		1, // 90
		1, // 91
		1, // 92
		1, // 93
		1, // 94
		1, // 95
		1, // 96
		5, // 97
		3, // 98
		3, // 99
		1, // 100
		1, // 101
		2, // 102
		2, // 103
		1, // 104
		1, // 105
		1, // 106
		3, // 107
		1, // 108
		1, // 109
		2, // 110
		3, // 111
		2, // 112
		2, // 113
		1, // 114
		1, // 115
		1, // 116
		1, // 117
		1, // 118
		3, // 119
		1, // 120
		1, // 121
		3, // 122
		1, // 123
		1, // 124
		2, // 125
		2, // 126
		1, // 127
		1, // 128
		1, // 129
		4, // 130
		2, // 131
		1, // 132
		2, // 133
		3, // 134
		1, // 135
		1, // 136
		1, // 137
		3, // 138
		3, // 139
		1, // 140
		1, // 141
		1, // 142
		3, // 143
		2, // 144
		2, // 145
		1, // 146
		1, // 147
		2, // 148
		1, // 149
		1, // 150
		1, // 151
		1, // 152
		4, // 153
		4, // 154
		1, // 155
		2, // 156
		1, // 157
		2, // 158
		2, // 159
		1, // 160
		2, // 161
		3, // 162
		1, // 163
		1, // 164
		2, // 165
		1, // 166
		1, // 167
		1, // 168
		1, // 169
		1, // 170
		1, // 171
		1, // 172
		5, // 173
		2, // 174
		2, // 175
		2, // 176
		2, // 177
		1, // 178
		1, // 179
		1, // 180
		1, // 181
		1, // 182
	},
}
var _ = _cover_atomic_.LoadUint32
