//line /home/cooper/go/src/github.com/hyperledger/fabric/core/ledger/kvledger/kv_ledger_provider.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package kvledger; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"fmt"

	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/common/ledger/util/leveldbhelper"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/core/ledger/confighistory"
	"github.com/hyperledger/fabric/core/ledger/kvledger/bookkeeping"
	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb"
	"github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/privacyenabledstate"
	"github.com/hyperledger/fabric/core/ledger/ledgerconfig"
	"github.com/hyperledger/fabric/core/ledger/ledgerstorage"
	"github.com/hyperledger/fabric/protos/common"
	"github.com/hyperledger/fabric/protos/utils"
	"github.com/pkg/errors"
	"github.com/syndtr/goleveldb/leveldb"
)

var (
	// ErrLedgerIDExists is thrown by a CreateLedger call if a ledger with the given id already exists
	ErrLedgerIDExists = errors.New("LedgerID already exists")
	// ErrNonExistingLedgerID is thrown by a OpenLedger call if a ledger with the given id does not exist
	ErrNonExistingLedgerID = errors.New("LedgerID does not exist")
	// ErrLedgerNotOpened is thrown by a CloseLedger call if a ledger with the given id has not been opened
	ErrLedgerNotOpened = errors.New("ledger is not opened yet")

	underConstructionLedgerKey = []byte("underConstructionLedgerKey")
	ledgerKeyPrefix            = []byte("l")
)

// Provider implements interface ledger.PeerLedgerProvider
type Provider struct {
	idStore             *idStore
	ledgerStoreProvider *ledgerstorage.Provider
	vdbProvider         privacyenabledstate.DBProvider
	historydbProvider   historydb.HistoryDBProvider
	configHistoryMgr    confighistory.Mgr
	stateListeners      []ledger.StateListener
	bookkeepingProvider bookkeeping.Provider
	initializer         *ledger.Initializer
	collElgNotifier     *collElgNotifier
	stats               *stats
}

// NewProvider instantiates a new Provider.
// This is not thread-safe and assumed to be synchronized be the caller
func NewProvider() (ledger.PeerLedgerProvider, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[0], 1);
	logger.Info("Initializing ledger provider")
	// Initialize the ID store (inventory of chainIds/ledgerIds)
	idStore := openIDStore(ledgerconfig.GetLedgerProviderPath())
	ledgerStoreProvider := ledgerstorage.NewProvider()
	// Initialize the history database (index for history of values by key)
	historydbProvider := historyleveldb.NewHistoryDBProvider()
	logger.Info("ledger provider Initialized")
	provider := &Provider{idStore, ledgerStoreProvider,
		nil, historydbProvider, nil, nil, nil, nil, nil, nil}
	return provider, nil
}

// Initialize implements the corresponding method from interface ledger.PeerLedgerProvider
func (provider *Provider) Initialize(initializer *ledger.Initializer) error {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[1], 1);
	var err error
	configHistoryMgr := confighistory.NewMgr(initializer.DeployedChaincodeInfoProvider)
	collElgNotifier := &collElgNotifier{
		initializer.DeployedChaincodeInfoProvider,
		initializer.MembershipInfoProvider,
		make(map[string]collElgListener),
	}
	stateListeners := initializer.StateListeners
	stateListeners = append(stateListeners, collElgNotifier)
	stateListeners = append(stateListeners, configHistoryMgr)

	provider.initializer = initializer
	provider.configHistoryMgr = configHistoryMgr
	provider.stateListeners = stateListeners
	provider.collElgNotifier = collElgNotifier
	provider.bookkeepingProvider = bookkeeping.NewProvider()
	provider.vdbProvider, err = privacyenabledstate.NewCommonStorageDBProvider(provider.bookkeepingProvider, initializer.MetricsProvider)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[3], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[2], 1);provider.stats = newStats(initializer.MetricsProvider)
	provider.recoverUnderConstructionLedger()
	return nil
}

// Create implements the corresponding method from interface ledger.PeerLedgerProvider
// This functions sets a under construction flag before doing any thing related to ledger creation and
// upon a successful ledger creation with the committed genesis block, removes the flag and add entry into
// created ledgers list (atomically). If a crash happens in between, the 'recoverUnderConstructionLedger'
// function is invoked before declaring the provider to be usable
func (provider *Provider) Create(genesisBlock *common.Block) (ledger.PeerLedger, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[4], 1);
	ledgerID, err := utils.GetChainIDFromBlock(genesisBlock)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[11], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[5], 1);exists, err := provider.idStore.ledgerIDExists(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[12], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[6], 1);if exists {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[13], 1);
		return nil, ErrLedgerIDExists
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[7], 1);if err = provider.idStore.setUnderConstructionFlag(ledgerID); err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[14], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[8], 1);lgr, err := provider.openInternal(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[15], 1);
		logger.Errorf("Error opening a new empty ledger. Unsetting under construction flag. Error: %+v", err)
		panicOnErr(provider.runCleanup(ledgerID), "Error running cleanup for ledger id [%s]", ledgerID)
		panicOnErr(provider.idStore.unsetUnderConstructionFlag(), "Error while unsetting under construction flag")
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[9], 1);if err := lgr.CommitWithPvtData(&ledger.BlockAndPvtData{
		Block: genesisBlock,
	}); err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[16], 1);
		lgr.Close()
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[10], 1);panicOnErr(provider.idStore.createLedgerID(ledgerID, genesisBlock), "Error while marking ledger as created")
	return lgr, nil
}

// Open implements the corresponding method from interface ledger.PeerLedgerProvider
func (provider *Provider) Open(ledgerID string) (ledger.PeerLedger, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[17], 1);
	logger.Debugf("Open() opening kvledger: %s", ledgerID)
	// Check the ID store to ensure that the chainId/ledgerId exists
	exists, err := provider.idStore.ledgerIDExists(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[20], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[18], 1);if !exists {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[21], 1);
		return nil, ErrNonExistingLedgerID
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[19], 1);return provider.openInternal(ledgerID)
}

func (provider *Provider) openInternal(ledgerID string) (ledger.PeerLedger, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[22], 1);
	// Get the block store for a chain/ledger
	blockStore, err := provider.ledgerStoreProvider.Open(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[27], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[23], 1);provider.collElgNotifier.registerListener(ledgerID, blockStore)

	// Get the versioned database (state database) for a chain/ledger
	vDB, err := provider.vdbProvider.GetDBHandle(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[28], 1);
		return nil, err
	}

	// Get the history database (index for history of values by key) for a chain/ledger
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[24], 1);historyDB, err := provider.historydbProvider.GetDBHandle(ledgerID)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[29], 1);
		return nil, err
	}

	// Create a kvLedger for this chain/ledger, which encasulates the underlying data stores
	// (id store, blockstore, state database, history database)
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[25], 1);l, err := newKVLedger(
		ledgerID, blockStore, vDB, historyDB, provider.configHistoryMgr,
		provider.stateListeners, provider.bookkeepingProvider,
		provider.initializer.DeployedChaincodeInfoProvider,
		provider.stats.ledgerStats(ledgerID),
	)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[30], 1);
		return nil, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[26], 1);return l, nil
}

// Exists implements the corresponding method from interface ledger.PeerLedgerProvider
func (provider *Provider) Exists(ledgerID string) (bool, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[31], 1);
	return provider.idStore.ledgerIDExists(ledgerID)
}

// List implements the corresponding method from interface ledger.PeerLedgerProvider
func (provider *Provider) List() ([]string, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[32], 1);
	return provider.idStore.getAllLedgerIds()
}

// Close implements the corresponding method from interface ledger.PeerLedgerProvider
func (provider *Provider) Close() {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[33], 1);
	provider.idStore.close()
	provider.ledgerStoreProvider.Close()
	provider.vdbProvider.Close()
	provider.historydbProvider.Close()
	provider.bookkeepingProvider.Close()
	provider.configHistoryMgr.Close()
}

// recoverUnderConstructionLedger checks whether the under construction flag is set - this would be the case
// if a crash had happened during creation of ledger and the ledger creation could have been left in intermediate
// state. Recovery checks if the ledger was created and the genesis block was committed successfully then it completes
// the last step of adding the ledger id to the list of created ledgers. Else, it clears the under construction flag
func (provider *Provider) recoverUnderConstructionLedger() {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[34], 1);
	logger.Debugf("Recovering under construction ledger")
	ledgerID, err := provider.idStore.getUnderConstructionFlag()
	panicOnErr(err, "Error while checking whether the under construction flag is set")
	if ledgerID == "" {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[37], 1);
		logger.Debugf("No under construction ledger found. Quitting recovery")
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[35], 1);logger.Infof("ledger [%s] found as under construction", ledgerID)
	ledger, err := provider.openInternal(ledgerID)
	panicOnErr(err, "Error while opening under construction ledger [%s]", ledgerID)
	bcInfo, err := ledger.GetBlockchainInfo()
	panicOnErr(err, "Error while getting blockchain info for the under construction ledger [%s]", ledgerID)
	ledger.Close()

	switch bcInfo.Height {
	case 0:_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[38], 1);
		logger.Infof("Genesis block was not committed. Hence, the peer ledger not created. unsetting the under construction flag")
		panicOnErr(provider.runCleanup(ledgerID), "Error while running cleanup for ledger id [%s]", ledgerID)
		panicOnErr(provider.idStore.unsetUnderConstructionFlag(), "Error while unsetting under construction flag")
	case 1:_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[39], 1);
		logger.Infof("Genesis block was committed. Hence, marking the peer ledger as created")
		genesisBlock, err := ledger.GetBlockByNumber(0)
		panicOnErr(err, "Error while retrieving genesis block from blockchain for ledger [%s]", ledgerID)
		panicOnErr(provider.idStore.createLedgerID(ledgerID, genesisBlock), "Error while adding ledgerID [%s] to created list", ledgerID)
	default:_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[40], 1);
		panic(errors.Errorf(
			"data inconsistency: under construction flag is set for ledger [%s] while the height of the blockchain is [%d]",
			ledgerID, bcInfo.Height))
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[36], 1);return
}

// runCleanup cleans up blockstorage, statedb, and historydb for what
// may have got created during in-complete ledger creation
func (provider *Provider) runCleanup(ledgerID string) error {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[41], 1);
	// TODO - though, not having this is harmless for kv ledger.
	// If we want, following could be done:
	// - blockstorage could remove empty folders
	// - couchdb backed statedb could delete the database if got created
	// - leveldb backed statedb and history db need not perform anything as it uses a single db shared across ledgers
	return nil
}

func panicOnErr(err error, mgsFormat string, args ...interface{}) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[42], 1);
	if err == nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[44], 1);
		return
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[43], 1);args = append(args, err)
	panic(fmt.Sprintf(mgsFormat+" Error: %s", args...))
}

//////////////////////////////////////////////////////////////////////
// Ledger id persistence related code
///////////////////////////////////////////////////////////////////////
type idStore struct {
	db *leveldbhelper.DB
}

func openIDStore(path string) *idStore {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[45], 1);
	db := leveldbhelper.CreateDB(&leveldbhelper.Conf{DBPath: path})
	db.Open()
	return &idStore{db}
}

func (s *idStore) setUnderConstructionFlag(ledgerID string) error {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[46], 1);
	return s.db.Put(underConstructionLedgerKey, []byte(ledgerID), true)
}

func (s *idStore) unsetUnderConstructionFlag() error {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[47], 1);
	return s.db.Delete(underConstructionLedgerKey, true)
}

func (s *idStore) getUnderConstructionFlag() (string, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[48], 1);
	val, err := s.db.Get(underConstructionLedgerKey)
	if err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[50], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[49], 1);return string(val), nil
}

func (s *idStore) createLedgerID(ledgerID string, gb *common.Block) error {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[51], 1);
	key := s.encodeLedgerKey(ledgerID)
	var val []byte
	var err error
	if val, err = s.db.Get(key); err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[55], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[52], 1);if val != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[56], 1);
		return ErrLedgerIDExists
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[53], 1);if val, err = proto.Marshal(gb); err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[57], 1);
		return err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[54], 1);batch := &leveldb.Batch{}
	batch.Put(key, val)
	batch.Delete(underConstructionLedgerKey)
	return s.db.WriteBatch(batch, true)
}

func (s *idStore) ledgerIDExists(ledgerID string) (bool, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[58], 1);
	key := s.encodeLedgerKey(ledgerID)
	val := []byte{}
	err := error(nil)
	if val, err = s.db.Get(key); err != nil {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[60], 1);
		return false, err
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[59], 1);return val != nil, nil
}

func (s *idStore) getAllLedgerIds() ([]string, error) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[61], 1);
	var ids []string
	itr := s.db.GetIterator(nil, nil)
	defer itr.Release()
	itr.First()
	for itr.Valid() {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[63], 1);
		if bytes.Equal(itr.Key(), underConstructionLedgerKey) {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[65], 1);
			continue
		}
		_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[64], 1);id := string(s.decodeLedgerID(itr.Key()))
		ids = append(ids, id)
		itr.Next()
	}
	_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[62], 1);return ids, nil
}

func (s *idStore) close() {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[66], 1);
	s.db.Close()
}

func (s *idStore) encodeLedgerKey(ledgerID string) []byte {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[67], 1);
	return append(ledgerKeyPrefix, []byte(ledgerID)...)
}

func (s *idStore) decodeLedgerID(key []byte) string {_cover_atomic_.AddUint32(&GoCover_3_653063666537353930343531.Count[68], 1);
	return string(key[len(ledgerKeyPrefix):])
}

var GoCover_3_653063666537353930343531 = struct {
	Count     [69]uint32
	Pos       [3 * 69]uint32
	NumStmt   [69]uint16
} {
	Pos: [3 * 69]uint32{
		57, 68, 0x20037, // [0]
		71, 89, 0x10004d, // [1]
		92, 94, 0xc0002, // [2]
		89, 91, 0x30010, // [3]
		102, 104, 0x100059, // [4]
		107, 108, 0x100002, // [5]
		111, 111, 0xc0002, // [6]
		114, 114, 0x4b0002, // [7]
		117, 118, 0x100002, // [8]
		124, 126, 0x110002, // [9]
		130, 131, 0x110002, // [10]
		104, 106, 0x30010, // [11]
		108, 110, 0x30010, // [12]
		111, 113, 0x3000c, // [13]
		114, 116, 0x3004b, // [14]
		118, 123, 0x30010, // [15]
		126, 129, 0x30011, // [16]
		135, 139, 0x10004c, // [17]
		142, 142, 0xd0002, // [18]
		145, 145, 0x280002, // [19]
		139, 141, 0x30010, // [20]
		142, 144, 0x3000d, // [21]
		148, 151, 0x100054, // [22]
		154, 158, 0x100002, // [23]
		163, 164, 0x100002, // [24]
		170, 176, 0x100002, // [25]
		179, 179, 0xf0002, // [26]
		151, 153, 0x30010, // [27]
		158, 160, 0x30010, // [28]
		164, 166, 0x30010, // [29]
		176, 178, 0x30010, // [30]
		183, 185, 0x20041, // [31]
		188, 190, 0x20034, // [32]
		193, 200, 0x20023, // [33]
		206, 210, 0x14003c, // [34]
		214, 221, 0x170002, // [35]
		236, 236, 0x80002, // [36]
		210, 213, 0x30014, // [37]
		222, 225, 0x6d0009, // [38]
		226, 230, 0x840009, // [39]
		231, 234, 0x1d000a, // [40]
		241, 248, 0x2003d, // [41]
		250, 251, 0x100043, // [42]
		254, 255, 0x350002, // [43]
		251, 253, 0x30010, // [44]
		265, 269, 0x20028, // [45]
		271, 273, 0x20043, // [46]
		275, 277, 0x20036, // [47]
		279, 281, 0x10003e, // [48]
		284, 284, 0x190002, // [49]
		281, 283, 0x30010, // [50]
		287, 291, 0x2a004b, // [51]
		294, 294, 0x100002, // [52]
		297, 297, 0x2e0002, // [53]
		300, 303, 0x250002, // [54]
		291, 293, 0x3002a, // [55]
		294, 296, 0x30010, // [56]
		297, 299, 0x3002e, // [57]
		306, 310, 0x2a0041, // [58]
		313, 313, 0x180002, // [59]
		310, 312, 0x3002a, // [60]
		316, 321, 0x120037, // [61]
		329, 329, 0x110002, // [62]
		321, 322, 0x390012, // [63]
		325, 327, 0xd0003, // [64]
		322, 323, 0xc0039, // [65]
		332, 334, 0x2001b, // [66]
		336, 338, 0x2003b, // [67]
		340, 342, 0x20035, // [68]
	},
	NumStmt: [69]uint16{
		7, // 0
		13, // 1
		3, // 2
		1, // 3
		2, // 4
		2, // 5
		1, // 6
		1, // 7
		2, // 8
		1, // 9
		2, // 10
		1, // 11
		1, // 12
		1, // 13
		1, // 14
		4, // 15
		2, // 16
		3, // 17
		1, // 18
		1, // 19
		1, // 20
		1, // 21
		2, // 22
		3, // 23
		2, // 24
		2, // 25
		1, // 26
		1, // 27
		1, // 28
		1, // 29
		1, // 30
		1, // 31
		1, // 32
		6, // 33
		4, // 34
		7, // 35
		1, // 36
		2, // 37
		3, // 38
		4, // 39
		1, // 40
		1, // 41
		1, // 42
		2, // 43
		1, // 44
		3, // 45
		1, // 46
		1, // 47
		2, // 48
		1, // 49
		1, // 50
		4, // 51
		1, // 52
		1, // 53
		4, // 54
		1, // 55
		1, // 56
		1, // 57
		4, // 58
		1, // 59
		1, // 60
		5, // 61
		1, // 62
		1, // 63
		3, // 64
		1, // 65
		1, // 66
		1, // 67
		1, // 68
	},
}
var _ = _cover_atomic_.LoadUint32
