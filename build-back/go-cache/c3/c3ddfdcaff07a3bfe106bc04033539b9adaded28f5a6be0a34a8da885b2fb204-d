//line /home/cooper/go/src/github.com/hyperledger/fabric/bccsp/sw/inmemoryks.go:1
/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package sw; import _cover_atomic_ "sync/atomic"

import (
	"encoding/hex"
	"sync"

	"github.com/hyperledger/fabric/bccsp"
	"github.com/pkg/errors"
)

// NewInMemoryKeyStore instantiates an ephemeral in-memory keystore
func NewInMemoryKeyStore() bccsp.KeyStore {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[0], 1);
	eks := &inmemoryKeyStore{}
	eks.keys = make(map[string]bccsp.Key)
	return eks
}

type inmemoryKeyStore struct {
	// keys maps the hex-encoded SKI to keys
	keys map[string]bccsp.Key
	m    sync.RWMutex
}

// ReadOnly returns false - the key store is not read-only
func (ks *inmemoryKeyStore) ReadOnly() bool {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[1], 1);
	return false
}

// GetKey returns a key object whose SKI is the one passed.
func (ks *inmemoryKeyStore) GetKey(ski []byte) (bccsp.Key, error) {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[2], 1);
	if len(ski) == 0 {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[5], 1);
		return nil, errors.New("ski is nil or empty")
	}

	_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[3], 1);skiStr := hex.EncodeToString(ski)

	ks.m.RLock()
	defer ks.m.RUnlock()
	if key, found := ks.keys[skiStr]; found {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[6], 1);
		return key, nil
	}
	_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[4], 1);return nil, errors.Errorf("no key found for ski %x", ski)
}

// StoreKey stores the key k in this KeyStore.
func (ks *inmemoryKeyStore) StoreKey(k bccsp.Key) error {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[7], 1);
	if k == nil {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[10], 1);
		return errors.New("key is nil")
	}

	_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[8], 1);ski := hex.EncodeToString(k.SKI())

	ks.m.Lock()
	defer ks.m.Unlock()

	if _, found := ks.keys[ski]; found {_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[11], 1);
		return errors.Errorf("ski %x already exists in the keystore", k.SKI())
	}
	_cover_atomic_.AddUint32(&GoCover_9_613964656536343766303630.Count[9], 1);ks.keys[ski] = k

	return nil
}

var GoCover_9_613964656536343766303630 = struct {
	Count     [12]uint32
	Pos       [3 * 12]uint32
	NumStmt   [12]uint16
} {
	Pos: [3 * 12]uint32{
		18, 22, 0x2002b, // [0]
		31, 33, 0x2002d, // [1]
		36, 37, 0x130043, // [2]
		41, 45, 0x2a0002, // [3]
		48, 48, 0x3b0002, // [4]
		37, 39, 0x30013, // [5]
		45, 47, 0x3002a, // [6]
		52, 53, 0xe0039, // [7]
		57, 62, 0x250002, // [8]
		65, 67, 0xc0002, // [9]
		53, 55, 0x3000e, // [10]
		62, 64, 0x30025, // [11]
	},
	NumStmt: [12]uint16{
		3, // 0
		1, // 1
		1, // 2
		4, // 3
		1, // 4
		1, // 5
		1, // 6
		1, // 7
		4, // 8
		2, // 9
		1, // 10
		1, // 11
	},
}
var _ = _cover_atomic_.LoadUint32
